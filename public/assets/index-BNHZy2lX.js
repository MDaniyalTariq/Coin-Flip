var br = Object.defineProperty;
var vr = (s, o, a) => o in s ? br(s, o, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : s[o] = a;
var jn = (s, o, a) => vr(s, typeof o != "symbol" ? o + "" : o, a);

function _mergeNamespaces(s, o) {
    for (var a = 0; a < o.length; a++) {
        const $ = o[a];
        if (typeof $ != "string" && !Array.isArray($)) {
            for (const j in $)
                if (j !== "default" && !(j in s)) {
                    const _e = Object.getOwnPropertyDescriptor($, j);
                    _e && Object.defineProperty(s, j, _e.get ? _e : {
                        enumerable: !0,
                        get: () => $[j]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(s, Symbol.toStringTag, {
        value: "Module"
    }))
}(function() {
    const o = document.createElement("link").relList;
    if (o && o.supports && o.supports("modulepreload")) return;
    for (const j of document.querySelectorAll('link[rel="modulepreload"]')) $(j);
    new MutationObserver(j => {
        for (const _e of j)
            if (_e.type === "childList")
                for (const et of _e.addedNodes) et.tagName === "LINK" && et.rel === "modulepreload" && $(et)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function a(j) {
        const _e = {};
        return j.integrity && (_e.integrity = j.integrity), j.referrerPolicy && (_e.referrerPolicy = j.referrerPolicy), j.crossOrigin === "use-credentials" ? _e.credentials = "include" : j.crossOrigin === "anonymous" ? _e.credentials = "omit" : _e.credentials = "same-origin", _e
    }

    function $(j) {
        if (j.ep) return;
        j.ep = !0;
        const _e = a(j);
        fetch(j.href, _e)
    }
})();
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function getDefaultExportFromCjs$3(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}

function getAugmentedNamespace(s) {
    if (s.__esModule) return s;
    var o = s.default;
    if (typeof o == "function") {
        var a = function $() {
            return this instanceof $ ? Reflect.construct(o, arguments, this.constructor) : o.apply(this, arguments)
        };
        a.prototype = o.prototype
    } else a = {};
    return Object.defineProperty(a, "__esModule", {
        value: !0
    }), Object.keys(s).forEach(function($) {
        var j = Object.getOwnPropertyDescriptor(s, $);
        Object.defineProperty(a, $, j.get ? j : {
            enumerable: !0,
            get: function() {
                return s[$]
            }
        })
    }), a
}
var jsxRuntime = {
        exports: {}
    },
    reactJsxRuntime_production_min = {},
    react = {
        exports: {}
    },
    react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"),
    n$3 = Symbol.for("react.portal"),
    p$4 = Symbol.for("react.fragment"),
    q$3 = Symbol.for("react.strict_mode"),
    r$2 = Symbol.for("react.profiler"),
    t$2 = Symbol.for("react.provider"),
    u$1 = Symbol.for("react.context"),
    v$3 = Symbol.for("react.forward_ref"),
    w$1 = Symbol.for("react.suspense"),
    x$1 = Symbol.for("react.memo"),
    y$1 = Symbol.for("react.lazy"),
    z$2 = Symbol.iterator;

function A$2(s) {
    return s === null || typeof s != "object" ? null : (s = z$2 && s[z$2] || s["@@iterator"], typeof s == "function" ? s : null)
}
var B$1 = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    C$1 = Object.assign,
    D$1 = {};

function E$1(s, o, a) {
    this.props = s, this.context = o, this.refs = D$1, this.updater = a || B$1
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(s, o) {
    if (typeof s != "object" && typeof s != "function" && s != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, s, o, "setState")
};
E$1.prototype.forceUpdate = function(s) {
    this.updater.enqueueForceUpdate(this, s, "forceUpdate")
};

function F() {}
F.prototype = E$1.prototype;

function G$1(s, o, a) {
    this.props = s, this.context = o, this.refs = D$1, this.updater = a || B$1
}
var H$1 = G$1.prototype = new F;
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = !0;
var I$1 = Array.isArray,
    J = Object.prototype.hasOwnProperty,
    K$1 = {
        current: null
    },
    L$1 = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function M$1(s, o, a) {
    var $, j = {},
        _e = null,
        et = null;
    if (o != null)
        for ($ in o.ref !== void 0 && (et = o.ref), o.key !== void 0 && (_e = "" + o.key), o) J.call(o, $) && !L$1.hasOwnProperty($) && (j[$] = o[$]);
    var tt = arguments.length - 2;
    if (tt === 1) j.children = a;
    else if (1 < tt) {
        for (var nt = Array(tt), rt = 0; rt < tt; rt++) nt[rt] = arguments[rt + 2];
        j.children = nt
    }
    if (s && s.defaultProps)
        for ($ in tt = s.defaultProps, tt) j[$] === void 0 && (j[$] = tt[$]);
    return {
        $$typeof: l$3,
        type: s,
        key: _e,
        ref: et,
        props: j,
        _owner: K$1.current
    }
}

function N$1(s, o) {
    return {
        $$typeof: l$3,
        type: s.type,
        key: o,
        ref: s.ref,
        props: s.props,
        _owner: s._owner
    }
}

function O$1(s) {
    return typeof s == "object" && s !== null && s.$$typeof === l$3
}

function escape(s) {
    var o = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + s.replace(/[=:]/g, function(a) {
        return o[a]
    })
}
var P$1 = /\/+/g;

function Q$1(s, o) {
    return typeof s == "object" && s !== null && s.key != null ? escape("" + s.key) : o.toString(36)
}

function R$1(s, o, a, $, j) {
    var _e = typeof s;
    (_e === "undefined" || _e === "boolean") && (s = null);
    var et = !1;
    if (s === null) et = !0;
    else switch (_e) {
        case "string":
        case "number":
            et = !0;
            break;
        case "object":
            switch (s.$$typeof) {
                case l$3:
                case n$3:
                    et = !0
            }
    }
    if (et) return et = s, j = j(et), s = $ === "" ? "." + Q$1(et, 0) : $, I$1(j) ? (a = "", s != null && (a = s.replace(P$1, "$&/") + "/"), R$1(j, o, a, "", function(rt) {
        return rt
    })) : j != null && (O$1(j) && (j = N$1(j, a + (!j.key || et && et.key === j.key ? "" : ("" + j.key).replace(P$1, "$&/") + "/") + s)), o.push(j)), 1;
    if (et = 0, $ = $ === "" ? "." : $ + ":", I$1(s))
        for (var tt = 0; tt < s.length; tt++) {
            _e = s[tt];
            var nt = $ + Q$1(_e, tt);
            et += R$1(_e, o, a, nt, j)
        } else if (nt = A$2(s), typeof nt == "function")
            for (s = nt.call(s), tt = 0; !(_e = s.next()).done;) _e = _e.value, nt = $ + Q$1(_e, tt++), et += R$1(_e, o, a, nt, j);
        else if (_e === "object") throw o = String(s), Error("Objects are not valid as a React child (found: " + (o === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : o) + "). If you meant to render a collection of children, use an array instead.");
    return et
}

function S$1(s, o, a) {
    if (s == null) return s;
    var $ = [],
        j = 0;
    return R$1(s, $, "", "", function(_e) {
        return o.call(a, _e, j++)
    }), $
}

function T$1(s) {
    if (s._status === -1) {
        var o = s._result;
        o = o(), o.then(function(a) {
            (s._status === 0 || s._status === -1) && (s._status = 1, s._result = a)
        }, function(a) {
            (s._status === 0 || s._status === -1) && (s._status = 2, s._result = a)
        }), s._status === -1 && (s._status = 0, s._result = o)
    }
    if (s._status === 1) return s._result.default;
    throw s._result
}
var U$1 = {
        current: null
    },
    V$1 = {
        transition: null
    },
    W$1 = {
        ReactCurrentDispatcher: U$1,
        ReactCurrentBatchConfig: V$1,
        ReactCurrentOwner: K$1
    };

function X$1() {
    throw Error("act(...) is not supported in production builds of React.")
}
react_production_min.Children = {
    map: S$1,
    forEach: function(s, o, a) {
        S$1(s, function() {
            o.apply(this, arguments)
        }, a)
    },
    count: function(s) {
        var o = 0;
        return S$1(s, function() {
            o++
        }), o
    },
    toArray: function(s) {
        return S$1(s, function(o) {
            return o
        }) || []
    },
    only: function(s) {
        if (!O$1(s)) throw Error("React.Children.only expected to receive a single React element child.");
        return s
    }
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(s, o, a) {
    if (s == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + s + ".");
    var $ = C$1({}, s.props),
        j = s.key,
        _e = s.ref,
        et = s._owner;
    if (o != null) {
        if (o.ref !== void 0 && (_e = o.ref, et = K$1.current), o.key !== void 0 && (j = "" + o.key), s.type && s.type.defaultProps) var tt = s.type.defaultProps;
        for (nt in o) J.call(o, nt) && !L$1.hasOwnProperty(nt) && ($[nt] = o[nt] === void 0 && tt !== void 0 ? tt[nt] : o[nt])
    }
    var nt = arguments.length - 2;
    if (nt === 1) $.children = a;
    else if (1 < nt) {
        tt = Array(nt);
        for (var rt = 0; rt < nt; rt++) tt[rt] = arguments[rt + 2];
        $.children = tt
    }
    return {
        $$typeof: l$3,
        type: s.type,
        key: j,
        ref: _e,
        props: $,
        _owner: et
    }
};
react_production_min.createContext = function(s) {
    return s = {
        $$typeof: u$1,
        _currentValue: s,
        _currentValue2: s,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, s.Provider = {
        $$typeof: t$2,
        _context: s
    }, s.Consumer = s
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(s) {
    var o = M$1.bind(null, s);
    return o.type = s, o
};
react_production_min.createRef = function() {
    return {
        current: null
    }
};
react_production_min.forwardRef = function(s) {
    return {
        $$typeof: v$3,
        render: s
    }
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(s) {
    return {
        $$typeof: y$1,
        _payload: {
            _status: -1,
            _result: s
        },
        _init: T$1
    }
};
react_production_min.memo = function(s, o) {
    return {
        $$typeof: x$1,
        type: s,
        compare: o === void 0 ? null : o
    }
};
react_production_min.startTransition = function(s) {
    var o = V$1.transition;
    V$1.transition = {};
    try {
        s()
    } finally {
        V$1.transition = o
    }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(s, o) {
    return U$1.current.useCallback(s, o)
};
react_production_min.useContext = function(s) {
    return U$1.current.useContext(s)
};
react_production_min.useDebugValue = function() {};
react_production_min.useDeferredValue = function(s) {
    return U$1.current.useDeferredValue(s)
};
react_production_min.useEffect = function(s, o) {
    return U$1.current.useEffect(s, o)
};
react_production_min.useId = function() {
    return U$1.current.useId()
};
react_production_min.useImperativeHandle = function(s, o, a) {
    return U$1.current.useImperativeHandle(s, o, a)
};
react_production_min.useInsertionEffect = function(s, o) {
    return U$1.current.useInsertionEffect(s, o)
};
react_production_min.useLayoutEffect = function(s, o) {
    return U$1.current.useLayoutEffect(s, o)
};
react_production_min.useMemo = function(s, o) {
    return U$1.current.useMemo(s, o)
};
react_production_min.useReducer = function(s, o, a) {
    return U$1.current.useReducer(s, o, a)
};
react_production_min.useRef = function(s) {
    return U$1.current.useRef(s)
};
react_production_min.useState = function(s) {
    return U$1.current.useState(s)
};
react_production_min.useSyncExternalStore = function(s, o, a) {
    return U$1.current.useSyncExternalStore(s, o, a)
};
react_production_min.useTransition = function() {
    return U$1.current.useTransition()
};
react_production_min.version = "18.3.1";
react.exports = react_production_min;
var reactExports = react.exports;
const React$1 = getDefaultExportFromCjs$3(reactExports),
    React$2 = _mergeNamespaces({
        __proto__: null,
        default: React$1
    }, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$4 = reactExports,
    k$2 = Symbol.for("react.element"),
    l$2 = Symbol.for("react.fragment"),
    m$3 = Object.prototype.hasOwnProperty,
    n$2 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    p$3 = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function q$2(s, o, a) {
    var $, j = {},
        _e = null,
        et = null;
    a !== void 0 && (_e = "" + a), o.key !== void 0 && (_e = "" + o.key), o.ref !== void 0 && (et = o.ref);
    for ($ in o) m$3.call(o, $) && !p$3.hasOwnProperty($) && (j[$] = o[$]);
    if (s && s.defaultProps)
        for ($ in o = s.defaultProps, o) j[$] === void 0 && (j[$] = o[$]);
    return {
        $$typeof: k$2,
        type: s,
        key: _e,
        ref: et,
        props: j,
        _owner: n$2.current
    }
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports,
    client = {},
    reactDom = {
        exports: {}
    },
    reactDom_production_min = {},
    scheduler = {
        exports: {}
    },
    scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(s) {
    function o($t, Rt) {
        var It = $t.length;
        $t.push(Rt);
        e: for (; 0 < It;) {
            var Tt = It - 1 >>> 1,
                dt = $t[Tt];
            if (0 < j(dt, Rt)) $t[Tt] = Rt, $t[It] = dt, It = Tt;
            else break e
        }
    }

    function a($t) {
        return $t.length === 0 ? null : $t[0]
    }

    function $($t) {
        if ($t.length === 0) return null;
        var Rt = $t[0],
            It = $t.pop();
        if (It !== Rt) {
            $t[0] = It;
            e: for (var Tt = 0, dt = $t.length, Et = dt >>> 1; Tt < Et;) {
                var Ot = 2 * (Tt + 1) - 1,
                    Mt = $t[Ot],
                    jt = Ot + 1,
                    Qt = $t[jt];
                if (0 > j(Mt, It)) jt < dt && 0 > j(Qt, Mt) ? ($t[Tt] = Qt, $t[jt] = It, Tt = jt) : ($t[Tt] = Mt, $t[Ot] = It, Tt = Ot);
                else if (jt < dt && 0 > j(Qt, It)) $t[Tt] = Qt, $t[jt] = It, Tt = jt;
                else break e
            }
        }
        return Rt
    }

    function j($t, Rt) {
        var It = $t.sortIndex - Rt.sortIndex;
        return It !== 0 ? It : $t.id - Rt.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var _e = performance;
        s.unstable_now = function() {
            return _e.now()
        }
    } else {
        var et = Date,
            tt = et.now();
        s.unstable_now = function() {
            return et.now() - tt
        }
    }
    var nt = [],
        rt = [],
        ot = 1,
        st = null,
        lt = 3,
        ft = !1,
        yt = !1,
        bt = !1,
        ht = typeof setTimeout == "function" ? setTimeout : null,
        vt = typeof clearTimeout == "function" ? clearTimeout : null,
        wt = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function gt($t) {
        for (var Rt = a(rt); Rt !== null;) {
            if (Rt.callback === null) $(rt);
            else if (Rt.startTime <= $t) $(rt), Rt.sortIndex = Rt.expirationTime, o(nt, Rt);
            else break;
            Rt = a(rt)
        }
    }

    function At($t) {
        if (bt = !1, gt($t), !yt)
            if (a(nt) !== null) yt = !0, mt(Pt);
            else {
                var Rt = a(rt);
                Rt !== null && xt(At, Rt.startTime - $t)
            }
    }

    function Pt($t, Rt) {
        yt = !1, bt && (bt = !1, vt(Nt), Nt = -1), ft = !0;
        var It = lt;
        try {
            for (gt(Rt), st = a(nt); st !== null && (!(st.expirationTime > Rt) || $t && !Ft());) {
                var Tt = st.callback;
                if (typeof Tt == "function") {
                    st.callback = null, lt = st.priorityLevel;
                    var dt = Tt(st.expirationTime <= Rt);
                    Rt = s.unstable_now(), typeof dt == "function" ? st.callback = dt : st === a(nt) && $(nt), gt(Rt)
                } else $(nt);
                st = a(nt)
            }
            if (st !== null) var Et = !0;
            else {
                var Ot = a(rt);
                Ot !== null && xt(At, Ot.startTime - Rt), Et = !1
            }
            return Et
        } finally {
            st = null, lt = It, ft = !1
        }
    }
    var Bt = !1,
        Lt = null,
        Nt = -1,
        Ut = 5,
        Vt = -1;

    function Ft() {
        return !(s.unstable_now() - Vt < Ut)
    }

    function Wt() {
        if (Lt !== null) {
            var $t = s.unstable_now();
            Vt = $t;
            var Rt = !0;
            try {
                Rt = Lt(!0, $t)
            } finally {
                Rt ? Ct() : (Bt = !1, Lt = null)
            }
        } else Bt = !1
    }
    var Ct;
    if (typeof wt == "function") Ct = function() {
        wt(Wt)
    };
    else if (typeof MessageChannel < "u") {
        var it = new MessageChannel,
            at = it.port2;
        it.port1.onmessage = Wt, Ct = function() {
            at.postMessage(null)
        }
    } else Ct = function() {
        ht(Wt, 0)
    };

    function mt($t) {
        Lt = $t, Bt || (Bt = !0, Ct())
    }

    function xt($t, Rt) {
        Nt = ht(function() {
            $t(s.unstable_now())
        }, Rt)
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function($t) {
        $t.callback = null
    }, s.unstable_continueExecution = function() {
        yt || ft || (yt = !0, mt(Pt))
    }, s.unstable_forceFrameRate = function($t) {
        0 > $t || 125 < $t ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ut = 0 < $t ? Math.floor(1e3 / $t) : 5
    }, s.unstable_getCurrentPriorityLevel = function() {
        return lt
    }, s.unstable_getFirstCallbackNode = function() {
        return a(nt)
    }, s.unstable_next = function($t) {
        switch (lt) {
            case 1:
            case 2:
            case 3:
                var Rt = 3;
                break;
            default:
                Rt = lt
        }
        var It = lt;
        lt = Rt;
        try {
            return $t()
        } finally {
            lt = It
        }
    }, s.unstable_pauseExecution = function() {}, s.unstable_requestPaint = function() {}, s.unstable_runWithPriority = function($t, Rt) {
        switch ($t) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                $t = 3
        }
        var It = lt;
        lt = $t;
        try {
            return Rt()
        } finally {
            lt = It
        }
    }, s.unstable_scheduleCallback = function($t, Rt, It) {
        var Tt = s.unstable_now();
        switch (typeof It == "object" && It !== null ? (It = It.delay, It = typeof It == "number" && 0 < It ? Tt + It : Tt) : It = Tt, $t) {
            case 1:
                var dt = -1;
                break;
            case 2:
                dt = 250;
                break;
            case 5:
                dt = 1073741823;
                break;
            case 4:
                dt = 1e4;
                break;
            default:
                dt = 5e3
        }
        return dt = It + dt, $t = {
            id: ot++,
            callback: Rt,
            priorityLevel: $t,
            startTime: It,
            expirationTime: dt,
            sortIndex: -1
        }, It > Tt ? ($t.sortIndex = It, o(rt, $t), a(nt) === null && $t === a(rt) && (bt ? (vt(Nt), Nt = -1) : bt = !0, xt(At, It - Tt))) : ($t.sortIndex = dt, o(nt, $t), yt || ft || (yt = !0, mt(Pt))), $t
    }, s.unstable_shouldYield = Ft, s.unstable_wrapCallback = function($t) {
        var Rt = lt;
        return function() {
            var It = lt;
            lt = Rt;
            try {
                return $t.apply(this, arguments)
            } finally {
                lt = It
            }
        }
    }
})(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports,
    ca = schedulerExports;

function p$2(s) {
    for (var o = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, a = 1; a < arguments.length; a++) o += "&args[]=" + encodeURIComponent(arguments[a]);
    return "Minified React error #" + s + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set,
    ea = {};

function fa(s, o) {
    ha(s, o), ha(s + "Capture", o)
}

function ha(s, o) {
    for (ea[s] = o, s = 0; s < o.length; s++) da.add(o[s])
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    ja = Object.prototype.hasOwnProperty,
    ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    la = {},
    ma = {};

function oa(s) {
    return ja.call(ma, s) ? !0 : ja.call(la, s) ? !1 : ka.test(s) ? ma[s] = !0 : (la[s] = !0, !1)
}

function pa(s, o, a, $) {
    if (a !== null && a.type === 0) return !1;
    switch (typeof o) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return $ ? !1 : a !== null ? !a.acceptsBooleans : (s = s.toLowerCase().slice(0, 5), s !== "data-" && s !== "aria-");
        default:
            return !1
    }
}

function qa(s, o, a, $) {
    if (o === null || typeof o > "u" || pa(s, o, a, $)) return !0;
    if ($) return !1;
    if (a !== null) switch (a.type) {
        case 3:
            return !o;
        case 4:
            return o === !1;
        case 5:
            return isNaN(o);
        case 6:
            return isNaN(o) || 1 > o
    }
    return !1
}

function v$2(s, o, a, $, j, _e, et) {
    this.acceptsBooleans = o === 2 || o === 3 || o === 4, this.attributeName = $, this.attributeNamespace = j, this.mustUseProperty = a, this.propertyName = s, this.type = o, this.sanitizeURL = _e, this.removeEmptyString = et
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s) {
    z$1[s] = new v$2(s, 0, !1, s, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(s) {
    var o = s[0];
    z$1[o] = new v$2(o, 1, !1, s[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
    z$1[s] = new v$2(s, 2, !1, s.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
    z$1[s] = new v$2(s, 2, !1, s, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s) {
    z$1[s] = new v$2(s, 3, !1, s.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(s) {
    z$1[s] = new v$2(s, 3, !0, s, null, !1, !1)
});
["capture", "download"].forEach(function(s) {
    z$1[s] = new v$2(s, 4, !1, s, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(s) {
    z$1[s] = new v$2(s, 6, !1, s, null, !1, !1)
});
["rowSpan", "start"].forEach(function(s) {
    z$1[s] = new v$2(s, 5, !1, s.toLowerCase(), null, !1, !1)
});
var ra = /[\-:]([a-z])/g;

function sa(s) {
    return s[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s) {
    var o = s.replace(ra, sa);
    z$1[o] = new v$2(o, 1, !1, s, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s) {
    var o = s.replace(ra, sa);
    z$1[o] = new v$2(o, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(s) {
    var o = s.replace(ra, sa);
    z$1[o] = new v$2(o, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(s) {
    z$1[s] = new v$2(s, 1, !1, s.toLowerCase(), null, !1, !1)
});
z$1.xlinkHref = new v$2("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(s) {
    z$1[s] = new v$2(s, 1, !1, s.toLowerCase(), null, !0, !0)
});

function ta(s, o, a, $) {
    var j = z$1.hasOwnProperty(o) ? z$1[o] : null;
    (j !== null ? j.type !== 0 : $ || !(2 < o.length) || o[0] !== "o" && o[0] !== "O" || o[1] !== "n" && o[1] !== "N") && (qa(o, a, j, $) && (a = null), $ || j === null ? oa(o) && (a === null ? s.removeAttribute(o) : s.setAttribute(o, "" + a)) : j.mustUseProperty ? s[j.propertyName] = a === null ? j.type === 3 ? !1 : "" : a : (o = j.attributeName, $ = j.attributeNamespace, a === null ? s.removeAttribute(o) : (j = j.type, a = j === 3 || j === 4 && a === !0 ? "" : "" + a, $ ? s.setAttributeNS($, o, a) : s.setAttribute(o, a))))
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    va = Symbol.for("react.element"),
    wa = Symbol.for("react.portal"),
    ya = Symbol.for("react.fragment"),
    za = Symbol.for("react.strict_mode"),
    Aa = Symbol.for("react.profiler"),
    Ba = Symbol.for("react.provider"),
    Ca = Symbol.for("react.context"),
    Da = Symbol.for("react.forward_ref"),
    Ea = Symbol.for("react.suspense"),
    Fa = Symbol.for("react.suspense_list"),
    Ga = Symbol.for("react.memo"),
    Ha = Symbol.for("react.lazy"),
    Ia = Symbol.for("react.offscreen"),
    Ja = Symbol.iterator;

function Ka(s) {
    return s === null || typeof s != "object" ? null : (s = Ja && s[Ja] || s["@@iterator"], typeof s == "function" ? s : null)
}
var A$1 = Object.assign,
    La;

function Ma(s) {
    if (La === void 0) try {
        throw Error()
    } catch (a) {
        var o = a.stack.trim().match(/\n( *(at )?)/);
        La = o && o[1] || ""
    }
    return `
` + La + s
}
var Na = !1;

function Oa(s, o) {
    if (!s || Na) return "";
    Na = !0;
    var a = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (o)
            if (o = function() {
                    throw Error()
                }, Object.defineProperty(o.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(o, [])
                } catch (rt) {
                    var $ = rt
                }
                Reflect.construct(s, [], o)
            } else {
                try {
                    o.call()
                } catch (rt) {
                    $ = rt
                }
                s.call(o.prototype)
            }
        else {
            try {
                throw Error()
            } catch (rt) {
                $ = rt
            }
            s()
        }
    } catch (rt) {
        if (rt && $ && typeof rt.stack == "string") {
            for (var j = rt.stack.split(`
`), _e = $.stack.split(`
`), et = j.length - 1, tt = _e.length - 1; 1 <= et && 0 <= tt && j[et] !== _e[tt];) tt--;
            for (; 1 <= et && 0 <= tt; et--, tt--)
                if (j[et] !== _e[tt]) {
                    if (et !== 1 || tt !== 1)
                        do
                            if (et--, tt--, 0 > tt || j[et] !== _e[tt]) {
                                var nt = `
` + j[et].replace(" at new ", " at ");
                                return s.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", s.displayName)), nt
                            }
                    while (1 <= et && 0 <= tt);
                    break
                }
        }
    } finally {
        Na = !1, Error.prepareStackTrace = a
    }
    return (s = s ? s.displayName || s.name : "") ? Ma(s) : ""
}

function Pa(s) {
    switch (s.tag) {
        case 5:
            return Ma(s.type);
        case 16:
            return Ma("Lazy");
        case 13:
            return Ma("Suspense");
        case 19:
            return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
            return s = Oa(s.type, !1), s;
        case 11:
            return s = Oa(s.type.render, !1), s;
        case 1:
            return s = Oa(s.type, !0), s;
        default:
            return ""
    }
}

function Qa(s) {
    if (s == null) return null;
    if (typeof s == "function") return s.displayName || s.name || null;
    if (typeof s == "string") return s;
    switch (s) {
        case ya:
            return "Fragment";
        case wa:
            return "Portal";
        case Aa:
            return "Profiler";
        case za:
            return "StrictMode";
        case Ea:
            return "Suspense";
        case Fa:
            return "SuspenseList"
    }
    if (typeof s == "object") switch (s.$$typeof) {
        case Ca:
            return (s.displayName || "Context") + ".Consumer";
        case Ba:
            return (s._context.displayName || "Context") + ".Provider";
        case Da:
            var o = s.render;
            return s = s.displayName, s || (s = o.displayName || o.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
        case Ga:
            return o = s.displayName || null, o !== null ? o : Qa(s.type) || "Memo";
        case Ha:
            o = s._payload, s = s._init;
            try {
                return Qa(s(o))
            } catch {}
    }
    return null
}

function Ra(s) {
    var o = s.type;
    switch (s.tag) {
        case 24:
            return "Cache";
        case 9:
            return (o.displayName || "Context") + ".Consumer";
        case 10:
            return (o._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return s = o.render, s = s.displayName || s.name || "", o.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return o;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return Qa(o);
        case 8:
            return o === za ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof o == "function") return o.displayName || o.name || null;
            if (typeof o == "string") return o
    }
    return null
}

function Sa(s) {
    switch (typeof s) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return s;
        case "object":
            return s;
        default:
            return ""
    }
}

function Ta(s) {
    var o = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (o === "checkbox" || o === "radio")
}

function Ua(s) {
    var o = Ta(s) ? "checked" : "value",
        a = Object.getOwnPropertyDescriptor(s.constructor.prototype, o),
        $ = "" + s[o];
    if (!s.hasOwnProperty(o) && typeof a < "u" && typeof a.get == "function" && typeof a.set == "function") {
        var j = a.get,
            _e = a.set;
        return Object.defineProperty(s, o, {
            configurable: !0,
            get: function() {
                return j.call(this)
            },
            set: function(et) {
                $ = "" + et, _e.call(this, et)
            }
        }), Object.defineProperty(s, o, {
            enumerable: a.enumerable
        }), {
            getValue: function() {
                return $
            },
            setValue: function(et) {
                $ = "" + et
            },
            stopTracking: function() {
                s._valueTracker = null, delete s[o]
            }
        }
    }
}

function Va(s) {
    s._valueTracker || (s._valueTracker = Ua(s))
}

function Wa(s) {
    if (!s) return !1;
    var o = s._valueTracker;
    if (!o) return !0;
    var a = o.getValue(),
        $ = "";
    return s && ($ = Ta(s) ? s.checked ? "true" : "false" : s.value), s = $, s !== a ? (o.setValue(s), !0) : !1
}

function Xa(s) {
    if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
    try {
        return s.activeElement || s.body
    } catch {
        return s.body
    }
}

function Ya(s, o) {
    var a = o.checked;
    return A$1({}, o, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: a ? ? s._wrapperState.initialChecked
    })
}

function Za(s, o) {
    var a = o.defaultValue == null ? "" : o.defaultValue,
        $ = o.checked != null ? o.checked : o.defaultChecked;
    a = Sa(o.value != null ? o.value : a), s._wrapperState = {
        initialChecked: $,
        initialValue: a,
        controlled: o.type === "checkbox" || o.type === "radio" ? o.checked != null : o.value != null
    }
}

function ab(s, o) {
    o = o.checked, o != null && ta(s, "checked", o, !1)
}

function bb(s, o) {
    ab(s, o);
    var a = Sa(o.value),
        $ = o.type;
    if (a != null) $ === "number" ? (a === 0 && s.value === "" || s.value != a) && (s.value = "" + a) : s.value !== "" + a && (s.value = "" + a);
    else if ($ === "submit" || $ === "reset") {
        s.removeAttribute("value");
        return
    }
    o.hasOwnProperty("value") ? cb(s, o.type, a) : o.hasOwnProperty("defaultValue") && cb(s, o.type, Sa(o.defaultValue)), o.checked == null && o.defaultChecked != null && (s.defaultChecked = !!o.defaultChecked)
}

function db(s, o, a) {
    if (o.hasOwnProperty("value") || o.hasOwnProperty("defaultValue")) {
        var $ = o.type;
        if (!($ !== "submit" && $ !== "reset" || o.value !== void 0 && o.value !== null)) return;
        o = "" + s._wrapperState.initialValue, a || o === s.value || (s.value = o), s.defaultValue = o
    }
    a = s.name, a !== "" && (s.name = ""), s.defaultChecked = !!s._wrapperState.initialChecked, a !== "" && (s.name = a)
}

function cb(s, o, a) {
    (o !== "number" || Xa(s.ownerDocument) !== s) && (a == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + a && (s.defaultValue = "" + a))
}
var eb = Array.isArray;

function fb(s, o, a, $) {
    if (s = s.options, o) {
        o = {};
        for (var j = 0; j < a.length; j++) o["$" + a[j]] = !0;
        for (a = 0; a < s.length; a++) j = o.hasOwnProperty("$" + s[a].value), s[a].selected !== j && (s[a].selected = j), j && $ && (s[a].defaultSelected = !0)
    } else {
        for (a = "" + Sa(a), o = null, j = 0; j < s.length; j++) {
            if (s[j].value === a) {
                s[j].selected = !0, $ && (s[j].defaultSelected = !0);
                return
            }
            o !== null || s[j].disabled || (o = s[j])
        }
        o !== null && (o.selected = !0)
    }
}

function gb(s, o) {
    if (o.dangerouslySetInnerHTML != null) throw Error(p$2(91));
    return A$1({}, o, {
        value: void 0,
        defaultValue: void 0,
        children: "" + s._wrapperState.initialValue
    })
}

function hb(s, o) {
    var a = o.value;
    if (a == null) {
        if (a = o.children, o = o.defaultValue, a != null) {
            if (o != null) throw Error(p$2(92));
            if (eb(a)) {
                if (1 < a.length) throw Error(p$2(93));
                a = a[0]
            }
            o = a
        }
        o == null && (o = ""), a = o
    }
    s._wrapperState = {
        initialValue: Sa(a)
    }
}

function ib(s, o) {
    var a = Sa(o.value),
        $ = Sa(o.defaultValue);
    a != null && (a = "" + a, a !== s.value && (s.value = a), o.defaultValue == null && s.defaultValue !== a && (s.defaultValue = a)), $ != null && (s.defaultValue = "" + $)
}

function jb(s) {
    var o = s.textContent;
    o === s._wrapperState.initialValue && o !== "" && o !== null && (s.value = o)
}

function kb(s) {
    switch (s) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function lb(s, o) {
    return s == null || s === "http://www.w3.org/1999/xhtml" ? kb(o) : s === "http://www.w3.org/2000/svg" && o === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s
}
var mb, nb = function(s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(o, a, $, j) {
        MSApp.execUnsafeLocalFunction(function() {
            return s(o, a, $, j)
        })
    } : s
}(function(s, o) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s) s.innerHTML = o;
    else {
        for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + o.valueOf().toString() + "</svg>", o = mb.firstChild; s.firstChild;) s.removeChild(s.firstChild);
        for (; o.firstChild;) s.appendChild(o.firstChild)
    }
});

function ob(s, o) {
    if (o) {
        var a = s.firstChild;
        if (a && a === s.lastChild && a.nodeType === 3) {
            a.nodeValue = o;
            return
        }
    }
    s.textContent = o
}
var pb = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(s) {
    qb.forEach(function(o) {
        o = o + s.charAt(0).toUpperCase() + s.substring(1), pb[o] = pb[s]
    })
});

function rb(s, o, a) {
    return o == null || typeof o == "boolean" || o === "" ? "" : a || typeof o != "number" || o === 0 || pb.hasOwnProperty(s) && pb[s] ? ("" + o).trim() : o + "px"
}

function sb(s, o) {
    s = s.style;
    for (var a in o)
        if (o.hasOwnProperty(a)) {
            var $ = a.indexOf("--") === 0,
                j = rb(a, o[a], $);
            a === "float" && (a = "cssFloat"), $ ? s.setProperty(a, j) : s[a] = j
        }
}
var tb = A$1({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function ub(s, o) {
    if (o) {
        if (tb[s] && (o.children != null || o.dangerouslySetInnerHTML != null)) throw Error(p$2(137, s));
        if (o.dangerouslySetInnerHTML != null) {
            if (o.children != null) throw Error(p$2(60));
            if (typeof o.dangerouslySetInnerHTML != "object" || !("__html" in o.dangerouslySetInnerHTML)) throw Error(p$2(61))
        }
        if (o.style != null && typeof o.style != "object") throw Error(p$2(62))
    }
}

function vb(s, o) {
    if (s.indexOf("-") === -1) return typeof o.is == "string";
    switch (s) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var wb = null;

function xb(s) {
    return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s
}
var yb = null,
    zb = null,
    Ab = null;

function Bb(s) {
    if (s = Cb(s)) {
        if (typeof yb != "function") throw Error(p$2(280));
        var o = s.stateNode;
        o && (o = Db(o), yb(s.stateNode, s.type, o))
    }
}

function Eb(s) {
    zb ? Ab ? Ab.push(s) : Ab = [s] : zb = s
}

function Fb() {
    if (zb) {
        var s = zb,
            o = Ab;
        if (Ab = zb = null, Bb(s), o)
            for (s = 0; s < o.length; s++) Bb(o[s])
    }
}

function Gb(s, o) {
    return s(o)
}

function Hb() {}
var Ib = !1;

function Jb(s, o, a) {
    if (Ib) return s(o, a);
    Ib = !0;
    try {
        return Gb(s, o, a)
    } finally {
        Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb())
    }
}

function Kb(s, o) {
    var a = s.stateNode;
    if (a === null) return null;
    var $ = Db(a);
    if ($ === null) return null;
    a = $[o];
    e: switch (o) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            ($ = !$.disabled) || (s = s.type, $ = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !$;
            break e;
        default:
            s = !1
    }
    if (s) return null;
    if (a && typeof a != "function") throw Error(p$2(231, o, typeof a));
    return a
}
var Lb = !1;
if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", {
        get: function() {
            Lb = !0
        }
    }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb)
} catch {
    Lb = !1
}

function Nb(s, o, a, $, j, _e, et, tt, nt) {
    var rt = Array.prototype.slice.call(arguments, 3);
    try {
        o.apply(a, rt)
    } catch (ot) {
        this.onError(ot)
    }
}
var Ob = !1,
    Pb = null,
    Qb = !1,
    Rb = null,
    Sb = {
        onError: function(s) {
            Ob = !0, Pb = s
        }
    };

function Tb(s, o, a, $, j, _e, et, tt, nt) {
    Ob = !1, Pb = null, Nb.apply(Sb, arguments)
}

function Ub(s, o, a, $, j, _e, et, tt, nt) {
    if (Tb.apply(this, arguments), Ob) {
        if (Ob) {
            var rt = Pb;
            Ob = !1, Pb = null
        } else throw Error(p$2(198));
        Qb || (Qb = !0, Rb = rt)
    }
}

function Vb(s) {
    var o = s,
        a = s;
    if (s.alternate)
        for (; o.return;) o = o.return;
    else {
        s = o;
        do o = s, o.flags & 4098 && (a = o.return), s = o.return; while (s)
    }
    return o.tag === 3 ? a : null
}

function Wb(s) {
    if (s.tag === 13) {
        var o = s.memoizedState;
        if (o === null && (s = s.alternate, s !== null && (o = s.memoizedState)), o !== null) return o.dehydrated
    }
    return null
}

function Xb(s) {
    if (Vb(s) !== s) throw Error(p$2(188))
}

function Yb(s) {
    var o = s.alternate;
    if (!o) {
        if (o = Vb(s), o === null) throw Error(p$2(188));
        return o !== s ? null : s
    }
    for (var a = s, $ = o;;) {
        var j = a.return;
        if (j === null) break;
        var _e = j.alternate;
        if (_e === null) {
            if ($ = j.return, $ !== null) {
                a = $;
                continue
            }
            break
        }
        if (j.child === _e.child) {
            for (_e = j.child; _e;) {
                if (_e === a) return Xb(j), s;
                if (_e === $) return Xb(j), o;
                _e = _e.sibling
            }
            throw Error(p$2(188))
        }
        if (a.return !== $.return) a = j, $ = _e;
        else {
            for (var et = !1, tt = j.child; tt;) {
                if (tt === a) {
                    et = !0, a = j, $ = _e;
                    break
                }
                if (tt === $) {
                    et = !0, $ = j, a = _e;
                    break
                }
                tt = tt.sibling
            }
            if (!et) {
                for (tt = _e.child; tt;) {
                    if (tt === a) {
                        et = !0, a = _e, $ = j;
                        break
                    }
                    if (tt === $) {
                        et = !0, $ = _e, a = j;
                        break
                    }
                    tt = tt.sibling
                }
                if (!et) throw Error(p$2(189))
            }
        }
        if (a.alternate !== $) throw Error(p$2(190))
    }
    if (a.tag !== 3) throw Error(p$2(188));
    return a.stateNode.current === a ? s : o
}

function Zb(s) {
    return s = Yb(s), s !== null ? $b(s) : null
}

function $b(s) {
    if (s.tag === 5 || s.tag === 6) return s;
    for (s = s.child; s !== null;) {
        var o = $b(s);
        if (o !== null) return o;
        s = s.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback,
    bc = ca.unstable_cancelCallback,
    cc = ca.unstable_shouldYield,
    dc = ca.unstable_requestPaint,
    B = ca.unstable_now,
    ec = ca.unstable_getCurrentPriorityLevel,
    fc = ca.unstable_ImmediatePriority,
    gc = ca.unstable_UserBlockingPriority,
    hc = ca.unstable_NormalPriority,
    ic = ca.unstable_LowPriority,
    jc = ca.unstable_IdlePriority,
    kc = null,
    lc = null;

function mc(s) {
    if (lc && typeof lc.onCommitFiberRoot == "function") try {
        lc.onCommitFiberRoot(kc, s, void 0, (s.current.flags & 128) === 128)
    } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc,
    pc = Math.log,
    qc = Math.LN2;

function nc(s) {
    return s >>>= 0, s === 0 ? 32 : 31 - (pc(s) / qc | 0) | 0
}
var rc = 64,
    sc = 4194304;

function tc(s) {
    switch (s & -s) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return s & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return s & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return s
    }
}

function uc(s, o) {
    var a = s.pendingLanes;
    if (a === 0) return 0;
    var $ = 0,
        j = s.suspendedLanes,
        _e = s.pingedLanes,
        et = a & 268435455;
    if (et !== 0) {
        var tt = et & ~j;
        tt !== 0 ? $ = tc(tt) : (_e &= et, _e !== 0 && ($ = tc(_e)))
    } else et = a & ~j, et !== 0 ? $ = tc(et) : _e !== 0 && ($ = tc(_e));
    if ($ === 0) return 0;
    if (o !== 0 && o !== $ && !(o & j) && (j = $ & -$, _e = o & -o, j >= _e || j === 16 && (_e & 4194240) !== 0)) return o;
    if ($ & 4 && ($ |= a & 16), o = s.entangledLanes, o !== 0)
        for (s = s.entanglements, o &= $; 0 < o;) a = 31 - oc(o), j = 1 << a, $ |= s[a], o &= ~j;
    return $
}

function vc(s, o) {
    switch (s) {
        case 1:
        case 2:
        case 4:
            return o + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return o + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function wc(s, o) {
    for (var a = s.suspendedLanes, $ = s.pingedLanes, j = s.expirationTimes, _e = s.pendingLanes; 0 < _e;) {
        var et = 31 - oc(_e),
            tt = 1 << et,
            nt = j[et];
        nt === -1 ? (!(tt & a) || tt & $) && (j[et] = vc(tt, o)) : nt <= o && (s.expiredLanes |= tt), _e &= ~tt
    }
}

function xc(s) {
    return s = s.pendingLanes & -1073741825, s !== 0 ? s : s & 1073741824 ? 1073741824 : 0
}

function yc() {
    var s = rc;
    return rc <<= 1, !(rc & 4194240) && (rc = 64), s
}

function zc(s) {
    for (var o = [], a = 0; 31 > a; a++) o.push(s);
    return o
}

function Ac(s, o, a) {
    s.pendingLanes |= o, o !== 536870912 && (s.suspendedLanes = 0, s.pingedLanes = 0), s = s.eventTimes, o = 31 - oc(o), s[o] = a
}

function Bc(s, o) {
    var a = s.pendingLanes & ~o;
    s.pendingLanes = o, s.suspendedLanes = 0, s.pingedLanes = 0, s.expiredLanes &= o, s.mutableReadLanes &= o, s.entangledLanes &= o, o = s.entanglements;
    var $ = s.eventTimes;
    for (s = s.expirationTimes; 0 < a;) {
        var j = 31 - oc(a),
            _e = 1 << j;
        o[j] = 0, $[j] = -1, s[j] = -1, a &= ~_e
    }
}

function Cc(s, o) {
    var a = s.entangledLanes |= o;
    for (s = s.entanglements; a;) {
        var $ = 31 - oc(a),
            j = 1 << $;
        j & o | s[$] & o && (s[$] |= o), a &= ~j
    }
}
var C = 0;

function Dc(s) {
    return s &= -s, 1 < s ? 4 < s ? s & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec, Fc, Gc, Hc, Ic, Jc = !1,
    Kc = [],
    Lc = null,
    Mc = null,
    Nc = null,
    Oc = new Map,
    Pc = new Map,
    Qc = [],
    Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function Sc(s, o) {
    switch (s) {
        case "focusin":
        case "focusout":
            Lc = null;
            break;
        case "dragenter":
        case "dragleave":
            Mc = null;
            break;
        case "mouseover":
        case "mouseout":
            Nc = null;
            break;
        case "pointerover":
        case "pointerout":
            Oc.delete(o.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Pc.delete(o.pointerId)
    }
}

function Tc(s, o, a, $, j, _e) {
    return s === null || s.nativeEvent !== _e ? (s = {
        blockedOn: o,
        domEventName: a,
        eventSystemFlags: $,
        nativeEvent: _e,
        targetContainers: [j]
    }, o !== null && (o = Cb(o), o !== null && Fc(o)), s) : (s.eventSystemFlags |= $, o = s.targetContainers, j !== null && o.indexOf(j) === -1 && o.push(j), s)
}

function Uc(s, o, a, $, j) {
    switch (o) {
        case "focusin":
            return Lc = Tc(Lc, s, o, a, $, j), !0;
        case "dragenter":
            return Mc = Tc(Mc, s, o, a, $, j), !0;
        case "mouseover":
            return Nc = Tc(Nc, s, o, a, $, j), !0;
        case "pointerover":
            var _e = j.pointerId;
            return Oc.set(_e, Tc(Oc.get(_e) || null, s, o, a, $, j)), !0;
        case "gotpointercapture":
            return _e = j.pointerId, Pc.set(_e, Tc(Pc.get(_e) || null, s, o, a, $, j)), !0
    }
    return !1
}

function Vc(s) {
    var o = Wc(s.target);
    if (o !== null) {
        var a = Vb(o);
        if (a !== null) {
            if (o = a.tag, o === 13) {
                if (o = Wb(a), o !== null) {
                    s.blockedOn = o, Ic(s.priority, function() {
                        Gc(a)
                    });
                    return
                }
            } else if (o === 3 && a.stateNode.current.memoizedState.isDehydrated) {
                s.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
                return
            }
        }
    }
    s.blockedOn = null
}

function Xc(s) {
    if (s.blockedOn !== null) return !1;
    for (var o = s.targetContainers; 0 < o.length;) {
        var a = Yc(s.domEventName, s.eventSystemFlags, o[0], s.nativeEvent);
        if (a === null) {
            a = s.nativeEvent;
            var $ = new a.constructor(a.type, a);
            wb = $, a.target.dispatchEvent($), wb = null
        } else return o = Cb(a), o !== null && Fc(o), s.blockedOn = a, !1;
        o.shift()
    }
    return !0
}

function Zc(s, o, a) {
    Xc(s) && a.delete(o)
}

function $c() {
    Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc)
}

function ad(s, o) {
    s.blockedOn === o && (s.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}

function bd(s) {
    function o(j) {
        return ad(j, s)
    }
    if (0 < Kc.length) {
        ad(Kc[0], s);
        for (var a = 1; a < Kc.length; a++) {
            var $ = Kc[a];
            $.blockedOn === s && ($.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, s), Mc !== null && ad(Mc, s), Nc !== null && ad(Nc, s), Oc.forEach(o), Pc.forEach(o), a = 0; a < Qc.length; a++) $ = Qc[a], $.blockedOn === s && ($.blockedOn = null);
    for (; 0 < Qc.length && (a = Qc[0], a.blockedOn === null);) Vc(a), a.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig,
    dd = !0;

function ed(s, o, a, $) {
    var j = C,
        _e = cd.transition;
    cd.transition = null;
    try {
        C = 1, fd(s, o, a, $)
    } finally {
        C = j, cd.transition = _e
    }
}

function gd(s, o, a, $) {
    var j = C,
        _e = cd.transition;
    cd.transition = null;
    try {
        C = 4, fd(s, o, a, $)
    } finally {
        C = j, cd.transition = _e
    }
}

function fd(s, o, a, $) {
    if (dd) {
        var j = Yc(s, o, a, $);
        if (j === null) hd(s, o, $, id$2, a), Sc(s, $);
        else if (Uc(j, s, o, a, $)) $.stopPropagation();
        else if (Sc(s, $), o & 4 && -1 < Rc.indexOf(s)) {
            for (; j !== null;) {
                var _e = Cb(j);
                if (_e !== null && Ec(_e), _e = Yc(s, o, a, $), _e === null && hd(s, o, $, id$2, a), _e === j) break;
                j = _e
            }
            j !== null && $.stopPropagation()
        } else hd(s, o, $, null, a)
    }
}
var id$2 = null;

function Yc(s, o, a, $) {
    if (id$2 = null, s = xb($), s = Wc(s), s !== null)
        if (o = Vb(s), o === null) s = null;
        else if (a = o.tag, a === 13) {
        if (s = Wb(o), s !== null) return s;
        s = null
    } else if (a === 3) {
        if (o.stateNode.current.memoizedState.isDehydrated) return o.tag === 3 ? o.stateNode.containerInfo : null;
        s = null
    } else o !== s && (s = null);
    return id$2 = s, null
}

function jd(s) {
    switch (s) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (ec()) {
                case fc:
                    return 1;
                case gc:
                    return 4;
                case hc:
                case ic:
                    return 16;
                case jc:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var kd = null,
    ld = null,
    md = null;

function nd() {
    if (md) return md;
    var s, o = ld,
        a = o.length,
        $, j = "value" in kd ? kd.value : kd.textContent,
        _e = j.length;
    for (s = 0; s < a && o[s] === j[s]; s++);
    var et = a - s;
    for ($ = 1; $ <= et && o[a - $] === j[_e - $]; $++);
    return md = j.slice(s, 1 < $ ? 1 - $ : void 0)
}

function od(s) {
    var o = s.keyCode;
    return "charCode" in s ? (s = s.charCode, s === 0 && o === 13 && (s = 13)) : s = o, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0
}

function pd() {
    return !0
}

function qd() {
    return !1
}

function rd(s) {
    function o(a, $, j, _e, et) {
        this._reactName = a, this._targetInst = j, this.type = $, this.nativeEvent = _e, this.target = et, this.currentTarget = null;
        for (var tt in s) s.hasOwnProperty(tt) && (a = s[tt], this[tt] = a ? a(_e) : _e[tt]);
        return this.isDefaultPrevented = (_e.defaultPrevented != null ? _e.defaultPrevented : _e.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this
    }
    return A$1(o.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var a = this.nativeEvent;
            a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1), this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var a = this.nativeEvent;
            a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0), this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }), o
}
var sd = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(s) {
            return s.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    td = rd(sd),
    ud = A$1({}, sd, {
        view: 0,
        detail: 0
    }),
    vd = rd(ud),
    wd, xd, yd, Ad = A$1({}, ud, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: zd,
        button: 0,
        buttons: 0,
        relatedTarget: function(s) {
            return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget
        },
        movementX: function(s) {
            return "movementX" in s ? s.movementX : (s !== yd && (yd && s.type === "mousemove" ? (wd = s.screenX - yd.screenX, xd = s.screenY - yd.screenY) : xd = wd = 0, yd = s), wd)
        },
        movementY: function(s) {
            return "movementY" in s ? s.movementY : xd
        }
    }),
    Bd = rd(Ad),
    Cd = A$1({}, Ad, {
        dataTransfer: 0
    }),
    Dd = rd(Cd),
    Ed = A$1({}, ud, {
        relatedTarget: 0
    }),
    Fd = rd(Ed),
    Gd = A$1({}, sd, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    Hd = rd(Gd),
    Id = A$1({}, sd, {
        clipboardData: function(s) {
            return "clipboardData" in s ? s.clipboardData : window.clipboardData
        }
    }),
    Jd = rd(Id),
    Kd = A$1({}, sd, {
        data: 0
    }),
    Ld = rd(Kd),
    Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    Od = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function Pd(s) {
    var o = this.nativeEvent;
    return o.getModifierState ? o.getModifierState(s) : (s = Od[s]) ? !!o[s] : !1
}

function zd() {
    return Pd
}
var Qd = A$1({}, ud, {
        key: function(s) {
            if (s.key) {
                var o = Md[s.key] || s.key;
                if (o !== "Unidentified") return o
            }
            return s.type === "keypress" ? (s = od(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Nd[s.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: zd,
        charCode: function(s) {
            return s.type === "keypress" ? od(s) : 0
        },
        keyCode: function(s) {
            return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
        },
        which: function(s) {
            return s.type === "keypress" ? od(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
        }
    }),
    Rd = rd(Qd),
    Sd = A$1({}, Ad, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    Td = rd(Sd),
    Ud = A$1({}, ud, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: zd
    }),
    Vd = rd(Ud),
    Wd = A$1({}, sd, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    Xd = rd(Wd),
    Yd = A$1({}, Ad, {
        deltaX: function(s) {
            return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0
        },
        deltaY: function(s) {
            return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    Zd = rd(Yd),
    $d = [9, 13, 27, 32],
    ae = ia && "CompositionEvent" in window,
    be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be,
    de = ia && (!ae || be && 8 < be && 11 >= be),
    ee = " ",
    fe = !1;

function ge(s, o) {
    switch (s) {
        case "keyup":
            return $d.indexOf(o.keyCode) !== -1;
        case "keydown":
            return o.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function he(s) {
    return s = s.detail, typeof s == "object" && "data" in s ? s.data : null
}
var ie = !1;

function je(s, o) {
    switch (s) {
        case "compositionend":
            return he(o);
        case "keypress":
            return o.which !== 32 ? null : (fe = !0, ee);
        case "textInput":
            return s = o.data, s === ee && fe ? null : s;
        default:
            return null
    }
}

function ke(s, o) {
    if (ie) return s === "compositionend" || !ae && ge(s, o) ? (s = nd(), md = ld = kd = null, ie = !1, s) : null;
    switch (s) {
        case "paste":
            return null;
        case "keypress":
            if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
                if (o.char && 1 < o.char.length) return o.char;
                if (o.which) return String.fromCharCode(o.which)
            }
            return null;
        case "compositionend":
            return de && o.locale !== "ko" ? null : o.data;
        default:
            return null
    }
}
var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function me(s) {
    var o = s && s.nodeName && s.nodeName.toLowerCase();
    return o === "input" ? !!le[s.type] : o === "textarea"
}

function ne(s, o, a, $) {
    Eb($), o = oe(o, "onChange"), 0 < o.length && (a = new td("onChange", "change", null, a, $), s.push({
        event: a,
        listeners: o
    }))
}
var pe = null,
    qe = null;

function re(s) {
    se(s, 0)
}

function te(s) {
    var o = ue(s);
    if (Wa(o)) return s
}

function ve(s, o) {
    if (s === "change") return o
}
var we = !1;
if (ia) {
    var xe;
    if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;"), ye = typeof ze.oninput == "function"
        }
        xe = ye
    } else xe = !1;
    we = xe && (!document.documentMode || 9 < document.documentMode)
}

function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null)
}

function Be(s) {
    if (s.propertyName === "value" && te(qe)) {
        var o = [];
        ne(o, qe, s, xb(s)), Jb(re, o)
    }
}

function Ce(s, o, a) {
    s === "focusin" ? (Ae(), pe = o, qe = a, pe.attachEvent("onpropertychange", Be)) : s === "focusout" && Ae()
}

function De(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown") return te(qe)
}

function Ee(s, o) {
    if (s === "click") return te(o)
}

function Fe(s, o) {
    if (s === "input" || s === "change") return te(o)
}

function Ge(s, o) {
    return s === o && (s !== 0 || 1 / s === 1 / o) || s !== s && o !== o
}
var He = typeof Object.is == "function" ? Object.is : Ge;

function Ie(s, o) {
    if (He(s, o)) return !0;
    if (typeof s != "object" || s === null || typeof o != "object" || o === null) return !1;
    var a = Object.keys(s),
        $ = Object.keys(o);
    if (a.length !== $.length) return !1;
    for ($ = 0; $ < a.length; $++) {
        var j = a[$];
        if (!ja.call(o, j) || !He(s[j], o[j])) return !1
    }
    return !0
}

function Je(s) {
    for (; s && s.firstChild;) s = s.firstChild;
    return s
}

function Ke(s, o) {
    var a = Je(s);
    s = 0;
    for (var $; a;) {
        if (a.nodeType === 3) {
            if ($ = s + a.textContent.length, s <= o && $ >= o) return {
                node: a,
                offset: o - s
            };
            s = $
        }
        e: {
            for (; a;) {
                if (a.nextSibling) {
                    a = a.nextSibling;
                    break e
                }
                a = a.parentNode
            }
            a = void 0
        }
        a = Je(a)
    }
}

function Le(s, o) {
    return s && o ? s === o ? !0 : s && s.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Le(s, o.parentNode) : "contains" in s ? s.contains(o) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(o) & 16) : !1 : !1
}

function Me() {
    for (var s = window, o = Xa(); o instanceof s.HTMLIFrameElement;) {
        try {
            var a = typeof o.contentWindow.location.href == "string"
        } catch {
            a = !1
        }
        if (a) s = o.contentWindow;
        else break;
        o = Xa(s.document)
    }
    return o
}

function Ne(s) {
    var o = s && s.nodeName && s.nodeName.toLowerCase();
    return o && (o === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || o === "textarea" || s.contentEditable === "true")
}

function Oe(s) {
    var o = Me(),
        a = s.focusedElem,
        $ = s.selectionRange;
    if (o !== a && a && a.ownerDocument && Le(a.ownerDocument.documentElement, a)) {
        if ($ !== null && Ne(a)) {
            if (o = $.start, s = $.end, s === void 0 && (s = o), "selectionStart" in a) a.selectionStart = o, a.selectionEnd = Math.min(s, a.value.length);
            else if (s = (o = a.ownerDocument || document) && o.defaultView || window, s.getSelection) {
                s = s.getSelection();
                var j = a.textContent.length,
                    _e = Math.min($.start, j);
                $ = $.end === void 0 ? _e : Math.min($.end, j), !s.extend && _e > $ && (j = $, $ = _e, _e = j), j = Ke(a, _e);
                var et = Ke(a, $);
                j && et && (s.rangeCount !== 1 || s.anchorNode !== j.node || s.anchorOffset !== j.offset || s.focusNode !== et.node || s.focusOffset !== et.offset) && (o = o.createRange(), o.setStart(j.node, j.offset), s.removeAllRanges(), _e > $ ? (s.addRange(o), s.extend(et.node, et.offset)) : (o.setEnd(et.node, et.offset), s.addRange(o)))
            }
        }
        for (o = [], s = a; s = s.parentNode;) s.nodeType === 1 && o.push({
            element: s,
            left: s.scrollLeft,
            top: s.scrollTop
        });
        for (typeof a.focus == "function" && a.focus(), a = 0; a < o.length; a++) s = o[a], s.element.scrollLeft = s.left, s.element.scrollTop = s.top
    }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
    Qe = null,
    Re = null,
    Se = null,
    Te = !1;

function Ue(s, o, a) {
    var $ = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
    Te || Qe == null || Qe !== Xa($) || ($ = Qe, "selectionStart" in $ && Ne($) ? $ = {
        start: $.selectionStart,
        end: $.selectionEnd
    } : ($ = ($.ownerDocument && $.ownerDocument.defaultView || window).getSelection(), $ = {
        anchorNode: $.anchorNode,
        anchorOffset: $.anchorOffset,
        focusNode: $.focusNode,
        focusOffset: $.focusOffset
    }), Se && Ie(Se, $) || (Se = $, $ = oe(Re, "onSelect"), 0 < $.length && (o = new td("onSelect", "select", null, o, a), s.push({
        event: o,
        listeners: $
    }), o.target = Qe)))
}

function Ve(s, o) {
    var a = {};
    return a[s.toLowerCase()] = o.toLowerCase(), a["Webkit" + s] = "webkit" + o, a["Moz" + s] = "moz" + o, a
}
var We = {
        animationend: Ve("Animation", "AnimationEnd"),
        animationiteration: Ve("Animation", "AnimationIteration"),
        animationstart: Ve("Animation", "AnimationStart"),
        transitionend: Ve("Transition", "TransitionEnd")
    },
    Xe = {},
    Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);

function Ze(s) {
    if (Xe[s]) return Xe[s];
    if (!We[s]) return s;
    var o = We[s],
        a;
    for (a in o)
        if (o.hasOwnProperty(a) && a in Ye) return Xe[s] = o[a];
    return s
}
var $e = Ze("animationend"),
    af = Ze("animationiteration"),
    bf = Ze("animationstart"),
    cf = Ze("transitionend"),
    df = new Map,
    ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function ff(s, o) {
    df.set(s, o), fa(o, [s])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf],
        jf = hf.toLowerCase(),
        kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));

function nf(s, o, a) {
    var $ = s.type || "unknown-event";
    s.currentTarget = a, Ub($, o, void 0, s), s.currentTarget = null
}

function se(s, o) {
    o = (o & 4) !== 0;
    for (var a = 0; a < s.length; a++) {
        var $ = s[a],
            j = $.event;
        $ = $.listeners;
        e: {
            var _e = void 0;
            if (o)
                for (var et = $.length - 1; 0 <= et; et--) {
                    var tt = $[et],
                        nt = tt.instance,
                        rt = tt.currentTarget;
                    if (tt = tt.listener, nt !== _e && j.isPropagationStopped()) break e;
                    nf(j, tt, rt), _e = nt
                } else
                    for (et = 0; et < $.length; et++) {
                        if (tt = $[et], nt = tt.instance, rt = tt.currentTarget, tt = tt.listener, nt !== _e && j.isPropagationStopped()) break e;
                        nf(j, tt, rt), _e = nt
                    }
        }
    }
    if (Qb) throw s = Rb, Qb = !1, Rb = null, s
}

function D(s, o) {
    var a = o[ of ];
    a === void 0 && (a = o[ of ] = new Set);
    var $ = s + "__bubble";
    a.has($) || (pf(o, s, 2, !1), a.add($))
}

function qf(s, o, a) {
    var $ = 0;
    o && ($ |= 4), pf(a, s, $, o)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);

function sf(s) {
    if (!s[rf]) {
        s[rf] = !0, da.forEach(function(a) {
            a !== "selectionchange" && (mf.has(a) || qf(a, !1, s), qf(a, !0, s))
        });
        var o = s.nodeType === 9 ? s : s.ownerDocument;
        o === null || o[rf] || (o[rf] = !0, qf("selectionchange", !1, o))
    }
}

function pf(s, o, a, $) {
    switch (jd(o)) {
        case 1:
            var j = ed;
            break;
        case 4:
            j = gd;
            break;
        default:
            j = fd
    }
    a = j.bind(null, o, a, s), j = void 0, !Lb || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (j = !0), $ ? j !== void 0 ? s.addEventListener(o, a, {
        capture: !0,
        passive: j
    }) : s.addEventListener(o, a, !0) : j !== void 0 ? s.addEventListener(o, a, {
        passive: j
    }) : s.addEventListener(o, a, !1)
}

function hd(s, o, a, $, j) {
    var _e = $;
    if (!(o & 1) && !(o & 2) && $ !== null) e: for (;;) {
        if ($ === null) return;
        var et = $.tag;
        if (et === 3 || et === 4) {
            var tt = $.stateNode.containerInfo;
            if (tt === j || tt.nodeType === 8 && tt.parentNode === j) break;
            if (et === 4)
                for (et = $.return; et !== null;) {
                    var nt = et.tag;
                    if ((nt === 3 || nt === 4) && (nt = et.stateNode.containerInfo, nt === j || nt.nodeType === 8 && nt.parentNode === j)) return;
                    et = et.return
                }
            for (; tt !== null;) {
                if (et = Wc(tt), et === null) return;
                if (nt = et.tag, nt === 5 || nt === 6) {
                    $ = _e = et;
                    continue e
                }
                tt = tt.parentNode
            }
        }
        $ = $.return
    }
    Jb(function() {
        var rt = _e,
            ot = xb(a),
            st = [];
        e: {
            var lt = df.get(s);
            if (lt !== void 0) {
                var ft = td,
                    yt = s;
                switch (s) {
                    case "keypress":
                        if (od(a) === 0) break e;
                    case "keydown":
                    case "keyup":
                        ft = Rd;
                        break;
                    case "focusin":
                        yt = "focus", ft = Fd;
                        break;
                    case "focusout":
                        yt = "blur", ft = Fd;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        ft = Fd;
                        break;
                    case "click":
                        if (a.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        ft = Bd;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        ft = Dd;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        ft = Vd;
                        break;
                    case $e:
                    case af:
                    case bf:
                        ft = Hd;
                        break;
                    case cf:
                        ft = Xd;
                        break;
                    case "scroll":
                        ft = vd;
                        break;
                    case "wheel":
                        ft = Zd;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        ft = Jd;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        ft = Td
                }
                var bt = (o & 4) !== 0,
                    ht = !bt && s === "scroll",
                    vt = bt ? lt !== null ? lt + "Capture" : null : lt;
                bt = [];
                for (var wt = rt, gt; wt !== null;) {
                    gt = wt;
                    var At = gt.stateNode;
                    if (gt.tag === 5 && At !== null && (gt = At, vt !== null && (At = Kb(wt, vt), At != null && bt.push(tf(wt, At, gt)))), ht) break;
                    wt = wt.return
                }
                0 < bt.length && (lt = new ft(lt, yt, null, a, ot), st.push({
                    event: lt,
                    listeners: bt
                }))
            }
        }
        if (!(o & 7)) {
            e: {
                if (lt = s === "mouseover" || s === "pointerover", ft = s === "mouseout" || s === "pointerout", lt && a !== wb && (yt = a.relatedTarget || a.fromElement) && (Wc(yt) || yt[uf])) break e;
                if ((ft || lt) && (lt = ot.window === ot ? ot : (lt = ot.ownerDocument) ? lt.defaultView || lt.parentWindow : window, ft ? (yt = a.relatedTarget || a.toElement, ft = rt, yt = yt ? Wc(yt) : null, yt !== null && (ht = Vb(yt), yt !== ht || yt.tag !== 5 && yt.tag !== 6) && (yt = null)) : (ft = null, yt = rt), ft !== yt)) {
                    if (bt = Bd, At = "onMouseLeave", vt = "onMouseEnter", wt = "mouse", (s === "pointerout" || s === "pointerover") && (bt = Td, At = "onPointerLeave", vt = "onPointerEnter", wt = "pointer"), ht = ft == null ? lt : ue(ft), gt = yt == null ? lt : ue(yt), lt = new bt(At, wt + "leave", ft, a, ot), lt.target = ht, lt.relatedTarget = gt, At = null, Wc(ot) === rt && (bt = new bt(vt, wt + "enter", yt, a, ot), bt.target = gt, bt.relatedTarget = ht, At = bt), ht = At, ft && yt) t: {
                        for (bt = ft, vt = yt, wt = 0, gt = bt; gt; gt = vf(gt)) wt++;
                        for (gt = 0, At = vt; At; At = vf(At)) gt++;
                        for (; 0 < wt - gt;) bt = vf(bt),
                        wt--;
                        for (; 0 < gt - wt;) vt = vf(vt),
                        gt--;
                        for (; wt--;) {
                            if (bt === vt || vt !== null && bt === vt.alternate) break t;
                            bt = vf(bt), vt = vf(vt)
                        }
                        bt = null
                    }
                    else bt = null;
                    ft !== null && wf(st, lt, ft, bt, !1), yt !== null && ht !== null && wf(st, ht, yt, bt, !0)
                }
            }
            e: {
                if (lt = rt ? ue(rt) : window, ft = lt.nodeName && lt.nodeName.toLowerCase(), ft === "select" || ft === "input" && lt.type === "file") var Pt = ve;
                else if (me(lt))
                    if (we) Pt = Fe;
                    else {
                        Pt = De;
                        var Bt = Ce
                    }
                else(ft = lt.nodeName) && ft.toLowerCase() === "input" && (lt.type === "checkbox" || lt.type === "radio") && (Pt = Ee);
                if (Pt && (Pt = Pt(s, rt))) {
                    ne(st, Pt, a, ot);
                    break e
                }
                Bt && Bt(s, lt, rt),
                s === "focusout" && (Bt = lt._wrapperState) && Bt.controlled && lt.type === "number" && cb(lt, "number", lt.value)
            }
            switch (Bt = rt ? ue(rt) : window, s) {
                case "focusin":
                    (me(Bt) || Bt.contentEditable === "true") && (Qe = Bt, Re = rt, Se = null);
                    break;
                case "focusout":
                    Se = Re = Qe = null;
                    break;
                case "mousedown":
                    Te = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Te = !1, Ue(st, a, ot);
                    break;
                case "selectionchange":
                    if (Pe) break;
                case "keydown":
                case "keyup":
                    Ue(st, a, ot)
            }
            var Lt;
            if (ae) e: {
                switch (s) {
                    case "compositionstart":
                        var Nt = "onCompositionStart";
                        break e;
                    case "compositionend":
                        Nt = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        Nt = "onCompositionUpdate";
                        break e
                }
                Nt = void 0
            }
            else ie ? ge(s, a) && (Nt = "onCompositionEnd") : s === "keydown" && a.keyCode === 229 && (Nt = "onCompositionStart");Nt && (de && a.locale !== "ko" && (ie || Nt !== "onCompositionStart" ? Nt === "onCompositionEnd" && ie && (Lt = nd()) : (kd = ot, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), Bt = oe(rt, Nt), 0 < Bt.length && (Nt = new Ld(Nt, s, null, a, ot), st.push({
                event: Nt,
                listeners: Bt
            }), Lt ? Nt.data = Lt : (Lt = he(a), Lt !== null && (Nt.data = Lt)))),
            (Lt = ce ? je(s, a) : ke(s, a)) && (rt = oe(rt, "onBeforeInput"), 0 < rt.length && (ot = new Ld("onBeforeInput", "beforeinput", null, a, ot), st.push({
                event: ot,
                listeners: rt
            }), ot.data = Lt))
        }
        se(st, o)
    })
}

function tf(s, o, a) {
    return {
        instance: s,
        listener: o,
        currentTarget: a
    }
}

function oe(s, o) {
    for (var a = o + "Capture", $ = []; s !== null;) {
        var j = s,
            _e = j.stateNode;
        j.tag === 5 && _e !== null && (j = _e, _e = Kb(s, a), _e != null && $.unshift(tf(s, _e, j)), _e = Kb(s, o), _e != null && $.push(tf(s, _e, j))), s = s.return
    }
    return $
}

function vf(s) {
    if (s === null) return null;
    do s = s.return; while (s && s.tag !== 5);
    return s || null
}

function wf(s, o, a, $, j) {
    for (var _e = o._reactName, et = []; a !== null && a !== $;) {
        var tt = a,
            nt = tt.alternate,
            rt = tt.stateNode;
        if (nt !== null && nt === $) break;
        tt.tag === 5 && rt !== null && (tt = rt, j ? (nt = Kb(a, _e), nt != null && et.unshift(tf(a, nt, tt))) : j || (nt = Kb(a, _e), nt != null && et.push(tf(a, nt, tt)))), a = a.return
    }
    et.length !== 0 && s.push({
        event: o,
        listeners: et
    })
}
var xf = /\r\n?/g,
    yf = /\u0000|\uFFFD/g;

function zf(s) {
    return (typeof s == "string" ? s : "" + s).replace(xf, `
`).replace(yf, "")
}

function Af(s, o, a) {
    if (o = zf(o), zf(s) !== o && a) throw Error(p$2(425))
}

function Bf() {}
var Cf = null,
    Df = null;

function Ef(s, o) {
    return s === "textarea" || s === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0,
    Gf = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Hf = typeof Promise == "function" ? Promise : void 0,
    Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(s) {
        return Hf.resolve(null).then(s).catch(If)
    } : Ff;

function If(s) {
    setTimeout(function() {
        throw s
    })
}

function Kf(s, o) {
    var a = o,
        $ = 0;
    do {
        var j = a.nextSibling;
        if (s.removeChild(a), j && j.nodeType === 8)
            if (a = j.data, a === "/$") {
                if ($ === 0) {
                    s.removeChild(j), bd(o);
                    return
                }
                $--
            } else a !== "$" && a !== "$?" && a !== "$!" || $++;
        a = j
    } while (a);
    bd(o)
}

function Lf(s) {
    for (; s != null; s = s.nextSibling) {
        var o = s.nodeType;
        if (o === 1 || o === 3) break;
        if (o === 8) {
            if (o = s.data, o === "$" || o === "$!" || o === "$?") break;
            if (o === "/$") return null
        }
    }
    return s
}

function Mf(s) {
    s = s.previousSibling;
    for (var o = 0; s;) {
        if (s.nodeType === 8) {
            var a = s.data;
            if (a === "$" || a === "$!" || a === "$?") {
                if (o === 0) return s;
                o--
            } else a === "/$" && o++
        }
        s = s.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2),
    Of = "__reactFiber$" + Nf,
    Pf = "__reactProps$" + Nf,
    uf = "__reactContainer$" + Nf,
    of = "__reactEvents$" + Nf,
    Qf = "__reactListeners$" + Nf,
    Rf = "__reactHandles$" + Nf;

function Wc(s) {
    var o = s[Of];
    if (o) return o;
    for (var a = s.parentNode; a;) {
        if (o = a[uf] || a[Of]) {
            if (a = o.alternate, o.child !== null || a !== null && a.child !== null)
                for (s = Mf(s); s !== null;) {
                    if (a = s[Of]) return a;
                    s = Mf(s)
                }
            return o
        }
        s = a, a = s.parentNode
    }
    return null
}

function Cb(s) {
    return s = s[Of] || s[uf], !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s
}

function ue(s) {
    if (s.tag === 5 || s.tag === 6) return s.stateNode;
    throw Error(p$2(33))
}

function Db(s) {
    return s[Pf] || null
}
var Sf = [],
    Tf = -1;

function Uf(s) {
    return {
        current: s
    }
}

function E(s) {
    0 > Tf || (s.current = Sf[Tf], Sf[Tf] = null, Tf--)
}

function G(s, o) {
    Tf++, Sf[Tf] = s.current, s.current = o
}
var Vf = {},
    H = Uf(Vf),
    Wf = Uf(!1),
    Xf = Vf;

function Yf(s, o) {
    var a = s.type.contextTypes;
    if (!a) return Vf;
    var $ = s.stateNode;
    if ($ && $.__reactInternalMemoizedUnmaskedChildContext === o) return $.__reactInternalMemoizedMaskedChildContext;
    var j = {},
        _e;
    for (_e in a) j[_e] = o[_e];
    return $ && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = o, s.__reactInternalMemoizedMaskedChildContext = j), j
}

function Zf(s) {
    return s = s.childContextTypes, s != null
}

function $f() {
    E(Wf), E(H)
}

function ag(s, o, a) {
    if (H.current !== Vf) throw Error(p$2(168));
    G(H, o), G(Wf, a)
}

function bg(s, o, a) {
    var $ = s.stateNode;
    if (o = o.childContextTypes, typeof $.getChildContext != "function") return a;
    $ = $.getChildContext();
    for (var j in $)
        if (!(j in o)) throw Error(p$2(108, Ra(s) || "Unknown", j));
    return A$1({}, a, $)
}

function cg(s) {
    return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || Vf, Xf = H.current, G(H, s), G(Wf, Wf.current), !0
}

function dg(s, o, a) {
    var $ = s.stateNode;
    if (!$) throw Error(p$2(169));
    a ? (s = bg(s, o, Xf), $.__reactInternalMemoizedMergedChildContext = s, E(Wf), E(H), G(H, s)) : E(Wf), G(Wf, a)
}
var eg = null,
    fg = !1,
    gg = !1;

function hg(s) {
    eg === null ? eg = [s] : eg.push(s)
}

function ig(s) {
    fg = !0, hg(s)
}

function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var s = 0,
            o = C;
        try {
            var a = eg;
            for (C = 1; s < a.length; s++) {
                var $ = a[s];
                do $ = $(!0); while ($ !== null)
            }
            eg = null, fg = !1
        } catch (j) {
            throw eg !== null && (eg = eg.slice(s + 1)), ac(fc, jg), j
        } finally {
            C = o, gg = !1
        }
    }
    return null
}
var kg = [],
    lg = 0,
    mg = null,
    ng = 0,
    og = [],
    pg = 0,
    qg = null,
    rg = 1,
    sg = "";

function tg(s, o) {
    kg[lg++] = ng, kg[lg++] = mg, mg = s, ng = o
}

function ug(s, o, a) {
    og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = s;
    var $ = rg;
    s = sg;
    var j = 32 - oc($) - 1;
    $ &= ~(1 << j), a += 1;
    var _e = 32 - oc(o) + j;
    if (30 < _e) {
        var et = j - j % 5;
        _e = ($ & (1 << et) - 1).toString(32), $ >>= et, j -= et, rg = 1 << 32 - oc(o) + j | a << j | $, sg = _e + s
    } else rg = 1 << _e | a << j | $, sg = s
}

function vg(s) {
    s.return !== null && (tg(s, 1), ug(s, 1, 0))
}

function wg(s) {
    for (; s === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; s === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null
}
var xg = null,
    yg = null,
    I = !1,
    zg = null;

function Ag(s, o) {
    var a = Bg(5, null, null, 0);
    a.elementType = "DELETED", a.stateNode = o, a.return = s, o = s.deletions, o === null ? (s.deletions = [a], s.flags |= 16) : o.push(a)
}

function Cg(s, o) {
    switch (s.tag) {
        case 5:
            var a = s.type;
            return o = o.nodeType !== 1 || a.toLowerCase() !== o.nodeName.toLowerCase() ? null : o, o !== null ? (s.stateNode = o, xg = s, yg = Lf(o.firstChild), !0) : !1;
        case 6:
            return o = s.pendingProps === "" || o.nodeType !== 3 ? null : o, o !== null ? (s.stateNode = o, xg = s, yg = null, !0) : !1;
        case 13:
            return o = o.nodeType !== 8 ? null : o, o !== null ? (a = qg !== null ? {
                id: rg,
                overflow: sg
            } : null, s.memoizedState = {
                dehydrated: o,
                treeContext: a,
                retryLane: 1073741824
            }, a = Bg(18, null, null, 0), a.stateNode = o, a.return = s, s.child = a, xg = s, yg = null, !0) : !1;
        default:
            return !1
    }
}

function Dg(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0
}

function Eg(s) {
    if (I) {
        var o = yg;
        if (o) {
            var a = o;
            if (!Cg(s, o)) {
                if (Dg(s)) throw Error(p$2(418));
                o = Lf(a.nextSibling);
                var $ = xg;
                o && Cg(s, o) ? Ag($, a) : (s.flags = s.flags & -4097 | 2, I = !1, xg = s)
            }
        } else {
            if (Dg(s)) throw Error(p$2(418));
            s.flags = s.flags & -4097 | 2, I = !1, xg = s
        }
    }
}

function Fg(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13;) s = s.return;
    xg = s
}

function Gg(s) {
    if (s !== xg) return !1;
    if (!I) return Fg(s), I = !0, !1;
    var o;
    if ((o = s.tag !== 3) && !(o = s.tag !== 5) && (o = s.type, o = o !== "head" && o !== "body" && !Ef(s.type, s.memoizedProps)), o && (o = yg)) {
        if (Dg(s)) throw Hg(), Error(p$2(418));
        for (; o;) Ag(s, o), o = Lf(o.nextSibling)
    }
    if (Fg(s), s.tag === 13) {
        if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(p$2(317));
        e: {
            for (s = s.nextSibling, o = 0; s;) {
                if (s.nodeType === 8) {
                    var a = s.data;
                    if (a === "/$") {
                        if (o === 0) {
                            yg = Lf(s.nextSibling);
                            break e
                        }
                        o--
                    } else a !== "$" && a !== "$!" && a !== "$?" || o++
                }
                s = s.nextSibling
            }
            yg = null
        }
    } else yg = xg ? Lf(s.stateNode.nextSibling) : null;
    return !0
}

function Hg() {
    for (var s = yg; s;) s = Lf(s.nextSibling)
}

function Ig() {
    yg = xg = null, I = !1
}

function Jg(s) {
    zg === null ? zg = [s] : zg.push(s)
}
var Kg = ua.ReactCurrentBatchConfig;

function Lg(s, o, a) {
    if (s = a.ref, s !== null && typeof s != "function" && typeof s != "object") {
        if (a._owner) {
            if (a = a._owner, a) {
                if (a.tag !== 1) throw Error(p$2(309));
                var $ = a.stateNode
            }
            if (!$) throw Error(p$2(147, s));
            var j = $,
                _e = "" + s;
            return o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === _e ? o.ref : (o = function(et) {
                var tt = j.refs;
                et === null ? delete tt[_e] : tt[_e] = et
            }, o._stringRef = _e, o)
        }
        if (typeof s != "string") throw Error(p$2(284));
        if (!a._owner) throw Error(p$2(290, s))
    }
    return s
}

function Mg(s, o) {
    throw s = Object.prototype.toString.call(o), Error(p$2(31, s === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : s))
}

function Ng(s) {
    var o = s._init;
    return o(s._payload)
}

function Og(s) {
    function o(vt, wt) {
        if (s) {
            var gt = vt.deletions;
            gt === null ? (vt.deletions = [wt], vt.flags |= 16) : gt.push(wt)
        }
    }

    function a(vt, wt) {
        if (!s) return null;
        for (; wt !== null;) o(vt, wt), wt = wt.sibling;
        return null
    }

    function $(vt, wt) {
        for (vt = new Map; wt !== null;) wt.key !== null ? vt.set(wt.key, wt) : vt.set(wt.index, wt), wt = wt.sibling;
        return vt
    }

    function j(vt, wt) {
        return vt = Pg(vt, wt), vt.index = 0, vt.sibling = null, vt
    }

    function _e(vt, wt, gt) {
        return vt.index = gt, s ? (gt = vt.alternate, gt !== null ? (gt = gt.index, gt < wt ? (vt.flags |= 2, wt) : gt) : (vt.flags |= 2, wt)) : (vt.flags |= 1048576, wt)
    }

    function et(vt) {
        return s && vt.alternate === null && (vt.flags |= 2), vt
    }

    function tt(vt, wt, gt, At) {
        return wt === null || wt.tag !== 6 ? (wt = Qg(gt, vt.mode, At), wt.return = vt, wt) : (wt = j(wt, gt), wt.return = vt, wt)
    }

    function nt(vt, wt, gt, At) {
        var Pt = gt.type;
        return Pt === ya ? ot(vt, wt, gt.props.children, At, gt.key) : wt !== null && (wt.elementType === Pt || typeof Pt == "object" && Pt !== null && Pt.$$typeof === Ha && Ng(Pt) === wt.type) ? (At = j(wt, gt.props), At.ref = Lg(vt, wt, gt), At.return = vt, At) : (At = Rg(gt.type, gt.key, gt.props, null, vt.mode, At), At.ref = Lg(vt, wt, gt), At.return = vt, At)
    }

    function rt(vt, wt, gt, At) {
        return wt === null || wt.tag !== 4 || wt.stateNode.containerInfo !== gt.containerInfo || wt.stateNode.implementation !== gt.implementation ? (wt = Sg(gt, vt.mode, At), wt.return = vt, wt) : (wt = j(wt, gt.children || []), wt.return = vt, wt)
    }

    function ot(vt, wt, gt, At, Pt) {
        return wt === null || wt.tag !== 7 ? (wt = Tg(gt, vt.mode, At, Pt), wt.return = vt, wt) : (wt = j(wt, gt), wt.return = vt, wt)
    }

    function st(vt, wt, gt) {
        if (typeof wt == "string" && wt !== "" || typeof wt == "number") return wt = Qg("" + wt, vt.mode, gt), wt.return = vt, wt;
        if (typeof wt == "object" && wt !== null) {
            switch (wt.$$typeof) {
                case va:
                    return gt = Rg(wt.type, wt.key, wt.props, null, vt.mode, gt), gt.ref = Lg(vt, null, wt), gt.return = vt, gt;
                case wa:
                    return wt = Sg(wt, vt.mode, gt), wt.return = vt, wt;
                case Ha:
                    var At = wt._init;
                    return st(vt, At(wt._payload), gt)
            }
            if (eb(wt) || Ka(wt)) return wt = Tg(wt, vt.mode, gt, null), wt.return = vt, wt;
            Mg(vt, wt)
        }
        return null
    }

    function lt(vt, wt, gt, At) {
        var Pt = wt !== null ? wt.key : null;
        if (typeof gt == "string" && gt !== "" || typeof gt == "number") return Pt !== null ? null : tt(vt, wt, "" + gt, At);
        if (typeof gt == "object" && gt !== null) {
            switch (gt.$$typeof) {
                case va:
                    return gt.key === Pt ? nt(vt, wt, gt, At) : null;
                case wa:
                    return gt.key === Pt ? rt(vt, wt, gt, At) : null;
                case Ha:
                    return Pt = gt._init, lt(vt, wt, Pt(gt._payload), At)
            }
            if (eb(gt) || Ka(gt)) return Pt !== null ? null : ot(vt, wt, gt, At, null);
            Mg(vt, gt)
        }
        return null
    }

    function ft(vt, wt, gt, At, Pt) {
        if (typeof At == "string" && At !== "" || typeof At == "number") return vt = vt.get(gt) || null, tt(wt, vt, "" + At, Pt);
        if (typeof At == "object" && At !== null) {
            switch (At.$$typeof) {
                case va:
                    return vt = vt.get(At.key === null ? gt : At.key) || null, nt(wt, vt, At, Pt);
                case wa:
                    return vt = vt.get(At.key === null ? gt : At.key) || null, rt(wt, vt, At, Pt);
                case Ha:
                    var Bt = At._init;
                    return ft(vt, wt, gt, Bt(At._payload), Pt)
            }
            if (eb(At) || Ka(At)) return vt = vt.get(gt) || null, ot(wt, vt, At, Pt, null);
            Mg(wt, At)
        }
        return null
    }

    function yt(vt, wt, gt, At) {
        for (var Pt = null, Bt = null, Lt = wt, Nt = wt = 0, Ut = null; Lt !== null && Nt < gt.length; Nt++) {
            Lt.index > Nt ? (Ut = Lt, Lt = null) : Ut = Lt.sibling;
            var Vt = lt(vt, Lt, gt[Nt], At);
            if (Vt === null) {
                Lt === null && (Lt = Ut);
                break
            }
            s && Lt && Vt.alternate === null && o(vt, Lt), wt = _e(Vt, wt, Nt), Bt === null ? Pt = Vt : Bt.sibling = Vt, Bt = Vt, Lt = Ut
        }
        if (Nt === gt.length) return a(vt, Lt), I && tg(vt, Nt), Pt;
        if (Lt === null) {
            for (; Nt < gt.length; Nt++) Lt = st(vt, gt[Nt], At), Lt !== null && (wt = _e(Lt, wt, Nt), Bt === null ? Pt = Lt : Bt.sibling = Lt, Bt = Lt);
            return I && tg(vt, Nt), Pt
        }
        for (Lt = $(vt, Lt); Nt < gt.length; Nt++) Ut = ft(Lt, vt, Nt, gt[Nt], At), Ut !== null && (s && Ut.alternate !== null && Lt.delete(Ut.key === null ? Nt : Ut.key), wt = _e(Ut, wt, Nt), Bt === null ? Pt = Ut : Bt.sibling = Ut, Bt = Ut);
        return s && Lt.forEach(function(Ft) {
            return o(vt, Ft)
        }), I && tg(vt, Nt), Pt
    }

    function bt(vt, wt, gt, At) {
        var Pt = Ka(gt);
        if (typeof Pt != "function") throw Error(p$2(150));
        if (gt = Pt.call(gt), gt == null) throw Error(p$2(151));
        for (var Bt = Pt = null, Lt = wt, Nt = wt = 0, Ut = null, Vt = gt.next(); Lt !== null && !Vt.done; Nt++, Vt = gt.next()) {
            Lt.index > Nt ? (Ut = Lt, Lt = null) : Ut = Lt.sibling;
            var Ft = lt(vt, Lt, Vt.value, At);
            if (Ft === null) {
                Lt === null && (Lt = Ut);
                break
            }
            s && Lt && Ft.alternate === null && o(vt, Lt), wt = _e(Ft, wt, Nt), Bt === null ? Pt = Ft : Bt.sibling = Ft, Bt = Ft, Lt = Ut
        }
        if (Vt.done) return a(vt, Lt), I && tg(vt, Nt), Pt;
        if (Lt === null) {
            for (; !Vt.done; Nt++, Vt = gt.next()) Vt = st(vt, Vt.value, At), Vt !== null && (wt = _e(Vt, wt, Nt), Bt === null ? Pt = Vt : Bt.sibling = Vt, Bt = Vt);
            return I && tg(vt, Nt), Pt
        }
        for (Lt = $(vt, Lt); !Vt.done; Nt++, Vt = gt.next()) Vt = ft(Lt, vt, Nt, Vt.value, At), Vt !== null && (s && Vt.alternate !== null && Lt.delete(Vt.key === null ? Nt : Vt.key), wt = _e(Vt, wt, Nt), Bt === null ? Pt = Vt : Bt.sibling = Vt, Bt = Vt);
        return s && Lt.forEach(function(Wt) {
            return o(vt, Wt)
        }), I && tg(vt, Nt), Pt
    }

    function ht(vt, wt, gt, At) {
        if (typeof gt == "object" && gt !== null && gt.type === ya && gt.key === null && (gt = gt.props.children), typeof gt == "object" && gt !== null) {
            switch (gt.$$typeof) {
                case va:
                    e: {
                        for (var Pt = gt.key, Bt = wt; Bt !== null;) {
                            if (Bt.key === Pt) {
                                if (Pt = gt.type, Pt === ya) {
                                    if (Bt.tag === 7) {
                                        a(vt, Bt.sibling), wt = j(Bt, gt.props.children), wt.return = vt, vt = wt;
                                        break e
                                    }
                                } else if (Bt.elementType === Pt || typeof Pt == "object" && Pt !== null && Pt.$$typeof === Ha && Ng(Pt) === Bt.type) {
                                    a(vt, Bt.sibling), wt = j(Bt, gt.props), wt.ref = Lg(vt, Bt, gt), wt.return = vt, vt = wt;
                                    break e
                                }
                                a(vt, Bt);
                                break
                            } else o(vt, Bt);
                            Bt = Bt.sibling
                        }
                        gt.type === ya ? (wt = Tg(gt.props.children, vt.mode, At, gt.key), wt.return = vt, vt = wt) : (At = Rg(gt.type, gt.key, gt.props, null, vt.mode, At), At.ref = Lg(vt, wt, gt), At.return = vt, vt = At)
                    }
                    return et(vt);
                case wa:
                    e: {
                        for (Bt = gt.key; wt !== null;) {
                            if (wt.key === Bt)
                                if (wt.tag === 4 && wt.stateNode.containerInfo === gt.containerInfo && wt.stateNode.implementation === gt.implementation) {
                                    a(vt, wt.sibling), wt = j(wt, gt.children || []), wt.return = vt, vt = wt;
                                    break e
                                } else {
                                    a(vt, wt);
                                    break
                                }
                            else o(vt, wt);
                            wt = wt.sibling
                        }
                        wt = Sg(gt, vt.mode, At),
                        wt.return = vt,
                        vt = wt
                    }
                    return et(vt);
                case Ha:
                    return Bt = gt._init, ht(vt, wt, Bt(gt._payload), At)
            }
            if (eb(gt)) return yt(vt, wt, gt, At);
            if (Ka(gt)) return bt(vt, wt, gt, At);
            Mg(vt, gt)
        }
        return typeof gt == "string" && gt !== "" || typeof gt == "number" ? (gt = "" + gt, wt !== null && wt.tag === 6 ? (a(vt, wt.sibling), wt = j(wt, gt), wt.return = vt, vt = wt) : (a(vt, wt), wt = Qg(gt, vt.mode, At), wt.return = vt, vt = wt), et(vt)) : a(vt, wt)
    }
    return ht
}
var Ug = Og(!0),
    Vg = Og(!1),
    Wg = Uf(null),
    Xg = null,
    Yg = null,
    Zg = null;

function $g() {
    Zg = Yg = Xg = null
}

function ah(s) {
    var o = Wg.current;
    E(Wg), s._currentValue = o
}

function bh(s, o, a) {
    for (; s !== null;) {
        var $ = s.alternate;
        if ((s.childLanes & o) !== o ? (s.childLanes |= o, $ !== null && ($.childLanes |= o)) : $ !== null && ($.childLanes & o) !== o && ($.childLanes |= o), s === a) break;
        s = s.return
    }
}

function ch(s, o) {
    Xg = s, Zg = Yg = null, s = s.dependencies, s !== null && s.firstContext !== null && (s.lanes & o && (dh = !0), s.firstContext = null)
}

function eh(s) {
    var o = s._currentValue;
    if (Zg !== s)
        if (s = {
                context: s,
                memoizedValue: o,
                next: null
            }, Yg === null) {
            if (Xg === null) throw Error(p$2(308));
            Yg = s, Xg.dependencies = {
                lanes: 0,
                firstContext: s
            }
        } else Yg = Yg.next = s;
    return o
}
var fh = null;

function gh(s) {
    fh === null ? fh = [s] : fh.push(s)
}

function hh(s, o, a, $) {
    var j = o.interleaved;
    return j === null ? (a.next = a, gh(o)) : (a.next = j.next, j.next = a), o.interleaved = a, ih(s, $)
}

function ih(s, o) {
    s.lanes |= o;
    var a = s.alternate;
    for (a !== null && (a.lanes |= o), a = s, s = s.return; s !== null;) s.childLanes |= o, a = s.alternate, a !== null && (a.childLanes |= o), a = s, s = s.return;
    return a.tag === 3 ? a.stateNode : null
}
var jh = !1;

function kh(s) {
    s.updateQueue = {
        baseState: s.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function lh(s, o) {
    s = s.updateQueue, o.updateQueue === s && (o.updateQueue = {
        baseState: s.baseState,
        firstBaseUpdate: s.firstBaseUpdate,
        lastBaseUpdate: s.lastBaseUpdate,
        shared: s.shared,
        effects: s.effects
    })
}

function mh(s, o) {
    return {
        eventTime: s,
        lane: o,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function nh(s, o, a) {
    var $ = s.updateQueue;
    if ($ === null) return null;
    if ($ = $.shared, K & 2) {
        var j = $.pending;
        return j === null ? o.next = o : (o.next = j.next, j.next = o), $.pending = o, ih(s, a)
    }
    return j = $.interleaved, j === null ? (o.next = o, gh($)) : (o.next = j.next, j.next = o), $.interleaved = o, ih(s, a)
}

function oh(s, o, a) {
    if (o = o.updateQueue, o !== null && (o = o.shared, (a & 4194240) !== 0)) {
        var $ = o.lanes;
        $ &= s.pendingLanes, a |= $, o.lanes = a, Cc(s, a)
    }
}

function ph(s, o) {
    var a = s.updateQueue,
        $ = s.alternate;
    if ($ !== null && ($ = $.updateQueue, a === $)) {
        var j = null,
            _e = null;
        if (a = a.firstBaseUpdate, a !== null) {
            do {
                var et = {
                    eventTime: a.eventTime,
                    lane: a.lane,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                };
                _e === null ? j = _e = et : _e = _e.next = et, a = a.next
            } while (a !== null);
            _e === null ? j = _e = o : _e = _e.next = o
        } else j = _e = o;
        a = {
            baseState: $.baseState,
            firstBaseUpdate: j,
            lastBaseUpdate: _e,
            shared: $.shared,
            effects: $.effects
        }, s.updateQueue = a;
        return
    }
    s = a.lastBaseUpdate, s === null ? a.firstBaseUpdate = o : s.next = o, a.lastBaseUpdate = o
}

function qh(s, o, a, $) {
    var j = s.updateQueue;
    jh = !1;
    var _e = j.firstBaseUpdate,
        et = j.lastBaseUpdate,
        tt = j.shared.pending;
    if (tt !== null) {
        j.shared.pending = null;
        var nt = tt,
            rt = nt.next;
        nt.next = null, et === null ? _e = rt : et.next = rt, et = nt;
        var ot = s.alternate;
        ot !== null && (ot = ot.updateQueue, tt = ot.lastBaseUpdate, tt !== et && (tt === null ? ot.firstBaseUpdate = rt : tt.next = rt, ot.lastBaseUpdate = nt))
    }
    if (_e !== null) {
        var st = j.baseState;
        et = 0, ot = rt = nt = null, tt = _e;
        do {
            var lt = tt.lane,
                ft = tt.eventTime;
            if (($ & lt) === lt) {
                ot !== null && (ot = ot.next = {
                    eventTime: ft,
                    lane: 0,
                    tag: tt.tag,
                    payload: tt.payload,
                    callback: tt.callback,
                    next: null
                });
                e: {
                    var yt = s,
                        bt = tt;
                    switch (lt = o, ft = a, bt.tag) {
                        case 1:
                            if (yt = bt.payload, typeof yt == "function") {
                                st = yt.call(ft, st, lt);
                                break e
                            }
                            st = yt;
                            break e;
                        case 3:
                            yt.flags = yt.flags & -65537 | 128;
                        case 0:
                            if (yt = bt.payload, lt = typeof yt == "function" ? yt.call(ft, st, lt) : yt, lt == null) break e;
                            st = A$1({}, st, lt);
                            break e;
                        case 2:
                            jh = !0
                    }
                }
                tt.callback !== null && tt.lane !== 0 && (s.flags |= 64, lt = j.effects, lt === null ? j.effects = [tt] : lt.push(tt))
            } else ft = {
                eventTime: ft,
                lane: lt,
                tag: tt.tag,
                payload: tt.payload,
                callback: tt.callback,
                next: null
            }, ot === null ? (rt = ot = ft, nt = st) : ot = ot.next = ft, et |= lt;
            if (tt = tt.next, tt === null) {
                if (tt = j.shared.pending, tt === null) break;
                lt = tt, tt = lt.next, lt.next = null, j.lastBaseUpdate = lt, j.shared.pending = null
            }
        } while (!0);
        if (ot === null && (nt = st), j.baseState = nt, j.firstBaseUpdate = rt, j.lastBaseUpdate = ot, o = j.shared.interleaved, o !== null) {
            j = o;
            do et |= j.lane, j = j.next; while (j !== o)
        } else _e === null && (j.shared.lanes = 0);
        rh |= et, s.lanes = et, s.memoizedState = st
    }
}

function sh(s, o, a) {
    if (s = o.effects, o.effects = null, s !== null)
        for (o = 0; o < s.length; o++) {
            var $ = s[o],
                j = $.callback;
            if (j !== null) {
                if ($.callback = null, $ = a, typeof j != "function") throw Error(p$2(191, j));
                j.call($)
            }
        }
}
var th = {},
    uh = Uf(th),
    vh$1 = Uf(th),
    wh = Uf(th);

function xh(s) {
    if (s === th) throw Error(p$2(174));
    return s
}

function yh(s, o) {
    switch (G(wh, o), G(vh$1, s), G(uh, th), s = o.nodeType, s) {
        case 9:
        case 11:
            o = (o = o.documentElement) ? o.namespaceURI : lb(null, "");
            break;
        default:
            s = s === 8 ? o.parentNode : o, o = s.namespaceURI || null, s = s.tagName, o = lb(o, s)
    }
    E(uh), G(uh, o)
}

function zh() {
    E(uh), E(vh$1), E(wh)
}

function Ah(s) {
    xh(wh.current);
    var o = xh(uh.current),
        a = lb(o, s.type);
    o !== a && (G(vh$1, s), G(uh, a))
}

function Bh(s) {
    vh$1.current === s && (E(uh), E(vh$1))
}
var L = Uf(0);

function Ch(s) {
    for (var o = s; o !== null;) {
        if (o.tag === 13) {
            var a = o.memoizedState;
            if (a !== null && (a = a.dehydrated, a === null || a.data === "$?" || a.data === "$!")) return o
        } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
            if (o.flags & 128) return o
        } else if (o.child !== null) {
            o.child.return = o, o = o.child;
            continue
        }
        if (o === s) break;
        for (; o.sibling === null;) {
            if (o.return === null || o.return === s) return null;
            o = o.return
        }
        o.sibling.return = o.return, o = o.sibling
    }
    return null
}
var Dh = [];

function Eh() {
    for (var s = 0; s < Dh.length; s++) Dh[s]._workInProgressVersionPrimary = null;
    Dh.length = 0
}
var Fh = ua.ReactCurrentDispatcher,
    Gh = ua.ReactCurrentBatchConfig,
    Hh = 0,
    M = null,
    N = null,
    O = null,
    Ih = !1,
    Jh = !1,
    Kh = 0,
    Lh = 0;

function P() {
    throw Error(p$2(321))
}

function Mh(s, o) {
    if (o === null) return !1;
    for (var a = 0; a < o.length && a < s.length; a++)
        if (!He(s[a], o[a])) return !1;
    return !0
}

function Nh(s, o, a, $, j, _e) {
    if (Hh = _e, M = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, Fh.current = s === null || s.memoizedState === null ? Oh : Ph, s = a($, j), Jh) {
        _e = 0;
        do {
            if (Jh = !1, Kh = 0, 25 <= _e) throw Error(p$2(301));
            _e += 1, O = N = null, o.updateQueue = null, Fh.current = Qh, s = a($, j)
        } while (Jh)
    }
    if (Fh.current = Rh, o = N !== null && N.next !== null, Hh = 0, O = N = M = null, Ih = !1, o) throw Error(p$2(300));
    return s
}

function Sh() {
    var s = Kh !== 0;
    return Kh = 0, s
}

function Th() {
    var s = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return O === null ? M.memoizedState = O = s : O = O.next = s, O
}

function Uh() {
    if (N === null) {
        var s = M.alternate;
        s = s !== null ? s.memoizedState : null
    } else s = N.next;
    var o = O === null ? M.memoizedState : O.next;
    if (o !== null) O = o, N = s;
    else {
        if (s === null) throw Error(p$2(310));
        N = s, s = {
            memoizedState: N.memoizedState,
            baseState: N.baseState,
            baseQueue: N.baseQueue,
            queue: N.queue,
            next: null
        }, O === null ? M.memoizedState = O = s : O = O.next = s
    }
    return O
}

function Vh(s, o) {
    return typeof o == "function" ? o(s) : o
}

function Wh(s) {
    var o = Uh(),
        a = o.queue;
    if (a === null) throw Error(p$2(311));
    a.lastRenderedReducer = s;
    var $ = N,
        j = $.baseQueue,
        _e = a.pending;
    if (_e !== null) {
        if (j !== null) {
            var et = j.next;
            j.next = _e.next, _e.next = et
        }
        $.baseQueue = j = _e, a.pending = null
    }
    if (j !== null) {
        _e = j.next, $ = $.baseState;
        var tt = et = null,
            nt = null,
            rt = _e;
        do {
            var ot = rt.lane;
            if ((Hh & ot) === ot) nt !== null && (nt = nt.next = {
                lane: 0,
                action: rt.action,
                hasEagerState: rt.hasEagerState,
                eagerState: rt.eagerState,
                next: null
            }), $ = rt.hasEagerState ? rt.eagerState : s($, rt.action);
            else {
                var st = {
                    lane: ot,
                    action: rt.action,
                    hasEagerState: rt.hasEagerState,
                    eagerState: rt.eagerState,
                    next: null
                };
                nt === null ? (tt = nt = st, et = $) : nt = nt.next = st, M.lanes |= ot, rh |= ot
            }
            rt = rt.next
        } while (rt !== null && rt !== _e);
        nt === null ? et = $ : nt.next = tt, He($, o.memoizedState) || (dh = !0), o.memoizedState = $, o.baseState = et, o.baseQueue = nt, a.lastRenderedState = $
    }
    if (s = a.interleaved, s !== null) {
        j = s;
        do _e = j.lane, M.lanes |= _e, rh |= _e, j = j.next; while (j !== s)
    } else j === null && (a.lanes = 0);
    return [o.memoizedState, a.dispatch]
}

function Xh(s) {
    var o = Uh(),
        a = o.queue;
    if (a === null) throw Error(p$2(311));
    a.lastRenderedReducer = s;
    var $ = a.dispatch,
        j = a.pending,
        _e = o.memoizedState;
    if (j !== null) {
        a.pending = null;
        var et = j = j.next;
        do _e = s(_e, et.action), et = et.next; while (et !== j);
        He(_e, o.memoizedState) || (dh = !0), o.memoizedState = _e, o.baseQueue === null && (o.baseState = _e), a.lastRenderedState = _e
    }
    return [_e, $]
}

function Yh() {}

function Zh(s, o) {
    var a = M,
        $ = Uh(),
        j = o(),
        _e = !He($.memoizedState, j);
    if (_e && ($.memoizedState = j, dh = !0), $ = $.queue, $h(ai.bind(null, a, $, s), [s]), $.getSnapshot !== o || _e || O !== null && O.memoizedState.tag & 1) {
        if (a.flags |= 2048, bi(9, ci.bind(null, a, $, j, o), void 0, null), Q === null) throw Error(p$2(349));
        Hh & 30 || di(a, o, j)
    }
    return j
}

function di(s, o, a) {
    s.flags |= 16384, s = {
        getSnapshot: o,
        value: a
    }, o = M.updateQueue, o === null ? (o = {
        lastEffect: null,
        stores: null
    }, M.updateQueue = o, o.stores = [s]) : (a = o.stores, a === null ? o.stores = [s] : a.push(s))
}

function ci(s, o, a, $) {
    o.value = a, o.getSnapshot = $, ei(o) && fi(s)
}

function ai(s, o, a) {
    return a(function() {
        ei(o) && fi(s)
    })
}

function ei(s) {
    var o = s.getSnapshot;
    s = s.value;
    try {
        var a = o();
        return !He(s, a)
    } catch {
        return !0
    }
}

function fi(s) {
    var o = ih(s, 1);
    o !== null && gi(o, s, 1, -1)
}

function hi(s) {
    var o = Th();
    return typeof s == "function" && (s = s()), o.memoizedState = o.baseState = s, s = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Vh,
        lastRenderedState: s
    }, o.queue = s, s = s.dispatch = ii.bind(null, M, s), [o.memoizedState, s]
}

function bi(s, o, a, $) {
    return s = {
        tag: s,
        create: o,
        destroy: a,
        deps: $,
        next: null
    }, o = M.updateQueue, o === null ? (o = {
        lastEffect: null,
        stores: null
    }, M.updateQueue = o, o.lastEffect = s.next = s) : (a = o.lastEffect, a === null ? o.lastEffect = s.next = s : ($ = a.next, a.next = s, s.next = $, o.lastEffect = s)), s
}

function ji() {
    return Uh().memoizedState
}

function ki(s, o, a, $) {
    var j = Th();
    M.flags |= s, j.memoizedState = bi(1 | o, a, void 0, $ === void 0 ? null : $)
}

function li(s, o, a, $) {
    var j = Uh();
    $ = $ === void 0 ? null : $;
    var _e = void 0;
    if (N !== null) {
        var et = N.memoizedState;
        if (_e = et.destroy, $ !== null && Mh($, et.deps)) {
            j.memoizedState = bi(o, a, _e, $);
            return
        }
    }
    M.flags |= s, j.memoizedState = bi(1 | o, a, _e, $)
}

function mi(s, o) {
    return ki(8390656, 8, s, o)
}

function $h(s, o) {
    return li(2048, 8, s, o)
}

function ni(s, o) {
    return li(4, 2, s, o)
}

function oi(s, o) {
    return li(4, 4, s, o)
}

function pi(s, o) {
    if (typeof o == "function") return s = s(), o(s),
        function() {
            o(null)
        };
    if (o != null) return s = s(), o.current = s,
        function() {
            o.current = null
        }
}

function qi(s, o, a) {
    return a = a != null ? a.concat([s]) : null, li(4, 4, pi.bind(null, o, s), a)
}

function ri() {}

function si(s, o) {
    var a = Uh();
    o = o === void 0 ? null : o;
    var $ = a.memoizedState;
    return $ !== null && o !== null && Mh(o, $[1]) ? $[0] : (a.memoizedState = [s, o], s)
}

function ti(s, o) {
    var a = Uh();
    o = o === void 0 ? null : o;
    var $ = a.memoizedState;
    return $ !== null && o !== null && Mh(o, $[1]) ? $[0] : (s = s(), a.memoizedState = [s, o], s)
}

function ui(s, o, a) {
    return Hh & 21 ? (He(a, o) || (a = yc(), M.lanes |= a, rh |= a, s.baseState = !0), o) : (s.baseState && (s.baseState = !1, dh = !0), s.memoizedState = a)
}

function vi(s, o) {
    var a = C;
    C = a !== 0 && 4 > a ? a : 4, s(!0);
    var $ = Gh.transition;
    Gh.transition = {};
    try {
        s(!1), o()
    } finally {
        C = a, Gh.transition = $
    }
}

function wi() {
    return Uh().memoizedState
}

function xi(s, o, a) {
    var $ = yi(s);
    if (a = {
            lane: $,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, zi(s)) Ai(o, a);
    else if (a = hh(s, o, a, $), a !== null) {
        var j = R();
        gi(a, s, $, j), Bi(a, o, $)
    }
}

function ii(s, o, a) {
    var $ = yi(s),
        j = {
            lane: $,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (zi(s)) Ai(o, j);
    else {
        var _e = s.alternate;
        if (s.lanes === 0 && (_e === null || _e.lanes === 0) && (_e = o.lastRenderedReducer, _e !== null)) try {
            var et = o.lastRenderedState,
                tt = _e(et, a);
            if (j.hasEagerState = !0, j.eagerState = tt, He(tt, et)) {
                var nt = o.interleaved;
                nt === null ? (j.next = j, gh(o)) : (j.next = nt.next, nt.next = j), o.interleaved = j;
                return
            }
        } catch {} finally {}
        a = hh(s, o, j, $), a !== null && (j = R(), gi(a, s, $, j), Bi(a, o, $))
    }
}

function zi(s) {
    var o = s.alternate;
    return s === M || o !== null && o === M
}

function Ai(s, o) {
    Jh = Ih = !0;
    var a = s.pending;
    a === null ? o.next = o : (o.next = a.next, a.next = o), s.pending = o
}

function Bi(s, o, a) {
    if (a & 4194240) {
        var $ = o.lanes;
        $ &= s.pendingLanes, a |= $, o.lanes = a, Cc(s, a)
    }
}
var Rh = {
        readContext: eh,
        useCallback: P,
        useContext: P,
        useEffect: P,
        useImperativeHandle: P,
        useInsertionEffect: P,
        useLayoutEffect: P,
        useMemo: P,
        useReducer: P,
        useRef: P,
        useState: P,
        useDebugValue: P,
        useDeferredValue: P,
        useTransition: P,
        useMutableSource: P,
        useSyncExternalStore: P,
        useId: P,
        unstable_isNewReconciler: !1
    },
    Oh = {
        readContext: eh,
        useCallback: function(s, o) {
            return Th().memoizedState = [s, o === void 0 ? null : o], s
        },
        useContext: eh,
        useEffect: mi,
        useImperativeHandle: function(s, o, a) {
            return a = a != null ? a.concat([s]) : null, ki(4194308, 4, pi.bind(null, o, s), a)
        },
        useLayoutEffect: function(s, o) {
            return ki(4194308, 4, s, o)
        },
        useInsertionEffect: function(s, o) {
            return ki(4, 2, s, o)
        },
        useMemo: function(s, o) {
            var a = Th();
            return o = o === void 0 ? null : o, s = s(), a.memoizedState = [s, o], s
        },
        useReducer: function(s, o, a) {
            var $ = Th();
            return o = a !== void 0 ? a(o) : o, $.memoizedState = $.baseState = o, s = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: s,
                lastRenderedState: o
            }, $.queue = s, s = s.dispatch = xi.bind(null, M, s), [$.memoizedState, s]
        },
        useRef: function(s) {
            var o = Th();
            return s = {
                current: s
            }, o.memoizedState = s
        },
        useState: hi,
        useDebugValue: ri,
        useDeferredValue: function(s) {
            return Th().memoizedState = s
        },
        useTransition: function() {
            var s = hi(!1),
                o = s[0];
            return s = vi.bind(null, s[1]), Th().memoizedState = s, [o, s]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(s, o, a) {
            var $ = M,
                j = Th();
            if (I) {
                if (a === void 0) throw Error(p$2(407));
                a = a()
            } else {
                if (a = o(), Q === null) throw Error(p$2(349));
                Hh & 30 || di($, o, a)
            }
            j.memoizedState = a;
            var _e = {
                value: a,
                getSnapshot: o
            };
            return j.queue = _e, mi(ai.bind(null, $, _e, s), [s]), $.flags |= 2048, bi(9, ci.bind(null, $, _e, a, o), void 0, null), a
        },
        useId: function() {
            var s = Th(),
                o = Q.identifierPrefix;
            if (I) {
                var a = sg,
                    $ = rg;
                a = ($ & ~(1 << 32 - oc($) - 1)).toString(32) + a, o = ":" + o + "R" + a, a = Kh++, 0 < a && (o += "H" + a.toString(32)), o += ":"
            } else a = Lh++, o = ":" + o + "r" + a.toString(32) + ":";
            return s.memoizedState = o
        },
        unstable_isNewReconciler: !1
    },
    Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
            return Wh(Vh)
        },
        useDebugValue: ri,
        useDeferredValue: function(s) {
            var o = Uh();
            return ui(o, N.memoizedState, s)
        },
        useTransition: function() {
            var s = Wh(Vh)[0],
                o = Uh().memoizedState;
            return [s, o]
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: !1
    },
    Qh = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Xh,
        useRef: ji,
        useState: function() {
            return Xh(Vh)
        },
        useDebugValue: ri,
        useDeferredValue: function(s) {
            var o = Uh();
            return N === null ? o.memoizedState = s : ui(o, N.memoizedState, s)
        },
        useTransition: function() {
            var s = Xh(Vh)[0],
                o = Uh().memoizedState;
            return [s, o]
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: !1
    };

function Ci(s, o) {
    if (s && s.defaultProps) {
        o = A$1({}, o), s = s.defaultProps;
        for (var a in s) o[a] === void 0 && (o[a] = s[a]);
        return o
    }
    return o
}

function Di(s, o, a, $) {
    o = s.memoizedState, a = a($, o), a = a == null ? o : A$1({}, o, a), s.memoizedState = a, s.lanes === 0 && (s.updateQueue.baseState = a)
}
var Ei = {
    isMounted: function(s) {
        return (s = s._reactInternals) ? Vb(s) === s : !1
    },
    enqueueSetState: function(s, o, a) {
        s = s._reactInternals;
        var $ = R(),
            j = yi(s),
            _e = mh($, j);
        _e.payload = o, a != null && (_e.callback = a), o = nh(s, _e, j), o !== null && (gi(o, s, j, $), oh(o, s, j))
    },
    enqueueReplaceState: function(s, o, a) {
        s = s._reactInternals;
        var $ = R(),
            j = yi(s),
            _e = mh($, j);
        _e.tag = 1, _e.payload = o, a != null && (_e.callback = a), o = nh(s, _e, j), o !== null && (gi(o, s, j, $), oh(o, s, j))
    },
    enqueueForceUpdate: function(s, o) {
        s = s._reactInternals;
        var a = R(),
            $ = yi(s),
            j = mh(a, $);
        j.tag = 2, o != null && (j.callback = o), o = nh(s, j, $), o !== null && (gi(o, s, $, a), oh(o, s, $))
    }
};

function Fi(s, o, a, $, j, _e, et) {
    return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate($, _e, et) : o.prototype && o.prototype.isPureReactComponent ? !Ie(a, $) || !Ie(j, _e) : !0
}

function Gi(s, o, a) {
    var $ = !1,
        j = Vf,
        _e = o.contextType;
    return typeof _e == "object" && _e !== null ? _e = eh(_e) : (j = Zf(o) ? Xf : H.current, $ = o.contextTypes, _e = ($ = $ != null) ? Yf(s, j) : Vf), o = new o(a, _e), s.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, o.updater = Ei, s.stateNode = o, o._reactInternals = s, $ && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = j, s.__reactInternalMemoizedMaskedChildContext = _e), o
}

function Hi(s, o, a, $) {
    s = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(a, $), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(a, $), o.state !== s && Ei.enqueueReplaceState(o, o.state, null)
}

function Ii(s, o, a, $) {
    var j = s.stateNode;
    j.props = a, j.state = s.memoizedState, j.refs = {}, kh(s);
    var _e = o.contextType;
    typeof _e == "object" && _e !== null ? j.context = eh(_e) : (_e = Zf(o) ? Xf : H.current, j.context = Yf(s, _e)), j.state = s.memoizedState, _e = o.getDerivedStateFromProps, typeof _e == "function" && (Di(s, o, _e, a), j.state = s.memoizedState), typeof o.getDerivedStateFromProps == "function" || typeof j.getSnapshotBeforeUpdate == "function" || typeof j.UNSAFE_componentWillMount != "function" && typeof j.componentWillMount != "function" || (o = j.state, typeof j.componentWillMount == "function" && j.componentWillMount(), typeof j.UNSAFE_componentWillMount == "function" && j.UNSAFE_componentWillMount(), o !== j.state && Ei.enqueueReplaceState(j, j.state, null), qh(s, a, j, $), j.state = s.memoizedState), typeof j.componentDidMount == "function" && (s.flags |= 4194308)
}

function Ji(s, o) {
    try {
        var a = "",
            $ = o;
        do a += Pa($), $ = $.return; while ($);
        var j = a
    } catch (_e) {
        j = `
Error generating stack: ` + _e.message + `
` + _e.stack
    }
    return {
        value: s,
        source: o,
        stack: j,
        digest: null
    }
}

function Ki(s, o, a) {
    return {
        value: s,
        source: null,
        stack: a ? ? null,
        digest: o ? ? null
    }
}

function Li(s, o) {
    try {
        console.error(o.value)
    } catch (a) {
        setTimeout(function() {
            throw a
        })
    }
}
var Mi = typeof WeakMap == "function" ? WeakMap : Map;

function Ni(s, o, a) {
    a = mh(-1, a), a.tag = 3, a.payload = {
        element: null
    };
    var $ = o.value;
    return a.callback = function() {
        Oi || (Oi = !0, Pi = $), Li(s, o)
    }, a
}

function Qi(s, o, a) {
    a = mh(-1, a), a.tag = 3;
    var $ = s.type.getDerivedStateFromError;
    if (typeof $ == "function") {
        var j = o.value;
        a.payload = function() {
            return $(j)
        }, a.callback = function() {
            Li(s, o)
        }
    }
    var _e = s.stateNode;
    return _e !== null && typeof _e.componentDidCatch == "function" && (a.callback = function() {
        Li(s, o), typeof $ != "function" && (Ri === null ? Ri = new Set([this]) : Ri.add(this));
        var et = o.stack;
        this.componentDidCatch(o.value, {
            componentStack: et !== null ? et : ""
        })
    }), a
}

function Si(s, o, a) {
    var $ = s.pingCache;
    if ($ === null) {
        $ = s.pingCache = new Mi;
        var j = new Set;
        $.set(o, j)
    } else j = $.get(o), j === void 0 && (j = new Set, $.set(o, j));
    j.has(a) || (j.add(a), s = Ti.bind(null, s, o, a), o.then(s, s))
}

function Ui(s) {
    do {
        var o;
        if ((o = s.tag === 13) && (o = s.memoizedState, o = o !== null ? o.dehydrated !== null : !0), o) return s;
        s = s.return
    } while (s !== null);
    return null
}

function Vi(s, o, a, $, j) {
    return s.mode & 1 ? (s.flags |= 65536, s.lanes = j, s) : (s === o ? s.flags |= 65536 : (s.flags |= 128, a.flags |= 131072, a.flags &= -52805, a.tag === 1 && (a.alternate === null ? a.tag = 17 : (o = mh(-1, 1), o.tag = 2, nh(a, o, 1))), a.lanes |= 1), s)
}
var Wi = ua.ReactCurrentOwner,
    dh = !1;

function Xi(s, o, a, $) {
    o.child = s === null ? Vg(o, null, a, $) : Ug(o, s.child, a, $)
}

function Yi(s, o, a, $, j) {
    a = a.render;
    var _e = o.ref;
    return ch(o, j), $ = Nh(s, o, a, $, _e, j), a = Sh(), s !== null && !dh ? (o.updateQueue = s.updateQueue, o.flags &= -2053, s.lanes &= ~j, Zi(s, o, j)) : (I && a && vg(o), o.flags |= 1, Xi(s, o, $, j), o.child)
}

function $i(s, o, a, $, j) {
    if (s === null) {
        var _e = a.type;
        return typeof _e == "function" && !aj(_e) && _e.defaultProps === void 0 && a.compare === null && a.defaultProps === void 0 ? (o.tag = 15, o.type = _e, bj(s, o, _e, $, j)) : (s = Rg(a.type, null, $, o, o.mode, j), s.ref = o.ref, s.return = o, o.child = s)
    }
    if (_e = s.child, !(s.lanes & j)) {
        var et = _e.memoizedProps;
        if (a = a.compare, a = a !== null ? a : Ie, a(et, $) && s.ref === o.ref) return Zi(s, o, j)
    }
    return o.flags |= 1, s = Pg(_e, $), s.ref = o.ref, s.return = o, o.child = s
}

function bj(s, o, a, $, j) {
    if (s !== null) {
        var _e = s.memoizedProps;
        if (Ie(_e, $) && s.ref === o.ref)
            if (dh = !1, o.pendingProps = $ = _e, (s.lanes & j) !== 0) s.flags & 131072 && (dh = !0);
            else return o.lanes = s.lanes, Zi(s, o, j)
    }
    return cj(s, o, a, $, j)
}

function dj(s, o, a) {
    var $ = o.pendingProps,
        j = $.children,
        _e = s !== null ? s.memoizedState : null;
    if ($.mode === "hidden")
        if (!(o.mode & 1)) o.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, G(ej, fj), fj |= a;
        else {
            if (!(a & 1073741824)) return s = _e !== null ? _e.baseLanes | a : a, o.lanes = o.childLanes = 1073741824, o.memoizedState = {
                baseLanes: s,
                cachePool: null,
                transitions: null
            }, o.updateQueue = null, G(ej, fj), fj |= s, null;
            o.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, $ = _e !== null ? _e.baseLanes : a, G(ej, fj), fj |= $
        }
    else _e !== null ? ($ = _e.baseLanes | a, o.memoizedState = null) : $ = a, G(ej, fj), fj |= $;
    return Xi(s, o, j, a), o.child
}

function gj(s, o) {
    var a = o.ref;
    (s === null && a !== null || s !== null && s.ref !== a) && (o.flags |= 512, o.flags |= 2097152)
}

function cj(s, o, a, $, j) {
    var _e = Zf(a) ? Xf : H.current;
    return _e = Yf(o, _e), ch(o, j), a = Nh(s, o, a, $, _e, j), $ = Sh(), s !== null && !dh ? (o.updateQueue = s.updateQueue, o.flags &= -2053, s.lanes &= ~j, Zi(s, o, j)) : (I && $ && vg(o), o.flags |= 1, Xi(s, o, a, j), o.child)
}

function hj(s, o, a, $, j) {
    if (Zf(a)) {
        var _e = !0;
        cg(o)
    } else _e = !1;
    if (ch(o, j), o.stateNode === null) ij(s, o), Gi(o, a, $), Ii(o, a, $, j), $ = !0;
    else if (s === null) {
        var et = o.stateNode,
            tt = o.memoizedProps;
        et.props = tt;
        var nt = et.context,
            rt = a.contextType;
        typeof rt == "object" && rt !== null ? rt = eh(rt) : (rt = Zf(a) ? Xf : H.current, rt = Yf(o, rt));
        var ot = a.getDerivedStateFromProps,
            st = typeof ot == "function" || typeof et.getSnapshotBeforeUpdate == "function";
        st || typeof et.UNSAFE_componentWillReceiveProps != "function" && typeof et.componentWillReceiveProps != "function" || (tt !== $ || nt !== rt) && Hi(o, et, $, rt), jh = !1;
        var lt = o.memoizedState;
        et.state = lt, qh(o, $, et, j), nt = o.memoizedState, tt !== $ || lt !== nt || Wf.current || jh ? (typeof ot == "function" && (Di(o, a, ot, $), nt = o.memoizedState), (tt = jh || Fi(o, a, tt, $, lt, nt, rt)) ? (st || typeof et.UNSAFE_componentWillMount != "function" && typeof et.componentWillMount != "function" || (typeof et.componentWillMount == "function" && et.componentWillMount(), typeof et.UNSAFE_componentWillMount == "function" && et.UNSAFE_componentWillMount()), typeof et.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof et.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = $, o.memoizedState = nt), et.props = $, et.state = nt, et.context = rt, $ = tt) : (typeof et.componentDidMount == "function" && (o.flags |= 4194308), $ = !1)
    } else {
        et = o.stateNode, lh(s, o), tt = o.memoizedProps, rt = o.type === o.elementType ? tt : Ci(o.type, tt), et.props = rt, st = o.pendingProps, lt = et.context, nt = a.contextType, typeof nt == "object" && nt !== null ? nt = eh(nt) : (nt = Zf(a) ? Xf : H.current, nt = Yf(o, nt));
        var ft = a.getDerivedStateFromProps;
        (ot = typeof ft == "function" || typeof et.getSnapshotBeforeUpdate == "function") || typeof et.UNSAFE_componentWillReceiveProps != "function" && typeof et.componentWillReceiveProps != "function" || (tt !== st || lt !== nt) && Hi(o, et, $, nt), jh = !1, lt = o.memoizedState, et.state = lt, qh(o, $, et, j);
        var yt = o.memoizedState;
        tt !== st || lt !== yt || Wf.current || jh ? (typeof ft == "function" && (Di(o, a, ft, $), yt = o.memoizedState), (rt = jh || Fi(o, a, rt, $, lt, yt, nt) || !1) ? (ot || typeof et.UNSAFE_componentWillUpdate != "function" && typeof et.componentWillUpdate != "function" || (typeof et.componentWillUpdate == "function" && et.componentWillUpdate($, yt, nt), typeof et.UNSAFE_componentWillUpdate == "function" && et.UNSAFE_componentWillUpdate($, yt, nt)), typeof et.componentDidUpdate == "function" && (o.flags |= 4), typeof et.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof et.componentDidUpdate != "function" || tt === s.memoizedProps && lt === s.memoizedState || (o.flags |= 4), typeof et.getSnapshotBeforeUpdate != "function" || tt === s.memoizedProps && lt === s.memoizedState || (o.flags |= 1024), o.memoizedProps = $, o.memoizedState = yt), et.props = $, et.state = yt, et.context = nt, $ = rt) : (typeof et.componentDidUpdate != "function" || tt === s.memoizedProps && lt === s.memoizedState || (o.flags |= 4), typeof et.getSnapshotBeforeUpdate != "function" || tt === s.memoizedProps && lt === s.memoizedState || (o.flags |= 1024), $ = !1)
    }
    return jj(s, o, a, $, _e, j)
}

function jj(s, o, a, $, j, _e) {
    gj(s, o);
    var et = (o.flags & 128) !== 0;
    if (!$ && !et) return j && dg(o, a, !1), Zi(s, o, _e);
    $ = o.stateNode, Wi.current = o;
    var tt = et && typeof a.getDerivedStateFromError != "function" ? null : $.render();
    return o.flags |= 1, s !== null && et ? (o.child = Ug(o, s.child, null, _e), o.child = Ug(o, null, tt, _e)) : Xi(s, o, tt, _e), o.memoizedState = $.state, j && dg(o, a, !0), o.child
}

function kj(s) {
    var o = s.stateNode;
    o.pendingContext ? ag(s, o.pendingContext, o.pendingContext !== o.context) : o.context && ag(s, o.context, !1), yh(s, o.containerInfo)
}

function lj(s, o, a, $, j) {
    return Ig(), Jg(j), o.flags |= 256, Xi(s, o, a, $), o.child
}
var mj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function nj(s) {
    return {
        baseLanes: s,
        cachePool: null,
        transitions: null
    }
}

function oj(s, o, a) {
    var $ = o.pendingProps,
        j = L.current,
        _e = !1,
        et = (o.flags & 128) !== 0,
        tt;
    if ((tt = et) || (tt = s !== null && s.memoizedState === null ? !1 : (j & 2) !== 0), tt ? (_e = !0, o.flags &= -129) : (s === null || s.memoizedState !== null) && (j |= 1), G(L, j & 1), s === null) return Eg(o), s = o.memoizedState, s !== null && (s = s.dehydrated, s !== null) ? (o.mode & 1 ? s.data === "$!" ? o.lanes = 8 : o.lanes = 1073741824 : o.lanes = 1, null) : (et = $.children, s = $.fallback, _e ? ($ = o.mode, _e = o.child, et = {
        mode: "hidden",
        children: et
    }, !($ & 1) && _e !== null ? (_e.childLanes = 0, _e.pendingProps = et) : _e = pj(et, $, 0, null), s = Tg(s, $, a, null), _e.return = o, s.return = o, _e.sibling = s, o.child = _e, o.child.memoizedState = nj(a), o.memoizedState = mj, s) : qj(o, et));
    if (j = s.memoizedState, j !== null && (tt = j.dehydrated, tt !== null)) return rj(s, o, et, $, tt, j, a);
    if (_e) {
        _e = $.fallback, et = o.mode, j = s.child, tt = j.sibling;
        var nt = {
            mode: "hidden",
            children: $.children
        };
        return !(et & 1) && o.child !== j ? ($ = o.child, $.childLanes = 0, $.pendingProps = nt, o.deletions = null) : ($ = Pg(j, nt), $.subtreeFlags = j.subtreeFlags & 14680064), tt !== null ? _e = Pg(tt, _e) : (_e = Tg(_e, et, a, null), _e.flags |= 2), _e.return = o, $.return = o, $.sibling = _e, o.child = $, $ = _e, _e = o.child, et = s.child.memoizedState, et = et === null ? nj(a) : {
            baseLanes: et.baseLanes | a,
            cachePool: null,
            transitions: et.transitions
        }, _e.memoizedState = et, _e.childLanes = s.childLanes & ~a, o.memoizedState = mj, $
    }
    return _e = s.child, s = _e.sibling, $ = Pg(_e, {
        mode: "visible",
        children: $.children
    }), !(o.mode & 1) && ($.lanes = a), $.return = o, $.sibling = null, s !== null && (a = o.deletions, a === null ? (o.deletions = [s], o.flags |= 16) : a.push(s)), o.child = $, o.memoizedState = null, $
}

function qj(s, o) {
    return o = pj({
        mode: "visible",
        children: o
    }, s.mode, 0, null), o.return = s, s.child = o
}

function sj(s, o, a, $) {
    return $ !== null && Jg($), Ug(o, s.child, null, a), s = qj(o, o.pendingProps.children), s.flags |= 2, o.memoizedState = null, s
}

function rj(s, o, a, $, j, _e, et) {
    if (a) return o.flags & 256 ? (o.flags &= -257, $ = Ki(Error(p$2(422))), sj(s, o, et, $)) : o.memoizedState !== null ? (o.child = s.child, o.flags |= 128, null) : (_e = $.fallback, j = o.mode, $ = pj({
        mode: "visible",
        children: $.children
    }, j, 0, null), _e = Tg(_e, j, et, null), _e.flags |= 2, $.return = o, _e.return = o, $.sibling = _e, o.child = $, o.mode & 1 && Ug(o, s.child, null, et), o.child.memoizedState = nj(et), o.memoizedState = mj, _e);
    if (!(o.mode & 1)) return sj(s, o, et, null);
    if (j.data === "$!") {
        if ($ = j.nextSibling && j.nextSibling.dataset, $) var tt = $.dgst;
        return $ = tt, _e = Error(p$2(419)), $ = Ki(_e, $, void 0), sj(s, o, et, $)
    }
    if (tt = (et & s.childLanes) !== 0, dh || tt) {
        if ($ = Q, $ !== null) {
            switch (et & -et) {
                case 4:
                    j = 2;
                    break;
                case 16:
                    j = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    j = 32;
                    break;
                case 536870912:
                    j = 268435456;
                    break;
                default:
                    j = 0
            }
            j = j & ($.suspendedLanes | et) ? 0 : j, j !== 0 && j !== _e.retryLane && (_e.retryLane = j, ih(s, j), gi($, s, j, -1))
        }
        return tj(), $ = Ki(Error(p$2(421))), sj(s, o, et, $)
    }
    return j.data === "$?" ? (o.flags |= 128, o.child = s.child, o = uj.bind(null, s), j._reactRetry = o, null) : (s = _e.treeContext, yg = Lf(j.nextSibling), xg = o, I = !0, zg = null, s !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = s.id, sg = s.overflow, qg = o), o = qj(o, $.children), o.flags |= 4096, o)
}

function vj(s, o, a) {
    s.lanes |= o;
    var $ = s.alternate;
    $ !== null && ($.lanes |= o), bh(s.return, o, a)
}

function wj(s, o, a, $, j) {
    var _e = s.memoizedState;
    _e === null ? s.memoizedState = {
        isBackwards: o,
        rendering: null,
        renderingStartTime: 0,
        last: $,
        tail: a,
        tailMode: j
    } : (_e.isBackwards = o, _e.rendering = null, _e.renderingStartTime = 0, _e.last = $, _e.tail = a, _e.tailMode = j)
}

function xj(s, o, a) {
    var $ = o.pendingProps,
        j = $.revealOrder,
        _e = $.tail;
    if (Xi(s, o, $.children, a), $ = L.current, $ & 2) $ = $ & 1 | 2, o.flags |= 128;
    else {
        if (s !== null && s.flags & 128) e: for (s = o.child; s !== null;) {
            if (s.tag === 13) s.memoizedState !== null && vj(s, a, o);
            else if (s.tag === 19) vj(s, a, o);
            else if (s.child !== null) {
                s.child.return = s, s = s.child;
                continue
            }
            if (s === o) break e;
            for (; s.sibling === null;) {
                if (s.return === null || s.return === o) break e;
                s = s.return
            }
            s.sibling.return = s.return, s = s.sibling
        }
        $ &= 1
    }
    if (G(L, $), !(o.mode & 1)) o.memoizedState = null;
    else switch (j) {
        case "forwards":
            for (a = o.child, j = null; a !== null;) s = a.alternate, s !== null && Ch(s) === null && (j = a), a = a.sibling;
            a = j, a === null ? (j = o.child, o.child = null) : (j = a.sibling, a.sibling = null), wj(o, !1, j, a, _e);
            break;
        case "backwards":
            for (a = null, j = o.child, o.child = null; j !== null;) {
                if (s = j.alternate, s !== null && Ch(s) === null) {
                    o.child = j;
                    break
                }
                s = j.sibling, j.sibling = a, a = j, j = s
            }
            wj(o, !0, a, null, _e);
            break;
        case "together":
            wj(o, !1, null, null, void 0);
            break;
        default:
            o.memoizedState = null
    }
    return o.child
}

function ij(s, o) {
    !(o.mode & 1) && s !== null && (s.alternate = null, o.alternate = null, o.flags |= 2)
}

function Zi(s, o, a) {
    if (s !== null && (o.dependencies = s.dependencies), rh |= o.lanes, !(a & o.childLanes)) return null;
    if (s !== null && o.child !== s.child) throw Error(p$2(153));
    if (o.child !== null) {
        for (s = o.child, a = Pg(s, s.pendingProps), o.child = a, a.return = o; s.sibling !== null;) s = s.sibling, a = a.sibling = Pg(s, s.pendingProps), a.return = o;
        a.sibling = null
    }
    return o.child
}

function yj(s, o, a) {
    switch (o.tag) {
        case 3:
            kj(o), Ig();
            break;
        case 5:
            Ah(o);
            break;
        case 1:
            Zf(o.type) && cg(o);
            break;
        case 4:
            yh(o, o.stateNode.containerInfo);
            break;
        case 10:
            var $ = o.type._context,
                j = o.memoizedProps.value;
            G(Wg, $._currentValue), $._currentValue = j;
            break;
        case 13:
            if ($ = o.memoizedState, $ !== null) return $.dehydrated !== null ? (G(L, L.current & 1), o.flags |= 128, null) : a & o.child.childLanes ? oj(s, o, a) : (G(L, L.current & 1), s = Zi(s, o, a), s !== null ? s.sibling : null);
            G(L, L.current & 1);
            break;
        case 19:
            if ($ = (a & o.childLanes) !== 0, s.flags & 128) {
                if ($) return xj(s, o, a);
                o.flags |= 128
            }
            if (j = o.memoizedState, j !== null && (j.rendering = null, j.tail = null, j.lastEffect = null), G(L, L.current), $) break;
            return null;
        case 22:
        case 23:
            return o.lanes = 0, dj(s, o, a)
    }
    return Zi(s, o, a)
}
var zj, Aj, Bj, Cj;
zj = function(s, o) {
    for (var a = o.child; a !== null;) {
        if (a.tag === 5 || a.tag === 6) s.appendChild(a.stateNode);
        else if (a.tag !== 4 && a.child !== null) {
            a.child.return = a, a = a.child;
            continue
        }
        if (a === o) break;
        for (; a.sibling === null;) {
            if (a.return === null || a.return === o) return;
            a = a.return
        }
        a.sibling.return = a.return, a = a.sibling
    }
};
Aj = function() {};
Bj = function(s, o, a, $) {
    var j = s.memoizedProps;
    if (j !== $) {
        s = o.stateNode, xh(uh.current);
        var _e = null;
        switch (a) {
            case "input":
                j = Ya(s, j), $ = Ya(s, $), _e = [];
                break;
            case "select":
                j = A$1({}, j, {
                    value: void 0
                }), $ = A$1({}, $, {
                    value: void 0
                }), _e = [];
                break;
            case "textarea":
                j = gb(s, j), $ = gb(s, $), _e = [];
                break;
            default:
                typeof j.onClick != "function" && typeof $.onClick == "function" && (s.onclick = Bf)
        }
        ub(a, $);
        var et;
        a = null;
        for (rt in j)
            if (!$.hasOwnProperty(rt) && j.hasOwnProperty(rt) && j[rt] != null)
                if (rt === "style") {
                    var tt = j[rt];
                    for (et in tt) tt.hasOwnProperty(et) && (a || (a = {}), a[et] = "")
                } else rt !== "dangerouslySetInnerHTML" && rt !== "children" && rt !== "suppressContentEditableWarning" && rt !== "suppressHydrationWarning" && rt !== "autoFocus" && (ea.hasOwnProperty(rt) ? _e || (_e = []) : (_e = _e || []).push(rt, null));
        for (rt in $) {
            var nt = $[rt];
            if (tt = j != null ? j[rt] : void 0, $.hasOwnProperty(rt) && nt !== tt && (nt != null || tt != null))
                if (rt === "style")
                    if (tt) {
                        for (et in tt) !tt.hasOwnProperty(et) || nt && nt.hasOwnProperty(et) || (a || (a = {}), a[et] = "");
                        for (et in nt) nt.hasOwnProperty(et) && tt[et] !== nt[et] && (a || (a = {}), a[et] = nt[et])
                    } else a || (_e || (_e = []), _e.push(rt, a)), a = nt;
            else rt === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0, tt = tt ? tt.__html : void 0, nt != null && tt !== nt && (_e = _e || []).push(rt, nt)) : rt === "children" ? typeof nt != "string" && typeof nt != "number" || (_e = _e || []).push(rt, "" + nt) : rt !== "suppressContentEditableWarning" && rt !== "suppressHydrationWarning" && (ea.hasOwnProperty(rt) ? (nt != null && rt === "onScroll" && D("scroll", s), _e || tt === nt || (_e = [])) : (_e = _e || []).push(rt, nt))
        }
        a && (_e = _e || []).push("style", a);
        var rt = _e;
        (o.updateQueue = rt) && (o.flags |= 4)
    }
};
Cj = function(s, o, a, $) {
    a !== $ && (o.flags |= 4)
};

function Dj(s, o) {
    if (!I) switch (s.tailMode) {
        case "hidden":
            o = s.tail;
            for (var a = null; o !== null;) o.alternate !== null && (a = o), o = o.sibling;
            a === null ? s.tail = null : a.sibling = null;
            break;
        case "collapsed":
            a = s.tail;
            for (var $ = null; a !== null;) a.alternate !== null && ($ = a), a = a.sibling;
            $ === null ? o || s.tail === null ? s.tail = null : s.tail.sibling = null : $.sibling = null
    }
}

function S(s) {
    var o = s.alternate !== null && s.alternate.child === s.child,
        a = 0,
        $ = 0;
    if (o)
        for (var j = s.child; j !== null;) a |= j.lanes | j.childLanes, $ |= j.subtreeFlags & 14680064, $ |= j.flags & 14680064, j.return = s, j = j.sibling;
    else
        for (j = s.child; j !== null;) a |= j.lanes | j.childLanes, $ |= j.subtreeFlags, $ |= j.flags, j.return = s, j = j.sibling;
    return s.subtreeFlags |= $, s.childLanes = a, o
}

function Ej(s, o, a) {
    var $ = o.pendingProps;
    switch (wg(o), o.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return S(o), null;
        case 1:
            return Zf(o.type) && $f(), S(o), null;
        case 3:
            return $ = o.stateNode, zh(), E(Wf), E(H), Eh(), $.pendingContext && ($.context = $.pendingContext, $.pendingContext = null), (s === null || s.child === null) && (Gg(o) ? o.flags |= 4 : s === null || s.memoizedState.isDehydrated && !(o.flags & 256) || (o.flags |= 1024, zg !== null && (Fj(zg), zg = null))), Aj(s, o), S(o), null;
        case 5:
            Bh(o);
            var j = xh(wh.current);
            if (a = o.type, s !== null && o.stateNode != null) Bj(s, o, a, $, j), s.ref !== o.ref && (o.flags |= 512, o.flags |= 2097152);
            else {
                if (!$) {
                    if (o.stateNode === null) throw Error(p$2(166));
                    return S(o), null
                }
                if (s = xh(uh.current), Gg(o)) {
                    $ = o.stateNode, a = o.type;
                    var _e = o.memoizedProps;
                    switch ($[Of] = o, $[Pf] = _e, s = (o.mode & 1) !== 0, a) {
                        case "dialog":
                            D("cancel", $), D("close", $);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            D("load", $);
                            break;
                        case "video":
                        case "audio":
                            for (j = 0; j < lf.length; j++) D(lf[j], $);
                            break;
                        case "source":
                            D("error", $);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            D("error", $), D("load", $);
                            break;
                        case "details":
                            D("toggle", $);
                            break;
                        case "input":
                            Za($, _e), D("invalid", $);
                            break;
                        case "select":
                            $._wrapperState = {
                                wasMultiple: !!_e.multiple
                            }, D("invalid", $);
                            break;
                        case "textarea":
                            hb($, _e), D("invalid", $)
                    }
                    ub(a, _e), j = null;
                    for (var et in _e)
                        if (_e.hasOwnProperty(et)) {
                            var tt = _e[et];
                            et === "children" ? typeof tt == "string" ? $.textContent !== tt && (_e.suppressHydrationWarning !== !0 && Af($.textContent, tt, s), j = ["children", tt]) : typeof tt == "number" && $.textContent !== "" + tt && (_e.suppressHydrationWarning !== !0 && Af($.textContent, tt, s), j = ["children", "" + tt]) : ea.hasOwnProperty(et) && tt != null && et === "onScroll" && D("scroll", $)
                        }
                    switch (a) {
                        case "input":
                            Va($), db($, _e, !0);
                            break;
                        case "textarea":
                            Va($), jb($);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof _e.onClick == "function" && ($.onclick = Bf)
                    }
                    $ = j, o.updateQueue = $, $ !== null && (o.flags |= 4)
                } else {
                    et = j.nodeType === 9 ? j : j.ownerDocument, s === "http://www.w3.org/1999/xhtml" && (s = kb(a)), s === "http://www.w3.org/1999/xhtml" ? a === "script" ? (s = et.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild)) : typeof $.is == "string" ? s = et.createElement(a, {
                        is: $.is
                    }) : (s = et.createElement(a), a === "select" && (et = s, $.multiple ? et.multiple = !0 : $.size && (et.size = $.size))) : s = et.createElementNS(s, a), s[Of] = o, s[Pf] = $, zj(s, o, !1, !1), o.stateNode = s;
                    e: {
                        switch (et = vb(a, $), a) {
                            case "dialog":
                                D("cancel", s), D("close", s), j = $;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                D("load", s), j = $;
                                break;
                            case "video":
                            case "audio":
                                for (j = 0; j < lf.length; j++) D(lf[j], s);
                                j = $;
                                break;
                            case "source":
                                D("error", s), j = $;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                D("error", s), D("load", s), j = $;
                                break;
                            case "details":
                                D("toggle", s), j = $;
                                break;
                            case "input":
                                Za(s, $), j = Ya(s, $), D("invalid", s);
                                break;
                            case "option":
                                j = $;
                                break;
                            case "select":
                                s._wrapperState = {
                                    wasMultiple: !!$.multiple
                                }, j = A$1({}, $, {
                                    value: void 0
                                }), D("invalid", s);
                                break;
                            case "textarea":
                                hb(s, $), j = gb(s, $), D("invalid", s);
                                break;
                            default:
                                j = $
                        }
                        ub(a, j),
                        tt = j;
                        for (_e in tt)
                            if (tt.hasOwnProperty(_e)) {
                                var nt = tt[_e];
                                _e === "style" ? sb(s, nt) : _e === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0, nt != null && nb(s, nt)) : _e === "children" ? typeof nt == "string" ? (a !== "textarea" || nt !== "") && ob(s, nt) : typeof nt == "number" && ob(s, "" + nt) : _e !== "suppressContentEditableWarning" && _e !== "suppressHydrationWarning" && _e !== "autoFocus" && (ea.hasOwnProperty(_e) ? nt != null && _e === "onScroll" && D("scroll", s) : nt != null && ta(s, _e, nt, et))
                            }
                        switch (a) {
                            case "input":
                                Va(s), db(s, $, !1);
                                break;
                            case "textarea":
                                Va(s), jb(s);
                                break;
                            case "option":
                                $.value != null && s.setAttribute("value", "" + Sa($.value));
                                break;
                            case "select":
                                s.multiple = !!$.multiple, _e = $.value, _e != null ? fb(s, !!$.multiple, _e, !1) : $.defaultValue != null && fb(s, !!$.multiple, $.defaultValue, !0);
                                break;
                            default:
                                typeof j.onClick == "function" && (s.onclick = Bf)
                        }
                        switch (a) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                $ = !!$.autoFocus;
                                break e;
                            case "img":
                                $ = !0;
                                break e;
                            default:
                                $ = !1
                        }
                    }
                    $ && (o.flags |= 4)
                }
                o.ref !== null && (o.flags |= 512, o.flags |= 2097152)
            }
            return S(o), null;
        case 6:
            if (s && o.stateNode != null) Cj(s, o, s.memoizedProps, $);
            else {
                if (typeof $ != "string" && o.stateNode === null) throw Error(p$2(166));
                if (a = xh(wh.current), xh(uh.current), Gg(o)) {
                    if ($ = o.stateNode, a = o.memoizedProps, $[Of] = o, (_e = $.nodeValue !== a) && (s = xg, s !== null)) switch (s.tag) {
                        case 3:
                            Af($.nodeValue, a, (s.mode & 1) !== 0);
                            break;
                        case 5:
                            s.memoizedProps.suppressHydrationWarning !== !0 && Af($.nodeValue, a, (s.mode & 1) !== 0)
                    }
                    _e && (o.flags |= 4)
                } else $ = (a.nodeType === 9 ? a : a.ownerDocument).createTextNode($), $[Of] = o, o.stateNode = $
            }
            return S(o), null;
        case 13:
            if (E(L), $ = o.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
                if (I && yg !== null && o.mode & 1 && !(o.flags & 128)) Hg(), Ig(), o.flags |= 98560, _e = !1;
                else if (_e = Gg(o), $ !== null && $.dehydrated !== null) {
                    if (s === null) {
                        if (!_e) throw Error(p$2(318));
                        if (_e = o.memoizedState, _e = _e !== null ? _e.dehydrated : null, !_e) throw Error(p$2(317));
                        _e[Of] = o
                    } else Ig(), !(o.flags & 128) && (o.memoizedState = null), o.flags |= 4;
                    S(o), _e = !1
                } else zg !== null && (Fj(zg), zg = null), _e = !0;
                if (!_e) return o.flags & 65536 ? o : null
            }
            return o.flags & 128 ? (o.lanes = a, o) : ($ = $ !== null, $ !== (s !== null && s.memoizedState !== null) && $ && (o.child.flags |= 8192, o.mode & 1 && (s === null || L.current & 1 ? T === 0 && (T = 3) : tj())), o.updateQueue !== null && (o.flags |= 4), S(o), null);
        case 4:
            return zh(), Aj(s, o), s === null && sf(o.stateNode.containerInfo), S(o), null;
        case 10:
            return ah(o.type._context), S(o), null;
        case 17:
            return Zf(o.type) && $f(), S(o), null;
        case 19:
            if (E(L), _e = o.memoizedState, _e === null) return S(o), null;
            if ($ = (o.flags & 128) !== 0, et = _e.rendering, et === null)
                if ($) Dj(_e, !1);
                else {
                    if (T !== 0 || s !== null && s.flags & 128)
                        for (s = o.child; s !== null;) {
                            if (et = Ch(s), et !== null) {
                                for (o.flags |= 128, Dj(_e, !1), $ = et.updateQueue, $ !== null && (o.updateQueue = $, o.flags |= 4), o.subtreeFlags = 0, $ = a, a = o.child; a !== null;) _e = a, s = $, _e.flags &= 14680066, et = _e.alternate, et === null ? (_e.childLanes = 0, _e.lanes = s, _e.child = null, _e.subtreeFlags = 0, _e.memoizedProps = null, _e.memoizedState = null, _e.updateQueue = null, _e.dependencies = null, _e.stateNode = null) : (_e.childLanes = et.childLanes, _e.lanes = et.lanes, _e.child = et.child, _e.subtreeFlags = 0, _e.deletions = null, _e.memoizedProps = et.memoizedProps, _e.memoizedState = et.memoizedState, _e.updateQueue = et.updateQueue, _e.type = et.type, s = et.dependencies, _e.dependencies = s === null ? null : {
                                    lanes: s.lanes,
                                    firstContext: s.firstContext
                                }), a = a.sibling;
                                return G(L, L.current & 1 | 2), o.child
                            }
                            s = s.sibling
                        }
                    _e.tail !== null && B() > Gj && (o.flags |= 128, $ = !0, Dj(_e, !1), o.lanes = 4194304)
                }
            else {
                if (!$)
                    if (s = Ch(et), s !== null) {
                        if (o.flags |= 128, $ = !0, a = s.updateQueue, a !== null && (o.updateQueue = a, o.flags |= 4), Dj(_e, !0), _e.tail === null && _e.tailMode === "hidden" && !et.alternate && !I) return S(o), null
                    } else 2 * B() - _e.renderingStartTime > Gj && a !== 1073741824 && (o.flags |= 128, $ = !0, Dj(_e, !1), o.lanes = 4194304);
                _e.isBackwards ? (et.sibling = o.child, o.child = et) : (a = _e.last, a !== null ? a.sibling = et : o.child = et, _e.last = et)
            }
            return _e.tail !== null ? (o = _e.tail, _e.rendering = o, _e.tail = o.sibling, _e.renderingStartTime = B(), o.sibling = null, a = L.current, G(L, $ ? a & 1 | 2 : a & 1), o) : (S(o), null);
        case 22:
        case 23:
            return Hj(), $ = o.memoizedState !== null, s !== null && s.memoizedState !== null !== $ && (o.flags |= 8192), $ && o.mode & 1 ? fj & 1073741824 && (S(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : S(o), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(p$2(156, o.tag))
}

function Ij(s, o) {
    switch (wg(o), o.tag) {
        case 1:
            return Zf(o.type) && $f(), s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
        case 3:
            return zh(), E(Wf), E(H), Eh(), s = o.flags, s & 65536 && !(s & 128) ? (o.flags = s & -65537 | 128, o) : null;
        case 5:
            return Bh(o), null;
        case 13:
            if (E(L), s = o.memoizedState, s !== null && s.dehydrated !== null) {
                if (o.alternate === null) throw Error(p$2(340));
                Ig()
            }
            return s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
        case 19:
            return E(L), null;
        case 4:
            return zh(), null;
        case 10:
            return ah(o.type._context), null;
        case 22:
        case 23:
            return Hj(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var Jj = !1,
    U = !1,
    Kj = typeof WeakSet == "function" ? WeakSet : Set,
    V = null;

function Lj(s, o) {
    var a = s.ref;
    if (a !== null)
        if (typeof a == "function") try {
            a(null)
        } catch ($) {
            W(s, o, $)
        } else a.current = null
}

function Mj(s, o, a) {
    try {
        a()
    } catch ($) {
        W(s, o, $)
    }
}
var Nj = !1;

function Oj(s, o) {
    if (Cf = dd, s = Me(), Ne(s)) {
        if ("selectionStart" in s) var a = {
            start: s.selectionStart,
            end: s.selectionEnd
        };
        else e: {
            a = (a = s.ownerDocument) && a.defaultView || window;
            var $ = a.getSelection && a.getSelection();
            if ($ && $.rangeCount !== 0) {
                a = $.anchorNode;
                var j = $.anchorOffset,
                    _e = $.focusNode;
                $ = $.focusOffset;
                try {
                    a.nodeType, _e.nodeType
                } catch {
                    a = null;
                    break e
                }
                var et = 0,
                    tt = -1,
                    nt = -1,
                    rt = 0,
                    ot = 0,
                    st = s,
                    lt = null;
                t: for (;;) {
                    for (var ft; st !== a || j !== 0 && st.nodeType !== 3 || (tt = et + j), st !== _e || $ !== 0 && st.nodeType !== 3 || (nt = et + $), st.nodeType === 3 && (et += st.nodeValue.length), (ft = st.firstChild) !== null;) lt = st, st = ft;
                    for (;;) {
                        if (st === s) break t;
                        if (lt === a && ++rt === j && (tt = et), lt === _e && ++ot === $ && (nt = et), (ft = st.nextSibling) !== null) break;
                        st = lt, lt = st.parentNode
                    }
                    st = ft
                }
                a = tt === -1 || nt === -1 ? null : {
                    start: tt,
                    end: nt
                }
            } else a = null
        }
        a = a || {
            start: 0,
            end: 0
        }
    } else a = null;
    for (Df = {
            focusedElem: s,
            selectionRange: a
        }, dd = !1, V = o; V !== null;)
        if (o = V, s = o.child, (o.subtreeFlags & 1028) !== 0 && s !== null) s.return = o, V = s;
        else
            for (; V !== null;) {
                o = V;
                try {
                    var yt = o.alternate;
                    if (o.flags & 1024) switch (o.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (yt !== null) {
                                var bt = yt.memoizedProps,
                                    ht = yt.memoizedState,
                                    vt = o.stateNode,
                                    wt = vt.getSnapshotBeforeUpdate(o.elementType === o.type ? bt : Ci(o.type, bt), ht);
                                vt.__reactInternalSnapshotBeforeUpdate = wt
                            }
                            break;
                        case 3:
                            var gt = o.stateNode.containerInfo;
                            gt.nodeType === 1 ? gt.textContent = "" : gt.nodeType === 9 && gt.documentElement && gt.removeChild(gt.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$2(163))
                    }
                } catch (At) {
                    W(o, o.return, At)
                }
                if (s = o.sibling, s !== null) {
                    s.return = o.return, V = s;
                    break
                }
                V = o.return
            }
    return yt = Nj, Nj = !1, yt
}

function Pj(s, o, a) {
    var $ = o.updateQueue;
    if ($ = $ !== null ? $.lastEffect : null, $ !== null) {
        var j = $ = $.next;
        do {
            if ((j.tag & s) === s) {
                var _e = j.destroy;
                j.destroy = void 0, _e !== void 0 && Mj(o, a, _e)
            }
            j = j.next
        } while (j !== $)
    }
}

function Qj(s, o) {
    if (o = o.updateQueue, o = o !== null ? o.lastEffect : null, o !== null) {
        var a = o = o.next;
        do {
            if ((a.tag & s) === s) {
                var $ = a.create;
                a.destroy = $()
            }
            a = a.next
        } while (a !== o)
    }
}

function Rj(s) {
    var o = s.ref;
    if (o !== null) {
        var a = s.stateNode;
        switch (s.tag) {
            case 5:
                s = a;
                break;
            default:
                s = a
        }
        typeof o == "function" ? o(s) : o.current = s
    }
}

function Sj(s) {
    var o = s.alternate;
    o !== null && (s.alternate = null, Sj(o)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (o = s.stateNode, o !== null && (delete o[Of], delete o[Pf], delete o[ of ], delete o[Qf], delete o[Rf])), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null
}

function Tj(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4
}

function Uj(s) {
    e: for (;;) {
        for (; s.sibling === null;) {
            if (s.return === null || Tj(s.return)) return null;
            s = s.return
        }
        for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18;) {
            if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
            s.child.return = s, s = s.child
        }
        if (!(s.flags & 2)) return s.stateNode
    }
}

function Vj(s, o, a) {
    var $ = s.tag;
    if ($ === 5 || $ === 6) s = s.stateNode, o ? a.nodeType === 8 ? a.parentNode.insertBefore(s, o) : a.insertBefore(s, o) : (a.nodeType === 8 ? (o = a.parentNode, o.insertBefore(s, a)) : (o = a, o.appendChild(s)), a = a._reactRootContainer, a != null || o.onclick !== null || (o.onclick = Bf));
    else if ($ !== 4 && (s = s.child, s !== null))
        for (Vj(s, o, a), s = s.sibling; s !== null;) Vj(s, o, a), s = s.sibling
}

function Wj(s, o, a) {
    var $ = s.tag;
    if ($ === 5 || $ === 6) s = s.stateNode, o ? a.insertBefore(s, o) : a.appendChild(s);
    else if ($ !== 4 && (s = s.child, s !== null))
        for (Wj(s, o, a), s = s.sibling; s !== null;) Wj(s, o, a), s = s.sibling
}
var X = null,
    Xj = !1;

function Yj(s, o, a) {
    for (a = a.child; a !== null;) Zj(s, o, a), a = a.sibling
}

function Zj(s, o, a) {
    if (lc && typeof lc.onCommitFiberUnmount == "function") try {
        lc.onCommitFiberUnmount(kc, a)
    } catch {}
    switch (a.tag) {
        case 5:
            U || Lj(a, o);
        case 6:
            var $ = X,
                j = Xj;
            X = null, Yj(s, o, a), X = $, Xj = j, X !== null && (Xj ? (s = X, a = a.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(a) : s.removeChild(a)) : X.removeChild(a.stateNode));
            break;
        case 18:
            X !== null && (Xj ? (s = X, a = a.stateNode, s.nodeType === 8 ? Kf(s.parentNode, a) : s.nodeType === 1 && Kf(s, a), bd(s)) : Kf(X, a.stateNode));
            break;
        case 4:
            $ = X, j = Xj, X = a.stateNode.containerInfo, Xj = !0, Yj(s, o, a), X = $, Xj = j;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!U && ($ = a.updateQueue, $ !== null && ($ = $.lastEffect, $ !== null))) {
                j = $ = $.next;
                do {
                    var _e = j,
                        et = _e.destroy;
                    _e = _e.tag, et !== void 0 && (_e & 2 || _e & 4) && Mj(a, o, et), j = j.next
                } while (j !== $)
            }
            Yj(s, o, a);
            break;
        case 1:
            if (!U && (Lj(a, o), $ = a.stateNode, typeof $.componentWillUnmount == "function")) try {
                $.props = a.memoizedProps, $.state = a.memoizedState, $.componentWillUnmount()
            } catch (tt) {
                W(a, o, tt)
            }
            Yj(s, o, a);
            break;
        case 21:
            Yj(s, o, a);
            break;
        case 22:
            a.mode & 1 ? (U = ($ = U) || a.memoizedState !== null, Yj(s, o, a), U = $) : Yj(s, o, a);
            break;
        default:
            Yj(s, o, a)
    }
}

function ak(s) {
    var o = s.updateQueue;
    if (o !== null) {
        s.updateQueue = null;
        var a = s.stateNode;
        a === null && (a = s.stateNode = new Kj), o.forEach(function($) {
            var j = bk.bind(null, s, $);
            a.has($) || (a.add($), $.then(j, j))
        })
    }
}

function ck(s, o) {
    var a = o.deletions;
    if (a !== null)
        for (var $ = 0; $ < a.length; $++) {
            var j = a[$];
            try {
                var _e = s,
                    et = o,
                    tt = et;
                e: for (; tt !== null;) {
                    switch (tt.tag) {
                        case 5:
                            X = tt.stateNode, Xj = !1;
                            break e;
                        case 3:
                            X = tt.stateNode.containerInfo, Xj = !0;
                            break e;
                        case 4:
                            X = tt.stateNode.containerInfo, Xj = !0;
                            break e
                    }
                    tt = tt.return
                }
                if (X === null) throw Error(p$2(160));
                Zj(_e, et, j), X = null, Xj = !1;
                var nt = j.alternate;
                nt !== null && (nt.return = null), j.return = null
            } catch (rt) {
                W(j, o, rt)
            }
        }
    if (o.subtreeFlags & 12854)
        for (o = o.child; o !== null;) dk(o, s), o = o.sibling
}

function dk(s, o) {
    var a = s.alternate,
        $ = s.flags;
    switch (s.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (ck(o, s), ek(s), $ & 4) {
                try {
                    Pj(3, s, s.return), Qj(3, s)
                } catch (bt) {
                    W(s, s.return, bt)
                }
                try {
                    Pj(5, s, s.return)
                } catch (bt) {
                    W(s, s.return, bt)
                }
            }
            break;
        case 1:
            ck(o, s), ek(s), $ & 512 && a !== null && Lj(a, a.return);
            break;
        case 5:
            if (ck(o, s), ek(s), $ & 512 && a !== null && Lj(a, a.return), s.flags & 32) {
                var j = s.stateNode;
                try {
                    ob(j, "")
                } catch (bt) {
                    W(s, s.return, bt)
                }
            }
            if ($ & 4 && (j = s.stateNode, j != null)) {
                var _e = s.memoizedProps,
                    et = a !== null ? a.memoizedProps : _e,
                    tt = s.type,
                    nt = s.updateQueue;
                if (s.updateQueue = null, nt !== null) try {
                    tt === "input" && _e.type === "radio" && _e.name != null && ab(j, _e), vb(tt, et);
                    var rt = vb(tt, _e);
                    for (et = 0; et < nt.length; et += 2) {
                        var ot = nt[et],
                            st = nt[et + 1];
                        ot === "style" ? sb(j, st) : ot === "dangerouslySetInnerHTML" ? nb(j, st) : ot === "children" ? ob(j, st) : ta(j, ot, st, rt)
                    }
                    switch (tt) {
                        case "input":
                            bb(j, _e);
                            break;
                        case "textarea":
                            ib(j, _e);
                            break;
                        case "select":
                            var lt = j._wrapperState.wasMultiple;
                            j._wrapperState.wasMultiple = !!_e.multiple;
                            var ft = _e.value;
                            ft != null ? fb(j, !!_e.multiple, ft, !1) : lt !== !!_e.multiple && (_e.defaultValue != null ? fb(j, !!_e.multiple, _e.defaultValue, !0) : fb(j, !!_e.multiple, _e.multiple ? [] : "", !1))
                    }
                    j[Pf] = _e
                } catch (bt) {
                    W(s, s.return, bt)
                }
            }
            break;
        case 6:
            if (ck(o, s), ek(s), $ & 4) {
                if (s.stateNode === null) throw Error(p$2(162));
                j = s.stateNode, _e = s.memoizedProps;
                try {
                    j.nodeValue = _e
                } catch (bt) {
                    W(s, s.return, bt)
                }
            }
            break;
        case 3:
            if (ck(o, s), ek(s), $ & 4 && a !== null && a.memoizedState.isDehydrated) try {
                bd(o.containerInfo)
            } catch (bt) {
                W(s, s.return, bt)
            }
            break;
        case 4:
            ck(o, s), ek(s);
            break;
        case 13:
            ck(o, s), ek(s), j = s.child, j.flags & 8192 && (_e = j.memoizedState !== null, j.stateNode.isHidden = _e, !_e || j.alternate !== null && j.alternate.memoizedState !== null || (fk = B())), $ & 4 && ak(s);
            break;
        case 22:
            if (ot = a !== null && a.memoizedState !== null, s.mode & 1 ? (U = (rt = U) || ot, ck(o, s), U = rt) : ck(o, s), ek(s), $ & 8192) {
                if (rt = s.memoizedState !== null, (s.stateNode.isHidden = rt) && !ot && s.mode & 1)
                    for (V = s, ot = s.child; ot !== null;) {
                        for (st = V = ot; V !== null;) {
                            switch (lt = V, ft = lt.child, lt.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Pj(4, lt, lt.return);
                                    break;
                                case 1:
                                    Lj(lt, lt.return);
                                    var yt = lt.stateNode;
                                    if (typeof yt.componentWillUnmount == "function") {
                                        $ = lt, a = lt.return;
                                        try {
                                            o = $, yt.props = o.memoizedProps, yt.state = o.memoizedState, yt.componentWillUnmount()
                                        } catch (bt) {
                                            W($, a, bt)
                                        }
                                    }
                                    break;
                                case 5:
                                    Lj(lt, lt.return);
                                    break;
                                case 22:
                                    if (lt.memoizedState !== null) {
                                        gk(st);
                                        continue
                                    }
                            }
                            ft !== null ? (ft.return = lt, V = ft) : gk(st)
                        }
                        ot = ot.sibling
                    }
                e: for (ot = null, st = s;;) {
                    if (st.tag === 5) {
                        if (ot === null) {
                            ot = st;
                            try {
                                j = st.stateNode, rt ? (_e = j.style, typeof _e.setProperty == "function" ? _e.setProperty("display", "none", "important") : _e.display = "none") : (tt = st.stateNode, nt = st.memoizedProps.style, et = nt != null && nt.hasOwnProperty("display") ? nt.display : null, tt.style.display = rb("display", et))
                            } catch (bt) {
                                W(s, s.return, bt)
                            }
                        }
                    } else if (st.tag === 6) {
                        if (ot === null) try {
                            st.stateNode.nodeValue = rt ? "" : st.memoizedProps
                        } catch (bt) {
                            W(s, s.return, bt)
                        }
                    } else if ((st.tag !== 22 && st.tag !== 23 || st.memoizedState === null || st === s) && st.child !== null) {
                        st.child.return = st, st = st.child;
                        continue
                    }
                    if (st === s) break e;
                    for (; st.sibling === null;) {
                        if (st.return === null || st.return === s) break e;
                        ot === st && (ot = null), st = st.return
                    }
                    ot === st && (ot = null), st.sibling.return = st.return, st = st.sibling
                }
            }
            break;
        case 19:
            ck(o, s), ek(s), $ & 4 && ak(s);
            break;
        case 21:
            break;
        default:
            ck(o, s), ek(s)
    }
}

function ek(s) {
    var o = s.flags;
    if (o & 2) {
        try {
            e: {
                for (var a = s.return; a !== null;) {
                    if (Tj(a)) {
                        var $ = a;
                        break e
                    }
                    a = a.return
                }
                throw Error(p$2(160))
            }
            switch ($.tag) {
                case 5:
                    var j = $.stateNode;
                    $.flags & 32 && (ob(j, ""), $.flags &= -33);
                    var _e = Uj(s);
                    Wj(s, _e, j);
                    break;
                case 3:
                case 4:
                    var et = $.stateNode.containerInfo,
                        tt = Uj(s);
                    Vj(s, tt, et);
                    break;
                default:
                    throw Error(p$2(161))
            }
        }
        catch (nt) {
            W(s, s.return, nt)
        }
        s.flags &= -3
    }
    o & 4096 && (s.flags &= -4097)
}

function hk(s, o, a) {
    V = s, ik(s)
}

function ik(s, o, a) {
    for (var $ = (s.mode & 1) !== 0; V !== null;) {
        var j = V,
            _e = j.child;
        if (j.tag === 22 && $) {
            var et = j.memoizedState !== null || Jj;
            if (!et) {
                var tt = j.alternate,
                    nt = tt !== null && tt.memoizedState !== null || U;
                tt = Jj;
                var rt = U;
                if (Jj = et, (U = nt) && !rt)
                    for (V = j; V !== null;) et = V, nt = et.child, et.tag === 22 && et.memoizedState !== null ? jk(j) : nt !== null ? (nt.return = et, V = nt) : jk(j);
                for (; _e !== null;) V = _e, ik(_e), _e = _e.sibling;
                V = j, Jj = tt, U = rt
            }
            kk(s)
        } else j.subtreeFlags & 8772 && _e !== null ? (_e.return = j, V = _e) : kk(s)
    }
}

function kk(s) {
    for (; V !== null;) {
        var o = V;
        if (o.flags & 8772) {
            var a = o.alternate;
            try {
                if (o.flags & 8772) switch (o.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U || Qj(5, o);
                        break;
                    case 1:
                        var $ = o.stateNode;
                        if (o.flags & 4 && !U)
                            if (a === null) $.componentDidMount();
                            else {
                                var j = o.elementType === o.type ? a.memoizedProps : Ci(o.type, a.memoizedProps);
                                $.componentDidUpdate(j, a.memoizedState, $.__reactInternalSnapshotBeforeUpdate)
                            }
                        var _e = o.updateQueue;
                        _e !== null && sh(o, _e, $);
                        break;
                    case 3:
                        var et = o.updateQueue;
                        if (et !== null) {
                            if (a = null, o.child !== null) switch (o.child.tag) {
                                case 5:
                                    a = o.child.stateNode;
                                    break;
                                case 1:
                                    a = o.child.stateNode
                            }
                            sh(o, et, a)
                        }
                        break;
                    case 5:
                        var tt = o.stateNode;
                        if (a === null && o.flags & 4) {
                            a = tt;
                            var nt = o.memoizedProps;
                            switch (o.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    nt.autoFocus && a.focus();
                                    break;
                                case "img":
                                    nt.src && (a.src = nt.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (o.memoizedState === null) {
                            var rt = o.alternate;
                            if (rt !== null) {
                                var ot = rt.memoizedState;
                                if (ot !== null) {
                                    var st = ot.dehydrated;
                                    st !== null && bd(st)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p$2(163))
                }
                U || o.flags & 512 && Rj(o)
            } catch (lt) {
                W(o, o.return, lt)
            }
        }
        if (o === s) {
            V = null;
            break
        }
        if (a = o.sibling, a !== null) {
            a.return = o.return, V = a;
            break
        }
        V = o.return
    }
}

function gk(s) {
    for (; V !== null;) {
        var o = V;
        if (o === s) {
            V = null;
            break
        }
        var a = o.sibling;
        if (a !== null) {
            a.return = o.return, V = a;
            break
        }
        V = o.return
    }
}

function jk(s) {
    for (; V !== null;) {
        var o = V;
        try {
            switch (o.tag) {
                case 0:
                case 11:
                case 15:
                    var a = o.return;
                    try {
                        Qj(4, o)
                    } catch (nt) {
                        W(o, a, nt)
                    }
                    break;
                case 1:
                    var $ = o.stateNode;
                    if (typeof $.componentDidMount == "function") {
                        var j = o.return;
                        try {
                            $.componentDidMount()
                        } catch (nt) {
                            W(o, j, nt)
                        }
                    }
                    var _e = o.return;
                    try {
                        Rj(o)
                    } catch (nt) {
                        W(o, _e, nt)
                    }
                    break;
                case 5:
                    var et = o.return;
                    try {
                        Rj(o)
                    } catch (nt) {
                        W(o, et, nt)
                    }
            }
        } catch (nt) {
            W(o, o.return, nt)
        }
        if (o === s) {
            V = null;
            break
        }
        var tt = o.sibling;
        if (tt !== null) {
            tt.return = o.return, V = tt;
            break
        }
        V = o.return
    }
}
var lk = Math.ceil,
    mk = ua.ReactCurrentDispatcher,
    nk = ua.ReactCurrentOwner,
    ok = ua.ReactCurrentBatchConfig,
    K = 0,
    Q = null,
    Y = null,
    Z = 0,
    fj = 0,
    ej = Uf(0),
    T = 0,
    pk = null,
    rh = 0,
    qk = 0,
    rk = 0,
    sk = null,
    tk = null,
    fk = 0,
    Gj = 1 / 0,
    uk = null,
    Oi = !1,
    Pi = null,
    Ri = null,
    vk = !1,
    wk = null,
    xk = 0,
    yk = 0,
    zk = null,
    Ak = -1,
    Bk = 0;

function R() {
    return K & 6 ? B() : Ak !== -1 ? Ak : Ak = B()
}

function yi(s) {
    return s.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Bk === 0 && (Bk = yc()), Bk) : (s = C, s !== 0 || (s = window.event, s = s === void 0 ? 16 : jd(s.type)), s) : 1
}

function gi(s, o, a, $) {
    if (50 < yk) throw yk = 0, zk = null, Error(p$2(185));
    Ac(s, a, $), (!(K & 2) || s !== Q) && (s === Q && (!(K & 2) && (qk |= a), T === 4 && Ck(s, Z)), Dk(s, $), a === 1 && K === 0 && !(o.mode & 1) && (Gj = B() + 500, fg && jg()))
}

function Dk(s, o) {
    var a = s.callbackNode;
    wc(s, o);
    var $ = uc(s, s === Q ? Z : 0);
    if ($ === 0) a !== null && bc(a), s.callbackNode = null, s.callbackPriority = 0;
    else if (o = $ & -$, s.callbackPriority !== o) {
        if (a != null && bc(a), o === 1) s.tag === 0 ? ig(Ek.bind(null, s)) : hg(Ek.bind(null, s)), Jf(function() {
            !(K & 6) && jg()
        }), a = null;
        else {
            switch (Dc($)) {
                case 1:
                    a = fc;
                    break;
                case 4:
                    a = gc;
                    break;
                case 16:
                    a = hc;
                    break;
                case 536870912:
                    a = jc;
                    break;
                default:
                    a = hc
            }
            a = Fk(a, Gk.bind(null, s))
        }
        s.callbackPriority = o, s.callbackNode = a
    }
}

function Gk(s, o) {
    if (Ak = -1, Bk = 0, K & 6) throw Error(p$2(327));
    var a = s.callbackNode;
    if (Hk() && s.callbackNode !== a) return null;
    var $ = uc(s, s === Q ? Z : 0);
    if ($ === 0) return null;
    if ($ & 30 || $ & s.expiredLanes || o) o = Ik(s, $);
    else {
        o = $;
        var j = K;
        K |= 2;
        var _e = Jk();
        (Q !== s || Z !== o) && (uk = null, Gj = B() + 500, Kk(s, o));
        do try {
            Lk();
            break
        } catch (tt) {
            Mk(s, tt)
        }
        while (!0);
        $g(), mk.current = _e, K = j, Y !== null ? o = 0 : (Q = null, Z = 0, o = T)
    }
    if (o !== 0) {
        if (o === 2 && (j = xc(s), j !== 0 && ($ = j, o = Nk(s, j))), o === 1) throw a = pk, Kk(s, 0), Ck(s, $), Dk(s, B()), a;
        if (o === 6) Ck(s, $);
        else {
            if (j = s.current.alternate, !($ & 30) && !Ok(j) && (o = Ik(s, $), o === 2 && (_e = xc(s), _e !== 0 && ($ = _e, o = Nk(s, _e))), o === 1)) throw a = pk, Kk(s, 0), Ck(s, $), Dk(s, B()), a;
            switch (s.finishedWork = j, s.finishedLanes = $, o) {
                case 0:
                case 1:
                    throw Error(p$2(345));
                case 2:
                    Pk(s, tk, uk);
                    break;
                case 3:
                    if (Ck(s, $), ($ & 130023424) === $ && (o = fk + 500 - B(), 10 < o)) {
                        if (uc(s, 0) !== 0) break;
                        if (j = s.suspendedLanes, (j & $) !== $) {
                            R(), s.pingedLanes |= s.suspendedLanes & j;
                            break
                        }
                        s.timeoutHandle = Ff(Pk.bind(null, s, tk, uk), o);
                        break
                    }
                    Pk(s, tk, uk);
                    break;
                case 4:
                    if (Ck(s, $), ($ & 4194240) === $) break;
                    for (o = s.eventTimes, j = -1; 0 < $;) {
                        var et = 31 - oc($);
                        _e = 1 << et, et = o[et], et > j && (j = et), $ &= ~_e
                    }
                    if ($ = j, $ = B() - $, $ = (120 > $ ? 120 : 480 > $ ? 480 : 1080 > $ ? 1080 : 1920 > $ ? 1920 : 3e3 > $ ? 3e3 : 4320 > $ ? 4320 : 1960 * lk($ / 1960)) - $, 10 < $) {
                        s.timeoutHandle = Ff(Pk.bind(null, s, tk, uk), $);
                        break
                    }
                    Pk(s, tk, uk);
                    break;
                case 5:
                    Pk(s, tk, uk);
                    break;
                default:
                    throw Error(p$2(329))
            }
        }
    }
    return Dk(s, B()), s.callbackNode === a ? Gk.bind(null, s) : null
}

function Nk(s, o) {
    var a = sk;
    return s.current.memoizedState.isDehydrated && (Kk(s, o).flags |= 256), s = Ik(s, o), s !== 2 && (o = tk, tk = a, o !== null && Fj(o)), s
}

function Fj(s) {
    tk === null ? tk = s : tk.push.apply(tk, s)
}

function Ok(s) {
    for (var o = s;;) {
        if (o.flags & 16384) {
            var a = o.updateQueue;
            if (a !== null && (a = a.stores, a !== null))
                for (var $ = 0; $ < a.length; $++) {
                    var j = a[$],
                        _e = j.getSnapshot;
                    j = j.value;
                    try {
                        if (!He(_e(), j)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (a = o.child, o.subtreeFlags & 16384 && a !== null) a.return = o, o = a;
        else {
            if (o === s) break;
            for (; o.sibling === null;) {
                if (o.return === null || o.return === s) return !0;
                o = o.return
            }
            o.sibling.return = o.return, o = o.sibling
        }
    }
    return !0
}

function Ck(s, o) {
    for (o &= ~rk, o &= ~qk, s.suspendedLanes |= o, s.pingedLanes &= ~o, s = s.expirationTimes; 0 < o;) {
        var a = 31 - oc(o),
            $ = 1 << a;
        s[a] = -1, o &= ~$
    }
}

function Ek(s) {
    if (K & 6) throw Error(p$2(327));
    Hk();
    var o = uc(s, 0);
    if (!(o & 1)) return Dk(s, B()), null;
    var a = Ik(s, o);
    if (s.tag !== 0 && a === 2) {
        var $ = xc(s);
        $ !== 0 && (o = $, a = Nk(s, $))
    }
    if (a === 1) throw a = pk, Kk(s, 0), Ck(s, o), Dk(s, B()), a;
    if (a === 6) throw Error(p$2(345));
    return s.finishedWork = s.current.alternate, s.finishedLanes = o, Pk(s, tk, uk), Dk(s, B()), null
}

function Qk(s, o) {
    var a = K;
    K |= 1;
    try {
        return s(o)
    } finally {
        K = a, K === 0 && (Gj = B() + 500, fg && jg())
    }
}

function Rk(s) {
    wk !== null && wk.tag === 0 && !(K & 6) && Hk();
    var o = K;
    K |= 1;
    var a = ok.transition,
        $ = C;
    try {
        if (ok.transition = null, C = 1, s) return s()
    } finally {
        C = $, ok.transition = a, K = o, !(K & 6) && jg()
    }
}

function Hj() {
    fj = ej.current, E(ej)
}

function Kk(s, o) {
    s.finishedWork = null, s.finishedLanes = 0;
    var a = s.timeoutHandle;
    if (a !== -1 && (s.timeoutHandle = -1, Gf(a)), Y !== null)
        for (a = Y.return; a !== null;) {
            var $ = a;
            switch (wg($), $.tag) {
                case 1:
                    $ = $.type.childContextTypes, $ != null && $f();
                    break;
                case 3:
                    zh(), E(Wf), E(H), Eh();
                    break;
                case 5:
                    Bh($);
                    break;
                case 4:
                    zh();
                    break;
                case 13:
                    E(L);
                    break;
                case 19:
                    E(L);
                    break;
                case 10:
                    ah($.type._context);
                    break;
                case 22:
                case 23:
                    Hj()
            }
            a = a.return
        }
    if (Q = s, Y = s = Pg(s.current, null), Z = fj = o, T = 0, pk = null, rk = qk = rh = 0, tk = sk = null, fh !== null) {
        for (o = 0; o < fh.length; o++)
            if (a = fh[o], $ = a.interleaved, $ !== null) {
                a.interleaved = null;
                var j = $.next,
                    _e = a.pending;
                if (_e !== null) {
                    var et = _e.next;
                    _e.next = j, $.next = et
                }
                a.pending = $
            }
        fh = null
    }
    return s
}

function Mk(s, o) {
    do {
        var a = Y;
        try {
            if ($g(), Fh.current = Rh, Ih) {
                for (var $ = M.memoizedState; $ !== null;) {
                    var j = $.queue;
                    j !== null && (j.pending = null), $ = $.next
                }
                Ih = !1
            }
            if (Hh = 0, O = N = M = null, Jh = !1, Kh = 0, nk.current = null, a === null || a.return === null) {
                T = 1, pk = o, Y = null;
                break
            }
            e: {
                var _e = s,
                    et = a.return,
                    tt = a,
                    nt = o;
                if (o = Z, tt.flags |= 32768, nt !== null && typeof nt == "object" && typeof nt.then == "function") {
                    var rt = nt,
                        ot = tt,
                        st = ot.tag;
                    if (!(ot.mode & 1) && (st === 0 || st === 11 || st === 15)) {
                        var lt = ot.alternate;
                        lt ? (ot.updateQueue = lt.updateQueue, ot.memoizedState = lt.memoizedState, ot.lanes = lt.lanes) : (ot.updateQueue = null, ot.memoizedState = null)
                    }
                    var ft = Ui(et);
                    if (ft !== null) {
                        ft.flags &= -257, Vi(ft, et, tt, _e, o), ft.mode & 1 && Si(_e, rt, o), o = ft, nt = rt;
                        var yt = o.updateQueue;
                        if (yt === null) {
                            var bt = new Set;
                            bt.add(nt), o.updateQueue = bt
                        } else yt.add(nt);
                        break e
                    } else {
                        if (!(o & 1)) {
                            Si(_e, rt, o), tj();
                            break e
                        }
                        nt = Error(p$2(426))
                    }
                } else if (I && tt.mode & 1) {
                    var ht = Ui(et);
                    if (ht !== null) {
                        !(ht.flags & 65536) && (ht.flags |= 256), Vi(ht, et, tt, _e, o), Jg(Ji(nt, tt));
                        break e
                    }
                }
                _e = nt = Ji(nt, tt),
                T !== 4 && (T = 2),
                sk === null ? sk = [_e] : sk.push(_e),
                _e = et;do {
                    switch (_e.tag) {
                        case 3:
                            _e.flags |= 65536, o &= -o, _e.lanes |= o;
                            var vt = Ni(_e, nt, o);
                            ph(_e, vt);
                            break e;
                        case 1:
                            tt = nt;
                            var wt = _e.type,
                                gt = _e.stateNode;
                            if (!(_e.flags & 128) && (typeof wt.getDerivedStateFromError == "function" || gt !== null && typeof gt.componentDidCatch == "function" && (Ri === null || !Ri.has(gt)))) {
                                _e.flags |= 65536, o &= -o, _e.lanes |= o;
                                var At = Qi(_e, tt, o);
                                ph(_e, At);
                                break e
                            }
                    }
                    _e = _e.return
                } while (_e !== null)
            }
            Sk(a)
        } catch (Pt) {
            o = Pt, Y === a && a !== null && (Y = a = a.return);
            continue
        }
        break
    } while (!0)
}

function Jk() {
    var s = mk.current;
    return mk.current = Rh, s === null ? Rh : s
}

function tj() {
    (T === 0 || T === 3 || T === 2) && (T = 4), Q === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q, Z)
}

function Ik(s, o) {
    var a = K;
    K |= 2;
    var $ = Jk();
    (Q !== s || Z !== o) && (uk = null, Kk(s, o));
    do try {
        Tk();
        break
    } catch (j) {
        Mk(s, j)
    }
    while (!0);
    if ($g(), K = a, mk.current = $, Y !== null) throw Error(p$2(261));
    return Q = null, Z = 0, T
}

function Tk() {
    for (; Y !== null;) Uk(Y)
}

function Lk() {
    for (; Y !== null && !cc();) Uk(Y)
}

function Uk(s) {
    var o = Vk(s.alternate, s, fj);
    s.memoizedProps = s.pendingProps, o === null ? Sk(s) : Y = o, nk.current = null
}

function Sk(s) {
    var o = s;
    do {
        var a = o.alternate;
        if (s = o.return, o.flags & 32768) {
            if (a = Ij(a, o), a !== null) {
                a.flags &= 32767, Y = a;
                return
            }
            if (s !== null) s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null;
            else {
                T = 6, Y = null;
                return
            }
        } else if (a = Ej(a, o, fj), a !== null) {
            Y = a;
            return
        }
        if (o = o.sibling, o !== null) {
            Y = o;
            return
        }
        Y = o = s
    } while (o !== null);
    T === 0 && (T = 5)
}

function Pk(s, o, a) {
    var $ = C,
        j = ok.transition;
    try {
        ok.transition = null, C = 1, Wk(s, o, a, $)
    } finally {
        ok.transition = j, C = $
    }
    return null
}

function Wk(s, o, a, $) {
    do Hk(); while (wk !== null);
    if (K & 6) throw Error(p$2(327));
    a = s.finishedWork;
    var j = s.finishedLanes;
    if (a === null) return null;
    if (s.finishedWork = null, s.finishedLanes = 0, a === s.current) throw Error(p$2(177));
    s.callbackNode = null, s.callbackPriority = 0;
    var _e = a.lanes | a.childLanes;
    if (Bc(s, _e), s === Q && (Y = Q = null, Z = 0), !(a.subtreeFlags & 2064) && !(a.flags & 2064) || vk || (vk = !0, Fk(hc, function() {
            return Hk(), null
        })), _e = (a.flags & 15990) !== 0, a.subtreeFlags & 15990 || _e) {
        _e = ok.transition, ok.transition = null;
        var et = C;
        C = 1;
        var tt = K;
        K |= 4, nk.current = null, Oj(s, a), dk(a, s), Oe(Df), dd = !!Cf, Df = Cf = null, s.current = a, hk(a), dc(), K = tt, C = et, ok.transition = _e
    } else s.current = a;
    if (vk && (vk = !1, wk = s, xk = j), _e = s.pendingLanes, _e === 0 && (Ri = null), mc(a.stateNode), Dk(s, B()), o !== null)
        for ($ = s.onRecoverableError, a = 0; a < o.length; a++) j = o[a], $(j.value, {
            componentStack: j.stack,
            digest: j.digest
        });
    if (Oi) throw Oi = !1, s = Pi, Pi = null, s;
    return xk & 1 && s.tag !== 0 && Hk(), _e = s.pendingLanes, _e & 1 ? s === zk ? yk++ : (yk = 0, zk = s) : yk = 0, jg(), null
}

function Hk() {
    if (wk !== null) {
        var s = Dc(xk),
            o = ok.transition,
            a = C;
        try {
            if (ok.transition = null, C = 16 > s ? 16 : s, wk === null) var $ = !1;
            else {
                if (s = wk, wk = null, xk = 0, K & 6) throw Error(p$2(331));
                var j = K;
                for (K |= 4, V = s.current; V !== null;) {
                    var _e = V,
                        et = _e.child;
                    if (V.flags & 16) {
                        var tt = _e.deletions;
                        if (tt !== null) {
                            for (var nt = 0; nt < tt.length; nt++) {
                                var rt = tt[nt];
                                for (V = rt; V !== null;) {
                                    var ot = V;
                                    switch (ot.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Pj(8, ot, _e)
                                    }
                                    var st = ot.child;
                                    if (st !== null) st.return = ot, V = st;
                                    else
                                        for (; V !== null;) {
                                            ot = V;
                                            var lt = ot.sibling,
                                                ft = ot.return;
                                            if (Sj(ot), ot === rt) {
                                                V = null;
                                                break
                                            }
                                            if (lt !== null) {
                                                lt.return = ft, V = lt;
                                                break
                                            }
                                            V = ft
                                        }
                                }
                            }
                            var yt = _e.alternate;
                            if (yt !== null) {
                                var bt = yt.child;
                                if (bt !== null) {
                                    yt.child = null;
                                    do {
                                        var ht = bt.sibling;
                                        bt.sibling = null, bt = ht
                                    } while (bt !== null)
                                }
                            }
                            V = _e
                        }
                    }
                    if (_e.subtreeFlags & 2064 && et !== null) et.return = _e, V = et;
                    else e: for (; V !== null;) {
                        if (_e = V, _e.flags & 2048) switch (_e.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Pj(9, _e, _e.return)
                        }
                        var vt = _e.sibling;
                        if (vt !== null) {
                            vt.return = _e.return, V = vt;
                            break e
                        }
                        V = _e.return
                    }
                }
                var wt = s.current;
                for (V = wt; V !== null;) {
                    et = V;
                    var gt = et.child;
                    if (et.subtreeFlags & 2064 && gt !== null) gt.return = et, V = gt;
                    else e: for (et = wt; V !== null;) {
                        if (tt = V, tt.flags & 2048) try {
                            switch (tt.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Qj(9, tt)
                            }
                        } catch (Pt) {
                            W(tt, tt.return, Pt)
                        }
                        if (tt === et) {
                            V = null;
                            break e
                        }
                        var At = tt.sibling;
                        if (At !== null) {
                            At.return = tt.return, V = At;
                            break e
                        }
                        V = tt.return
                    }
                }
                if (K = j, jg(), lc && typeof lc.onPostCommitFiberRoot == "function") try {
                    lc.onPostCommitFiberRoot(kc, s)
                } catch {}
                $ = !0
            }
            return $
        } finally {
            C = a, ok.transition = o
        }
    }
    return !1
}

function Xk(s, o, a) {
    o = Ji(a, o), o = Ni(s, o, 1), s = nh(s, o, 1), o = R(), s !== null && (Ac(s, 1, o), Dk(s, o))
}

function W(s, o, a) {
    if (s.tag === 3) Xk(s, s, a);
    else
        for (; o !== null;) {
            if (o.tag === 3) {
                Xk(o, s, a);
                break
            } else if (o.tag === 1) {
                var $ = o.stateNode;
                if (typeof o.type.getDerivedStateFromError == "function" || typeof $.componentDidCatch == "function" && (Ri === null || !Ri.has($))) {
                    s = Ji(a, s), s = Qi(o, s, 1), o = nh(o, s, 1), s = R(), o !== null && (Ac(o, 1, s), Dk(o, s));
                    break
                }
            }
            o = o.return
        }
}

function Ti(s, o, a) {
    var $ = s.pingCache;
    $ !== null && $.delete(o), o = R(), s.pingedLanes |= s.suspendedLanes & a, Q === s && (Z & a) === a && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(s, 0) : rk |= a), Dk(s, o)
}

function Yk(s, o) {
    o === 0 && (s.mode & 1 ? (o = sc, sc <<= 1, !(sc & 130023424) && (sc = 4194304)) : o = 1);
    var a = R();
    s = ih(s, o), s !== null && (Ac(s, o, a), Dk(s, a))
}

function uj(s) {
    var o = s.memoizedState,
        a = 0;
    o !== null && (a = o.retryLane), Yk(s, a)
}

function bk(s, o) {
    var a = 0;
    switch (s.tag) {
        case 13:
            var $ = s.stateNode,
                j = s.memoizedState;
            j !== null && (a = j.retryLane);
            break;
        case 19:
            $ = s.stateNode;
            break;
        default:
            throw Error(p$2(314))
    }
    $ !== null && $.delete(o), Yk(s, a)
}
var Vk;
Vk = function(s, o, a) {
    if (s !== null)
        if (s.memoizedProps !== o.pendingProps || Wf.current) dh = !0;
        else {
            if (!(s.lanes & a) && !(o.flags & 128)) return dh = !1, yj(s, o, a);
            dh = !!(s.flags & 131072)
        }
    else dh = !1, I && o.flags & 1048576 && ug(o, ng, o.index);
    switch (o.lanes = 0, o.tag) {
        case 2:
            var $ = o.type;
            ij(s, o), s = o.pendingProps;
            var j = Yf(o, H.current);
            ch(o, a), j = Nh(null, o, $, s, j, a);
            var _e = Sh();
            return o.flags |= 1, typeof j == "object" && j !== null && typeof j.render == "function" && j.$$typeof === void 0 ? (o.tag = 1, o.memoizedState = null, o.updateQueue = null, Zf($) ? (_e = !0, cg(o)) : _e = !1, o.memoizedState = j.state !== null && j.state !== void 0 ? j.state : null, kh(o), j.updater = Ei, o.stateNode = j, j._reactInternals = o, Ii(o, $, s, a), o = jj(null, o, $, !0, _e, a)) : (o.tag = 0, I && _e && vg(o), Xi(null, o, j, a), o = o.child), o;
        case 16:
            $ = o.elementType;
            e: {
                switch (ij(s, o), s = o.pendingProps, j = $._init, $ = j($._payload), o.type = $, j = o.tag = Zk($), s = Ci($, s), j) {
                    case 0:
                        o = cj(null, o, $, s, a);
                        break e;
                    case 1:
                        o = hj(null, o, $, s, a);
                        break e;
                    case 11:
                        o = Yi(null, o, $, s, a);
                        break e;
                    case 14:
                        o = $i(null, o, $, Ci($.type, s), a);
                        break e
                }
                throw Error(p$2(306, $, ""))
            }
            return o;
        case 0:
            return $ = o.type, j = o.pendingProps, j = o.elementType === $ ? j : Ci($, j), cj(s, o, $, j, a);
        case 1:
            return $ = o.type, j = o.pendingProps, j = o.elementType === $ ? j : Ci($, j), hj(s, o, $, j, a);
        case 3:
            e: {
                if (kj(o), s === null) throw Error(p$2(387));$ = o.pendingProps,
                _e = o.memoizedState,
                j = _e.element,
                lh(s, o),
                qh(o, $, null, a);
                var et = o.memoizedState;
                if ($ = et.element, _e.isDehydrated)
                    if (_e = {
                            element: $,
                            isDehydrated: !1,
                            cache: et.cache,
                            pendingSuspenseBoundaries: et.pendingSuspenseBoundaries,
                            transitions: et.transitions
                        }, o.updateQueue.baseState = _e, o.memoizedState = _e, o.flags & 256) {
                        j = Ji(Error(p$2(423)), o), o = lj(s, o, $, a, j);
                        break e
                    } else if ($ !== j) {
                    j = Ji(Error(p$2(424)), o), o = lj(s, o, $, a, j);
                    break e
                } else
                    for (yg = Lf(o.stateNode.containerInfo.firstChild), xg = o, I = !0, zg = null, a = Vg(o, null, $, a), o.child = a; a;) a.flags = a.flags & -3 | 4096, a = a.sibling;
                else {
                    if (Ig(), $ === j) {
                        o = Zi(s, o, a);
                        break e
                    }
                    Xi(s, o, $, a)
                }
                o = o.child
            }
            return o;
        case 5:
            return Ah(o), s === null && Eg(o), $ = o.type, j = o.pendingProps, _e = s !== null ? s.memoizedProps : null, et = j.children, Ef($, j) ? et = null : _e !== null && Ef($, _e) && (o.flags |= 32), gj(s, o), Xi(s, o, et, a), o.child;
        case 6:
            return s === null && Eg(o), null;
        case 13:
            return oj(s, o, a);
        case 4:
            return yh(o, o.stateNode.containerInfo), $ = o.pendingProps, s === null ? o.child = Ug(o, null, $, a) : Xi(s, o, $, a), o.child;
        case 11:
            return $ = o.type, j = o.pendingProps, j = o.elementType === $ ? j : Ci($, j), Yi(s, o, $, j, a);
        case 7:
            return Xi(s, o, o.pendingProps, a), o.child;
        case 8:
            return Xi(s, o, o.pendingProps.children, a), o.child;
        case 12:
            return Xi(s, o, o.pendingProps.children, a), o.child;
        case 10:
            e: {
                if ($ = o.type._context, j = o.pendingProps, _e = o.memoizedProps, et = j.value, G(Wg, $._currentValue), $._currentValue = et, _e !== null)
                    if (He(_e.value, et)) {
                        if (_e.children === j.children && !Wf.current) {
                            o = Zi(s, o, a);
                            break e
                        }
                    } else
                        for (_e = o.child, _e !== null && (_e.return = o); _e !== null;) {
                            var tt = _e.dependencies;
                            if (tt !== null) {
                                et = _e.child;
                                for (var nt = tt.firstContext; nt !== null;) {
                                    if (nt.context === $) {
                                        if (_e.tag === 1) {
                                            nt = mh(-1, a & -a), nt.tag = 2;
                                            var rt = _e.updateQueue;
                                            if (rt !== null) {
                                                rt = rt.shared;
                                                var ot = rt.pending;
                                                ot === null ? nt.next = nt : (nt.next = ot.next, ot.next = nt), rt.pending = nt
                                            }
                                        }
                                        _e.lanes |= a, nt = _e.alternate, nt !== null && (nt.lanes |= a), bh(_e.return, a, o), tt.lanes |= a;
                                        break
                                    }
                                    nt = nt.next
                                }
                            } else if (_e.tag === 10) et = _e.type === o.type ? null : _e.child;
                            else if (_e.tag === 18) {
                                if (et = _e.return, et === null) throw Error(p$2(341));
                                et.lanes |= a, tt = et.alternate, tt !== null && (tt.lanes |= a), bh(et, a, o), et = _e.sibling
                            } else et = _e.child;
                            if (et !== null) et.return = _e;
                            else
                                for (et = _e; et !== null;) {
                                    if (et === o) {
                                        et = null;
                                        break
                                    }
                                    if (_e = et.sibling, _e !== null) {
                                        _e.return = et.return, et = _e;
                                        break
                                    }
                                    et = et.return
                                }
                            _e = et
                        }
                Xi(s, o, j.children, a),
                o = o.child
            }
            return o;
        case 9:
            return j = o.type, $ = o.pendingProps.children, ch(o, a), j = eh(j), $ = $(j), o.flags |= 1, Xi(s, o, $, a), o.child;
        case 14:
            return $ = o.type, j = Ci($, o.pendingProps), j = Ci($.type, j), $i(s, o, $, j, a);
        case 15:
            return bj(s, o, o.type, o.pendingProps, a);
        case 17:
            return $ = o.type, j = o.pendingProps, j = o.elementType === $ ? j : Ci($, j), ij(s, o), o.tag = 1, Zf($) ? (s = !0, cg(o)) : s = !1, ch(o, a), Gi(o, $, j), Ii(o, $, j, a), jj(null, o, $, !0, s, a);
        case 19:
            return xj(s, o, a);
        case 22:
            return dj(s, o, a)
    }
    throw Error(p$2(156, o.tag))
};

function Fk(s, o) {
    return ac(s, o)
}

function $k(s, o, a, $) {
    this.tag = s, this.key = a, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = $, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function Bg(s, o, a, $) {
    return new $k(s, o, a, $)
}

function aj(s) {
    return s = s.prototype, !(!s || !s.isReactComponent)
}

function Zk(s) {
    if (typeof s == "function") return aj(s) ? 1 : 0;
    if (s != null) {
        if (s = s.$$typeof, s === Da) return 11;
        if (s === Ga) return 14
    }
    return 2
}

function Pg(s, o) {
    var a = s.alternate;
    return a === null ? (a = Bg(s.tag, o, s.key, s.mode), a.elementType = s.elementType, a.type = s.type, a.stateNode = s.stateNode, a.alternate = s, s.alternate = a) : (a.pendingProps = o, a.type = s.type, a.flags = 0, a.subtreeFlags = 0, a.deletions = null), a.flags = s.flags & 14680064, a.childLanes = s.childLanes, a.lanes = s.lanes, a.child = s.child, a.memoizedProps = s.memoizedProps, a.memoizedState = s.memoizedState, a.updateQueue = s.updateQueue, o = s.dependencies, a.dependencies = o === null ? null : {
        lanes: o.lanes,
        firstContext: o.firstContext
    }, a.sibling = s.sibling, a.index = s.index, a.ref = s.ref, a
}

function Rg(s, o, a, $, j, _e) {
    var et = 2;
    if ($ = s, typeof s == "function") aj(s) && (et = 1);
    else if (typeof s == "string") et = 5;
    else e: switch (s) {
        case ya:
            return Tg(a.children, j, _e, o);
        case za:
            et = 8, j |= 8;
            break;
        case Aa:
            return s = Bg(12, a, o, j | 2), s.elementType = Aa, s.lanes = _e, s;
        case Ea:
            return s = Bg(13, a, o, j), s.elementType = Ea, s.lanes = _e, s;
        case Fa:
            return s = Bg(19, a, o, j), s.elementType = Fa, s.lanes = _e, s;
        case Ia:
            return pj(a, j, _e, o);
        default:
            if (typeof s == "object" && s !== null) switch (s.$$typeof) {
                case Ba:
                    et = 10;
                    break e;
                case Ca:
                    et = 9;
                    break e;
                case Da:
                    et = 11;
                    break e;
                case Ga:
                    et = 14;
                    break e;
                case Ha:
                    et = 16, $ = null;
                    break e
            }
            throw Error(p$2(130, s == null ? s : typeof s, ""))
    }
    return o = Bg(et, a, o, j), o.elementType = s, o.type = $, o.lanes = _e, o
}

function Tg(s, o, a, $) {
    return s = Bg(7, s, $, o), s.lanes = a, s
}

function pj(s, o, a, $) {
    return s = Bg(22, s, $, o), s.elementType = Ia, s.lanes = a, s.stateNode = {
        isHidden: !1
    }, s
}

function Qg(s, o, a) {
    return s = Bg(6, s, null, o), s.lanes = a, s
}

function Sg(s, o, a) {
    return o = Bg(4, s.children !== null ? s.children : [], s.key, o), o.lanes = a, o.stateNode = {
        containerInfo: s.containerInfo,
        pendingChildren: null,
        implementation: s.implementation
    }, o
}

function al(s, o, a, $, j) {
    this.tag = o, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = $, this.onRecoverableError = j, this.mutableSourceEagerHydrationData = null
}

function bl(s, o, a, $, j, _e, et, tt, nt) {
    return s = new al(s, o, a, tt, nt), o === 1 ? (o = 1, _e === !0 && (o |= 8)) : o = 0, _e = Bg(3, null, null, o), s.current = _e, _e.stateNode = s, _e.memoizedState = {
        element: $,
        isDehydrated: a,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, kh(_e), s
}

function cl(s, o, a) {
    var $ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: $ == null ? null : "" + $,
        children: s,
        containerInfo: o,
        implementation: a
    }
}

function dl(s) {
    if (!s) return Vf;
    s = s._reactInternals;
    e: {
        if (Vb(s) !== s || s.tag !== 1) throw Error(p$2(170));
        var o = s;do {
            switch (o.tag) {
                case 3:
                    o = o.stateNode.context;
                    break e;
                case 1:
                    if (Zf(o.type)) {
                        o = o.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            o = o.return
        } while (o !== null);
        throw Error(p$2(171))
    }
    if (s.tag === 1) {
        var a = s.type;
        if (Zf(a)) return bg(s, a, o)
    }
    return o
}

function el(s, o, a, $, j, _e, et, tt, nt) {
    return s = bl(a, $, !0, s, j, _e, et, tt, nt), s.context = dl(null), a = s.current, $ = R(), j = yi(a), _e = mh($, j), _e.callback = o ? ? null, nh(a, _e, j), s.current.lanes = j, Ac(s, j, $), Dk(s, $), s
}

function fl(s, o, a, $) {
    var j = o.current,
        _e = R(),
        et = yi(j);
    return a = dl(a), o.context === null ? o.context = a : o.pendingContext = a, o = mh(_e, et), o.payload = {
        element: s
    }, $ = $ === void 0 ? null : $, $ !== null && (o.callback = $), s = nh(j, o, et), s !== null && (gi(s, j, et, _e), oh(s, j, et)), et
}

function gl(s) {
    if (s = s.current, !s.child) return null;
    switch (s.child.tag) {
        case 5:
            return s.child.stateNode;
        default:
            return s.child.stateNode
    }
}

function hl(s, o) {
    if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
        var a = s.retryLane;
        s.retryLane = a !== 0 && a < o ? a : o
    }
}

function il(s, o) {
    hl(s, o), (s = s.alternate) && hl(s, o)
}

function jl() {
    return null
}
var kl = typeof reportError == "function" ? reportError : function(s) {
    console.error(s)
};

function ll(s) {
    this._internalRoot = s
}
ml.prototype.render = ll.prototype.render = function(s) {
    var o = this._internalRoot;
    if (o === null) throw Error(p$2(409));
    fl(s, o, null, null)
};
ml.prototype.unmount = ll.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
        this._internalRoot = null;
        var o = s.containerInfo;
        Rk(function() {
            fl(null, s, null, null)
        }), o[uf] = null
    }
};

function ml(s) {
    this._internalRoot = s
}
ml.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
        var o = Hc();
        s = {
            blockedOn: null,
            target: s,
            priority: o
        };
        for (var a = 0; a < Qc.length && o !== 0 && o < Qc[a].priority; a++);
        Qc.splice(a, 0, s), a === 0 && Vc(s)
    }
};

function nl(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11)
}

function ol(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "))
}

function pl() {}

function ql(s, o, a, $, j) {
    if (j) {
        if (typeof $ == "function") {
            var _e = $;
            $ = function() {
                var rt = gl(et);
                _e.call(rt)
            }
        }
        var et = el(o, $, s, 0, null, !1, !1, "", pl);
        return s._reactRootContainer = et, s[uf] = et.current, sf(s.nodeType === 8 ? s.parentNode : s), Rk(), et
    }
    for (; j = s.lastChild;) s.removeChild(j);
    if (typeof $ == "function") {
        var tt = $;
        $ = function() {
            var rt = gl(nt);
            tt.call(rt)
        }
    }
    var nt = bl(s, 0, !1, null, null, !1, !1, "", pl);
    return s._reactRootContainer = nt, s[uf] = nt.current, sf(s.nodeType === 8 ? s.parentNode : s), Rk(function() {
        fl(o, nt, a, $)
    }), nt
}

function rl(s, o, a, $, j) {
    var _e = a._reactRootContainer;
    if (_e) {
        var et = _e;
        if (typeof j == "function") {
            var tt = j;
            j = function() {
                var nt = gl(et);
                tt.call(nt)
            }
        }
        fl(o, et, s, j)
    } else et = ql(a, o, s, j, $);
    return gl(et)
}
Ec = function(s) {
    switch (s.tag) {
        case 3:
            var o = s.stateNode;
            if (o.current.memoizedState.isDehydrated) {
                var a = tc(o.pendingLanes);
                a !== 0 && (Cc(o, a | 1), Dk(o, B()), !(K & 6) && (Gj = B() + 500, jg()))
            }
            break;
        case 13:
            Rk(function() {
                var $ = ih(s, 1);
                if ($ !== null) {
                    var j = R();
                    gi($, s, 1, j)
                }
            }), il(s, 1)
    }
};
Fc = function(s) {
    if (s.tag === 13) {
        var o = ih(s, 134217728);
        if (o !== null) {
            var a = R();
            gi(o, s, 134217728, a)
        }
        il(s, 134217728)
    }
};
Gc = function(s) {
    if (s.tag === 13) {
        var o = yi(s),
            a = ih(s, o);
        if (a !== null) {
            var $ = R();
            gi(a, s, o, $)
        }
        il(s, o)
    }
};
Hc = function() {
    return C
};
Ic = function(s, o) {
    var a = C;
    try {
        return C = s, o()
    } finally {
        C = a
    }
};
yb = function(s, o, a) {
    switch (o) {
        case "input":
            if (bb(s, a), o = a.name, a.type === "radio" && o != null) {
                for (a = s; a.parentNode;) a = a.parentNode;
                for (a = a.querySelectorAll("input[name=" + JSON.stringify("" + o) + '][type="radio"]'), o = 0; o < a.length; o++) {
                    var $ = a[o];
                    if ($ !== s && $.form === s.form) {
                        var j = Db($);
                        if (!j) throw Error(p$2(90));
                        Wa($), bb($, j)
                    }
                }
            }
            break;
        case "textarea":
            ib(s, a);
            break;
        case "select":
            o = a.value, o != null && fb(s, !!a.multiple, o, !1)
    }
};
Gb = Qk;
Hb = Rk;
var sl = {
        usingClientEntryPoint: !1,
        Events: [Cb, ue, Db, Eb, Fb, Qk]
    },
    tl = {
        findFiberByHostInstance: Wc,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    },
    ul = {
        bundleType: tl.bundleType,
        version: tl.version,
        rendererPackageName: tl.rendererPackageName,
        rendererConfig: tl.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ua.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(s) {
            return s = Zb(s), s === null ? null : s.stateNode
        },
        findFiberByHostInstance: tl.findFiberByHostInstance || jl,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
        kc = vl.inject(ul), lc = vl
    } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(s, o) {
    var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!nl(o)) throw Error(p$2(200));
    return cl(s, o, null, a)
};
reactDom_production_min.createRoot = function(s, o) {
    if (!nl(s)) throw Error(p$2(299));
    var a = !1,
        $ = "",
        j = kl;
    return o != null && (o.unstable_strictMode === !0 && (a = !0), o.identifierPrefix !== void 0 && ($ = o.identifierPrefix), o.onRecoverableError !== void 0 && (j = o.onRecoverableError)), o = bl(s, 1, !1, null, null, a, !1, $, j), s[uf] = o.current, sf(s.nodeType === 8 ? s.parentNode : s), new ll(o)
};
reactDom_production_min.findDOMNode = function(s) {
    if (s == null) return null;
    if (s.nodeType === 1) return s;
    var o = s._reactInternals;
    if (o === void 0) throw typeof s.render == "function" ? Error(p$2(188)) : (s = Object.keys(s).join(","), Error(p$2(268, s)));
    return s = Zb(o), s = s === null ? null : s.stateNode, s
};
reactDom_production_min.flushSync = function(s) {
    return Rk(s)
};
reactDom_production_min.hydrate = function(s, o, a) {
    if (!ol(o)) throw Error(p$2(200));
    return rl(null, s, o, !0, a)
};
reactDom_production_min.hydrateRoot = function(s, o, a) {
    if (!nl(s)) throw Error(p$2(405));
    var $ = a != null && a.hydratedSources || null,
        j = !1,
        _e = "",
        et = kl;
    if (a != null && (a.unstable_strictMode === !0 && (j = !0), a.identifierPrefix !== void 0 && (_e = a.identifierPrefix), a.onRecoverableError !== void 0 && (et = a.onRecoverableError)), o = el(o, null, s, 1, a ? ? null, j, !1, _e, et), s[uf] = o.current, sf(s), $)
        for (s = 0; s < $.length; s++) a = $[s], j = a._getVersion, j = j(a._source), o.mutableSourceEagerHydrationData == null ? o.mutableSourceEagerHydrationData = [a, j] : o.mutableSourceEagerHydrationData.push(a, j);
    return new ml(o)
};
reactDom_production_min.render = function(s, o, a) {
    if (!ol(o)) throw Error(p$2(200));
    return rl(null, s, o, !1, a)
};
reactDom_production_min.unmountComponentAtNode = function(s) {
    if (!ol(s)) throw Error(p$2(40));
    return s._reactRootContainer ? (Rk(function() {
        rl(null, null, s, !1, function() {
            s._reactRootContainer = null, s[uf] = null
        })
    }), !0) : !1
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(s, o, a, $) {
    if (!ol(a)) throw Error(p$2(200));
    if (s == null || s._reactInternals === void 0) throw Error(p$2(38));
    return rl(s, o, a, !1, $)
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";

function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
    } catch (s) {
        console.error(s)
    }
}
checkDCE(), reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports;
const ReactDOM = getDefaultExportFromCjs$3(reactDomExports);
var m$2 = reactDomExports;
client.createRoot = m$2.createRoot, client.hydrateRoot = m$2.hydrateRoot;

function formatMuiErrorMessage$1(s) {
    let o = "https://mui.com/production-error/?code=" + s;
    for (let a = 1; a < arguments.length; a += 1) o += "&args[]=" + encodeURIComponent(arguments[a]);
    return "Minified MUI error #" + s + "; visit " + o + " for the full message."
}
const formatMuiErrorMessage = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: formatMuiErrorMessage$1
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    THEME_ID = "$$material";

function _extends$4() {
    return _extends$4 = Object.assign ? Object.assign.bind() : function(s) {
        for (var o = 1; o < arguments.length; o++) {
            var a = arguments[o];
            for (var $ in a)({}).hasOwnProperty.call(a, $) && (s[$] = a[$])
        }
        return s
    }, _extends$4.apply(null, arguments)
}

function _objectWithoutPropertiesLoose$1(s, o) {
    if (s == null) return {};
    var a = {};
    for (var $ in s)
        if ({}.hasOwnProperty.call(s, $)) {
            if (o.includes($)) continue;
            a[$] = s[$]
        }
    return a
}

function memoize$1(s) {
    var o = Object.create(null);
    return function(a) {
        return o[a] === void 0 && (o[a] = s(a)), o[a]
    }
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
    isPropValid = memoize$1(function(s) {
        return reactPropsRegex.test(s) || s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && s.charCodeAt(2) < 91
    }),
    isDevelopment$2 = !1;

function sheetForTag(s) {
    if (s.sheet) return s.sheet;
    for (var o = 0; o < document.styleSheets.length; o++)
        if (document.styleSheets[o].ownerNode === s) return document.styleSheets[o]
}

function createStyleElement(s) {
    var o = document.createElement("style");
    return o.setAttribute("data-emotion", s.key), s.nonce !== void 0 && o.setAttribute("nonce", s.nonce), o.appendChild(document.createTextNode("")), o.setAttribute("data-s", ""), o
}
var StyleSheet = function() {
        function s(a) {
            var $ = this;
            this._insertTag = function(j) {
                var _e;
                $.tags.length === 0 ? $.insertionPoint ? _e = $.insertionPoint.nextSibling : $.prepend ? _e = $.container.firstChild : _e = $.before : _e = $.tags[$.tags.length - 1].nextSibling, $.container.insertBefore(j, _e), $.tags.push(j)
            }, this.isSpeedy = a.speedy === void 0 ? !isDevelopment$2 : a.speedy, this.tags = [], this.ctr = 0, this.nonce = a.nonce, this.key = a.key, this.container = a.container, this.prepend = a.prepend, this.insertionPoint = a.insertionPoint, this.before = null
        }
        var o = s.prototype;
        return o.hydrate = function($) {
            $.forEach(this._insertTag)
        }, o.insert = function($) {
            this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
            var j = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
                var _e = sheetForTag(j);
                try {
                    _e.insertRule($, _e.cssRules.length)
                } catch {}
            } else j.appendChild(document.createTextNode($));
            this.ctr++
        }, o.flush = function() {
            this.tags.forEach(function($) {
                var j;
                return (j = $.parentNode) == null ? void 0 : j.removeChild($)
            }), this.tags = [], this.ctr = 0
        }, s
    }(),
    MS = "-ms-",
    MOZ = "-moz-",
    WEBKIT = "-webkit-",
    COMMENT$1 = "comm",
    RULESET = "rule",
    DECLARATION = "decl",
    IMPORT = "@import",
    KEYFRAMES = "@keyframes",
    LAYER = "@layer",
    abs = Math.abs,
    from = String.fromCharCode,
    assign$1 = Object.assign;

function hash$5(s, o) {
    return charat(s, 0) ^ 45 ? (((o << 2 ^ charat(s, 0)) << 2 ^ charat(s, 1)) << 2 ^ charat(s, 2)) << 2 ^ charat(s, 3) : 0
}

function trim(s) {
    return s.trim()
}

function match(s, o) {
    return (s = o.exec(s)) ? s[0] : s
}

function replace$1(s, o, a) {
    return s.replace(o, a)
}

function indexof(s, o) {
    return s.indexOf(o)
}

function charat(s, o) {
    return s.charCodeAt(o) | 0
}

function substr(s, o, a) {
    return s.slice(o, a)
}

function strlen(s) {
    return s.length
}

function sizeof(s) {
    return s.length
}

function append(s, o) {
    return o.push(s), s
}

function combine(s, o) {
    return s.map(o).join("")
}
var line = 1,
    column = 1,
    length = 0,
    position = 0,
    character = 0,
    characters = "";

function node(s, o, a, $, j, _e, et) {
    return {
        value: s,
        root: o,
        parent: a,
        type: $,
        props: j,
        children: _e,
        line,
        column,
        length: et,
        return: ""
    }
}

function copy(s, o) {
    return assign$1(node("", null, null, "", null, null, 0), s, {
        length: -s.length
    }, o)
}

function char() {
    return character
}

function prev() {
    return character = position > 0 ? charat(characters, --position) : 0, column--, character === 10 && (column = 1, line--), character
}

function next() {
    return character = position < length ? charat(characters, position++) : 0, column++, character === 10 && (column = 1, line++), character
}

function peek() {
    return charat(characters, position)
}

function caret() {
    return position
}

function slice$1(s, o) {
    return substr(characters, s, o)
}

function token$1(s) {
    switch (s) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1
    }
    return 0
}

function alloc(s) {
    return line = column = 1, length = strlen(characters = s), position = 0, []
}

function dealloc(s) {
    return characters = "", s
}

function delimit(s) {
    return trim(slice$1(position - 1, delimiter(s === 91 ? s + 2 : s === 40 ? s + 1 : s)))
}

function whitespace(s) {
    for (;
        (character = peek()) && character < 33;) next();
    return token$1(s) > 2 || token$1(character) > 3 ? "" : " "
}

function escaping(s, o) {
    for (; --o && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97););
    return slice$1(s, caret() + (o < 6 && peek() == 32 && next() == 32))
}

function delimiter(s) {
    for (; next();) switch (character) {
        case s:
            return position;
        case 34:
        case 39:
            s !== 34 && s !== 39 && delimiter(character);
            break;
        case 40:
            s === 41 && delimiter(s);
            break;
        case 92:
            next();
            break
    }
    return position
}

function commenter(s, o) {
    for (; next() && s + character !== 57;)
        if (s + character === 84 && peek() === 47) break;
    return "/*" + slice$1(o, position - 1) + "*" + from(s === 47 ? s : next())
}

function identifier(s) {
    for (; !token$1(peek());) next();
    return slice$1(s, position)
}

function compile(s) {
    return dealloc(parse$2("", null, null, null, [""], s = alloc(s), 0, [0], s))
}

function parse$2(s, o, a, $, j, _e, et, tt, nt) {
    for (var rt = 0, ot = 0, st = et, lt = 0, ft = 0, yt = 0, bt = 1, ht = 1, vt = 1, wt = 0, gt = "", At = j, Pt = _e, Bt = $, Lt = gt; ht;) switch (yt = wt, wt = next()) {
        case 40:
            if (yt != 108 && charat(Lt, st - 1) == 58) {
                indexof(Lt += replace$1(delimit(wt), "&", "&\f"), "&\f") != -1 && (vt = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            Lt += delimit(wt);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            Lt += whitespace(yt);
            break;
        case 92:
            Lt += escaping(caret() - 1, 7);
            continue;
        case 47:
            switch (peek()) {
                case 42:
                case 47:
                    append(comment(commenter(next(), caret()), o, a), nt);
                    break;
                default:
                    Lt += "/"
            }
            break;
        case 123 * bt:
            tt[rt++] = strlen(Lt) * vt;
        case 125 * bt:
        case 59:
        case 0:
            switch (wt) {
                case 0:
                case 125:
                    ht = 0;
                case 59 + ot:
                    vt == -1 && (Lt = replace$1(Lt, /\f/g, "")), ft > 0 && strlen(Lt) - st && append(ft > 32 ? declaration(Lt + ";", $, a, st - 1) : declaration(replace$1(Lt, " ", "") + ";", $, a, st - 2), nt);
                    break;
                case 59:
                    Lt += ";";
                default:
                    if (append(Bt = ruleset(Lt, o, a, rt, ot, j, tt, gt, At = [], Pt = [], st), _e), wt === 123)
                        if (ot === 0) parse$2(Lt, o, Bt, Bt, At, _e, st, tt, Pt);
                        else switch (lt === 99 && charat(Lt, 3) === 110 ? 100 : lt) {
                            case 100:
                            case 108:
                            case 109:
                            case 115:
                                parse$2(s, Bt, Bt, $ && append(ruleset(s, Bt, Bt, 0, 0, j, tt, gt, j, At = [], st), Pt), j, Pt, st, tt, $ ? At : Pt);
                                break;
                            default:
                                parse$2(Lt, Bt, Bt, Bt, [""], Pt, 0, tt, Pt)
                        }
            }
            rt = ot = ft = 0, bt = vt = 1, gt = Lt = "", st = et;
            break;
        case 58:
            st = 1 + strlen(Lt), ft = yt;
        default:
            if (bt < 1) {
                if (wt == 123) --bt;
                else if (wt == 125 && bt++ == 0 && prev() == 125) continue
            }
            switch (Lt += from(wt), wt * bt) {
                case 38:
                    vt = ot > 0 ? 1 : (Lt += "\f", -1);
                    break;
                case 44:
                    tt[rt++] = (strlen(Lt) - 1) * vt, vt = 1;
                    break;
                case 64:
                    peek() === 45 && (Lt += delimit(next())), lt = peek(), ot = st = strlen(gt = Lt += identifier(caret())), wt++;
                    break;
                case 45:
                    yt === 45 && strlen(Lt) == 2 && (bt = 0)
            }
    }
    return _e
}

function ruleset(s, o, a, $, j, _e, et, tt, nt, rt, ot) {
    for (var st = j - 1, lt = j === 0 ? _e : [""], ft = sizeof(lt), yt = 0, bt = 0, ht = 0; yt < $; ++yt)
        for (var vt = 0, wt = substr(s, st + 1, st = abs(bt = et[yt])), gt = s; vt < ft; ++vt)(gt = trim(bt > 0 ? lt[vt] + " " + wt : replace$1(wt, /&\f/g, lt[vt]))) && (nt[ht++] = gt);
    return node(s, o, a, j === 0 ? RULESET : tt, nt, rt, ot)
}

function comment(s, o, a) {
    return node(s, o, a, COMMENT$1, from(char()), substr(s, 2, -2), 0)
}

function declaration(s, o, a, $) {
    return node(s, o, a, DECLARATION, substr(s, 0, $), substr(s, $ + 1, -1), $)
}

function serialize$2(s, o) {
    for (var a = "", $ = sizeof(s), j = 0; j < $; j++) a += o(s[j], j, s, o) || "";
    return a
}

function stringify$4(s, o, a, $) {
    switch (s.type) {
        case LAYER:
            if (s.children.length) break;
        case IMPORT:
        case DECLARATION:
            return s.return = s.return || s.value;
        case COMMENT$1:
            return "";
        case KEYFRAMES:
            return s.return = s.value + "{" + serialize$2(s.children, $) + "}";
        case RULESET:
            s.value = s.props.join(",")
    }
    return strlen(a = serialize$2(s.children, $)) ? s.return = s.value + "{" + a + "}" : ""
}

function middleware(s) {
    var o = sizeof(s);
    return function(a, $, j, _e) {
        for (var et = "", tt = 0; tt < o; tt++) et += s[tt](a, $, j, _e) || "";
        return et
    }
}

function rulesheet(s) {
    return function(o) {
        o.root || (o = o.return) && s(o)
    }
}
var identifierWithPointTracking = function(o, a, $) {
        for (var j = 0, _e = 0; j = _e, _e = peek(), j === 38 && _e === 12 && (a[$] = 1), !token$1(_e);) next();
        return slice$1(o, position)
    },
    toRules = function(o, a) {
        var $ = -1,
            j = 44;
        do switch (token$1(j)) {
            case 0:
                j === 38 && peek() === 12 && (a[$] = 1), o[$] += identifierWithPointTracking(position - 1, a, $);
                break;
            case 2:
                o[$] += delimit(j);
                break;
            case 4:
                if (j === 44) {
                    o[++$] = peek() === 58 ? "&\f" : "", a[$] = o[$].length;
                    break
                }
            default:
                o[$] += from(j)
        }
        while (j = next());
        return o
    },
    getRules = function(o, a) {
        return dealloc(toRules(alloc(o), a))
    },
    fixedElements = new WeakMap,
    compat = function(o) {
        if (!(o.type !== "rule" || !o.parent || o.length < 1)) {
            for (var a = o.value, $ = o.parent, j = o.column === $.column && o.line === $.line; $.type !== "rule";)
                if ($ = $.parent, !$) return;
            if (!(o.props.length === 1 && a.charCodeAt(0) !== 58 && !fixedElements.get($)) && !j) {
                fixedElements.set(o, !0);
                for (var _e = [], et = getRules(a, _e), tt = $.props, nt = 0, rt = 0; nt < et.length; nt++)
                    for (var ot = 0; ot < tt.length; ot++, rt++) o.props[rt] = _e[nt] ? et[nt].replace(/&\f/g, tt[ot]) : tt[ot] + " " + et[nt]
            }
        }
    },
    removeLabel = function(o) {
        if (o.type === "decl") {
            var a = o.value;
            a.charCodeAt(0) === 108 && a.charCodeAt(2) === 98 && (o.return = "", o.value = "")
        }
    };

function prefix(s, o) {
    switch (hash$5(s, o)) {
        case 5103:
            return WEBKIT + "print-" + s + s;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return WEBKIT + s + s;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return WEBKIT + s + MOZ + s + MS + s + s;
        case 6828:
        case 4268:
            return WEBKIT + s + MS + s + s;
        case 6165:
            return WEBKIT + s + MS + "flex-" + s + s;
        case 5187:
            return WEBKIT + s + replace$1(s, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + s;
        case 5443:
            return WEBKIT + s + MS + "flex-item-" + replace$1(s, /flex-|-self/, "") + s;
        case 4675:
            return WEBKIT + s + MS + "flex-line-pack" + replace$1(s, /align-content|flex-|-self/, "") + s;
        case 5548:
            return WEBKIT + s + MS + replace$1(s, "shrink", "negative") + s;
        case 5292:
            return WEBKIT + s + MS + replace$1(s, "basis", "preferred-size") + s;
        case 6060:
            return WEBKIT + "box-" + replace$1(s, "-grow", "") + WEBKIT + s + MS + replace$1(s, "grow", "positive") + s;
        case 4554:
            return WEBKIT + replace$1(s, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + s;
        case 6187:
            return replace$1(replace$1(replace$1(s, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), s, "") + s;
        case 5495:
        case 3959:
            return replace$1(s, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4968:
            return replace$1(replace$1(s, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + s + s;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return replace$1(s, /(.+)-inline(.+)/, WEBKIT + "$1$2") + s;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (strlen(s) - 1 - o > 6) switch (charat(s, o + 1)) {
                case 109:
                    if (charat(s, o + 4) !== 45) break;
                case 102:
                    return replace$1(s, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(s, o + 3) == 108 ? "$3" : "$2-$3")) + s;
                case 115:
                    return ~indexof(s, "stretch") ? prefix(replace$1(s, "stretch", "fill-available"), o) + s : s
            }
            break;
        case 4949:
            if (charat(s, o + 1) !== 115) break;
        case 6444:
            switch (charat(s, strlen(s) - 3 - (~indexof(s, "!important") && 10))) {
                case 107:
                    return replace$1(s, ":", ":" + WEBKIT) + s;
                case 101:
                    return replace$1(s, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(s, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + s
            }
            break;
        case 5936:
            switch (charat(s, o + 11)) {
                case 114:
                    return WEBKIT + s + MS + replace$1(s, /[svh]\w+-[tblr]{2}/, "tb") + s;
                case 108:
                    return WEBKIT + s + MS + replace$1(s, /[svh]\w+-[tblr]{2}/, "tb-rl") + s;
                case 45:
                    return WEBKIT + s + MS + replace$1(s, /[svh]\w+-[tblr]{2}/, "lr") + s
            }
            return WEBKIT + s + MS + s + s
    }
    return s
}
var prefixer = function(o, a, $, j) {
        if (o.length > -1 && !o.return) switch (o.type) {
            case DECLARATION:
                o.return = prefix(o.value, o.length);
                break;
            case KEYFRAMES:
                return serialize$2([copy(o, {
                    value: replace$1(o.value, "@", "@" + WEBKIT)
                })], j);
            case RULESET:
                if (o.length) return combine(o.props, function(_e) {
                    switch (match(_e, /(::plac\w+|:read-\w+)/)) {
                        case ":read-only":
                        case ":read-write":
                            return serialize$2([copy(o, {
                                props: [replace$1(_e, /:(read-\w+)/, ":" + MOZ + "$1")]
                            })], j);
                        case "::placeholder":
                            return serialize$2([copy(o, {
                                props: [replace$1(_e, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                            }), copy(o, {
                                props: [replace$1(_e, /:(plac\w+)/, ":" + MOZ + "$1")]
                            }), copy(o, {
                                props: [replace$1(_e, /:(plac\w+)/, MS + "input-$1")]
                            })], j)
                    }
                    return ""
                })
        }
    },
    defaultStylisPlugins = [prefixer],
    createCache = function(o) {
        var a = o.key;
        if (a === "css") {
            var $ = document.querySelectorAll("style[data-emotion]:not([data-s])");
            Array.prototype.forEach.call($, function(bt) {
                var ht = bt.getAttribute("data-emotion");
                ht.indexOf(" ") !== -1 && (document.head.appendChild(bt), bt.setAttribute("data-s", ""))
            })
        }
        var j = o.stylisPlugins || defaultStylisPlugins,
            _e = {},
            et, tt = [];
        et = o.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + a + ' "]'), function(bt) {
            for (var ht = bt.getAttribute("data-emotion").split(" "), vt = 1; vt < ht.length; vt++) _e[ht[vt]] = !0;
            tt.push(bt)
        });
        var nt, rt = [compat, removeLabel]; {
            var ot, st = [stringify$4, rulesheet(function(bt) {
                    ot.insert(bt)
                })],
                lt = middleware(rt.concat(j, st)),
                ft = function(ht) {
                    return serialize$2(compile(ht), lt)
                };
            nt = function(ht, vt, wt, gt) {
                ot = wt, ft(ht ? ht + "{" + vt.styles + "}" : vt.styles), gt && (yt.inserted[vt.name] = !0)
            }
        }
        var yt = {
            key: a,
            sheet: new StyleSheet({
                key: a,
                container: et,
                nonce: o.nonce,
                speedy: o.speedy,
                prepend: o.prepend,
                insertionPoint: o.insertionPoint
            }),
            nonce: o.nonce,
            inserted: _e,
            registered: {},
            insert: nt
        };
        return yt.sheet.hydrate(tt), yt
    },
    reactIs$2 = {
        exports: {}
    },
    reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = typeof Symbol == "function" && Symbol.for,
    c$1 = b$1 ? Symbol.for("react.element") : 60103,
    d$1 = b$1 ? Symbol.for("react.portal") : 60106,
    e$1 = b$1 ? Symbol.for("react.fragment") : 60107,
    f$3 = b$1 ? Symbol.for("react.strict_mode") : 60108,
    g$3 = b$1 ? Symbol.for("react.profiler") : 60114,
    h$1 = b$1 ? Symbol.for("react.provider") : 60109,
    k$1 = b$1 ? Symbol.for("react.context") : 60110,
    l$1 = b$1 ? Symbol.for("react.async_mode") : 60111,
    m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111,
    n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112,
    p$1 = b$1 ? Symbol.for("react.suspense") : 60113,
    q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120,
    r$1 = b$1 ? Symbol.for("react.memo") : 60115,
    t$1 = b$1 ? Symbol.for("react.lazy") : 60116,
    v$1 = b$1 ? Symbol.for("react.block") : 60121,
    w = b$1 ? Symbol.for("react.fundamental") : 60117,
    x = b$1 ? Symbol.for("react.responder") : 60118,
    y = b$1 ? Symbol.for("react.scope") : 60119;

function z(s) {
    if (typeof s == "object" && s !== null) {
        var o = s.$$typeof;
        switch (o) {
            case c$1:
                switch (s = s.type, s) {
                    case l$1:
                    case m$1:
                    case e$1:
                    case g$3:
                    case f$3:
                    case p$1:
                        return s;
                    default:
                        switch (s = s && s.$$typeof, s) {
                            case k$1:
                            case n$1:
                            case t$1:
                            case r$1:
                            case h$1:
                                return s;
                            default:
                                return o
                        }
                }
            case d$1:
                return o
        }
    }
}

function A(s) {
    return z(s) === m$1
}
reactIs_production_min$1.AsyncMode = l$1;
reactIs_production_min$1.ConcurrentMode = m$1;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$1;
reactIs_production_min$1.ForwardRef = n$1;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t$1;
reactIs_production_min$1.Memo = r$1;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$3;
reactIs_production_min$1.StrictMode = f$3;
reactIs_production_min$1.Suspense = p$1;
reactIs_production_min$1.isAsyncMode = function(s) {
    return A(s) || z(s) === l$1
};
reactIs_production_min$1.isConcurrentMode = A;
reactIs_production_min$1.isContextConsumer = function(s) {
    return z(s) === k$1
};
reactIs_production_min$1.isContextProvider = function(s) {
    return z(s) === h$1
};
reactIs_production_min$1.isElement = function(s) {
    return typeof s == "object" && s !== null && s.$$typeof === c$1
};
reactIs_production_min$1.isForwardRef = function(s) {
    return z(s) === n$1
};
reactIs_production_min$1.isFragment = function(s) {
    return z(s) === e$1
};
reactIs_production_min$1.isLazy = function(s) {
    return z(s) === t$1
};
reactIs_production_min$1.isMemo = function(s) {
    return z(s) === r$1
};
reactIs_production_min$1.isPortal = function(s) {
    return z(s) === d$1
};
reactIs_production_min$1.isProfiler = function(s) {
    return z(s) === g$3
};
reactIs_production_min$1.isStrictMode = function(s) {
    return z(s) === f$3
};
reactIs_production_min$1.isSuspense = function(s) {
    return z(s) === p$1
};
reactIs_production_min$1.isValidElementType = function(s) {
    return typeof s == "string" || typeof s == "function" || s === e$1 || s === m$1 || s === g$3 || s === f$3 || s === p$1 || s === q$1 || typeof s == "object" && s !== null && (s.$$typeof === t$1 || s.$$typeof === r$1 || s.$$typeof === h$1 || s.$$typeof === k$1 || s.$$typeof === n$1 || s.$$typeof === w || s.$$typeof === x || s.$$typeof === y || s.$$typeof === v$1)
};
reactIs_production_min$1.typeOf = z;
reactIs$2.exports = reactIs_production_min$1;
var reactIsExports$1 = reactIs$2.exports,
    reactIs$1 = reactIsExports$1,
    FORWARD_REF_STATICS = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    },
    MEMO_STATICS = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    },
    TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser$2 = !0;

function getRegisteredStyles(s, o, a) {
    var $ = "";
    return a.split(" ").forEach(function(j) {
        s[j] !== void 0 ? o.push(s[j] + ";") : $ += j + " "
    }), $
}
var registerStyles = function(o, a, $) {
        var j = o.key + "-" + a.name;
        ($ === !1 || isBrowser$2 === !1) && o.registered[j] === void 0 && (o.registered[j] = a.styles)
    },
    insertStyles = function(o, a, $) {
        registerStyles(o, a, $);
        var j = o.key + "-" + a.name;
        if (o.inserted[a.name] === void 0) {
            var _e = a;
            do o.insert(a === _e ? "." + j : "", _e, o.sheet, !0), _e = _e.next; while (_e !== void 0)
        }
    };

function murmur2(s) {
    for (var o = 0, a, $ = 0, j = s.length; j >= 4; ++$, j -= 4) a = s.charCodeAt($) & 255 | (s.charCodeAt(++$) & 255) << 8 | (s.charCodeAt(++$) & 255) << 16 | (s.charCodeAt(++$) & 255) << 24, a = (a & 65535) * 1540483477 + ((a >>> 16) * 59797 << 16), a ^= a >>> 24, o = (a & 65535) * 1540483477 + ((a >>> 16) * 59797 << 16) ^ (o & 65535) * 1540483477 + ((o >>> 16) * 59797 << 16);
    switch (j) {
        case 3:
            o ^= (s.charCodeAt($ + 2) & 255) << 16;
        case 2:
            o ^= (s.charCodeAt($ + 1) & 255) << 8;
        case 1:
            o ^= s.charCodeAt($) & 255, o = (o & 65535) * 1540483477 + ((o >>> 16) * 59797 << 16)
    }
    return o ^= o >>> 13, o = (o & 65535) * 1540483477 + ((o >>> 16) * 59797 << 16), ((o ^ o >>> 15) >>> 0).toString(36)
}
var unitlessKeys = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    },
    isDevelopment$1 = !1,
    hyphenateRegex = /[A-Z]|^ms/g,
    animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
    isCustomProperty = function(o) {
        return o.charCodeAt(1) === 45
    },
    isProcessableValue = function(o) {
        return o != null && typeof o != "boolean"
    },
    processStyleName = memoize$1(function(s) {
        return isCustomProperty(s) ? s : s.replace(hyphenateRegex, "-$&").toLowerCase()
    }),
    processStyleValue = function(o, a) {
        switch (o) {
            case "animation":
            case "animationName":
                if (typeof a == "string") return a.replace(animationRegex, function($, j, _e) {
                    return cursor = {
                        name: j,
                        styles: _e,
                        next: cursor
                    }, j
                })
        }
        return unitlessKeys[o] !== 1 && !isCustomProperty(o) && typeof a == "number" && a !== 0 ? a + "px" : a
    },
    noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";

function handleInterpolation(s, o, a) {
    if (a == null) return "";
    var $ = a;
    if ($.__emotion_styles !== void 0) return $;
    switch (typeof a) {
        case "boolean":
            return "";
        case "object":
            {
                var j = a;
                if (j.anim === 1) return cursor = {
                    name: j.name,
                    styles: j.styles,
                    next: cursor
                }, j.name;
                var _e = a;
                if (_e.styles !== void 0) {
                    var et = _e.next;
                    if (et !== void 0)
                        for (; et !== void 0;) cursor = {
                            name: et.name,
                            styles: et.styles,
                            next: cursor
                        }, et = et.next;
                    var tt = _e.styles + ";";
                    return tt
                }
                return createStringFromObject(s, o, a)
            }
        case "function":
            {
                if (s !== void 0) {
                    var nt = cursor,
                        rt = a(s);
                    return cursor = nt, handleInterpolation(s, o, rt)
                }
                break
            }
    }
    var ot = a;
    if (o == null) return ot;
    var st = o[ot];
    return st !== void 0 ? st : ot
}

function createStringFromObject(s, o, a) {
    var $ = "";
    if (Array.isArray(a))
        for (var j = 0; j < a.length; j++) $ += handleInterpolation(s, o, a[j]) + ";";
    else
        for (var _e in a) {
            var et = a[_e];
            if (typeof et != "object") {
                var tt = et;
                o != null && o[tt] !== void 0 ? $ += _e + "{" + o[tt] + "}" : isProcessableValue(tt) && ($ += processStyleName(_e) + ":" + processStyleValue(_e, tt) + ";")
            } else {
                if (_e === "NO_COMPONENT_SELECTOR" && isDevelopment$1) throw new Error(noComponentSelectorMessage);
                if (Array.isArray(et) && typeof et[0] == "string" && (o == null || o[et[0]] === void 0))
                    for (var nt = 0; nt < et.length; nt++) isProcessableValue(et[nt]) && ($ += processStyleName(_e) + ":" + processStyleValue(_e, et[nt]) + ";");
                else {
                    var rt = handleInterpolation(s, o, et);
                    switch (_e) {
                        case "animation":
                        case "animationName":
                            {
                                $ += processStyleName(_e) + ":" + rt + ";";
                                break
                            }
                        default:
                            $ += _e + "{" + rt + "}"
                    }
                }
            }
        }
    return $
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
    cursor;

function serializeStyles(s, o, a) {
    if (s.length === 1 && typeof s[0] == "object" && s[0] !== null && s[0].styles !== void 0) return s[0];
    var $ = !0,
        j = "";
    cursor = void 0;
    var _e = s[0];
    if (_e == null || _e.raw === void 0) $ = !1, j += handleInterpolation(a, o, _e);
    else {
        var et = _e;
        j += et[0]
    }
    for (var tt = 1; tt < s.length; tt++)
        if (j += handleInterpolation(a, o, s[tt]), $) {
            var nt = _e;
            j += nt[tt]
        }
    labelPattern.lastIndex = 0;
    for (var rt = "", ot;
        (ot = labelPattern.exec(j)) !== null;) rt += "-" + ot[1];
    var st = murmur2(j) + rt;
    return {
        name: st,
        styles: j,
        next: cursor
    }
}
var syncFallback = function(o) {
        return o()
    },
    useInsertionEffect = React$2.useInsertionEffect ? React$2.useInsertionEffect : !1,
    useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback,
    useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect,
    EmotionCacheContext = reactExports.createContext(typeof HTMLElement < "u" ? createCache({
        key: "css"
    }) : null),
    CacheProvider = EmotionCacheContext.Provider,
    withEmotionCache = function(o) {
        return reactExports.forwardRef(function(a, $) {
            var j = reactExports.useContext(EmotionCacheContext);
            return o(a, j, $)
        })
    },
    ThemeContext$1 = reactExports.createContext({}),
    _extends$3 = {
        exports: {}
    },
    hasRequired_extends;

function require_extends() {
    return hasRequired_extends || (hasRequired_extends = 1, function(s) {
        function o() {
            return s.exports = o = Object.assign ? Object.assign.bind() : function(a) {
                for (var $ = 1; $ < arguments.length; $++) {
                    var j = arguments[$];
                    for (var _e in j)({}).hasOwnProperty.call(j, _e) && (a[_e] = j[_e])
                }
                return a
            }, s.exports.__esModule = !0, s.exports.default = s.exports, o.apply(null, arguments)
        }
        s.exports = o, s.exports.__esModule = !0, s.exports.default = s.exports
    }(_extends$3)), _extends$3.exports
}
require_extends();
var Global = withEmotionCache(function(s, o) {
    var a = s.styles,
        $ = serializeStyles([a], void 0, reactExports.useContext(ThemeContext$1)),
        j = reactExports.useRef();
    return useInsertionEffectWithLayoutFallback(function() {
        var _e = o.key + "-global",
            et = new o.sheet.constructor({
                key: _e,
                nonce: o.sheet.nonce,
                container: o.sheet.container,
                speedy: o.sheet.isSpeedy
            }),
            tt = !1,
            nt = document.querySelector('style[data-emotion="' + _e + " " + $.name + '"]');
        return o.sheet.tags.length && (et.before = o.sheet.tags[0]), nt !== null && (tt = !0, nt.setAttribute("data-emotion", _e), et.hydrate([nt])), j.current = [et, tt],
            function() {
                et.flush()
            }
    }, [o]), useInsertionEffectWithLayoutFallback(function() {
        var _e = j.current,
            et = _e[0],
            tt = _e[1];
        if (tt) {
            _e[1] = !1;
            return
        }
        if ($.next !== void 0 && insertStyles(o, $.next, !0), et.tags.length) {
            var nt = et.tags[et.tags.length - 1].nextElementSibling;
            et.before = nt, et.flush()
        }
        o.insert("", $, et, !1)
    }, [o, $.name]), null
});

function css() {
    for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++) o[a] = arguments[a];
    return serializeStyles(o)
}
var keyframes$1 = function() {
        var o = css.apply(void 0, arguments),
            a = "animation-" + o.name;
        return {
            name: a,
            styles: "@keyframes " + a + "{" + o.styles + "}",
            anim: 1,
            toString: function() {
                return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
            }
        }
    },
    testOmitPropsOnStringTag = isPropValid,
    testOmitPropsOnComponent = function(o) {
        return o !== "theme"
    },
    getDefaultShouldForwardProp = function(o) {
        return typeof o == "string" && o.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent
    },
    composeShouldForwardProps = function(o, a, $) {
        var j;
        if (a) {
            var _e = a.shouldForwardProp;
            j = o.__emotion_forwardProp && _e ? function(et) {
                return o.__emotion_forwardProp(et) && _e(et)
            } : _e
        }
        return typeof j != "function" && $ && (j = o.__emotion_forwardProp), j
    },
    isDevelopment = !1,
    Insertion = function(o) {
        var a = o.cache,
            $ = o.serialized,
            j = o.isStringTag;
        return registerStyles(a, $, j), useInsertionEffectAlwaysWithSyncFallback(function() {
            return insertStyles(a, $, j)
        }), null
    },
    createStyled$3 = function s(o, a) {
        var $ = o.__emotion_real === o,
            j = $ && o.__emotion_base || o,
            _e, et;
        a !== void 0 && (_e = a.label, et = a.target);
        var tt = composeShouldForwardProps(o, a, $),
            nt = tt || getDefaultShouldForwardProp(j),
            rt = !nt("as");
        return function() {
            var ot = arguments,
                st = $ && o.__emotion_styles !== void 0 ? o.__emotion_styles.slice(0) : [];
            if (_e !== void 0 && st.push("label:" + _e + ";"), ot[0] == null || ot[0].raw === void 0) st.push.apply(st, ot);
            else {
                st.push(ot[0][0]);
                for (var lt = ot.length, ft = 1; ft < lt; ft++) st.push(ot[ft], ot[0][ft])
            }
            var yt = withEmotionCache(function(bt, ht, vt) {
                var wt = rt && bt.as || j,
                    gt = "",
                    At = [],
                    Pt = bt;
                if (bt.theme == null) {
                    Pt = {};
                    for (var Bt in bt) Pt[Bt] = bt[Bt];
                    Pt.theme = reactExports.useContext(ThemeContext$1)
                }
                typeof bt.className == "string" ? gt = getRegisteredStyles(ht.registered, At, bt.className) : bt.className != null && (gt = bt.className + " ");
                var Lt = serializeStyles(st.concat(At), ht.registered, Pt);
                gt += ht.key + "-" + Lt.name, et !== void 0 && (gt += " " + et);
                var Nt = rt && tt === void 0 ? getDefaultShouldForwardProp(wt) : nt,
                    Ut = {};
                for (var Vt in bt) rt && Vt === "as" || Nt(Vt) && (Ut[Vt] = bt[Vt]);
                return Ut.className = gt, vt && (Ut.ref = vt), reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion, {
                    cache: ht,
                    serialized: Lt,
                    isStringTag: typeof wt == "string"
                }), reactExports.createElement(wt, Ut))
            });
            return yt.displayName = _e !== void 0 ? _e : "Styled(" + (typeof j == "string" ? j : j.displayName || j.name || "Component") + ")", yt.defaultProps = o.defaultProps, yt.__emotion_real = yt, yt.__emotion_base = j, yt.__emotion_styles = st, yt.__emotion_forwardProp = tt, Object.defineProperty(yt, "toString", {
                value: function() {
                    return et === void 0 && isDevelopment ? "NO_COMPONENT_SELECTOR" : "." + et
                }
            }), yt.withComponent = function(bt, ht) {
                return s(bt, _extends$4({}, a, ht, {
                    shouldForwardProp: composeShouldForwardProps(yt, ht, !0)
                })).apply(void 0, st)
            }, yt
        }
    },
    tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"],
    newStyled = createStyled$3.bind();
tags.forEach(function(s) {
    newStyled[s] = newStyled(s)
});
let cache$1;
typeof document == "object" && (cache$1 = createCache({
    key: "css",
    prepend: !0
}));

function StyledEngineProvider(s) {
    const {
        injectFirst: o,
        children: a
    } = s;
    return o && cache$1 ? jsxRuntimeExports.jsx(CacheProvider, {
        value: cache$1,
        children: a
    }) : a
}

function isEmpty$4(s) {
    return s == null || Object.keys(s).length === 0
}

function GlobalStyles$2(s) {
    const {
        styles: o,
        defaultTheme: a = {}
    } = s, $ = typeof o == "function" ? j => o(isEmpty$4(j) ? a : j) : o;
    return jsxRuntimeExports.jsx(Global, {
        styles: $
    })
}

function styled$2(s, o) {
    return newStyled(s, o)
}
const internal_processStyles = (s, o) => {
        Array.isArray(s.__emotion_styles) && (s.__emotion_styles = o(s.__emotion_styles))
    },
    styledEngine = Object.freeze(Object.defineProperty({
        __proto__: null,
        GlobalStyles: GlobalStyles$2,
        StyledEngineProvider,
        ThemeContext: ThemeContext$1,
        css,
        default: styled$2,
        internal_processStyles,
        keyframes: keyframes$1
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function isPlainObject(s) {
    if (typeof s != "object" || s === null) return !1;
    const o = Object.getPrototypeOf(s);
    return (o === null || o === Object.prototype || Object.getPrototypeOf(o) === null) && !(Symbol.toStringTag in s) && !(Symbol.iterator in s)
}

function deepClone(s) {
    if (!isPlainObject(s)) return s;
    const o = {};
    return Object.keys(s).forEach(a => {
        o[a] = deepClone(s[a])
    }), o
}

function deepmerge$1(s, o, a = {
    clone: !0
}) {
    const $ = a.clone ? _extends$4({}, s) : s;
    return isPlainObject(s) && isPlainObject(o) && Object.keys(o).forEach(j => {
        isPlainObject(o[j]) && Object.prototype.hasOwnProperty.call(s, j) && isPlainObject(s[j]) ? $[j] = deepmerge$1(s[j], o[j], a) : a.clone ? $[j] = isPlainObject(o[j]) ? deepClone(o[j]) : o[j] : $[j] = o[j]
    }), $
}
const deepmerge = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: deepmerge$1,
        isPlainObject
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    _excluded$1g = ["values", "unit", "step"],
    sortBreakpointsValues = s => {
        const o = Object.keys(s).map(a => ({
            key: a,
            val: s[a]
        })) || [];
        return o.sort((a, $) => a.val - $.val), o.reduce((a, $) => _extends$4({}, a, {
            [$.key]: $.val
        }), {})
    };

function createBreakpoints(s) {
    const {
        values: o = {
            xs: 0,
            sm: 600,
            md: 900,
            lg: 1200,
            xl: 1536
        },
        unit: a = "px",
        step: $ = 5
    } = s, j = _objectWithoutPropertiesLoose$1(s, _excluded$1g), _e = sortBreakpointsValues(o), et = Object.keys(_e);

    function tt(lt) {
        return `@media (min-width:${typeof o[lt]=="number"?o[lt]:lt}${a})`
    }

    function nt(lt) {
        return `@media (max-width:${(typeof o[lt]=="number"?o[lt]:lt)-$/100}${a})`
    }

    function rt(lt, ft) {
        const yt = et.indexOf(ft);
        return `@media (min-width:${typeof o[lt]=="number"?o[lt]:lt}${a}) and (max-width:${(yt!==-1&&typeof o[et[yt]]=="number"?o[et[yt]]:ft)-$/100}${a})`
    }

    function ot(lt) {
        return et.indexOf(lt) + 1 < et.length ? rt(lt, et[et.indexOf(lt) + 1]) : tt(lt)
    }

    function st(lt) {
        const ft = et.indexOf(lt);
        return ft === 0 ? tt(et[1]) : ft === et.length - 1 ? nt(et[ft]) : rt(lt, et[et.indexOf(lt) + 1]).replace("@media", "@media not all and")
    }
    return _extends$4({
        keys: et,
        values: _e,
        up: tt,
        down: nt,
        between: rt,
        only: ot,
        not: st,
        unit: a
    }, j)
}
const shape = {
    borderRadius: 4
};

function merge(s, o) {
    return o ? deepmerge$1(s, o, {
        clone: !1
    }) : s
}
const values$1 = {
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536
    },
    defaultBreakpoints = {
        keys: ["xs", "sm", "md", "lg", "xl"],
        up: s => `@media (min-width:${values$1[s]}px)`
    };

function handleBreakpoints(s, o, a) {
    const $ = s.theme || {};
    if (Array.isArray(o)) {
        const _e = $.breakpoints || defaultBreakpoints;
        return o.reduce((et, tt, nt) => (et[_e.up(_e.keys[nt])] = a(o[nt]), et), {})
    }
    if (typeof o == "object") {
        const _e = $.breakpoints || defaultBreakpoints;
        return Object.keys(o).reduce((et, tt) => {
            if (Object.keys(_e.values || values$1).indexOf(tt) !== -1) {
                const nt = _e.up(tt);
                et[nt] = a(o[tt], tt)
            } else {
                const nt = tt;
                et[nt] = o[nt]
            }
            return et
        }, {})
    }
    return a(o)
}

function createEmptyBreakpointObject(s = {}) {
    var o;
    return ((o = s.keys) == null ? void 0 : o.reduce(($, j) => {
        const _e = s.up(j);
        return $[_e] = {}, $
    }, {})) || {}
}

function removeUnusedBreakpoints(s, o) {
    return s.reduce((a, $) => {
        const j = a[$];
        return (!j || Object.keys(j).length === 0) && delete a[$], a
    }, o)
}

function mergeBreakpointsInOrder(s, ...o) {
    const a = createEmptyBreakpointObject(s),
        $ = [a, ...o].reduce((j, _e) => deepmerge$1(j, _e), {});
    return removeUnusedBreakpoints(Object.keys(a), $)
}

function computeBreakpointsBase(s, o) {
    if (typeof s != "object") return {};
    const a = {},
        $ = Object.keys(o);
    return Array.isArray(s) ? $.forEach((j, _e) => {
        _e < s.length && (a[j] = !0)
    }) : $.forEach(j => {
        s[j] != null && (a[j] = !0)
    }), a
}

function resolveBreakpointValues({
    values: s,
    breakpoints: o,
    base: a
}) {
    const $ = a || computeBreakpointsBase(s, o),
        j = Object.keys($);
    if (j.length === 0) return s;
    let _e;
    return j.reduce((et, tt, nt) => (Array.isArray(s) ? (et[tt] = s[nt] != null ? s[nt] : s[_e], _e = nt) : typeof s == "object" ? (et[tt] = s[tt] != null ? s[tt] : s[_e], _e = tt) : et[tt] = s, et), {})
}

function capitalize$1(s) {
    if (typeof s != "string") throw new Error(formatMuiErrorMessage$1(7));
    return s.charAt(0).toUpperCase() + s.slice(1)
}
const capitalize = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: capitalize$1
}, Symbol.toStringTag, {
    value: "Module"
}));

function getPath(s, o, a = !0) {
    if (!o || typeof o != "string") return null;
    if (s && s.vars && a) {
        const $ = `vars.${o}`.split(".").reduce((j, _e) => j && j[_e] ? j[_e] : null, s);
        if ($ != null) return $
    }
    return o.split(".").reduce(($, j) => $ && $[j] != null ? $[j] : null, s)
}

function getStyleValue$1(s, o, a, $ = a) {
    let j;
    return typeof s == "function" ? j = s(a) : Array.isArray(s) ? j = s[a] || $ : j = getPath(s, a) || $, o && (j = o(j, $, s)), j
}

function style$3(s) {
    const {
        prop: o,
        cssProperty: a = s.prop,
        themeKey: $,
        transform: j
    } = s, _e = et => {
        if (et[o] == null) return null;
        const tt = et[o],
            nt = et.theme,
            rt = getPath(nt, $) || {};
        return handleBreakpoints(et, tt, st => {
            let lt = getStyleValue$1(rt, j, st);
            return st === lt && typeof st == "string" && (lt = getStyleValue$1(rt, j, `${o}${st==="default"?"":capitalize$1(st)}`, st)), a === !1 ? lt : {
                [a]: lt
            }
        })
    };
    return _e.propTypes = {}, _e.filterProps = [o], _e
}

function memoize(s) {
    const o = {};
    return a => (o[a] === void 0 && (o[a] = s(a)), o[a])
}
const properties = {
        m: "margin",
        p: "padding"
    },
    directions = {
        t: "Top",
        r: "Right",
        b: "Bottom",
        l: "Left",
        x: ["Left", "Right"],
        y: ["Top", "Bottom"]
    },
    aliases = {
        marginX: "mx",
        marginY: "my",
        paddingX: "px",
        paddingY: "py"
    },
    getCssProperties = memoize(s => {
        if (s.length > 2)
            if (aliases[s]) s = aliases[s];
            else return [s];
        const [o, a] = s.split(""), $ = properties[o], j = directions[a] || "";
        return Array.isArray(j) ? j.map(_e => $ + _e) : [$ + j]
    }),
    marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"],
    paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];

function createUnaryUnit(s, o, a, $) {
    var j;
    const _e = (j = getPath(s, o, !1)) != null ? j : a;
    return typeof _e == "number" ? et => typeof et == "string" ? et : _e * et : Array.isArray(_e) ? et => typeof et == "string" ? et : _e[et] : typeof _e == "function" ? _e : () => {}
}

function createUnarySpacing(s) {
    return createUnaryUnit(s, "spacing", 8)
}

function getValue(s, o) {
    if (typeof o == "string" || o == null) return o;
    const a = Math.abs(o),
        $ = s(a);
    return o >= 0 ? $ : typeof $ == "number" ? -$ : `-${$}`
}

function getStyleFromPropValue(s, o) {
    return a => s.reduce(($, j) => ($[j] = getValue(o, a), $), {})
}

function resolveCssProperty(s, o, a, $) {
    if (o.indexOf(a) === -1) return null;
    const j = getCssProperties(a),
        _e = getStyleFromPropValue(j, $),
        et = s[a];
    return handleBreakpoints(s, et, _e)
}

function style$2(s, o) {
    const a = createUnarySpacing(s.theme);
    return Object.keys(s).map($ => resolveCssProperty(s, o, $, a)).reduce(merge, {})
}

function margin(s) {
    return style$2(s, marginKeys)
}
margin.propTypes = {};
margin.filterProps = marginKeys;

function padding(s) {
    return style$2(s, paddingKeys)
}
padding.propTypes = {};
padding.filterProps = paddingKeys;

function createSpacing(s = 8) {
    if (s.mui) return s;
    const o = createUnarySpacing({
            spacing: s
        }),
        a = (...$) => ($.length === 0 ? [1] : $).map(_e => {
            const et = o(_e);
            return typeof et == "number" ? `${et}px` : et
        }).join(" ");
    return a.mui = !0, a
}

function compose(...s) {
    const o = s.reduce(($, j) => (j.filterProps.forEach(_e => {
            $[_e] = j
        }), $), {}),
        a = $ => Object.keys($).reduce((j, _e) => o[_e] ? merge(j, o[_e]($)) : j, {});
    return a.propTypes = {}, a.filterProps = s.reduce(($, j) => $.concat(j.filterProps), []), a
}

function borderTransform(s) {
    return typeof s != "number" ? s : `${s}px solid`
}

function createBorderStyle(s, o) {
    return style$3({
        prop: s,
        themeKey: "borders",
        transform: o
    })
}
const border = createBorderStyle("border", borderTransform),
    borderTop = createBorderStyle("borderTop", borderTransform),
    borderRight = createBorderStyle("borderRight", borderTransform),
    borderBottom = createBorderStyle("borderBottom", borderTransform),
    borderLeft = createBorderStyle("borderLeft", borderTransform),
    borderColor = createBorderStyle("borderColor"),
    borderTopColor = createBorderStyle("borderTopColor"),
    borderRightColor = createBorderStyle("borderRightColor"),
    borderBottomColor = createBorderStyle("borderBottomColor"),
    borderLeftColor = createBorderStyle("borderLeftColor"),
    outline = createBorderStyle("outline", borderTransform),
    outlineColor = createBorderStyle("outlineColor"),
    borderRadius = s => {
        if (s.borderRadius !== void 0 && s.borderRadius !== null) {
            const o = createUnaryUnit(s.theme, "shape.borderRadius", 4),
                a = $ => ({
                    borderRadius: getValue(o, $)
                });
            return handleBreakpoints(s, s.borderRadius, a)
        }
        return null
    };
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = s => {
    if (s.gap !== void 0 && s.gap !== null) {
        const o = createUnaryUnit(s.theme, "spacing", 8),
            a = $ => ({
                gap: getValue(o, $)
            });
        return handleBreakpoints(s, s.gap, a)
    }
    return null
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = s => {
    if (s.columnGap !== void 0 && s.columnGap !== null) {
        const o = createUnaryUnit(s.theme, "spacing", 8),
            a = $ => ({
                columnGap: getValue(o, $)
            });
        return handleBreakpoints(s, s.columnGap, a)
    }
    return null
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = s => {
    if (s.rowGap !== void 0 && s.rowGap !== null) {
        const o = createUnaryUnit(s.theme, "spacing", 8),
            a = $ => ({
                rowGap: getValue(o, $)
            });
        return handleBreakpoints(s, s.rowGap, a)
    }
    return null
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$3({
        prop: "gridColumn"
    }),
    gridRow = style$3({
        prop: "gridRow"
    }),
    gridAutoFlow = style$3({
        prop: "gridAutoFlow"
    }),
    gridAutoColumns = style$3({
        prop: "gridAutoColumns"
    }),
    gridAutoRows = style$3({
        prop: "gridAutoRows"
    }),
    gridTemplateColumns = style$3({
        prop: "gridTemplateColumns"
    }),
    gridTemplateRows = style$3({
        prop: "gridTemplateRows"
    }),
    gridTemplateAreas = style$3({
        prop: "gridTemplateAreas"
    }),
    gridArea = style$3({
        prop: "gridArea"
    });
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

function paletteTransform(s, o) {
    return o === "grey" ? o : s
}
const color$1 = style$3({
        prop: "color",
        themeKey: "palette",
        transform: paletteTransform
    }),
    bgcolor = style$3({
        prop: "bgcolor",
        cssProperty: "backgroundColor",
        themeKey: "palette",
        transform: paletteTransform
    }),
    backgroundColor = style$3({
        prop: "backgroundColor",
        themeKey: "palette",
        transform: paletteTransform
    });
compose(color$1, bgcolor, backgroundColor);

function sizingTransform(s) {
    return s <= 1 && s !== 0 ? `${s*100}%` : s
}
const width = style$3({
        prop: "width",
        transform: sizingTransform
    }),
    maxWidth = s => {
        if (s.maxWidth !== void 0 && s.maxWidth !== null) {
            const o = a => {
                var $, j;
                const _e = (($ = s.theme) == null || ($ = $.breakpoints) == null || ($ = $.values) == null ? void 0 : $[a]) || values$1[a];
                return _e ? ((j = s.theme) == null || (j = j.breakpoints) == null ? void 0 : j.unit) !== "px" ? {
                    maxWidth: `${_e}${s.theme.breakpoints.unit}`
                } : {
                    maxWidth: _e
                } : {
                    maxWidth: sizingTransform(a)
                }
            };
            return handleBreakpoints(s, s.maxWidth, o)
        }
        return null
    };
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$3({
        prop: "minWidth",
        transform: sizingTransform
    }),
    height = style$3({
        prop: "height",
        transform: sizingTransform
    }),
    maxHeight = style$3({
        prop: "maxHeight",
        transform: sizingTransform
    }),
    minHeight = style$3({
        prop: "minHeight",
        transform: sizingTransform
    });
style$3({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform
});
style$3({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform
});
const boxSizing = style$3({
    prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
    border: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderTop: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderRight: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderBottom: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderLeft: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderColor: {
        themeKey: "palette"
    },
    borderTopColor: {
        themeKey: "palette"
    },
    borderRightColor: {
        themeKey: "palette"
    },
    borderBottomColor: {
        themeKey: "palette"
    },
    borderLeftColor: {
        themeKey: "palette"
    },
    outline: {
        themeKey: "borders",
        transform: borderTransform
    },
    outlineColor: {
        themeKey: "palette"
    },
    borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius
    },
    color: {
        themeKey: "palette",
        transform: paletteTransform
    },
    bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform
    },
    backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform
    },
    p: {
        style: padding
    },
    pt: {
        style: padding
    },
    pr: {
        style: padding
    },
    pb: {
        style: padding
    },
    pl: {
        style: padding
    },
    px: {
        style: padding
    },
    py: {
        style: padding
    },
    padding: {
        style: padding
    },
    paddingTop: {
        style: padding
    },
    paddingRight: {
        style: padding
    },
    paddingBottom: {
        style: padding
    },
    paddingLeft: {
        style: padding
    },
    paddingX: {
        style: padding
    },
    paddingY: {
        style: padding
    },
    paddingInline: {
        style: padding
    },
    paddingInlineStart: {
        style: padding
    },
    paddingInlineEnd: {
        style: padding
    },
    paddingBlock: {
        style: padding
    },
    paddingBlockStart: {
        style: padding
    },
    paddingBlockEnd: {
        style: padding
    },
    m: {
        style: margin
    },
    mt: {
        style: margin
    },
    mr: {
        style: margin
    },
    mb: {
        style: margin
    },
    ml: {
        style: margin
    },
    mx: {
        style: margin
    },
    my: {
        style: margin
    },
    margin: {
        style: margin
    },
    marginTop: {
        style: margin
    },
    marginRight: {
        style: margin
    },
    marginBottom: {
        style: margin
    },
    marginLeft: {
        style: margin
    },
    marginX: {
        style: margin
    },
    marginY: {
        style: margin
    },
    marginInline: {
        style: margin
    },
    marginInlineStart: {
        style: margin
    },
    marginInlineEnd: {
        style: margin
    },
    marginBlock: {
        style: margin
    },
    marginBlockStart: {
        style: margin
    },
    marginBlockEnd: {
        style: margin
    },
    displayPrint: {
        cssProperty: !1,
        transform: s => ({
            "@media print": {
                display: s
            }
        })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: {
        style: gap
    },
    rowGap: {
        style: rowGap
    },
    columnGap: {
        style: columnGap
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: {
        themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: {
        themeKey: "shadows"
    },
    width: {
        transform: sizingTransform
    },
    maxWidth: {
        style: maxWidth
    },
    minWidth: {
        transform: sizingTransform
    },
    height: {
        transform: sizingTransform
    },
    maxHeight: {
        transform: sizingTransform
    },
    minHeight: {
        transform: sizingTransform
    },
    boxSizing: {},
    fontFamily: {
        themeKey: "typography"
    },
    fontSize: {
        themeKey: "typography"
    },
    fontStyle: {
        themeKey: "typography"
    },
    fontWeight: {
        themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
        cssProperty: !1,
        themeKey: "typography"
    }
};

function objectsHaveSameKeys(...s) {
    const o = s.reduce(($, j) => $.concat(Object.keys(j)), []),
        a = new Set(o);
    return s.every($ => a.size === Object.keys($).length)
}

function callIfFn(s, o) {
    return typeof s == "function" ? s(o) : s
}

function unstable_createStyleFunctionSx() {
    function s(a, $, j, _e) {
        const et = {
                [a]: $,
                theme: j
            },
            tt = _e[a];
        if (!tt) return {
            [a]: $
        };
        const {
            cssProperty: nt = a,
            themeKey: rt,
            transform: ot,
            style: st
        } = tt;
        if ($ == null) return null;
        if (rt === "typography" && $ === "inherit") return {
            [a]: $
        };
        const lt = getPath(j, rt) || {};
        return st ? st(et) : handleBreakpoints(et, $, yt => {
            let bt = getStyleValue$1(lt, ot, yt);
            return yt === bt && typeof yt == "string" && (bt = getStyleValue$1(lt, ot, `${a}${yt==="default"?"":capitalize$1(yt)}`, yt)), nt === !1 ? bt : {
                [nt]: bt
            }
        })
    }

    function o(a) {
        var $;
        const {
            sx: j,
            theme: _e = {}
        } = a || {};
        if (!j) return null;
        const et = ($ = _e.unstable_sxConfig) != null ? $ : defaultSxConfig;

        function tt(nt) {
            let rt = nt;
            if (typeof nt == "function") rt = nt(_e);
            else if (typeof nt != "object") return nt;
            if (!rt) return null;
            const ot = createEmptyBreakpointObject(_e.breakpoints),
                st = Object.keys(ot);
            let lt = ot;
            return Object.keys(rt).forEach(ft => {
                const yt = callIfFn(rt[ft], _e);
                if (yt != null)
                    if (typeof yt == "object")
                        if (et[ft]) lt = merge(lt, s(ft, yt, _e, et));
                        else {
                            const bt = handleBreakpoints({
                                theme: _e
                            }, yt, ht => ({
                                [ft]: ht
                            }));
                            objectsHaveSameKeys(bt, yt) ? lt[ft] = o({
                                sx: yt,
                                theme: _e
                            }) : lt = merge(lt, bt)
                        }
                else lt = merge(lt, s(ft, yt, _e, et))
            }), removeUnusedBreakpoints(st, lt)
        }
        return Array.isArray(j) ? j.map(tt) : tt(j)
    }
    return o
}
const styleFunctionSx$1 = unstable_createStyleFunctionSx();
styleFunctionSx$1.filterProps = ["sx"];

function applyStyles$2(s, o) {
    const a = this;
    return a.vars && typeof a.getColorSchemeSelector == "function" ? {
        [a.getColorSchemeSelector(s).replace(/(\[[^\]]+\])/, "*:where($1)")]: o
    } : a.palette.mode === s ? o : {}
}
const _excluded$1f = ["breakpoints", "palette", "spacing", "shape"];

function createTheme$2(s = {}, ...o) {
    const {
        breakpoints: a = {},
        palette: $ = {},
        spacing: j,
        shape: _e = {}
    } = s, et = _objectWithoutPropertiesLoose$1(s, _excluded$1f), tt = createBreakpoints(a), nt = createSpacing(j);
    let rt = deepmerge$1({
        breakpoints: tt,
        direction: "ltr",
        components: {},
        palette: _extends$4({
            mode: "light"
        }, $),
        spacing: nt,
        shape: _extends$4({}, shape, _e)
    }, et);
    return rt.applyStyles = applyStyles$2, rt = o.reduce((ot, st) => deepmerge$1(ot, st), rt), rt.unstable_sxConfig = _extends$4({}, defaultSxConfig, et == null ? void 0 : et.unstable_sxConfig), rt.unstable_sx = function(st) {
        return styleFunctionSx$1({
            sx: st,
            theme: this
        })
    }, rt
}
const createTheme$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: createTheme$2,
    private_createBreakpoints: createBreakpoints,
    unstable_applyStyles: applyStyles$2
}, Symbol.toStringTag, {
    value: "Module"
}));

function isObjectEmpty$1(s) {
    return Object.keys(s).length === 0
}

function useTheme$4(s = null) {
    const o = reactExports.useContext(ThemeContext$1);
    return !o || isObjectEmpty$1(o) ? s : o
}
const systemDefaultTheme$2 = createTheme$2();

function useTheme$3(s = systemDefaultTheme$2) {
    return useTheme$4(s)
}

function GlobalStyles$1({
    styles: s,
    themeId: o,
    defaultTheme: a = {}
}) {
    const $ = useTheme$3(a),
        j = typeof s == "function" ? s(o && $[o] || $) : s;
    return jsxRuntimeExports.jsx(GlobalStyles$2, {
        styles: j
    })
}
const _excluded$1e = ["sx"],
    splitProps = s => {
        var o, a;
        const $ = {
                systemProps: {},
                otherProps: {}
            },
            j = (o = s == null || (a = s.theme) == null ? void 0 : a.unstable_sxConfig) != null ? o : defaultSxConfig;
        return Object.keys(s).forEach(_e => {
            j[_e] ? $.systemProps[_e] = s[_e] : $.otherProps[_e] = s[_e]
        }), $
    };

function extendSxProp(s) {
    const {
        sx: o
    } = s, a = _objectWithoutPropertiesLoose$1(s, _excluded$1e), {
        systemProps: $,
        otherProps: j
    } = splitProps(a);
    let _e;
    return Array.isArray(o) ? _e = [$, ...o] : typeof o == "function" ? _e = (...et) => {
        const tt = o(...et);
        return isPlainObject(tt) ? _extends$4({}, $, tt) : $
    } : _e = _extends$4({}, $, o), _extends$4({}, j, {
        sx: _e
    })
}
const styleFunctionSx = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: styleFunctionSx$1,
        extendSxProp,
        unstable_createStyleFunctionSx,
        unstable_defaultSxConfig: defaultSxConfig
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    defaultGenerator = s => s,
    createClassNameGenerator = () => {
        let s = defaultGenerator;
        return {
            configure(o) {
                s = o
            },
            generate(o) {
                return s(o)
            },
            reset() {
                s = defaultGenerator
            }
        }
    },
    ClassNameGenerator = createClassNameGenerator();

function r(s) {
    var o, a, $ = "";
    if (typeof s == "string" || typeof s == "number") $ += s;
    else if (typeof s == "object")
        if (Array.isArray(s)) {
            var j = s.length;
            for (o = 0; o < j; o++) s[o] && (a = r(s[o])) && ($ && ($ += " "), $ += a)
        } else
            for (a in s) s[a] && ($ && ($ += " "), $ += a);
    return $
}

function clsx() {
    for (var s, o, a = 0, $ = "", j = arguments.length; a < j; a++)(s = arguments[a]) && (o = r(s)) && ($ && ($ += " "), $ += o);
    return $
}
const _excluded$1d = ["className", "component"];

function createBox$1(s = {}) {
    const {
        themeId: o,
        defaultTheme: a,
        defaultClassName: $ = "MuiBox-root",
        generateClassName: j
    } = s, _e = styled$2("div", {
        shouldForwardProp: tt => tt !== "theme" && tt !== "sx" && tt !== "as"
    })(styleFunctionSx$1);
    return reactExports.forwardRef(function(nt, rt) {
        const ot = useTheme$3(a),
            st = extendSxProp(nt),
            {
                className: lt,
                component: ft = "div"
            } = st,
            yt = _objectWithoutPropertiesLoose$1(st, _excluded$1d);
        return jsxRuntimeExports.jsx(_e, _extends$4({
            as: ft,
            ref: rt,
            className: clsx(lt, j ? j($) : $),
            theme: o && ot[o] || ot
        }, yt))
    })
}
const globalStateClasses = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
};

function generateUtilityClass(s, o, a = "Mui") {
    const $ = globalStateClasses[o];
    return $ ? `${a}-${$}` : `${ClassNameGenerator.generate(s)}-${o}`
}

function generateUtilityClasses(s, o, a = "Mui") {
    const $ = {};
    return o.forEach(j => {
        $[j] = generateUtilityClass(s, j, a)
    }), $
}
var reactIs = {
        exports: {}
    },
    reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    d = Symbol.for("react.fragment"),
    e = Symbol.for("react.strict_mode"),
    f$2 = Symbol.for("react.profiler"),
    g$2 = Symbol.for("react.provider"),
    h = Symbol.for("react.context"),
    k = Symbol.for("react.server_context"),
    l = Symbol.for("react.forward_ref"),
    m = Symbol.for("react.suspense"),
    n = Symbol.for("react.suspense_list"),
    p = Symbol.for("react.memo"),
    q = Symbol.for("react.lazy"),
    t = Symbol.for("react.offscreen"),
    u;
u = Symbol.for("react.module.reference");

function v(s) {
    if (typeof s == "object" && s !== null) {
        var o = s.$$typeof;
        switch (o) {
            case b:
                switch (s = s.type, s) {
                    case d:
                    case f$2:
                    case e:
                    case m:
                    case n:
                        return s;
                    default:
                        switch (s = s && s.$$typeof, s) {
                            case k:
                            case h:
                            case l:
                            case q:
                            case p:
                            case g$2:
                                return s;
                            default:
                                return o
                        }
                }
            case c:
                return o
        }
    }
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g$2;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p;
reactIs_production_min.Portal = c;
reactIs_production_min.Profiler = f$2;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m;
reactIs_production_min.SuspenseList = n;
reactIs_production_min.isAsyncMode = function() {
    return !1
};
reactIs_production_min.isConcurrentMode = function() {
    return !1
};
reactIs_production_min.isContextConsumer = function(s) {
    return v(s) === h
};
reactIs_production_min.isContextProvider = function(s) {
    return v(s) === g$2
};
reactIs_production_min.isElement = function(s) {
    return typeof s == "object" && s !== null && s.$$typeof === b
};
reactIs_production_min.isForwardRef = function(s) {
    return v(s) === l
};
reactIs_production_min.isFragment = function(s) {
    return v(s) === d
};
reactIs_production_min.isLazy = function(s) {
    return v(s) === q
};
reactIs_production_min.isMemo = function(s) {
    return v(s) === p
};
reactIs_production_min.isPortal = function(s) {
    return v(s) === c
};
reactIs_production_min.isProfiler = function(s) {
    return v(s) === f$2
};
reactIs_production_min.isStrictMode = function(s) {
    return v(s) === e
};
reactIs_production_min.isSuspense = function(s) {
    return v(s) === m
};
reactIs_production_min.isSuspenseList = function(s) {
    return v(s) === n
};
reactIs_production_min.isValidElementType = function(s) {
    return typeof s == "string" || typeof s == "function" || s === d || s === f$2 || s === e || s === m || s === n || s === t || typeof s == "object" && s !== null && (s.$$typeof === q || s.$$typeof === p || s.$$typeof === g$2 || s.$$typeof === h || s.$$typeof === l || s.$$typeof === u || s.getModuleId !== void 0)
};
reactIs_production_min.typeOf = v;
reactIs.exports = reactIs_production_min;
var reactIsExports = reactIs.exports;
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;

function getFunctionName(s) {
    const o = `${s}`.match(fnNameMatchRegex);
    return o && o[1] || ""
}

function getFunctionComponentName(s, o = "") {
    return s.displayName || s.name || getFunctionName(s) || o
}

function getWrappedName(s, o, a) {
    const $ = getFunctionComponentName(o);
    return s.displayName || ($ !== "" ? `${a}(${$})` : a)
}

function getDisplayName$1(s) {
    if (s != null) {
        if (typeof s == "string") return s;
        if (typeof s == "function") return getFunctionComponentName(s, "Component");
        if (typeof s == "object") switch (s.$$typeof) {
            case reactIsExports.ForwardRef:
                return getWrappedName(s, s.render, "ForwardRef");
            case reactIsExports.Memo:
                return getWrappedName(s, s.type, "memo");
            default:
                return
        }
    }
}
const getDisplayName = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: getDisplayName$1,
        getFunctionName
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    _excluded$1c = ["ownerState"],
    _excluded2$9 = ["variants"],
    _excluded3$3 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];

function isEmpty$3(s) {
    return Object.keys(s).length === 0
}

function isStringTag$1(s) {
    return typeof s == "string" && s.charCodeAt(0) > 96
}

function shouldForwardProp$1(s) {
    return s !== "ownerState" && s !== "theme" && s !== "sx" && s !== "as"
}
const systemDefaultTheme$1 = createTheme$2(),
    lowercaseFirstLetter$1 = s => s && s.charAt(0).toLowerCase() + s.slice(1);

function resolveTheme$1({
    defaultTheme: s,
    theme: o,
    themeId: a
}) {
    return isEmpty$3(o) ? s : o[a] || o
}

function defaultOverridesResolver$1(s) {
    return s ? (o, a) => a[s] : null
}

function processStyleArg$1(s, o) {
    let {
        ownerState: a
    } = o, $ = _objectWithoutPropertiesLoose$1(o, _excluded$1c);
    const j = typeof s == "function" ? s(_extends$4({
        ownerState: a
    }, $)) : s;
    if (Array.isArray(j)) return j.flatMap(_e => processStyleArg$1(_e, _extends$4({
        ownerState: a
    }, $)));
    if (j && typeof j == "object" && Array.isArray(j.variants)) {
        const {
            variants: _e = []
        } = j;
        let tt = _objectWithoutPropertiesLoose$1(j, _excluded2$9);
        return _e.forEach(nt => {
            let rt = !0;
            typeof nt.props == "function" ? rt = nt.props(_extends$4({
                ownerState: a
            }, $, a)) : Object.keys(nt.props).forEach(ot => {
                (a == null ? void 0 : a[ot]) !== nt.props[ot] && $[ot] !== nt.props[ot] && (rt = !1)
            }), rt && (Array.isArray(tt) || (tt = [tt]), tt.push(typeof nt.style == "function" ? nt.style(_extends$4({
                ownerState: a
            }, $, a)) : nt.style))
        }), tt
    }
    return j
}

function createStyled$2(s = {}) {
    const {
        themeId: o,
        defaultTheme: a = systemDefaultTheme$1,
        rootShouldForwardProp: $ = shouldForwardProp$1,
        slotShouldForwardProp: j = shouldForwardProp$1
    } = s, _e = et => styleFunctionSx$1(_extends$4({}, et, {
        theme: resolveTheme$1(_extends$4({}, et, {
            defaultTheme: a,
            themeId: o
        }))
    }));
    return _e.__mui_systemSx = !0, (et, tt = {}) => {
        internal_processStyles(et, Pt => Pt.filter(Bt => !(Bt != null && Bt.__mui_systemSx)));
        const {
            name: nt,
            slot: rt,
            skipVariantsResolver: ot,
            skipSx: st,
            overridesResolver: lt = defaultOverridesResolver$1(lowercaseFirstLetter$1(rt))
        } = tt, ft = _objectWithoutPropertiesLoose$1(tt, _excluded3$3), yt = ot !== void 0 ? ot : rt && rt !== "Root" && rt !== "root" || !1, bt = st || !1;
        let ht, vt = shouldForwardProp$1;
        rt === "Root" || rt === "root" ? vt = $ : rt ? vt = j : isStringTag$1(et) && (vt = void 0);
        const wt = styled$2(et, _extends$4({
                shouldForwardProp: vt,
                label: ht
            }, ft)),
            gt = Pt => typeof Pt == "function" && Pt.__emotion_real !== Pt || isPlainObject(Pt) ? Bt => processStyleArg$1(Pt, _extends$4({}, Bt, {
                theme: resolveTheme$1({
                    theme: Bt.theme,
                    defaultTheme: a,
                    themeId: o
                })
            })) : Pt,
            At = (Pt, ...Bt) => {
                let Lt = gt(Pt);
                const Nt = Bt ? Bt.map(gt) : [];
                nt && lt && Nt.push(Ft => {
                    const Wt = resolveTheme$1(_extends$4({}, Ft, {
                        defaultTheme: a,
                        themeId: o
                    }));
                    if (!Wt.components || !Wt.components[nt] || !Wt.components[nt].styleOverrides) return null;
                    const Ct = Wt.components[nt].styleOverrides,
                        it = {};
                    return Object.entries(Ct).forEach(([at, mt]) => {
                        it[at] = processStyleArg$1(mt, _extends$4({}, Ft, {
                            theme: Wt
                        }))
                    }), lt(Ft, it)
                }), nt && !yt && Nt.push(Ft => {
                    var Wt;
                    const Ct = resolveTheme$1(_extends$4({}, Ft, {
                            defaultTheme: a,
                            themeId: o
                        })),
                        it = Ct == null || (Wt = Ct.components) == null || (Wt = Wt[nt]) == null ? void 0 : Wt.variants;
                    return processStyleArg$1({
                        variants: it
                    }, _extends$4({}, Ft, {
                        theme: Ct
                    }))
                }), bt || Nt.push(_e);
                const Ut = Nt.length - Bt.length;
                if (Array.isArray(Pt) && Ut > 0) {
                    const Ft = new Array(Ut).fill("");
                    Lt = [...Pt, ...Ft], Lt.raw = [...Pt.raw, ...Ft]
                }
                const Vt = wt(Lt, ...Nt);
                return et.muiName && (Vt.muiName = et.muiName), Vt
            };
        return wt.withConfig && (At.withConfig = wt.withConfig), At
    }
}
const styled$1 = createStyled$2();

function resolveProps(s, o) {
    const a = _extends$4({}, o);
    return Object.keys(s).forEach($ => {
        if ($.toString().match(/^(components|slots)$/)) a[$] = _extends$4({}, s[$], a[$]);
        else if ($.toString().match(/^(componentsProps|slotProps)$/)) {
            const j = s[$] || {},
                _e = o[$];
            a[$] = {}, !_e || !Object.keys(_e) ? a[$] = j : !j || !Object.keys(j) ? a[$] = _e : (a[$] = _extends$4({}, _e), Object.keys(j).forEach(et => {
                a[$][et] = resolveProps(j[et], _e[et])
            }))
        } else a[$] === void 0 && (a[$] = s[$])
    }), a
}

function getThemeProps$1(s) {
    const {
        theme: o,
        name: a,
        props: $
    } = s;
    return !o || !o.components || !o.components[a] || !o.components[a].defaultProps ? $ : resolveProps(o.components[a].defaultProps, $)
}

function useThemeProps({
    props: s,
    name: o,
    defaultTheme: a,
    themeId: $
}) {
    let j = useTheme$3(a);
    return $ && (j = j[$] || j), getThemeProps$1({
        theme: j,
        name: o,
        props: s
    })
}
const useEnhancedEffect = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;

function clamp$2(s, o = Number.MIN_SAFE_INTEGER, a = Number.MAX_SAFE_INTEGER) {
    return Math.max(o, Math.min(s, a))
}
const clamp$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: clamp$2
}, Symbol.toStringTag, {
    value: "Module"
}));

function clampWrapper$1(s, o = 0, a = 1) {
    return clamp$2(s, o, a)
}

function hexToRgb$1(s) {
    s = s.slice(1);
    const o = new RegExp(`.{1,${s.length>=6?2:1}}`, "g");
    let a = s.match(o);
    return a && a[0].length === 1 && (a = a.map($ => $ + $)), a ? `rgb${a.length===4?"a":""}(${a.map(($,j)=>j<3?parseInt($,16):Math.round(parseInt($,16)/255*1e3)/1e3).join(", ")})` : ""
}

function decomposeColor$1(s) {
    if (s.type) return s;
    if (s.charAt(0) === "#") return decomposeColor$1(hexToRgb$1(s));
    const o = s.indexOf("("),
        a = s.substring(0, o);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(a) === -1) throw new Error(formatMuiErrorMessage$1(9, s));
    let $ = s.substring(o + 1, s.length - 1),
        j;
    if (a === "color") {
        if ($ = $.split(" "), j = $.shift(), $.length === 4 && $[3].charAt(0) === "/" && ($[3] = $[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(j) === -1) throw new Error(formatMuiErrorMessage$1(10, j))
    } else $ = $.split(",");
    return $ = $.map(_e => parseFloat(_e)), {
        type: a,
        values: $,
        colorSpace: j
    }
}

function recomposeColor$1(s) {
    const {
        type: o,
        colorSpace: a
    } = s;
    let {
        values: $
    } = s;
    return o.indexOf("rgb") !== -1 ? $ = $.map((j, _e) => _e < 3 ? parseInt(j, 10) : j) : o.indexOf("hsl") !== -1 && ($[1] = `${$[1]}%`, $[2] = `${$[2]}%`), o.indexOf("color") !== -1 ? $ = `${a} ${$.join(" ")}` : $ = `${$.join(", ")}`, `${o}(${$})`
}

function alpha$2(s, o) {
    return s = decomposeColor$1(s), o = clampWrapper$1(o), (s.type === "rgb" || s.type === "hsl") && (s.type += "a"), s.type === "color" ? s.values[3] = `/${o}` : s.values[3] = o, recomposeColor$1(s)
}

function createChainedFunction(...s) {
    return s.reduce((o, a) => a == null ? o : function(...j) {
        o.apply(this, j), a.apply(this, j)
    }, () => {})
}

function debounce$1(s, o = 166) {
    let a;

    function $(...j) {
        const _e = () => {
            s.apply(this, j)
        };
        clearTimeout(a), a = setTimeout(_e, o)
    }
    return $.clear = () => {
        clearTimeout(a)
    }, $
}

function deprecatedPropType(s, o) {
    return () => null
}

function isMuiElement(s, o) {
    var a, $;
    return reactExports.isValidElement(s) && o.indexOf((a = s.type.muiName) != null ? a : ($ = s.type) == null || ($ = $._payload) == null || ($ = $.value) == null ? void 0 : $.muiName) !== -1
}

function ownerDocument(s) {
    return s && s.ownerDocument || document
}

function ownerWindow(s) {
    return ownerDocument(s).defaultView || window
}

function requirePropFactory(s, o) {
    return () => null
}

function setRef(s, o) {
    typeof s == "function" ? s(o) : s && (s.current = o)
}
let globalId = 0;

function useGlobalId(s) {
    const [o, a] = reactExports.useState(s), $ = s || o;
    return reactExports.useEffect(() => {
        o == null && (globalId += 1, a(`mui-${globalId}`))
    }, [o]), $
}
const maybeReactUseId = React$2.useId;

function useId(s) {
    if (maybeReactUseId !== void 0) {
        const o = maybeReactUseId();
        return s ? ? o
    }
    return useGlobalId(s)
}

function unsupportedProp(s, o, a, $, j) {
    return null
}

function useControlled({
    controlled: s,
    default: o,
    name: a,
    state: $ = "value"
}) {
    const {
        current: j
    } = reactExports.useRef(s !== void 0), [_e, et] = reactExports.useState(o), tt = j ? s : _e, nt = reactExports.useCallback(rt => {
        j || et(rt)
    }, []);
    return [tt, nt]
}

function useEventCallback(s) {
    const o = reactExports.useRef(s);
    return useEnhancedEffect(() => {
        o.current = s
    }), reactExports.useRef((...a) => (0, o.current)(...a)).current
}

function useForkRef(...s) {
    return reactExports.useMemo(() => s.every(o => o == null) ? null : o => {
        s.forEach(a => {
            setRef(a, o)
        })
    }, s)
}
const UNINITIALIZED = {};

function useLazyRef(s, o) {
    const a = reactExports.useRef(UNINITIALIZED);
    return a.current === UNINITIALIZED && (a.current = s(o)), a
}
const EMPTY = [];

function useOnMount(s) {
    reactExports.useEffect(s, EMPTY)
}
class Timeout {
    constructor() {
        this.currentId = null, this.clear = () => {
            this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null)
        }, this.disposeEffect = () => this.clear
    }
    static create() {
        return new Timeout
    }
    start(o, a) {
        this.clear(), this.currentId = setTimeout(() => {
            this.currentId = null, a()
        }, o)
    }
}

function useTimeout() {
    const s = useLazyRef(Timeout.create).current;
    return useOnMount(s.disposeEffect), s
}
let hadKeyboardEvent = !0,
    hadFocusVisibleRecently = !1;
const hadFocusVisibleRecentlyTimeout = new Timeout,
    inputTypesWhitelist = {
        text: !0,
        search: !0,
        url: !0,
        tel: !0,
        email: !0,
        password: !0,
        number: !0,
        date: !0,
        month: !0,
        week: !0,
        time: !0,
        datetime: !0,
        "datetime-local": !0
    };

function focusTriggersKeyboardModality(s) {
    const {
        type: o,
        tagName: a
    } = s;
    return !!(a === "INPUT" && inputTypesWhitelist[o] && !s.readOnly || a === "TEXTAREA" && !s.readOnly || s.isContentEditable)
}

function handleKeyDown(s) {
    s.metaKey || s.altKey || s.ctrlKey || (hadKeyboardEvent = !0)
}

function handlePointerDown() {
    hadKeyboardEvent = !1
}

function handleVisibilityChange() {
    this.visibilityState === "hidden" && hadFocusVisibleRecently && (hadKeyboardEvent = !0)
}

function prepare(s) {
    s.addEventListener("keydown", handleKeyDown, !0), s.addEventListener("mousedown", handlePointerDown, !0), s.addEventListener("pointerdown", handlePointerDown, !0), s.addEventListener("touchstart", handlePointerDown, !0), s.addEventListener("visibilitychange", handleVisibilityChange, !0)
}

function isFocusVisible(s) {
    const {
        target: o
    } = s;
    try {
        return o.matches(":focus-visible")
    } catch {}
    return hadKeyboardEvent || focusTriggersKeyboardModality(o)
}

function useIsFocusVisible() {
    const s = reactExports.useCallback(j => {
            j != null && prepare(j.ownerDocument)
        }, []),
        o = reactExports.useRef(!1);

    function a() {
        return o.current ? (hadFocusVisibleRecently = !0, hadFocusVisibleRecentlyTimeout.start(100, () => {
            hadFocusVisibleRecently = !1
        }), o.current = !1, !0) : !1
    }

    function $(j) {
        return isFocusVisible(j) ? (o.current = !0, !0) : !1
    }
    return {
        isFocusVisibleRef: o,
        onFocus: $,
        onBlur: a,
        ref: s
    }
}

function getScrollbarSize(s) {
    const o = s.documentElement.clientWidth;
    return Math.abs(window.innerWidth - o)
}
let cachedType;

function detectScrollType() {
    if (cachedType) return cachedType;
    const s = document.createElement("div"),
        o = document.createElement("div");
    return o.style.width = "10px", o.style.height = "1px", s.appendChild(o), s.dir = "rtl", s.style.fontSize = "14px", s.style.width = "4px", s.style.height = "1px", s.style.position = "absolute", s.style.top = "-1000px", s.style.overflow = "scroll", document.body.appendChild(s), cachedType = "reverse", s.scrollLeft > 0 ? cachedType = "default" : (s.scrollLeft = 1, s.scrollLeft === 0 && (cachedType = "negative")), document.body.removeChild(s), cachedType
}

function getNormalizedScrollLeft(s, o) {
    const a = s.scrollLeft;
    if (o !== "rtl") return a;
    switch (detectScrollType()) {
        case "negative":
            return s.scrollWidth - s.clientWidth + a;
        case "reverse":
            return s.scrollWidth - s.clientWidth - a;
        default:
            return a
    }
}

function composeClasses(s, o, a = void 0) {
    const $ = {};
    return Object.keys(s).forEach(j => {
        $[j] = s[j].reduce((_e, et) => {
            if (et) {
                const tt = o(et);
                tt !== "" && _e.push(tt), a && a[et] && _e.push(a[et])
            }
            return _e
        }, []).join(" ")
    }), $
}

function isHostComponent(s) {
    return typeof s == "string"
}

function appendOwnerState(s, o, a) {
    return s === void 0 || isHostComponent(s) ? o : _extends$4({}, o, {
        ownerState: _extends$4({}, o.ownerState, a)
    })
}

function extractEventHandlers(s, o = []) {
    if (s === void 0) return {};
    const a = {};
    return Object.keys(s).filter($ => $.match(/^on[A-Z]/) && typeof s[$] == "function" && !o.includes($)).forEach($ => {
        a[$] = s[$]
    }), a
}

function omitEventHandlers(s) {
    if (s === void 0) return {};
    const o = {};
    return Object.keys(s).filter(a => !(a.match(/^on[A-Z]/) && typeof s[a] == "function")).forEach(a => {
        o[a] = s[a]
    }), o
}

function mergeSlotProps(s) {
    const {
        getSlotProps: o,
        additionalProps: a,
        externalSlotProps: $,
        externalForwardedProps: j,
        className: _e
    } = s;
    if (!o) {
        const ft = clsx(a == null ? void 0 : a.className, _e, j == null ? void 0 : j.className, $ == null ? void 0 : $.className),
            yt = _extends$4({}, a == null ? void 0 : a.style, j == null ? void 0 : j.style, $ == null ? void 0 : $.style),
            bt = _extends$4({}, a, j, $);
        return ft.length > 0 && (bt.className = ft), Object.keys(yt).length > 0 && (bt.style = yt), {
            props: bt,
            internalRef: void 0
        }
    }
    const et = extractEventHandlers(_extends$4({}, j, $)),
        tt = omitEventHandlers($),
        nt = omitEventHandlers(j),
        rt = o(et),
        ot = clsx(rt == null ? void 0 : rt.className, a == null ? void 0 : a.className, _e, j == null ? void 0 : j.className, $ == null ? void 0 : $.className),
        st = _extends$4({}, rt == null ? void 0 : rt.style, a == null ? void 0 : a.style, j == null ? void 0 : j.style, $ == null ? void 0 : $.style),
        lt = _extends$4({}, rt, a, nt, tt);
    return ot.length > 0 && (lt.className = ot), Object.keys(st).length > 0 && (lt.style = st), {
        props: lt,
        internalRef: rt.ref
    }
}

function resolveComponentProps(s, o, a) {
    return typeof s == "function" ? s(o, a) : s
}
const _excluded$1b = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];

function useSlotProps(s) {
    var o;
    const {
        elementType: a,
        externalSlotProps: $,
        ownerState: j,
        skipResolvingSlotProps: _e = !1
    } = s, et = _objectWithoutPropertiesLoose$1(s, _excluded$1b), tt = _e ? {} : resolveComponentProps($, j), {
        props: nt,
        internalRef: rt
    } = mergeSlotProps(_extends$4({}, et, {
        externalSlotProps: tt
    })), ot = useForkRef(rt, tt == null ? void 0 : tt.ref, (o = s.additionalProps) == null ? void 0 : o.ref);
    return appendOwnerState(a, _extends$4({}, nt, {
        ref: ot
    }), j)
}
const ThemeContext = reactExports.createContext(null);

function useTheme$2() {
    return reactExports.useContext(ThemeContext)
}
const hasSymbol = typeof Symbol == "function" && Symbol.for,
    nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";

function mergeOuterLocalTheme(s, o) {
    return typeof o == "function" ? o(s) : _extends$4({}, s, o)
}

function ThemeProvider$2(s) {
    const {
        children: o,
        theme: a
    } = s, $ = useTheme$2(), j = reactExports.useMemo(() => {
        const _e = $ === null ? a : mergeOuterLocalTheme($, a);
        return _e != null && (_e[nested] = $ !== null), _e
    }, [a, $]);
    return jsxRuntimeExports.jsx(ThemeContext.Provider, {
        value: j,
        children: o
    })
}
const _excluded$1a = ["value"],
    RtlContext = reactExports.createContext();

function RtlProvider(s) {
    let {
        value: o
    } = s, a = _objectWithoutPropertiesLoose$1(s, _excluded$1a);
    return jsxRuntimeExports.jsx(RtlContext.Provider, _extends$4({
        value: o ? ? !0
    }, a))
}
const useRtl = () => {
        const s = reactExports.useContext(RtlContext);
        return s ? ? !1
    },
    PropsContext = reactExports.createContext(void 0);

function DefaultPropsProvider({
    value: s,
    children: o
}) {
    return jsxRuntimeExports.jsx(PropsContext.Provider, {
        value: s,
        children: o
    })
}

function getThemeProps(s) {
    const {
        theme: o,
        name: a,
        props: $
    } = s;
    if (!o || !o.components || !o.components[a]) return $;
    const j = o.components[a];
    return j.defaultProps ? resolveProps(j.defaultProps, $) : !j.styleOverrides && !j.variants ? resolveProps(j, $) : $
}

function useDefaultProps$1({
    props: s,
    name: o
}) {
    const a = reactExports.useContext(PropsContext);
    return getThemeProps({
        props: s,
        name: o,
        theme: {
            components: a
        }
    })
}
const EMPTY_THEME = {};

function useThemeScoping(s, o, a, $ = !1) {
    return reactExports.useMemo(() => {
        const j = s && o[s] || o;
        if (typeof a == "function") {
            const _e = a(j),
                et = s ? _extends$4({}, o, {
                    [s]: _e
                }) : _e;
            return $ ? () => et : et
        }
        return s ? _extends$4({}, o, {
            [s]: a
        }) : _extends$4({}, o, a)
    }, [s, o, a, $])
}

function ThemeProvider$1(s) {
    const {
        children: o,
        theme: a,
        themeId: $
    } = s, j = useTheme$4(EMPTY_THEME), _e = useTheme$2() || EMPTY_THEME, et = useThemeScoping($, j, a), tt = useThemeScoping($, _e, a, !0), nt = et.direction === "rtl";
    return jsxRuntimeExports.jsx(ThemeProvider$2, {
        theme: tt,
        children: jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
            value: et,
            children: jsxRuntimeExports.jsx(RtlProvider, {
                value: nt,
                children: jsxRuntimeExports.jsx(DefaultPropsProvider, {
                    value: et == null ? void 0 : et.components,
                    children: o
                })
            })
        })
    })
}
const _excluded$19 = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"],
    defaultTheme$2 = createTheme$2(),
    defaultCreateStyledComponent = styled$1("div", {
        name: "MuiStack",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    });

function useThemePropsDefault(s) {
    return useThemeProps({
        props: s,
        name: "MuiStack",
        defaultTheme: defaultTheme$2
    })
}

function joinChildren(s, o) {
    const a = reactExports.Children.toArray(s).filter(Boolean);
    return a.reduce(($, j, _e) => ($.push(j), _e < a.length - 1 && $.push(reactExports.cloneElement(o, {
        key: `separator-${_e}`
    })), $), [])
}
const getSideFromDirection = s => ({
        row: "Left",
        "row-reverse": "Right",
        column: "Top",
        "column-reverse": "Bottom"
    })[s],
    style$1 = ({
        ownerState: s,
        theme: o
    }) => {
        let a = _extends$4({
            display: "flex",
            flexDirection: "column"
        }, handleBreakpoints({
            theme: o
        }, resolveBreakpointValues({
            values: s.direction,
            breakpoints: o.breakpoints.values
        }), $ => ({
            flexDirection: $
        })));
        if (s.spacing) {
            const $ = createUnarySpacing(o),
                j = Object.keys(o.breakpoints.values).reduce((nt, rt) => ((typeof s.spacing == "object" && s.spacing[rt] != null || typeof s.direction == "object" && s.direction[rt] != null) && (nt[rt] = !0), nt), {}),
                _e = resolveBreakpointValues({
                    values: s.direction,
                    base: j
                }),
                et = resolveBreakpointValues({
                    values: s.spacing,
                    base: j
                });
            typeof _e == "object" && Object.keys(_e).forEach((nt, rt, ot) => {
                if (!_e[nt]) {
                    const lt = rt > 0 ? _e[ot[rt - 1]] : "column";
                    _e[nt] = lt
                }
            }), a = deepmerge$1(a, handleBreakpoints({
                theme: o
            }, et, (nt, rt) => s.useFlexGap ? {
                gap: getValue($, nt)
            } : {
                "& > :not(style):not(style)": {
                    margin: 0
                },
                "& > :not(style) ~ :not(style)": {
                    [`margin${getSideFromDirection(rt?_e[rt]:s.direction)}`]: getValue($, nt)
                }
            }))
        }
        return a = mergeBreakpointsInOrder(o.breakpoints, a), a
    };

function createStack(s = {}) {
    const {
        createStyledComponent: o = defaultCreateStyledComponent,
        useThemeProps: a = useThemePropsDefault,
        componentName: $ = "MuiStack"
    } = s, j = () => composeClasses({
        root: ["root"]
    }, nt => generateUtilityClass($, nt), {}), _e = o(style$1);
    return reactExports.forwardRef(function(nt, rt) {
        const ot = a(nt),
            st = extendSxProp(ot),
            {
                component: lt = "div",
                direction: ft = "column",
                spacing: yt = 0,
                divider: bt,
                children: ht,
                className: vt,
                useFlexGap: wt = !1
            } = st,
            gt = _objectWithoutPropertiesLoose$1(st, _excluded$19),
            At = {
                direction: ft,
                spacing: yt,
                useFlexGap: wt
            },
            Pt = j();
        return jsxRuntimeExports.jsx(_e, _extends$4({
            as: lt,
            ownerState: At,
            ref: rt,
            className: clsx(Pt.root, vt)
        }, gt, {
            children: bt ? joinChildren(ht, bt) : ht
        }))
    })
}

function createMixins(s, o) {
    return _extends$4({
        toolbar: {
            minHeight: 56,
            [s.up("xs")]: {
                "@media (orientation: landscape)": {
                    minHeight: 48
                }
            },
            [s.up("sm")]: {
                minHeight: 64
            }
        }
    }, o)
}
var colorManipulator = {},
    interopRequireDefault = {
        exports: {}
    };
(function(s) {
    function o(a) {
        return a && a.__esModule ? a : {
            default: a
        }
    }
    s.exports = o, s.exports.__esModule = !0, s.exports.default = s.exports
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
const require$$1$3 = getAugmentedNamespace(formatMuiErrorMessage),
    require$$2$2 = getAugmentedNamespace(clamp$1);
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(colorManipulator, "__esModule", {
    value: !0
});
var alpha_1 = colorManipulator.alpha = alpha$1;
colorManipulator.blend = blend;
colorManipulator.colorChannel = void 0;
var darken_1 = colorManipulator.darken = darken;
colorManipulator.decomposeColor = decomposeColor;
colorManipulator.emphasize = emphasize;
var getContrastRatio_1 = colorManipulator.getContrastRatio = getContrastRatio;
colorManipulator.getLuminance = getLuminance;
colorManipulator.hexToRgb = hexToRgb;
colorManipulator.hslToRgb = hslToRgb;
var lighten_1 = colorManipulator.lighten = lighten;
colorManipulator.private_safeAlpha = private_safeAlpha;
colorManipulator.private_safeColorChannel = void 0;
colorManipulator.private_safeDarken = private_safeDarken;
colorManipulator.private_safeEmphasize = private_safeEmphasize;
colorManipulator.private_safeLighten = private_safeLighten;
colorManipulator.recomposeColor = recomposeColor;
colorManipulator.rgbToHex = rgbToHex;
var _formatMuiErrorMessage2 = _interopRequireDefault$5(require$$1$3),
    _clamp = _interopRequireDefault$5(require$$2$2);

function clampWrapper(s, o = 0, a = 1) {
    return (0, _clamp.default)(s, o, a)
}

function hexToRgb(s) {
    s = s.slice(1);
    const o = new RegExp(`.{1,${s.length>=6?2:1}}`, "g");
    let a = s.match(o);
    return a && a[0].length === 1 && (a = a.map($ => $ + $)), a ? `rgb${a.length===4?"a":""}(${a.map(($,j)=>j<3?parseInt($,16):Math.round(parseInt($,16)/255*1e3)/1e3).join(", ")})` : ""
}

function intToHex(s) {
    const o = s.toString(16);
    return o.length === 1 ? `0${o}` : o
}

function decomposeColor(s) {
    if (s.type) return s;
    if (s.charAt(0) === "#") return decomposeColor(hexToRgb(s));
    const o = s.indexOf("("),
        a = s.substring(0, o);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(a) === -1) throw new Error((0, _formatMuiErrorMessage2.default)(9, s));
    let $ = s.substring(o + 1, s.length - 1),
        j;
    if (a === "color") {
        if ($ = $.split(" "), j = $.shift(), $.length === 4 && $[3].charAt(0) === "/" && ($[3] = $[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(j) === -1) throw new Error((0, _formatMuiErrorMessage2.default)(10, j))
    } else $ = $.split(",");
    return $ = $.map(_e => parseFloat(_e)), {
        type: a,
        values: $,
        colorSpace: j
    }
}
const colorChannel = s => {
    const o = decomposeColor(s);
    return o.values.slice(0, 3).map((a, $) => o.type.indexOf("hsl") !== -1 && $ !== 0 ? `${a}%` : a).join(" ")
};
colorManipulator.colorChannel = colorChannel;
const private_safeColorChannel = (s, o) => {
    try {
        return colorChannel(s)
    } catch {
        return s
    }
};
colorManipulator.private_safeColorChannel = private_safeColorChannel;

function recomposeColor(s) {
    const {
        type: o,
        colorSpace: a
    } = s;
    let {
        values: $
    } = s;
    return o.indexOf("rgb") !== -1 ? $ = $.map((j, _e) => _e < 3 ? parseInt(j, 10) : j) : o.indexOf("hsl") !== -1 && ($[1] = `${$[1]}%`, $[2] = `${$[2]}%`), o.indexOf("color") !== -1 ? $ = `${a} ${$.join(" ")}` : $ = `${$.join(", ")}`, `${o}(${$})`
}

function rgbToHex(s) {
    if (s.indexOf("#") === 0) return s;
    const {
        values: o
    } = decomposeColor(s);
    return `#${o.map((a,$)=>intToHex($===3?Math.round(255*a):a)).join("")}`
}

function hslToRgb(s) {
    s = decomposeColor(s);
    const {
        values: o
    } = s, a = o[0], $ = o[1] / 100, j = o[2] / 100, _e = $ * Math.min(j, 1 - j), et = (rt, ot = (rt + a / 30) % 12) => j - _e * Math.max(Math.min(ot - 3, 9 - ot, 1), -1);
    let tt = "rgb";
    const nt = [Math.round(et(0) * 255), Math.round(et(8) * 255), Math.round(et(4) * 255)];
    return s.type === "hsla" && (tt += "a", nt.push(o[3])), recomposeColor({
        type: tt,
        values: nt
    })
}

function getLuminance(s) {
    s = decomposeColor(s);
    let o = s.type === "hsl" || s.type === "hsla" ? decomposeColor(hslToRgb(s)).values : s.values;
    return o = o.map(a => (s.type !== "color" && (a /= 255), a <= .03928 ? a / 12.92 : ((a + .055) / 1.055) ** 2.4)), Number((.2126 * o[0] + .7152 * o[1] + .0722 * o[2]).toFixed(3))
}

function getContrastRatio(s, o) {
    const a = getLuminance(s),
        $ = getLuminance(o);
    return (Math.max(a, $) + .05) / (Math.min(a, $) + .05)
}

function alpha$1(s, o) {
    return s = decomposeColor(s), o = clampWrapper(o), (s.type === "rgb" || s.type === "hsl") && (s.type += "a"), s.type === "color" ? s.values[3] = `/${o}` : s.values[3] = o, recomposeColor(s)
}

function private_safeAlpha(s, o, a) {
    try {
        return alpha$1(s, o)
    } catch {
        return s
    }
}

function darken(s, o) {
    if (s = decomposeColor(s), o = clampWrapper(o), s.type.indexOf("hsl") !== -1) s.values[2] *= 1 - o;
    else if (s.type.indexOf("rgb") !== -1 || s.type.indexOf("color") !== -1)
        for (let a = 0; a < 3; a += 1) s.values[a] *= 1 - o;
    return recomposeColor(s)
}

function private_safeDarken(s, o, a) {
    try {
        return darken(s, o)
    } catch {
        return s
    }
}

function lighten(s, o) {
    if (s = decomposeColor(s), o = clampWrapper(o), s.type.indexOf("hsl") !== -1) s.values[2] += (100 - s.values[2]) * o;
    else if (s.type.indexOf("rgb") !== -1)
        for (let a = 0; a < 3; a += 1) s.values[a] += (255 - s.values[a]) * o;
    else if (s.type.indexOf("color") !== -1)
        for (let a = 0; a < 3; a += 1) s.values[a] += (1 - s.values[a]) * o;
    return recomposeColor(s)
}

function private_safeLighten(s, o, a) {
    try {
        return lighten(s, o)
    } catch {
        return s
    }
}

function emphasize(s, o = .15) {
    return getLuminance(s) > .5 ? darken(s, o) : lighten(s, o)
}

function private_safeEmphasize(s, o, a) {
    try {
        return emphasize(s, o)
    } catch {
        return s
    }
}

function blend(s, o, a, $ = 1) {
    const j = (nt, rt) => Math.round((nt ** (1 / $) * (1 - a) + rt ** (1 / $) * a) ** $),
        _e = decomposeColor(s),
        et = decomposeColor(o),
        tt = [j(_e.values[0], et.values[0]), j(_e.values[1], et.values[1]), j(_e.values[2], et.values[2])];
    return recomposeColor({
        type: "rgb",
        values: tt
    })
}
const common$1 = {
        black: "#000",
        white: "#fff"
    },
    grey = {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#eeeeee",
        300: "#e0e0e0",
        400: "#bdbdbd",
        500: "#9e9e9e",
        600: "#757575",
        700: "#616161",
        800: "#424242",
        900: "#212121",
        A100: "#f5f5f5",
        A200: "#eeeeee",
        A400: "#bdbdbd",
        A700: "#616161"
    },
    purple = {
        50: "#f3e5f5",
        100: "#e1bee7",
        200: "#ce93d8",
        300: "#ba68c8",
        400: "#ab47bc",
        500: "#9c27b0",
        600: "#8e24aa",
        700: "#7b1fa2",
        800: "#6a1b9a",
        900: "#4a148c",
        A100: "#ea80fc",
        A200: "#e040fb",
        A400: "#d500f9",
        A700: "#aa00ff"
    },
    red = {
        50: "#ffebee",
        100: "#ffcdd2",
        200: "#ef9a9a",
        300: "#e57373",
        400: "#ef5350",
        500: "#f44336",
        600: "#e53935",
        700: "#d32f2f",
        800: "#c62828",
        900: "#b71c1c",
        A100: "#ff8a80",
        A200: "#ff5252",
        A400: "#ff1744",
        A700: "#d50000"
    },
    orange = {
        50: "#fff3e0",
        100: "#ffe0b2",
        200: "#ffcc80",
        300: "#ffb74d",
        400: "#ffa726",
        500: "#ff9800",
        600: "#fb8c00",
        700: "#f57c00",
        800: "#ef6c00",
        900: "#e65100",
        A100: "#ffd180",
        A200: "#ffab40",
        A400: "#ff9100",
        A700: "#ff6d00"
    },
    blue = {
        50: "#e3f2fd",
        100: "#bbdefb",
        200: "#90caf9",
        300: "#64b5f6",
        400: "#42a5f5",
        500: "#2196f3",
        600: "#1e88e5",
        700: "#1976d2",
        800: "#1565c0",
        900: "#0d47a1",
        A100: "#82b1ff",
        A200: "#448aff",
        A400: "#2979ff",
        A700: "#2962ff"
    },
    lightBlue = {
        50: "#e1f5fe",
        100: "#b3e5fc",
        200: "#81d4fa",
        300: "#4fc3f7",
        400: "#29b6f6",
        500: "#03a9f4",
        600: "#039be5",
        700: "#0288d1",
        800: "#0277bd",
        900: "#01579b",
        A100: "#80d8ff",
        A200: "#40c4ff",
        A400: "#00b0ff",
        A700: "#0091ea"
    },
    green = {
        50: "#e8f5e9",
        100: "#c8e6c9",
        200: "#a5d6a7",
        300: "#81c784",
        400: "#66bb6a",
        500: "#4caf50",
        600: "#43a047",
        700: "#388e3c",
        800: "#2e7d32",
        900: "#1b5e20",
        A100: "#b9f6ca",
        A200: "#69f0ae",
        A400: "#00e676",
        A700: "#00c853"
    },
    _excluded$18 = ["mode", "contrastThreshold", "tonalOffset"],
    light = {
        text: {
            primary: "rgba(0, 0, 0, 0.87)",
            secondary: "rgba(0, 0, 0, 0.6)",
            disabled: "rgba(0, 0, 0, 0.38)"
        },
        divider: "rgba(0, 0, 0, 0.12)",
        background: {
            paper: common$1.white,
            default: common$1.white
        },
        action: {
            active: "rgba(0, 0, 0, 0.54)",
            hover: "rgba(0, 0, 0, 0.04)",
            hoverOpacity: .04,
            selected: "rgba(0, 0, 0, 0.08)",
            selectedOpacity: .08,
            disabled: "rgba(0, 0, 0, 0.26)",
            disabledBackground: "rgba(0, 0, 0, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(0, 0, 0, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .12
        }
    },
    dark = {
        text: {
            primary: common$1.white,
            secondary: "rgba(255, 255, 255, 0.7)",
            disabled: "rgba(255, 255, 255, 0.5)",
            icon: "rgba(255, 255, 255, 0.5)"
        },
        divider: "rgba(255, 255, 255, 0.12)",
        background: {
            paper: "#121212",
            default: "#121212"
        },
        action: {
            active: common$1.white,
            hover: "rgba(255, 255, 255, 0.08)",
            hoverOpacity: .08,
            selected: "rgba(255, 255, 255, 0.16)",
            selectedOpacity: .16,
            disabled: "rgba(255, 255, 255, 0.3)",
            disabledBackground: "rgba(255, 255, 255, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(255, 255, 255, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .24
        }
    };

function addLightOrDark(s, o, a, $) {
    const j = $.light || $,
        _e = $.dark || $ * 1.5;
    s[o] || (s.hasOwnProperty(a) ? s[o] = s[a] : o === "light" ? s.light = lighten_1(s.main, j) : o === "dark" && (s.dark = darken_1(s.main, _e)))
}

function getDefaultPrimary(s = "light") {
    return s === "dark" ? {
        main: blue[200],
        light: blue[50],
        dark: blue[400]
    } : {
        main: blue[700],
        light: blue[400],
        dark: blue[800]
    }
}

function getDefaultSecondary(s = "light") {
    return s === "dark" ? {
        main: purple[200],
        light: purple[50],
        dark: purple[400]
    } : {
        main: purple[500],
        light: purple[300],
        dark: purple[700]
    }
}

function getDefaultError(s = "light") {
    return s === "dark" ? {
        main: red[500],
        light: red[300],
        dark: red[700]
    } : {
        main: red[700],
        light: red[400],
        dark: red[800]
    }
}

function getDefaultInfo(s = "light") {
    return s === "dark" ? {
        main: lightBlue[400],
        light: lightBlue[300],
        dark: lightBlue[700]
    } : {
        main: lightBlue[700],
        light: lightBlue[500],
        dark: lightBlue[900]
    }
}

function getDefaultSuccess(s = "light") {
    return s === "dark" ? {
        main: green[400],
        light: green[300],
        dark: green[700]
    } : {
        main: green[800],
        light: green[500],
        dark: green[900]
    }
}

function getDefaultWarning(s = "light") {
    return s === "dark" ? {
        main: orange[400],
        light: orange[300],
        dark: orange[700]
    } : {
        main: "#ed6c02",
        light: orange[500],
        dark: orange[900]
    }
}

function createPalette(s) {
    const {
        mode: o = "light",
        contrastThreshold: a = 3,
        tonalOffset: $ = .2
    } = s, j = _objectWithoutPropertiesLoose$1(s, _excluded$18), _e = s.primary || getDefaultPrimary(o), et = s.secondary || getDefaultSecondary(o), tt = s.error || getDefaultError(o), nt = s.info || getDefaultInfo(o), rt = s.success || getDefaultSuccess(o), ot = s.warning || getDefaultWarning(o);

    function st(bt) {
        return getContrastRatio_1(bt, dark.text.primary) >= a ? dark.text.primary : light.text.primary
    }
    const lt = ({
            color: bt,
            name: ht,
            mainShade: vt = 500,
            lightShade: wt = 300,
            darkShade: gt = 700
        }) => {
            if (bt = _extends$4({}, bt), !bt.main && bt[vt] && (bt.main = bt[vt]), !bt.hasOwnProperty("main")) throw new Error(formatMuiErrorMessage$1(11, ht ? ` (${ht})` : "", vt));
            if (typeof bt.main != "string") throw new Error(formatMuiErrorMessage$1(12, ht ? ` (${ht})` : "", JSON.stringify(bt.main)));
            return addLightOrDark(bt, "light", wt, $), addLightOrDark(bt, "dark", gt, $), bt.contrastText || (bt.contrastText = st(bt.main)), bt
        },
        ft = {
            dark,
            light
        };
    return deepmerge$1(_extends$4({
        common: _extends$4({}, common$1),
        mode: o,
        primary: lt({
            color: _e,
            name: "primary"
        }),
        secondary: lt({
            color: et,
            name: "secondary",
            mainShade: "A400",
            lightShade: "A200",
            darkShade: "A700"
        }),
        error: lt({
            color: tt,
            name: "error"
        }),
        warning: lt({
            color: ot,
            name: "warning"
        }),
        info: lt({
            color: nt,
            name: "info"
        }),
        success: lt({
            color: rt,
            name: "success"
        }),
        grey,
        contrastThreshold: a,
        getContrastText: st,
        augmentColor: lt,
        tonalOffset: $
    }, ft[o]), j)
}
const _excluded$17 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];

function round$2(s) {
    return Math.round(s * 1e5) / 1e5
}
const caseAllCaps = {
        textTransform: "uppercase"
    },
    defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';

function createTypography(s, o) {
    const a = typeof o == "function" ? o(s) : o,
        {
            fontFamily: $ = defaultFontFamily,
            fontSize: j = 14,
            fontWeightLight: _e = 300,
            fontWeightRegular: et = 400,
            fontWeightMedium: tt = 500,
            fontWeightBold: nt = 700,
            htmlFontSize: rt = 16,
            allVariants: ot,
            pxToRem: st
        } = a,
        lt = _objectWithoutPropertiesLoose$1(a, _excluded$17),
        ft = j / 14,
        yt = st || (vt => `${vt/rt*ft}rem`),
        bt = (vt, wt, gt, At, Pt) => _extends$4({
            fontFamily: $,
            fontWeight: vt,
            fontSize: yt(wt),
            lineHeight: gt
        }, $ === defaultFontFamily ? {
            letterSpacing: `${round$2(At/wt)}em`
        } : {}, Pt, ot),
        ht = {
            h1: bt(_e, 96, 1.167, -1.5),
            h2: bt(_e, 60, 1.2, -.5),
            h3: bt(et, 48, 1.167, 0),
            h4: bt(et, 34, 1.235, .25),
            h5: bt(et, 24, 1.334, 0),
            h6: bt(tt, 20, 1.6, .15),
            subtitle1: bt(et, 16, 1.75, .15),
            subtitle2: bt(tt, 14, 1.57, .1),
            body1: bt(et, 16, 1.5, .15),
            body2: bt(et, 14, 1.43, .15),
            button: bt(tt, 14, 1.75, .4, caseAllCaps),
            caption: bt(et, 12, 1.66, .4),
            overline: bt(et, 12, 2.66, 1, caseAllCaps),
            inherit: {
                fontFamily: "inherit",
                fontWeight: "inherit",
                fontSize: "inherit",
                lineHeight: "inherit",
                letterSpacing: "inherit"
            }
        };
    return deepmerge$1(_extends$4({
        htmlFontSize: rt,
        pxToRem: yt,
        fontFamily: $,
        fontSize: j,
        fontWeightLight: _e,
        fontWeightRegular: et,
        fontWeightMedium: tt,
        fontWeightBold: nt
    }, ht), lt, {
        clone: !1
    })
}
const shadowKeyUmbraOpacity = .2,
    shadowKeyPenumbraOpacity = .14,
    shadowAmbientShadowOpacity = .12;

function createShadow(...s) {
    return [`${s[0]}px ${s[1]}px ${s[2]}px ${s[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${s[4]}px ${s[5]}px ${s[6]}px ${s[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${s[8]}px ${s[9]}px ${s[10]}px ${s[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",")
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)],
    _excluded$16 = ["duration", "easing", "delay"],
    easing = {
        easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
        easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
        easeIn: "cubic-bezier(0.4, 0, 1, 1)",
        sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    },
    duration = {
        shortest: 150,
        shorter: 200,
        short: 250,
        standard: 300,
        complex: 375,
        enteringScreen: 225,
        leavingScreen: 195
    };

function formatMs(s) {
    return `${Math.round(s)}ms`
}

function getAutoHeightDuration(s) {
    if (!s) return 0;
    const o = s / 36;
    return Math.round((4 + 15 * o ** .25 + o / 5) * 10)
}

function createTransitions(s) {
    const o = _extends$4({}, easing, s.easing),
        a = _extends$4({}, duration, s.duration);
    return _extends$4({
        getAutoHeightDuration,
        create: (j = ["all"], _e = {}) => {
            const {
                duration: et = a.standard,
                easing: tt = o.easeInOut,
                delay: nt = 0
            } = _e;
            return _objectWithoutPropertiesLoose$1(_e, _excluded$16), (Array.isArray(j) ? j : [j]).map(rt => `${rt} ${typeof et=="string"?et:formatMs(et)} ${tt} ${typeof nt=="string"?nt:formatMs(nt)}`).join(",")
        }
    }, s, {
        easing: o,
        duration: a
    })
}
const zIndex = {
        mobileStepper: 1e3,
        fab: 1050,
        speedDial: 1050,
        appBar: 1100,
        drawer: 1200,
        modal: 1300,
        snackbar: 1400,
        tooltip: 1500
    },
    _excluded$15 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];

function createTheme(s = {}, ...o) {
    const {
        mixins: a = {},
        palette: $ = {},
        transitions: j = {},
        typography: _e = {}
    } = s, et = _objectWithoutPropertiesLoose$1(s, _excluded$15);
    if (s.vars) throw new Error(formatMuiErrorMessage$1(18));
    const tt = createPalette($),
        nt = createTheme$2(s);
    let rt = deepmerge$1(nt, {
        mixins: createMixins(nt.breakpoints, a),
        palette: tt,
        shadows: shadows.slice(),
        typography: createTypography(tt, _e),
        transitions: createTransitions(j),
        zIndex: _extends$4({}, zIndex)
    });
    return rt = deepmerge$1(rt, et), rt = o.reduce((ot, st) => deepmerge$1(ot, st), rt), rt.unstable_sxConfig = _extends$4({}, defaultSxConfig, et == null ? void 0 : et.unstable_sxConfig), rt.unstable_sx = function(st) {
        return styleFunctionSx$1({
            sx: st,
            theme: this
        })
    }, rt
}
const defaultTheme$1 = createTheme();

function useTheme$1() {
    const s = useTheme$3(defaultTheme$1);
    return s[THEME_ID] || s
}
var createStyled$1 = {},
    objectWithoutPropertiesLoose = {
        exports: {}
    },
    hasRequiredObjectWithoutPropertiesLoose;

function requireObjectWithoutPropertiesLoose() {
    return hasRequiredObjectWithoutPropertiesLoose || (hasRequiredObjectWithoutPropertiesLoose = 1, function(s) {
        function o(a, $) {
            if (a == null) return {};
            var j = {};
            for (var _e in a)
                if ({}.hasOwnProperty.call(a, _e)) {
                    if ($.includes(_e)) continue;
                    j[_e] = a[_e]
                }
            return j
        }
        s.exports = o, s.exports.__esModule = !0, s.exports.default = s.exports
    }(objectWithoutPropertiesLoose)), objectWithoutPropertiesLoose.exports
}
const require$$1$2 = getAugmentedNamespace(styledEngine),
    require$$4$1 = getAugmentedNamespace(deepmerge),
    require$$5 = getAugmentedNamespace(capitalize),
    require$$6 = getAugmentedNamespace(getDisplayName),
    require$$7 = getAugmentedNamespace(createTheme$1),
    require$$8 = getAugmentedNamespace(styleFunctionSx);
var _interopRequireDefault$4 = interopRequireDefaultExports;
Object.defineProperty(createStyled$1, "__esModule", {
    value: !0
});
var _default = createStyled$1.default = createStyled;
createStyled$1.shouldForwardProp = shouldForwardProp;
createStyled$1.systemDefaultTheme = void 0;
var _extends2 = _interopRequireDefault$4(require_extends()),
    _objectWithoutPropertiesLoose2 = _interopRequireDefault$4(requireObjectWithoutPropertiesLoose()),
    _styledEngine$1 = _interopRequireWildcard$1(require$$1$2),
    _deepmerge = require$$4$1;
_interopRequireDefault$4(require$$5);
_interopRequireDefault$4(require$$6);
var _createTheme = _interopRequireDefault$4(require$$7),
    _styleFunctionSx = _interopRequireDefault$4(require$$8);
const _excluded$14 = ["ownerState"],
    _excluded2$8 = ["variants"],
    _excluded3$2 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];

function _getRequireWildcardCache$1(s) {
    if (typeof WeakMap != "function") return null;
    var o = new WeakMap,
        a = new WeakMap;
    return (_getRequireWildcardCache$1 = function($) {
        return $ ? a : o
    })(s)
}

function _interopRequireWildcard$1(s, o) {
    if (s && s.__esModule) return s;
    if (s === null || typeof s != "object" && typeof s != "function") return {
        default: s
    };
    var a = _getRequireWildcardCache$1(o);
    if (a && a.has(s)) return a.get(s);
    var $ = {
            __proto__: null
        },
        j = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var _e in s)
        if (_e !== "default" && Object.prototype.hasOwnProperty.call(s, _e)) {
            var et = j ? Object.getOwnPropertyDescriptor(s, _e) : null;
            et && (et.get || et.set) ? Object.defineProperty($, _e, et) : $[_e] = s[_e]
        }
    return $.default = s, a && a.set(s, $), $
}

function isEmpty$2(s) {
    return Object.keys(s).length === 0
}

function isStringTag(s) {
    return typeof s == "string" && s.charCodeAt(0) > 96
}

function shouldForwardProp(s) {
    return s !== "ownerState" && s !== "theme" && s !== "sx" && s !== "as"
}
const systemDefaultTheme = createStyled$1.systemDefaultTheme = (0, _createTheme.default)(),
    lowercaseFirstLetter = s => s && s.charAt(0).toLowerCase() + s.slice(1);

function resolveTheme({
    defaultTheme: s,
    theme: o,
    themeId: a
}) {
    return isEmpty$2(o) ? s : o[a] || o
}

function defaultOverridesResolver(s) {
    return s ? (o, a) => a[s] : null
}

function processStyleArg(s, o) {
    let {
        ownerState: a
    } = o, $ = (0, _objectWithoutPropertiesLoose2.default)(o, _excluded$14);
    const j = typeof s == "function" ? s((0, _extends2.default)({
        ownerState: a
    }, $)) : s;
    if (Array.isArray(j)) return j.flatMap(_e => processStyleArg(_e, (0, _extends2.default)({
        ownerState: a
    }, $)));
    if (j && typeof j == "object" && Array.isArray(j.variants)) {
        const {
            variants: _e = []
        } = j;
        let tt = (0, _objectWithoutPropertiesLoose2.default)(j, _excluded2$8);
        return _e.forEach(nt => {
            let rt = !0;
            typeof nt.props == "function" ? rt = nt.props((0, _extends2.default)({
                ownerState: a
            }, $, a)) : Object.keys(nt.props).forEach(ot => {
                (a == null ? void 0 : a[ot]) !== nt.props[ot] && $[ot] !== nt.props[ot] && (rt = !1)
            }), rt && (Array.isArray(tt) || (tt = [tt]), tt.push(typeof nt.style == "function" ? nt.style((0, _extends2.default)({
                ownerState: a
            }, $, a)) : nt.style))
        }), tt
    }
    return j
}

function createStyled(s = {}) {
    const {
        themeId: o,
        defaultTheme: a = systemDefaultTheme,
        rootShouldForwardProp: $ = shouldForwardProp,
        slotShouldForwardProp: j = shouldForwardProp
    } = s, _e = et => (0, _styleFunctionSx.default)((0, _extends2.default)({}, et, {
        theme: resolveTheme((0, _extends2.default)({}, et, {
            defaultTheme: a,
            themeId: o
        }))
    }));
    return _e.__mui_systemSx = !0, (et, tt = {}) => {
        (0, _styledEngine$1.internal_processStyles)(et, Pt => Pt.filter(Bt => !(Bt != null && Bt.__mui_systemSx)));
        const {
            name: nt,
            slot: rt,
            skipVariantsResolver: ot,
            skipSx: st,
            overridesResolver: lt = defaultOverridesResolver(lowercaseFirstLetter(rt))
        } = tt, ft = (0, _objectWithoutPropertiesLoose2.default)(tt, _excluded3$2), yt = ot !== void 0 ? ot : rt && rt !== "Root" && rt !== "root" || !1, bt = st || !1;
        let ht, vt = shouldForwardProp;
        rt === "Root" || rt === "root" ? vt = $ : rt ? vt = j : isStringTag(et) && (vt = void 0);
        const wt = (0, _styledEngine$1.default)(et, (0, _extends2.default)({
                shouldForwardProp: vt,
                label: ht
            }, ft)),
            gt = Pt => typeof Pt == "function" && Pt.__emotion_real !== Pt || (0, _deepmerge.isPlainObject)(Pt) ? Bt => processStyleArg(Pt, (0, _extends2.default)({}, Bt, {
                theme: resolveTheme({
                    theme: Bt.theme,
                    defaultTheme: a,
                    themeId: o
                })
            })) : Pt,
            At = (Pt, ...Bt) => {
                let Lt = gt(Pt);
                const Nt = Bt ? Bt.map(gt) : [];
                nt && lt && Nt.push(Ft => {
                    const Wt = resolveTheme((0, _extends2.default)({}, Ft, {
                        defaultTheme: a,
                        themeId: o
                    }));
                    if (!Wt.components || !Wt.components[nt] || !Wt.components[nt].styleOverrides) return null;
                    const Ct = Wt.components[nt].styleOverrides,
                        it = {};
                    return Object.entries(Ct).forEach(([at, mt]) => {
                        it[at] = processStyleArg(mt, (0, _extends2.default)({}, Ft, {
                            theme: Wt
                        }))
                    }), lt(Ft, it)
                }), nt && !yt && Nt.push(Ft => {
                    var Wt;
                    const Ct = resolveTheme((0, _extends2.default)({}, Ft, {
                            defaultTheme: a,
                            themeId: o
                        })),
                        it = Ct == null || (Wt = Ct.components) == null || (Wt = Wt[nt]) == null ? void 0 : Wt.variants;
                    return processStyleArg({
                        variants: it
                    }, (0, _extends2.default)({}, Ft, {
                        theme: Ct
                    }))
                }), bt || Nt.push(_e);
                const Ut = Nt.length - Bt.length;
                if (Array.isArray(Pt) && Ut > 0) {
                    const Ft = new Array(Ut).fill("");
                    Lt = [...Pt, ...Ft], Lt.raw = [...Pt.raw, ...Ft]
                }
                const Vt = wt(Lt, ...Nt);
                return et.muiName && (Vt.muiName = et.muiName), Vt
            };
        return wt.withConfig && (At.withConfig = wt.withConfig), At
    }
}

function slotShouldForwardProp(s) {
    return s !== "ownerState" && s !== "theme" && s !== "sx" && s !== "as"
}
const rootShouldForwardProp = s => slotShouldForwardProp(s) && s !== "classes",
    styled = _default({
        themeId: THEME_ID,
        defaultTheme: defaultTheme$1,
        rootShouldForwardProp
    }),
    _excluded$13 = ["theme"];

function ThemeProvider(s) {
    let {
        theme: o
    } = s, a = _objectWithoutPropertiesLoose$1(s, _excluded$13);
    const $ = o[THEME_ID];
    return jsxRuntimeExports.jsx(ThemeProvider$1, _extends$4({}, a, {
        themeId: $ ? THEME_ID : void 0,
        theme: $ || o
    }))
}
const getOverlayAlpha = s => {
    let o;
    return s < 1 ? o = 5.11916 * s ** 2 : o = 4.5 * Math.log(s + 1) + 2, (o / 100).toFixed(2)
};
/**
 * @remix-run/router v1.19.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
    return _extends$2 = Object.assign ? Object.assign.bind() : function(s) {
        for (var o = 1; o < arguments.length; o++) {
            var a = arguments[o];
            for (var $ in a) Object.prototype.hasOwnProperty.call(a, $) && (s[$] = a[$])
        }
        return s
    }, _extends$2.apply(this, arguments)
}
var Action;
(function(s) {
    s.Pop = "POP", s.Push = "PUSH", s.Replace = "REPLACE"
})(Action || (Action = {}));
const PopStateEventType = "popstate";

function createBrowserHistory(s) {
    s === void 0 && (s = {});

    function o($, j) {
        let {
            pathname: _e,
            search: et,
            hash: tt
        } = $.location;
        return createLocation("", {
            pathname: _e,
            search: et,
            hash: tt
        }, j.state && j.state.usr || null, j.state && j.state.key || "default")
    }

    function a($, j) {
        return typeof j == "string" ? j : createPath(j)
    }
    return getUrlBasedHistory(o, a, null, s)
}

function invariant$1(s, o) {
    if (s === !1 || s === null || typeof s > "u") throw new Error(o)
}

function warning(s, o) {
    if (!s) {
        typeof console < "u" && console.warn(o);
        try {
            throw new Error(o)
        } catch {}
    }
}

function createKey() {
    return Math.random().toString(36).substr(2, 8)
}

function getHistoryState(s, o) {
    return {
        usr: s.state,
        key: s.key,
        idx: o
    }
}

function createLocation(s, o, a, $) {
    return a === void 0 && (a = null), _extends$2({
        pathname: typeof s == "string" ? s : s.pathname,
        search: "",
        hash: ""
    }, typeof o == "string" ? parsePath(o) : o, {
        state: a,
        key: o && o.key || $ || createKey()
    })
}

function createPath(s) {
    let {
        pathname: o = "/",
        search: a = "",
        hash: $ = ""
    } = s;
    return a && a !== "?" && (o += a.charAt(0) === "?" ? a : "?" + a), $ && $ !== "#" && (o += $.charAt(0) === "#" ? $ : "#" + $), o
}

function parsePath(s) {
    let o = {};
    if (s) {
        let a = s.indexOf("#");
        a >= 0 && (o.hash = s.substr(a), s = s.substr(0, a));
        let $ = s.indexOf("?");
        $ >= 0 && (o.search = s.substr($), s = s.substr(0, $)), s && (o.pathname = s)
    }
    return o
}

function getUrlBasedHistory(s, o, a, $) {
    $ === void 0 && ($ = {});
    let {
        window: j = document.defaultView,
        v5Compat: _e = !1
    } = $, et = j.history, tt = Action.Pop, nt = null, rt = ot();
    rt == null && (rt = 0, et.replaceState(_extends$2({}, et.state, {
        idx: rt
    }), ""));

    function ot() {
        return (et.state || {
            idx: null
        }).idx
    }

    function st() {
        tt = Action.Pop;
        let ht = ot(),
            vt = ht == null ? null : ht - rt;
        rt = ht, nt && nt({
            action: tt,
            location: bt.location,
            delta: vt
        })
    }

    function lt(ht, vt) {
        tt = Action.Push;
        let wt = createLocation(bt.location, ht, vt);
        rt = ot() + 1;
        let gt = getHistoryState(wt, rt),
            At = bt.createHref(wt);
        try {
            et.pushState(gt, "", At)
        } catch (Pt) {
            if (Pt instanceof DOMException && Pt.name === "DataCloneError") throw Pt;
            j.location.assign(At)
        }
        _e && nt && nt({
            action: tt,
            location: bt.location,
            delta: 1
        })
    }

    function ft(ht, vt) {
        tt = Action.Replace;
        let wt = createLocation(bt.location, ht, vt);
        rt = ot();
        let gt = getHistoryState(wt, rt),
            At = bt.createHref(wt);
        et.replaceState(gt, "", At), _e && nt && nt({
            action: tt,
            location: bt.location,
            delta: 0
        })
    }

    function yt(ht) {
        let vt = j.location.origin !== "null" ? j.location.origin : j.location.href,
            wt = typeof ht == "string" ? ht : createPath(ht);
        return wt = wt.replace(/ $/, "%20"), invariant$1(vt, "No window.location.(origin|href) available to create URL for href: " + wt), new URL(wt, vt)
    }
    let bt = {
        get action() {
            return tt
        },
        get location() {
            return s(j, et)
        },
        listen(ht) {
            if (nt) throw new Error("A history only accepts one active listener");
            return j.addEventListener(PopStateEventType, st), nt = ht, () => {
                j.removeEventListener(PopStateEventType, st), nt = null
            }
        },
        createHref(ht) {
            return o(j, ht)
        },
        createURL: yt,
        encodeLocation(ht) {
            let vt = yt(ht);
            return {
                pathname: vt.pathname,
                search: vt.search,
                hash: vt.hash
            }
        },
        push: lt,
        replace: ft,
        go(ht) {
            return et.go(ht)
        }
    };
    return bt
}
var ResultType;
(function(s) {
    s.data = "data", s.deferred = "deferred", s.redirect = "redirect", s.error = "error"
})(ResultType || (ResultType = {}));

function matchRoutes(s, o, a) {
    return a === void 0 && (a = "/"), matchRoutesImpl(s, o, a, !1)
}

function matchRoutesImpl(s, o, a, $) {
    let j = typeof o == "string" ? parsePath(o) : o,
        _e = stripBasename(j.pathname || "/", a);
    if (_e == null) return null;
    let et = flattenRoutes(s);
    rankRouteBranches(et);
    let tt = null;
    for (let nt = 0; tt == null && nt < et.length; ++nt) {
        let rt = decodePath(_e);
        tt = matchRouteBranch(et[nt], rt, $)
    }
    return tt
}

function flattenRoutes(s, o, a, $) {
    o === void 0 && (o = []), a === void 0 && (a = []), $ === void 0 && ($ = "");
    let j = (_e, et, tt) => {
        let nt = {
            relativePath: tt === void 0 ? _e.path || "" : tt,
            caseSensitive: _e.caseSensitive === !0,
            childrenIndex: et,
            route: _e
        };
        nt.relativePath.startsWith("/") && (invariant$1(nt.relativePath.startsWith($), 'Absolute route path "' + nt.relativePath + '" nested under path ' + ('"' + $ + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), nt.relativePath = nt.relativePath.slice($.length));
        let rt = joinPaths([$, nt.relativePath]),
            ot = a.concat(nt);
        _e.children && _e.children.length > 0 && (invariant$1(_e.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + rt + '".')), flattenRoutes(_e.children, o, ot, rt)), !(_e.path == null && !_e.index) && o.push({
            path: rt,
            score: computeScore(rt, _e.index),
            routesMeta: ot
        })
    };
    return s.forEach((_e, et) => {
        var tt;
        if (_e.path === "" || !((tt = _e.path) != null && tt.includes("?"))) j(_e, et);
        else
            for (let nt of explodeOptionalSegments(_e.path)) j(_e, et, nt)
    }), o
}

function explodeOptionalSegments(s) {
    let o = s.split("/");
    if (o.length === 0) return [];
    let [a, ...$] = o, j = a.endsWith("?"), _e = a.replace(/\?$/, "");
    if ($.length === 0) return j ? [_e, ""] : [_e];
    let et = explodeOptionalSegments($.join("/")),
        tt = [];
    return tt.push(...et.map(nt => nt === "" ? _e : [_e, nt].join("/"))), j && tt.push(...et), tt.map(nt => s.startsWith("/") && nt === "" ? "/" : nt)
}

function rankRouteBranches(s) {
    s.sort((o, a) => o.score !== a.score ? a.score - o.score : compareIndexes(o.routesMeta.map($ => $.childrenIndex), a.routesMeta.map($ => $.childrenIndex)))
}
const paramRe = /^:[\w-]+$/,
    dynamicSegmentValue = 3,
    indexRouteValue = 2,
    emptySegmentValue = 1,
    staticSegmentValue = 10,
    splatPenalty = -2,
    isSplat = s => s === "*";

function computeScore(s, o) {
    let a = s.split("/"),
        $ = a.length;
    return a.some(isSplat) && ($ += splatPenalty), o && ($ += indexRouteValue), a.filter(j => !isSplat(j)).reduce((j, _e) => j + (paramRe.test(_e) ? dynamicSegmentValue : _e === "" ? emptySegmentValue : staticSegmentValue), $)
}

function compareIndexes(s, o) {
    return s.length === o.length && s.slice(0, -1).every(($, j) => $ === o[j]) ? s[s.length - 1] - o[o.length - 1] : 0
}

function matchRouteBranch(s, o, a) {
    let {
        routesMeta: $
    } = s, j = {}, _e = "/", et = [];
    for (let tt = 0; tt < $.length; ++tt) {
        let nt = $[tt],
            rt = tt === $.length - 1,
            ot = _e === "/" ? o : o.slice(_e.length) || "/",
            st = matchPath({
                path: nt.relativePath,
                caseSensitive: nt.caseSensitive,
                end: rt
            }, ot),
            lt = nt.route;
        if (!st && rt && a && !$[$.length - 1].route.index && (st = matchPath({
                path: nt.relativePath,
                caseSensitive: nt.caseSensitive,
                end: !1
            }, ot)), !st) return null;
        Object.assign(j, st.params), et.push({
            params: j,
            pathname: joinPaths([_e, st.pathname]),
            pathnameBase: normalizePathname(joinPaths([_e, st.pathnameBase])),
            route: lt
        }), st.pathnameBase !== "/" && (_e = joinPaths([_e, st.pathnameBase]))
    }
    return et
}

function matchPath(s, o) {
    typeof s == "string" && (s = {
        path: s,
        caseSensitive: !1,
        end: !0
    });
    let [a, $] = compilePath(s.path, s.caseSensitive, s.end), j = o.match(a);
    if (!j) return null;
    let _e = j[0],
        et = _e.replace(/(.)\/+$/, "$1"),
        tt = j.slice(1);
    return {
        params: $.reduce((rt, ot, st) => {
            let {
                paramName: lt,
                isOptional: ft
            } = ot;
            if (lt === "*") {
                let bt = tt[st] || "";
                et = _e.slice(0, _e.length - bt.length).replace(/(.)\/+$/, "$1")
            }
            const yt = tt[st];
            return ft && !yt ? rt[lt] = void 0 : rt[lt] = (yt || "").replace(/%2F/g, "/"), rt
        }, {}),
        pathname: _e,
        pathnameBase: et,
        pattern: s
    }
}

function compilePath(s, o, a) {
    o === void 0 && (o = !1), a === void 0 && (a = !0), warning(s === "*" || !s.endsWith("*") || s.endsWith("/*"), 'Route path "' + s + '" will be treated as if it were ' + ('"' + s.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + s.replace(/\*$/, "/*") + '".'));
    let $ = [],
        j = "^" + s.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (et, tt, nt) => ($.push({
            paramName: tt,
            isOptional: nt != null
        }), nt ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return s.endsWith("*") ? ($.push({
        paramName: "*"
    }), j += s === "*" || s === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : a ? j += "\\/*$" : s !== "" && s !== "/" && (j += "(?:(?=\\/|$))"), [new RegExp(j, o ? void 0 : "i"), $]
}

function decodePath(s) {
    try {
        return s.split("/").map(o => decodeURIComponent(o).replace(/\//g, "%2F")).join("/")
    } catch (o) {
        return warning(!1, 'The URL path "' + s + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + o + ").")), s
    }
}

function stripBasename(s, o) {
    if (o === "/") return s;
    if (!s.toLowerCase().startsWith(o.toLowerCase())) return null;
    let a = o.endsWith("/") ? o.length - 1 : o.length,
        $ = s.charAt(a);
    return $ && $ !== "/" ? null : s.slice(a) || "/"
}

function resolvePath(s, o) {
    o === void 0 && (o = "/");
    let {
        pathname: a,
        search: $ = "",
        hash: j = ""
    } = typeof s == "string" ? parsePath(s) : s;
    return {
        pathname: a ? a.startsWith("/") ? a : resolvePathname(a, o) : o,
        search: normalizeSearch($),
        hash: normalizeHash(j)
    }
}

function resolvePathname(s, o) {
    let a = o.replace(/\/+$/, "").split("/");
    return s.split("/").forEach(j => {
        j === ".." ? a.length > 1 && a.pop() : j !== "." && a.push(j)
    }), a.length > 1 ? a.join("/") : "/"
}

function getInvalidPathError(s, o, a, $) {
    return "Cannot include a '" + s + "' character in a manually specified " + ("`to." + o + "` field [" + JSON.stringify($) + "].  Please separate it out to the ") + ("`to." + a + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}

function getPathContributingMatches(s) {
    return s.filter((o, a) => a === 0 || o.route.path && o.route.path.length > 0)
}

function getResolveToMatches(s, o) {
    let a = getPathContributingMatches(s);
    return o ? a.map(($, j) => j === a.length - 1 ? $.pathname : $.pathnameBase) : a.map($ => $.pathnameBase)
}

function resolveTo(s, o, a, $) {
    $ === void 0 && ($ = !1);
    let j;
    typeof s == "string" ? j = parsePath(s) : (j = _extends$2({}, s), invariant$1(!j.pathname || !j.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", j)), invariant$1(!j.pathname || !j.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", j)), invariant$1(!j.search || !j.search.includes("#"), getInvalidPathError("#", "search", "hash", j)));
    let _e = s === "" || j.pathname === "",
        et = _e ? "/" : j.pathname,
        tt;
    if (et == null) tt = a;
    else {
        let st = o.length - 1;
        if (!$ && et.startsWith("..")) {
            let lt = et.split("/");
            for (; lt[0] === "..";) lt.shift(), st -= 1;
            j.pathname = lt.join("/")
        }
        tt = st >= 0 ? o[st] : "/"
    }
    let nt = resolvePath(j, tt),
        rt = et && et !== "/" && et.endsWith("/"),
        ot = (_e || et === ".") && a.endsWith("/");
    return !nt.pathname.endsWith("/") && (rt || ot) && (nt.pathname += "/"), nt
}
const joinPaths = s => s.join("/").replace(/\/\/+/g, "/"),
    normalizePathname = s => s.replace(/\/+$/, "").replace(/^\/*/, "/"),
    normalizeSearch = s => !s || s === "?" ? "" : s.startsWith("?") ? s : "?" + s,
    normalizeHash = s => !s || s === "#" ? "" : s.startsWith("#") ? s : "#" + s;

function isRouteErrorResponse(s) {
    return s != null && typeof s.status == "number" && typeof s.statusText == "string" && typeof s.internal == "boolean" && "data" in s
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.26.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(s) {
        for (var o = 1; o < arguments.length; o++) {
            var a = arguments[o];
            for (var $ in a) Object.prototype.hasOwnProperty.call(a, $) && (s[$] = a[$])
        }
        return s
    }, _extends$1.apply(this, arguments)
}
const DataRouterContext = reactExports.createContext(null),
    DataRouterStateContext = reactExports.createContext(null),
    NavigationContext = reactExports.createContext(null),
    LocationContext = reactExports.createContext(null),
    RouteContext = reactExports.createContext({
        outlet: null,
        matches: [],
        isDataRoute: !1
    }),
    RouteErrorContext = reactExports.createContext(null);

function useHref(s, o) {
    let {
        relative: a
    } = o === void 0 ? {} : o;
    useInRouterContext() || invariant$1(!1);
    let {
        basename: $,
        navigator: j
    } = reactExports.useContext(NavigationContext), {
        hash: _e,
        pathname: et,
        search: tt
    } = useResolvedPath(s, {
        relative: a
    }), nt = et;
    return $ !== "/" && (nt = et === "/" ? $ : joinPaths([$, et])), j.createHref({
        pathname: nt,
        search: tt,
        hash: _e
    })
}

function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}

function useLocation() {
    return useInRouterContext() || invariant$1(!1), reactExports.useContext(LocationContext).location
}

function useIsomorphicLayoutEffect$1(s) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(s)
}

function useNavigate() {
    let {
        isDataRoute: s
    } = reactExports.useContext(RouteContext);
    return s ? useNavigateStable() : useNavigateUnstable()
}

function useNavigateUnstable() {
    useInRouterContext() || invariant$1(!1);
    let s = reactExports.useContext(DataRouterContext),
        {
            basename: o,
            future: a,
            navigator: $
        } = reactExports.useContext(NavigationContext),
        {
            matches: j
        } = reactExports.useContext(RouteContext),
        {
            pathname: _e
        } = useLocation(),
        et = JSON.stringify(getResolveToMatches(j, a.v7_relativeSplatPath)),
        tt = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$1(() => {
        tt.current = !0
    }), reactExports.useCallback(function(rt, ot) {
        if (ot === void 0 && (ot = {}), !tt.current) return;
        if (typeof rt == "number") {
            $.go(rt);
            return
        }
        let st = resolveTo(rt, JSON.parse(et), _e, ot.relative === "path");
        s == null && o !== "/" && (st.pathname = st.pathname === "/" ? o : joinPaths([o, st.pathname])), (ot.replace ? $.replace : $.push)(st, ot.state, ot)
    }, [o, $, et, _e, s])
}
const OutletContext = reactExports.createContext(null);

function useOutlet(s) {
    let o = reactExports.useContext(RouteContext).outlet;
    return o && reactExports.createElement(OutletContext.Provider, {
        value: s
    }, o)
}

function useResolvedPath(s, o) {
    let {
        relative: a
    } = o === void 0 ? {} : o, {
        future: $
    } = reactExports.useContext(NavigationContext), {
        matches: j
    } = reactExports.useContext(RouteContext), {
        pathname: _e
    } = useLocation(), et = JSON.stringify(getResolveToMatches(j, $.v7_relativeSplatPath));
    return reactExports.useMemo(() => resolveTo(s, JSON.parse(et), _e, a === "path"), [s, et, _e, a])
}

function useRoutes(s, o) {
    return useRoutesImpl(s, o)
}

function useRoutesImpl(s, o, a, $) {
    useInRouterContext() || invariant$1(!1);
    let {
        navigator: j
    } = reactExports.useContext(NavigationContext), {
        matches: _e
    } = reactExports.useContext(RouteContext), et = _e[_e.length - 1], tt = et ? et.params : {};
    et && et.pathname;
    let nt = et ? et.pathnameBase : "/";
    et && et.route;
    let rt = useLocation(),
        ot;
    if (o) {
        var st;
        let ht = typeof o == "string" ? parsePath(o) : o;
        nt === "/" || (st = ht.pathname) != null && st.startsWith(nt) || invariant$1(!1), ot = ht
    } else ot = rt;
    let lt = ot.pathname || "/",
        ft = lt;
    if (nt !== "/") {
        let ht = nt.replace(/^\//, "").split("/");
        ft = "/" + lt.replace(/^\//, "").split("/").slice(ht.length).join("/")
    }
    let yt = matchRoutes(s, {
            pathname: ft
        }),
        bt = _renderMatches(yt && yt.map(ht => Object.assign({}, ht, {
            params: Object.assign({}, tt, ht.params),
            pathname: joinPaths([nt, j.encodeLocation ? j.encodeLocation(ht.pathname).pathname : ht.pathname]),
            pathnameBase: ht.pathnameBase === "/" ? nt : joinPaths([nt, j.encodeLocation ? j.encodeLocation(ht.pathnameBase).pathname : ht.pathnameBase])
        })), _e, a, $);
    return o && bt ? reactExports.createElement(LocationContext.Provider, {
        value: {
            location: _extends$1({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, ot),
            navigationType: Action.Pop
        }
    }, bt) : bt
}

function DefaultErrorComponent() {
    let s = useRouteError(),
        o = isRouteErrorResponse(s) ? s.status + " " + s.statusText : s instanceof Error ? s.message : JSON.stringify(s),
        a = s instanceof Error ? s.stack : null,
        j = {
            padding: "0.5rem",
            backgroundColor: "rgba(200,200,200, 0.5)"
        };
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, o), a ? reactExports.createElement("pre", {
        style: j
    }, a) : null, null)
}
const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
    constructor(o) {
        super(o), this.state = {
            location: o.location,
            revalidation: o.revalidation,
            error: o.error
        }
    }
    static getDerivedStateFromError(o) {
        return {
            error: o
        }
    }
    static getDerivedStateFromProps(o, a) {
        return a.location !== o.location || a.revalidation !== "idle" && o.revalidation === "idle" ? {
            error: o.error,
            location: o.location,
            revalidation: o.revalidation
        } : {
            error: o.error !== void 0 ? o.error : a.error,
            location: a.location,
            revalidation: o.revalidation || a.revalidation
        }
    }
    componentDidCatch(o, a) {
        console.error("React Router caught the following error during render", o, a)
    }
    render() {
        return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}

function RenderedRoute(s) {
    let {
        routeContext: o,
        match: a,
        children: $
    } = s, j = reactExports.useContext(DataRouterContext);
    return j && j.static && j.staticContext && (a.route.errorElement || a.route.ErrorBoundary) && (j.staticContext._deepestRenderedBoundaryId = a.route.id), reactExports.createElement(RouteContext.Provider, {
        value: o
    }, $)
}

function _renderMatches(s, o, a, $) {
    var j;
    if (o === void 0 && (o = []), a === void 0 && (a = null), $ === void 0 && ($ = null), s == null) {
        var _e;
        if (!a) return null;
        if (a.errors) s = a.matches;
        else if ((_e = $) != null && _e.v7_partialHydration && o.length === 0 && !a.initialized && a.matches.length > 0) s = a.matches;
        else return null
    }
    let et = s,
        tt = (j = a) == null ? void 0 : j.errors;
    if (tt != null) {
        let ot = et.findIndex(st => st.route.id && (tt == null ? void 0 : tt[st.route.id]) !== void 0);
        ot >= 0 || invariant$1(!1), et = et.slice(0, Math.min(et.length, ot + 1))
    }
    let nt = !1,
        rt = -1;
    if (a && $ && $.v7_partialHydration)
        for (let ot = 0; ot < et.length; ot++) {
            let st = et[ot];
            if ((st.route.HydrateFallback || st.route.hydrateFallbackElement) && (rt = ot), st.route.id) {
                let {
                    loaderData: lt,
                    errors: ft
                } = a, yt = st.route.loader && lt[st.route.id] === void 0 && (!ft || ft[st.route.id] === void 0);
                if (st.route.lazy || yt) {
                    nt = !0, rt >= 0 ? et = et.slice(0, rt + 1) : et = [et[0]];
                    break
                }
            }
        }
    return et.reduceRight((ot, st, lt) => {
        let ft, yt = !1,
            bt = null,
            ht = null;
        a && (ft = tt && st.route.id ? tt[st.route.id] : void 0, bt = st.route.errorElement || defaultErrorElement, nt && (rt < 0 && lt === 0 ? (yt = !0, ht = null) : rt === lt && (yt = !0, ht = st.route.hydrateFallbackElement || null)));
        let vt = o.concat(et.slice(0, lt + 1)),
            wt = () => {
                let gt;
                return ft ? gt = bt : yt ? gt = ht : st.route.Component ? gt = reactExports.createElement(st.route.Component, null) : st.route.element ? gt = st.route.element : gt = ot, reactExports.createElement(RenderedRoute, {
                    match: st,
                    routeContext: {
                        outlet: ot,
                        matches: vt,
                        isDataRoute: a != null
                    },
                    children: gt
                })
            };
        return a && (st.route.ErrorBoundary || st.route.errorElement || lt === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: a.location,
            revalidation: a.revalidation,
            component: bt,
            error: ft,
            children: wt(),
            routeContext: {
                outlet: null,
                matches: vt,
                isDataRoute: !0
            }
        }) : wt()
    }, null)
}
var DataRouterHook$1 = function(s) {
        return s.UseBlocker = "useBlocker", s.UseRevalidator = "useRevalidator", s.UseNavigateStable = "useNavigate", s
    }(DataRouterHook$1 || {}),
    DataRouterStateHook$1 = function(s) {
        return s.UseBlocker = "useBlocker", s.UseLoaderData = "useLoaderData", s.UseActionData = "useActionData", s.UseRouteError = "useRouteError", s.UseNavigation = "useNavigation", s.UseRouteLoaderData = "useRouteLoaderData", s.UseMatches = "useMatches", s.UseRevalidator = "useRevalidator", s.UseNavigateStable = "useNavigate", s.UseRouteId = "useRouteId", s
    }(DataRouterStateHook$1 || {});

function useDataRouterContext(s) {
    let o = reactExports.useContext(DataRouterContext);
    return o || invariant$1(!1), o
}

function useDataRouterState(s) {
    let o = reactExports.useContext(DataRouterStateContext);
    return o || invariant$1(!1), o
}

function useRouteContext(s) {
    let o = reactExports.useContext(RouteContext);
    return o || invariant$1(!1), o
}

function useCurrentRouteId(s) {
    let o = useRouteContext(),
        a = o.matches[o.matches.length - 1];
    return a.route.id || invariant$1(!1), a.route.id
}

function useRouteError() {
    var s;
    let o = reactExports.useContext(RouteErrorContext),
        a = useDataRouterState(DataRouterStateHook$1.UseRouteError),
        $ = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
    return o !== void 0 ? o : (s = a.errors) == null ? void 0 : s[$]
}

function useNavigateStable() {
    let {
        router: s
    } = useDataRouterContext(DataRouterHook$1.UseNavigateStable), o = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable), a = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$1(() => {
        a.current = !0
    }), reactExports.useCallback(function(j, _e) {
        _e === void 0 && (_e = {}), a.current && (typeof j == "number" ? s.navigate(j) : s.navigate(j, _extends$1({
            fromRouteId: o
        }, _e)))
    }, [s, o])
}

function Outlet(s) {
    return useOutlet(s.context)
}

function Route(s) {
    invariant$1(!1)
}

function Router(s) {
    let {
        basename: o = "/",
        children: a = null,
        location: $,
        navigationType: j = Action.Pop,
        navigator: _e,
        static: et = !1,
        future: tt
    } = s;
    useInRouterContext() && invariant$1(!1);
    let nt = o.replace(/^\/*/, "/"),
        rt = reactExports.useMemo(() => ({
            basename: nt,
            navigator: _e,
            static: et,
            future: _extends$1({
                v7_relativeSplatPath: !1
            }, tt)
        }), [nt, tt, _e, et]);
    typeof $ == "string" && ($ = parsePath($));
    let {
        pathname: ot = "/",
        search: st = "",
        hash: lt = "",
        state: ft = null,
        key: yt = "default"
    } = $, bt = reactExports.useMemo(() => {
        let ht = stripBasename(ot, nt);
        return ht == null ? null : {
            location: {
                pathname: ht,
                search: st,
                hash: lt,
                state: ft,
                key: yt
            },
            navigationType: j
        }
    }, [nt, ot, st, lt, ft, yt, j]);
    return bt == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: rt
    }, reactExports.createElement(LocationContext.Provider, {
        children: a,
        value: bt
    }))
}

function Routes$1(s) {
    let {
        children: o,
        location: a
    } = s;
    return useRoutes(createRoutesFromChildren(o), a)
}
new Promise(() => {});

function createRoutesFromChildren(s, o) {
    o === void 0 && (o = []);
    let a = [];
    return reactExports.Children.forEach(s, ($, j) => {
        if (!reactExports.isValidElement($)) return;
        let _e = [...o, j];
        if ($.type === reactExports.Fragment) {
            a.push.apply(a, createRoutesFromChildren($.props.children, _e));
            return
        }
        $.type !== Route && invariant$1(!1), !$.props.index || !$.props.children || invariant$1(!1);
        let et = {
            id: $.props.id || _e.join("-"),
            caseSensitive: $.props.caseSensitive,
            element: $.props.element,
            Component: $.props.Component,
            index: $.props.index,
            path: $.props.path,
            loader: $.props.loader,
            action: $.props.action,
            errorElement: $.props.errorElement,
            ErrorBoundary: $.props.ErrorBoundary,
            hasErrorBoundary: $.props.ErrorBoundary != null || $.props.errorElement != null,
            shouldRevalidate: $.props.shouldRevalidate,
            handle: $.props.handle,
            lazy: $.props.lazy
        };
        $.props.children && (et.children = createRoutesFromChildren($.props.children, _e)), a.push(et)
    }), a
}
/**
 * React Router DOM v6.26.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(s) {
        for (var o = 1; o < arguments.length; o++) {
            var a = arguments[o];
            for (var $ in a) Object.prototype.hasOwnProperty.call(a, $) && (s[$] = a[$])
        }
        return s
    }, _extends.apply(this, arguments)
}

function _objectWithoutPropertiesLoose(s, o) {
    if (s == null) return {};
    var a = {},
        $ = Object.keys(s),
        j, _e;
    for (_e = 0; _e < $.length; _e++) j = $[_e], !(o.indexOf(j) >= 0) && (a[j] = s[j]);
    return a
}

function isModifiedEvent(s) {
    return !!(s.metaKey || s.altKey || s.ctrlKey || s.shiftKey)
}

function shouldProcessLinkClick(s, o) {
    return s.button === 0 && (!o || o === "_self") && !isModifiedEvent(s)
}
const _excluded$12 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"],
    REACT_ROUTER_VERSION = "6";
try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION
} catch {}
const START_TRANSITION = "startTransition",
    startTransitionImpl = React$2[START_TRANSITION];

function BrowserRouter(s) {
    let {
        basename: o,
        children: a,
        future: $,
        window: j
    } = s, _e = reactExports.useRef();
    _e.current == null && (_e.current = createBrowserHistory({
        window: j,
        v5Compat: !0
    }));
    let et = _e.current,
        [tt, nt] = reactExports.useState({
            action: et.action,
            location: et.location
        }),
        {
            v7_startTransition: rt
        } = $ || {},
        ot = reactExports.useCallback(st => {
            rt && startTransitionImpl ? startTransitionImpl(() => nt(st)) : nt(st)
        }, [nt, rt]);
    return reactExports.useLayoutEffect(() => et.listen(ot), [et, ot]), reactExports.createElement(Router, {
        basename: o,
        children: a,
        location: tt.location,
        navigationType: tt.action,
        navigator: et,
        future: $
    })
}
const isBrowser$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    Link = reactExports.forwardRef(function(o, a) {
        let {
            onClick: $,
            relative: j,
            reloadDocument: _e,
            replace: et,
            state: tt,
            target: nt,
            to: rt,
            preventScrollReset: ot,
            unstable_viewTransition: st
        } = o, lt = _objectWithoutPropertiesLoose(o, _excluded$12), {
            basename: ft
        } = reactExports.useContext(NavigationContext), yt, bt = !1;
        if (typeof rt == "string" && ABSOLUTE_URL_REGEX.test(rt) && (yt = rt, isBrowser$1)) try {
            let gt = new URL(window.location.href),
                At = rt.startsWith("//") ? new URL(gt.protocol + rt) : new URL(rt),
                Pt = stripBasename(At.pathname, ft);
            At.origin === gt.origin && Pt != null ? rt = Pt + At.search + At.hash : bt = !0
        } catch {}
        let ht = useHref(rt, {
                relative: j
            }),
            vt = useLinkClickHandler(rt, {
                replace: et,
                state: tt,
                target: nt,
                preventScrollReset: ot,
                relative: j,
                unstable_viewTransition: st
            });

        function wt(gt) {
            $ && $(gt), gt.defaultPrevented || vt(gt)
        }
        return reactExports.createElement("a", _extends({}, lt, {
            href: yt || ht,
            onClick: bt || _e ? $ : wt,
            ref: a,
            target: nt
        }))
    });
var DataRouterHook;
(function(s) {
    s.UseScrollRestoration = "useScrollRestoration", s.UseSubmit = "useSubmit", s.UseSubmitFetcher = "useSubmitFetcher", s.UseFetcher = "useFetcher", s.useViewTransitionState = "useViewTransitionState"
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(s) {
    s.UseFetcher = "useFetcher", s.UseFetchers = "useFetchers", s.UseScrollRestoration = "useScrollRestoration"
})(DataRouterStateHook || (DataRouterStateHook = {}));

function useLinkClickHandler(s, o) {
    let {
        target: a,
        replace: $,
        state: j,
        preventScrollReset: _e,
        relative: et,
        unstable_viewTransition: tt
    } = o === void 0 ? {} : o, nt = useNavigate(), rt = useLocation(), ot = useResolvedPath(s, {
        relative: et
    });
    return reactExports.useCallback(st => {
        if (shouldProcessLinkClick(st, a)) {
            st.preventDefault();
            let lt = $ !== void 0 ? $ : createPath(rt) === createPath(ot);
            nt(s, {
                replace: lt,
                state: j,
                preventScrollReset: _e,
                relative: et,
                unstable_viewTransition: tt
            })
        }
    }, [rt, nt, ot, $, j, a, s, _e, et, tt])
}
const userIcon = "data:image/svg+xml,%3csvg%20width='56'%20height='39'%20viewBox='0%200%2056%2039'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M38.446%2019.3795C43.232%2019.3795%2047.132%2015.1165%2047.132%209.9295C47.132%204.8015%2043.252%200.739502%2038.446%200.739502C33.68%200.739502%2029.759%204.8615%2029.759%209.9695C29.779%2015.1365%2033.68%2019.3795%2038.446%2019.3795ZM15.282%2019.8215C19.424%2019.8215%2022.822%2016.1015%2022.822%2011.5375C22.822%207.0735%2019.464%203.4745%2015.282%203.4745C11.14%203.4745%207.722%207.1345%207.742%2011.5775C7.762%2016.1225%2011.14%2019.8215%2015.282%2019.8215ZM38.446%2016.3435C35.51%2016.3435%2032.996%2013.5285%2032.996%209.9695C32.996%206.4695%2035.47%203.7765%2038.446%203.7765C41.442%203.7765%2043.895%206.4305%2043.895%209.9285C43.895%2013.4885%2041.422%2016.3435%2038.446%2016.3435ZM15.282%2016.8255C12.829%2016.8255%2010.738%2014.4735%2010.738%2011.5775C10.738%208.7425%2012.808%206.4705%2015.282%206.4705C17.815%206.4705%2019.846%208.7025%2019.846%2011.5375C19.846%2014.4735%2017.755%2016.8255%2015.282%2016.8255ZM4.102%2038.2605H19.887C18.921%2037.7175%2018.177%2036.5105%2018.318%2035.2845H3.6C3.198%2035.2845%202.997%2035.1245%202.997%2034.7415C2.997%2029.7555%208.687%2025.0905%2015.263%2025.0905C17.796%2025.0905%2020.068%2025.6935%2022.019%2026.8395C22.6658%2026.0198%2023.4316%2025.3015%2024.291%2024.7085C21.697%2022.9985%2018.581%2022.1145%2015.263%2022.1145C6.837%2022.1145%200%2028.2265%200%2034.9225C0%2037.1545%201.367%2038.2605%204.102%2038.2605ZM25.818%2038.2605H51.074C54.411%2038.2605%2056%2037.2555%2056%2035.0435C56%2029.7755%2049.344%2022.1535%2038.446%2022.1535C27.527%2022.1535%2020.872%2029.7755%2020.872%2035.0435C20.872%2037.2555%2022.46%2038.2605%2025.818%2038.2605ZM24.853%2035.2245C24.33%2035.2245%2024.109%2035.0845%2024.109%2034.6615C24.109%2031.3635%2029.216%2025.1915%2038.446%2025.1915C47.656%2025.1915%2052.762%2031.3635%2052.762%2034.6615C52.762%2035.0835%2052.562%2035.2245%2052.038%2035.2245H24.853Z'%20fill='white'/%3e%3c/svg%3e",
    whiteCoinIcon = "/assets/white-coin-BGctmpWs.svg",
    mobilemenuIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%3e%3cdefs%3e%3cclipPath%20id='clip-path'%3e%3crect%20id='Rectangle_52'%20data-name='Rectangle%2052'%20width='20'%20height='20'%20transform='translate(307%2021)'%20fill='%23fff'%20stroke='%23707070'%20stroke-width='1'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20id='Mask_Group_27'%20data-name='Mask%20Group%2027'%20transform='translate(-307%20-21)'%20clip-path='url(%23clip-path)'%3e%3cg%20id='__TEMP__SVG__'%20transform='translate(305%2019)'%3e%3cpath%20id='Path_63'%20data-name='Path%2063'%20d='M21.333,19.333H2.667a.667.667,0,1,1,0-1.333H21.333a.667.667,0,1,1,0,1.333Z'%20fill='%236b7280'/%3e%3cpath%20id='Path_64'%20data-name='Path%2064'%20d='M21.333,12.667H2.667a.667.667,0,1,1,0-1.333H21.333a.667.667,0,0,1,0,1.333Z'%20fill='%236b7280'/%3e%3cpath%20id='Path_65'%20data-name='Path%2065'%20d='M21.333,6H2.667a.667.667,0,1,1,0-1.333H21.333a.667.667,0,0,1,0,1.333Z'%20fill='%236b7280'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e",
    lastWinner1 = "/assets/last-winner-1-BG8-5L8_.svg",
    lastWinner2 = "/assets/last-winner-2-D4kIYhem.svg",
    lastWinner3 = "/assets/last-winner-3-C4wtV8pv.svg",
    hero = "/assets/hero-HYtPKfRi.svg",
    recent1 = "/assets/recent1-DohOBNo9.svg",
    recent2 = "/assets/recent2-qJRBE_AL.svg",
    recent3 = "/assets/recent3-zZN6hm4F.svg",
    recent4 = "/assets/recent4-ymaJsBM2.svg",
    recent5 = "/assets/recent5-B-3JVRYw.svg",
    recent6 = "/assets/recent6-B3grkHvs.svg",
    colunIcon = "data:image/svg+xml,%3csvg%20width='18'%20height='66'%20viewBox='0%200%2018%2066'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M8.97359%2065.1112C6.64405%2065.1112%204.64121%2064.2873%202.96507%2062.6396C1.28893%2060.9635%200.450867%2058.9464%200.450867%2056.5885C0.450867%2054.2589%201.28893%2052.2703%202.96507%2050.6226C4.64121%2048.9464%206.64405%2048.1084%208.97359%2048.1084C11.3031%2048.1084%2013.306%2048.9464%2014.9821%2050.6226C16.6583%2052.2703%2017.4963%2054.2589%2017.4963%2056.5885C17.4963%2058.151%2017.0986%2059.5856%2016.3031%2060.8924C15.5361%2062.1709%2014.5134%2063.1936%2013.235%2063.9606C11.9565%2064.7277%2010.5361%2065.1112%208.97359%2065.1112ZM8.97359%2017.4691C6.64405%2017.4691%204.64121%2016.6311%202.96507%2014.9549C1.28893%2013.2788%200.450867%2011.276%200.450867%208.94642C0.450867%206.61688%201.28893%204.62824%202.96507%202.98051C4.64121%201.30438%206.64405%200.466309%208.97359%200.466309C11.3031%200.466309%2013.306%201.30438%2014.9821%202.98051C16.6583%204.62824%2017.4963%206.61688%2017.4963%208.94642C17.4963%2010.5089%2017.0986%2011.9436%2016.3031%2013.2504C15.5361%2014.5288%2014.5134%2015.5515%2013.235%2016.3186C11.9565%2017.0856%2010.5361%2017.4691%208.97359%2017.4691Z'%20fill='white'/%3e%3c/svg%3e",
    Svg = {
        userIcon,
        whiteCoinIcon,
        mobilemenuIcon,
        lastWinner1,
        lastWinner2,
        lastWinner3,
        hero,
        recent1,
        recent2,
        recent3,
        recent4,
        recent5,
        recent6,
        colunIcon
    },
    Png = {};

function useDefaultProps(s) {
    return useDefaultProps$1(s)
}

function getSvgIconUtilityClass(s) {
    return generateUtilityClass("MuiSvgIcon", s)
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$11 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"],
    useUtilityClasses$Q = s => {
        const {
            color: o,
            fontSize: a,
            classes: $
        } = s, j = {
            root: ["root", o !== "inherit" && `color${capitalize$1(o)}`, `fontSize${capitalize$1(a)}`]
        };
        return composeClasses(j, getSvgIconUtilityClass, $)
    },
    SvgIconRoot = styled("svg", {
        name: "MuiSvgIcon",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.color !== "inherit" && o[`color${capitalize$1(a.color)}`], o[`fontSize${capitalize$1(a.fontSize)}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => {
        var a, $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt;
        return {
            userSelect: "none",
            width: "1em",
            height: "1em",
            display: "inline-block",
            fill: o.hasSvgAsChild ? void 0 : "currentColor",
            flexShrink: 0,
            transition: (a = s.transitions) == null || ($ = a.create) == null ? void 0 : $.call(a, "fill", {
                duration: (j = s.transitions) == null || (j = j.duration) == null ? void 0 : j.shorter
            }),
            fontSize: {
                inherit: "inherit",
                small: ((_e = s.typography) == null || (et = _e.pxToRem) == null ? void 0 : et.call(_e, 20)) || "1.25rem",
                medium: ((tt = s.typography) == null || (nt = tt.pxToRem) == null ? void 0 : nt.call(tt, 24)) || "1.5rem",
                large: ((rt = s.typography) == null || (ot = rt.pxToRem) == null ? void 0 : ot.call(rt, 35)) || "2.1875rem"
            }[o.fontSize],
            color: (st = (lt = (s.vars || s).palette) == null || (lt = lt[o.color]) == null ? void 0 : lt.main) != null ? st : {
                action: (ft = (s.vars || s).palette) == null || (ft = ft.action) == null ? void 0 : ft.active,
                disabled: (yt = (s.vars || s).palette) == null || (yt = yt.action) == null ? void 0 : yt.disabled,
                inherit: void 0
            }[o.color]
        }
    }),
    SvgIcon = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiSvgIcon"
            }),
            {
                children: j,
                className: _e,
                color: et = "inherit",
                component: tt = "svg",
                fontSize: nt = "medium",
                htmlColor: rt,
                inheritViewBox: ot = !1,
                titleAccess: st,
                viewBox: lt = "0 0 24 24"
            } = $,
            ft = _objectWithoutPropertiesLoose$1($, _excluded$11),
            yt = reactExports.isValidElement(j) && j.type === "svg",
            bt = _extends$4({}, $, {
                color: et,
                component: tt,
                fontSize: nt,
                instanceFontSize: o.fontSize,
                inheritViewBox: ot,
                viewBox: lt,
                hasSvgAsChild: yt
            }),
            ht = {};
        ot || (ht.viewBox = lt);
        const vt = useUtilityClasses$Q(bt);
        return jsxRuntimeExports.jsxs(SvgIconRoot, _extends$4({
            as: tt,
            className: clsx(vt.root, _e),
            focusable: "false",
            color: rt,
            "aria-hidden": st ? void 0 : !0,
            role: st ? "img" : void 0,
            ref: a
        }, ht, ft, yt && j.props, {
            ownerState: bt,
            children: [yt ? j.props.children : j, st ? jsxRuntimeExports.jsx("title", {
                children: st
            }) : null]
        }))
    });
SvgIcon.muiName = "SvgIcon";

function createSvgIcon$1(s, o) {
    function a($, j) {
        return jsxRuntimeExports.jsx(SvgIcon, _extends$4({
            "data-testid": `${o}Icon`,
            ref: j
        }, $, {
            children: s
        }))
    }
    return a.muiName = SvgIcon.muiName, reactExports.memo(reactExports.forwardRef(a))
}
const unstable_ClassNameGenerator = {
        configure: s => {
            ClassNameGenerator.configure(s)
        }
    },
    utils = Object.freeze(Object.defineProperty({
        __proto__: null,
        capitalize: capitalize$1,
        createChainedFunction,
        createSvgIcon: createSvgIcon$1,
        debounce: debounce$1,
        deprecatedPropType,
        isMuiElement,
        ownerDocument,
        ownerWindow,
        requirePropFactory,
        setRef,
        unstable_ClassNameGenerator,
        unstable_useEnhancedEffect: useEnhancedEffect,
        unstable_useId: useId,
        unsupportedProp,
        useControlled,
        useEventCallback,
        useForkRef,
        useIsFocusVisible
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function _setPrototypeOf(s, o) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, $) {
        return a.__proto__ = $, a
    }, _setPrototypeOf(s, o)
}

function _inheritsLoose(s, o) {
    s.prototype = Object.create(o.prototype), s.prototype.constructor = s, _setPrototypeOf(s, o)
}
const config = {
        disabled: !1
    },
    TransitionGroupContext = React$1.createContext(null);
var forceReflow = function(o) {
        return o.scrollTop
    },
    UNMOUNTED = "unmounted",
    EXITED = "exited",
    ENTERING = "entering",
    ENTERED = "entered",
    EXITING = "exiting",
    Transition = function(s) {
        _inheritsLoose(o, s);

        function o($, j) {
            var _e;
            _e = s.call(this, $, j) || this;
            var et = j,
                tt = et && !et.isMounting ? $.enter : $.appear,
                nt;
            return _e.appearStatus = null, $.in ? tt ? (nt = EXITED, _e.appearStatus = ENTERING) : nt = ENTERED : $.unmountOnExit || $.mountOnEnter ? nt = UNMOUNTED : nt = EXITED, _e.state = {
                status: nt
            }, _e.nextCallback = null, _e
        }
        o.getDerivedStateFromProps = function(j, _e) {
            var et = j.in;
            return et && _e.status === UNMOUNTED ? {
                status: EXITED
            } : null
        };
        var a = o.prototype;
        return a.componentDidMount = function() {
            this.updateStatus(!0, this.appearStatus)
        }, a.componentDidUpdate = function(j) {
            var _e = null;
            if (j !== this.props) {
                var et = this.state.status;
                this.props.in ? et !== ENTERING && et !== ENTERED && (_e = ENTERING) : (et === ENTERING || et === ENTERED) && (_e = EXITING)
            }
            this.updateStatus(!1, _e)
        }, a.componentWillUnmount = function() {
            this.cancelNextCallback()
        }, a.getTimeouts = function() {
            var j = this.props.timeout,
                _e, et, tt;
            return _e = et = tt = j, j != null && typeof j != "number" && (_e = j.exit, et = j.enter, tt = j.appear !== void 0 ? j.appear : et), {
                exit: _e,
                enter: et,
                appear: tt
            }
        }, a.updateStatus = function(j, _e) {
            if (j === void 0 && (j = !1), _e !== null)
                if (this.cancelNextCallback(), _e === ENTERING) {
                    if (this.props.unmountOnExit || this.props.mountOnEnter) {
                        var et = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
                        et && forceReflow(et)
                    }
                    this.performEnter(j)
                } else this.performExit();
            else this.props.unmountOnExit && this.state.status === EXITED && this.setState({
                status: UNMOUNTED
            })
        }, a.performEnter = function(j) {
            var _e = this,
                et = this.props.enter,
                tt = this.context ? this.context.isMounting : j,
                nt = this.props.nodeRef ? [tt] : [ReactDOM.findDOMNode(this), tt],
                rt = nt[0],
                ot = nt[1],
                st = this.getTimeouts(),
                lt = tt ? st.appear : st.enter;
            if (!j && !et || config.disabled) {
                this.safeSetState({
                    status: ENTERED
                }, function() {
                    _e.props.onEntered(rt)
                });
                return
            }
            this.props.onEnter(rt, ot), this.safeSetState({
                status: ENTERING
            }, function() {
                _e.props.onEntering(rt, ot), _e.onTransitionEnd(lt, function() {
                    _e.safeSetState({
                        status: ENTERED
                    }, function() {
                        _e.props.onEntered(rt, ot)
                    })
                })
            })
        }, a.performExit = function() {
            var j = this,
                _e = this.props.exit,
                et = this.getTimeouts(),
                tt = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
            if (!_e || config.disabled) {
                this.safeSetState({
                    status: EXITED
                }, function() {
                    j.props.onExited(tt)
                });
                return
            }
            this.props.onExit(tt), this.safeSetState({
                status: EXITING
            }, function() {
                j.props.onExiting(tt), j.onTransitionEnd(et.exit, function() {
                    j.safeSetState({
                        status: EXITED
                    }, function() {
                        j.props.onExited(tt)
                    })
                })
            })
        }, a.cancelNextCallback = function() {
            this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null)
        }, a.safeSetState = function(j, _e) {
            _e = this.setNextCallback(_e), this.setState(j, _e)
        }, a.setNextCallback = function(j) {
            var _e = this,
                et = !0;
            return this.nextCallback = function(tt) {
                et && (et = !1, _e.nextCallback = null, j(tt))
            }, this.nextCallback.cancel = function() {
                et = !1
            }, this.nextCallback
        }, a.onTransitionEnd = function(j, _e) {
            this.setNextCallback(_e);
            var et = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this),
                tt = j == null && !this.props.addEndListener;
            if (!et || tt) {
                setTimeout(this.nextCallback, 0);
                return
            }
            if (this.props.addEndListener) {
                var nt = this.props.nodeRef ? [this.nextCallback] : [et, this.nextCallback],
                    rt = nt[0],
                    ot = nt[1];
                this.props.addEndListener(rt, ot)
            }
            j != null && setTimeout(this.nextCallback, j)
        }, a.render = function() {
            var j = this.state.status;
            if (j === UNMOUNTED) return null;
            var _e = this.props,
                et = _e.children;
            _e.in, _e.mountOnEnter, _e.unmountOnExit, _e.appear, _e.enter, _e.exit, _e.timeout, _e.addEndListener, _e.onEnter, _e.onEntering, _e.onEntered, _e.onExit, _e.onExiting, _e.onExited, _e.nodeRef;
            var tt = _objectWithoutPropertiesLoose$1(_e, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
            return React$1.createElement(TransitionGroupContext.Provider, {
                value: null
            }, typeof et == "function" ? et(j, tt) : React$1.cloneElement(React$1.Children.only(et), tt))
        }, o
    }(React$1.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};

function noop$2() {}
Transition.defaultProps = { in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;

function _assertThisInitialized(s) {
    if (s === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return s
}

function getChildMapping(s, o) {
    var a = function(_e) {
            return o && reactExports.isValidElement(_e) ? o(_e) : _e
        },
        $ = Object.create(null);
    return s && reactExports.Children.map(s, function(j) {
        return j
    }).forEach(function(j) {
        $[j.key] = a(j)
    }), $
}

function mergeChildMappings(s, o) {
    s = s || {}, o = o || {};

    function a(ot) {
        return ot in o ? o[ot] : s[ot]
    }
    var $ = Object.create(null),
        j = [];
    for (var _e in s) _e in o ? j.length && ($[_e] = j, j = []) : j.push(_e);
    var et, tt = {};
    for (var nt in o) {
        if ($[nt])
            for (et = 0; et < $[nt].length; et++) {
                var rt = $[nt][et];
                tt[$[nt][et]] = a(rt)
            }
        tt[nt] = a(nt)
    }
    for (et = 0; et < j.length; et++) tt[j[et]] = a(j[et]);
    return tt
}

function getProp(s, o, a) {
    return a[o] != null ? a[o] : s.props[o]
}

function getInitialChildMapping(s, o) {
    return getChildMapping(s.children, function(a) {
        return reactExports.cloneElement(a, {
            onExited: o.bind(null, a),
            in: !0,
            appear: getProp(a, "appear", s),
            enter: getProp(a, "enter", s),
            exit: getProp(a, "exit", s)
        })
    })
}

function getNextChildMapping(s, o, a) {
    var $ = getChildMapping(s.children),
        j = mergeChildMappings(o, $);
    return Object.keys(j).forEach(function(_e) {
        var et = j[_e];
        if (reactExports.isValidElement(et)) {
            var tt = _e in o,
                nt = _e in $,
                rt = o[_e],
                ot = reactExports.isValidElement(rt) && !rt.props.in;
            nt && (!tt || ot) ? j[_e] = reactExports.cloneElement(et, {
                onExited: a.bind(null, et),
                in: !0,
                exit: getProp(et, "exit", s),
                enter: getProp(et, "enter", s)
            }) : !nt && tt && !ot ? j[_e] = reactExports.cloneElement(et, { in: !1
            }) : nt && tt && reactExports.isValidElement(rt) && (j[_e] = reactExports.cloneElement(et, {
                onExited: a.bind(null, et),
                in: rt.props.in,
                exit: getProp(et, "exit", s),
                enter: getProp(et, "enter", s)
            }))
        }
    }), j
}
var values = Object.values || function(s) {
        return Object.keys(s).map(function(o) {
            return s[o]
        })
    },
    defaultProps = {
        component: "div",
        childFactory: function(o) {
            return o
        }
    },
    TransitionGroup = function(s) {
        _inheritsLoose(o, s);

        function o($, j) {
            var _e;
            _e = s.call(this, $, j) || this;
            var et = _e.handleExited.bind(_assertThisInitialized(_e));
            return _e.state = {
                contextValue: {
                    isMounting: !0
                },
                handleExited: et,
                firstRender: !0
            }, _e
        }
        var a = o.prototype;
        return a.componentDidMount = function() {
            this.mounted = !0, this.setState({
                contextValue: {
                    isMounting: !1
                }
            })
        }, a.componentWillUnmount = function() {
            this.mounted = !1
        }, o.getDerivedStateFromProps = function(j, _e) {
            var et = _e.children,
                tt = _e.handleExited,
                nt = _e.firstRender;
            return {
                children: nt ? getInitialChildMapping(j, tt) : getNextChildMapping(j, et, tt),
                firstRender: !1
            }
        }, a.handleExited = function(j, _e) {
            var et = getChildMapping(this.props.children);
            j.key in et || (j.props.onExited && j.props.onExited(_e), this.mounted && this.setState(function(tt) {
                var nt = _extends$4({}, tt.children);
                return delete nt[j.key], {
                    children: nt
                }
            }))
        }, a.render = function() {
            var j = this.props,
                _e = j.component,
                et = j.childFactory,
                tt = _objectWithoutPropertiesLoose$1(j, ["component", "childFactory"]),
                nt = this.state.contextValue,
                rt = values(this.state.children).map(et);
            return delete tt.appear, delete tt.enter, delete tt.exit, _e === null ? React$1.createElement(TransitionGroupContext.Provider, {
                value: nt
            }, rt) : React$1.createElement(TransitionGroupContext.Provider, {
                value: nt
            }, React$1.createElement(_e, tt, rt))
        }, o
    }(React$1.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const reflow = s => s.scrollTop;

function getTransitionProps(s, o) {
    var a, $;
    const {
        timeout: j,
        easing: _e,
        style: et = {}
    } = s;
    return {
        duration: (a = et.transitionDuration) != null ? a : typeof j == "number" ? j : j[o.mode] || 0,
        easing: ($ = et.transitionTimingFunction) != null ? $ : typeof _e == "object" ? _e[o.mode] : _e,
        delay: et.transitionDelay
    }
}

function getCollapseUtilityClass(s) {
    return generateUtilityClass("MuiCollapse", s)
}
generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const _excluded$10 = ["addEndListener", "children", "className", "collapsedSize", "component", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "orientation", "style", "timeout", "TransitionComponent"],
    useUtilityClasses$P = s => {
        const {
            orientation: o,
            classes: a
        } = s, $ = {
            root: ["root", `${o}`],
            entered: ["entered"],
            hidden: ["hidden"],
            wrapper: ["wrapper", `${o}`],
            wrapperInner: ["wrapperInner", `${o}`]
        };
        return composeClasses($, getCollapseUtilityClass, a)
    },
    CollapseRoot = styled("div", {
        name: "MuiCollapse",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, o[a.orientation], a.state === "entered" && o.entered, a.state === "exited" && !a.in && a.collapsedSize === "0px" && o.hidden]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        height: 0,
        overflow: "hidden",
        transition: s.transitions.create("height")
    }, o.orientation === "horizontal" && {
        height: "auto",
        width: 0,
        transition: s.transitions.create("width")
    }, o.state === "entered" && _extends$4({
        height: "auto",
        overflow: "visible"
    }, o.orientation === "horizontal" && {
        width: "auto"
    }), o.state === "exited" && !o.in && o.collapsedSize === "0px" && {
        visibility: "hidden"
    })),
    CollapseWrapper = styled("div", {
        name: "MuiCollapse",
        slot: "Wrapper",
        overridesResolver: (s, o) => o.wrapper
    })(({
        ownerState: s
    }) => _extends$4({
        display: "flex",
        width: "100%"
    }, s.orientation === "horizontal" && {
        width: "auto",
        height: "100%"
    })),
    CollapseWrapperInner = styled("div", {
        name: "MuiCollapse",
        slot: "WrapperInner",
        overridesResolver: (s, o) => o.wrapperInner
    })(({
        ownerState: s
    }) => _extends$4({
        width: "100%"
    }, s.orientation === "horizontal" && {
        width: "auto",
        height: "100%"
    })),
    Collapse$1 = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiCollapse"
            }),
            {
                addEndListener: j,
                children: _e,
                className: et,
                collapsedSize: tt = "0px",
                component: nt,
                easing: rt,
                in: ot,
                onEnter: st,
                onEntered: lt,
                onEntering: ft,
                onExit: yt,
                onExited: bt,
                onExiting: ht,
                orientation: vt = "vertical",
                style: wt,
                timeout: gt = duration.standard,
                TransitionComponent: At = Transition
            } = $,
            Pt = _objectWithoutPropertiesLoose$1($, _excluded$10),
            Bt = _extends$4({}, $, {
                orientation: vt,
                collapsedSize: tt
            }),
            Lt = useUtilityClasses$P(Bt),
            Nt = useTheme$1(),
            Ut = useTimeout(),
            Vt = reactExports.useRef(null),
            Ft = reactExports.useRef(),
            Wt = typeof tt == "number" ? `${tt}px` : tt,
            Ct = vt === "horizontal",
            it = Ct ? "width" : "height",
            at = reactExports.useRef(null),
            mt = useForkRef(a, at),
            xt = jt => Qt => {
                if (jt) {
                    const Kt = at.current;
                    Qt === void 0 ? jt(Kt) : jt(Kt, Qt)
                }
            },
            $t = () => Vt.current ? Vt.current[Ct ? "clientWidth" : "clientHeight"] : 0,
            Rt = xt((jt, Qt) => {
                Vt.current && Ct && (Vt.current.style.position = "absolute"), jt.style[it] = Wt, st && st(jt, Qt)
            }),
            It = xt((jt, Qt) => {
                const Kt = $t();
                Vt.current && Ct && (Vt.current.style.position = "");
                const {
                    duration: qt,
                    easing: Jt
                } = getTransitionProps({
                    style: wt,
                    timeout: gt,
                    easing: rt
                }, {
                    mode: "enter"
                });
                if (gt === "auto") {
                    const Zt = Nt.transitions.getAutoHeightDuration(Kt);
                    jt.style.transitionDuration = `${Zt}ms`, Ft.current = Zt
                } else jt.style.transitionDuration = typeof qt == "string" ? qt : `${qt}ms`;
                jt.style[it] = `${Kt}px`, jt.style.transitionTimingFunction = Jt, ft && ft(jt, Qt)
            }),
            Tt = xt((jt, Qt) => {
                jt.style[it] = "auto", lt && lt(jt, Qt)
            }),
            dt = xt(jt => {
                jt.style[it] = `${$t()}px`, yt && yt(jt)
            }),
            Et = xt(bt),
            Ot = xt(jt => {
                const Qt = $t(),
                    {
                        duration: Kt,
                        easing: qt
                    } = getTransitionProps({
                        style: wt,
                        timeout: gt,
                        easing: rt
                    }, {
                        mode: "exit"
                    });
                if (gt === "auto") {
                    const Jt = Nt.transitions.getAutoHeightDuration(Qt);
                    jt.style.transitionDuration = `${Jt}ms`, Ft.current = Jt
                } else jt.style.transitionDuration = typeof Kt == "string" ? Kt : `${Kt}ms`;
                jt.style[it] = Wt, jt.style.transitionTimingFunction = qt, ht && ht(jt)
            }),
            Mt = jt => {
                gt === "auto" && Ut.start(Ft.current || 0, jt), j && j(at.current, jt)
            };
        return jsxRuntimeExports.jsx(At, _extends$4({ in: ot,
            onEnter: Rt,
            onEntered: Tt,
            onEntering: It,
            onExit: dt,
            onExited: Et,
            onExiting: Ot,
            addEndListener: Mt,
            nodeRef: at,
            timeout: gt === "auto" ? null : gt
        }, Pt, {
            children: (jt, Qt) => jsxRuntimeExports.jsx(CollapseRoot, _extends$4({
                as: nt,
                className: clsx(Lt.root, et, {
                    entered: Lt.entered,
                    exited: !ot && Wt === "0px" && Lt.hidden
                }[jt]),
                style: _extends$4({
                    [Ct ? "minWidth" : "minHeight"]: Wt
                }, wt),
                ref: mt
            }, Qt, {
                ownerState: _extends$4({}, Bt, {
                    state: jt
                }),
                children: jsxRuntimeExports.jsx(CollapseWrapper, {
                    ownerState: _extends$4({}, Bt, {
                        state: jt
                    }),
                    className: Lt.wrapper,
                    ref: Vt,
                    children: jsxRuntimeExports.jsx(CollapseWrapperInner, {
                        ownerState: _extends$4({}, Bt, {
                            state: jt
                        }),
                        className: Lt.wrapperInner,
                        children: _e
                    })
                })
            }))
        }))
    });
Collapse$1.muiSupportAuto = !0;

function getPaperUtilityClass(s) {
    return generateUtilityClass("MuiPaper", s)
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$$ = ["className", "component", "elevation", "square", "variant"],
    useUtilityClasses$O = s => {
        const {
            square: o,
            elevation: a,
            variant: $,
            classes: j
        } = s, _e = {
            root: ["root", $, !o && "rounded", $ === "elevation" && `elevation${a}`]
        };
        return composeClasses(_e, getPaperUtilityClass, j)
    },
    PaperRoot = styled("div", {
        name: "MuiPaper",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, o[a.variant], !a.square && o.rounded, a.variant === "elevation" && o[`elevation${a.elevation}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => {
        var a;
        return _extends$4({
            backgroundColor: (s.vars || s).palette.background.paper,
            color: (s.vars || s).palette.text.primary,
            transition: s.transitions.create("box-shadow")
        }, !o.square && {
            borderRadius: s.shape.borderRadius
        }, o.variant === "outlined" && {
            border: `1px solid ${(s.vars||s).palette.divider}`
        }, o.variant === "elevation" && _extends$4({
            boxShadow: (s.vars || s).shadows[o.elevation]
        }, !s.vars && s.palette.mode === "dark" && {
            backgroundImage: `linear-gradient(${alpha_1("#fff",getOverlayAlpha(o.elevation))}, ${alpha_1("#fff",getOverlayAlpha(o.elevation))})`
        }, s.vars && {
            backgroundImage: (a = s.vars.overlays) == null ? void 0 : a[o.elevation]
        }))
    }),
    Paper = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiPaper"
            }),
            {
                className: j,
                component: _e = "div",
                elevation: et = 1,
                square: tt = !1,
                variant: nt = "elevation"
            } = $,
            rt = _objectWithoutPropertiesLoose$1($, _excluded$$),
            ot = _extends$4({}, $, {
                component: _e,
                elevation: et,
                square: tt,
                variant: nt
            }),
            st = useUtilityClasses$O(ot);
        return jsxRuntimeExports.jsx(PaperRoot, _extends$4({
            as: _e,
            ownerState: ot,
            className: clsx(st.root, j),
            ref: a
        }, rt))
    }),
    AccordionContext = reactExports.createContext({}),
    _excluded$_ = ["className", "elementType", "ownerState", "externalForwardedProps", "getSlotOwnerState", "internalForwardedProps"],
    _excluded2$7 = ["component", "slots", "slotProps"],
    _excluded3$1 = ["component"];

function useSlot(s, o) {
    const {
        className: a,
        elementType: $,
        ownerState: j,
        externalForwardedProps: _e,
        getSlotOwnerState: et,
        internalForwardedProps: tt
    } = o, nt = _objectWithoutPropertiesLoose$1(o, _excluded$_), {
        component: rt,
        slots: ot = {
            [s]: void 0
        },
        slotProps: st = {
            [s]: void 0
        }
    } = _e;
    _objectWithoutPropertiesLoose$1(_e, _excluded2$7);
    const lt = ot[s] || $,
        ft = resolveComponentProps(st[s], j),
        yt = mergeSlotProps(_extends$4({
            className: a
        }, nt, {
            externalForwardedProps: void 0,
            externalSlotProps: ft
        })),
        {
            props: {
                component: bt
            },
            internalRef: ht
        } = yt,
        vt = _objectWithoutPropertiesLoose$1(yt.props, _excluded3$1),
        wt = useForkRef(ht, ft == null ? void 0 : ft.ref, o.ref),
        gt = et ? et(vt) : {},
        At = _extends$4({}, j, gt),
        Pt = bt,
        Bt = appendOwnerState(lt, _extends$4({}, s === "root", !ot[s] && tt, vt, Pt && {
            as: Pt
        }, {
            ref: wt
        }), At);
    return Object.keys(gt).forEach(Lt => {
        delete Bt[Lt]
    }), [lt, Bt]
}

function getAccordionUtilityClass(s) {
    return generateUtilityClass("MuiAccordion", s)
}
const accordionClasses = generateUtilityClasses("MuiAccordion", ["root", "rounded", "expanded", "disabled", "gutters", "region"]),
    _excluded$Z = ["children", "className", "defaultExpanded", "disabled", "disableGutters", "expanded", "onChange", "square", "slots", "slotProps", "TransitionComponent", "TransitionProps"],
    useUtilityClasses$N = s => {
        const {
            classes: o,
            square: a,
            expanded: $,
            disabled: j,
            disableGutters: _e
        } = s;
        return composeClasses({
            root: ["root", !a && "rounded", $ && "expanded", j && "disabled", !_e && "gutters"],
            region: ["region"]
        }, getAccordionUtilityClass, o)
    },
    AccordionRoot = styled(Paper, {
        name: "MuiAccordion",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [{
                [`& .${accordionClasses.region}`]: o.region
            }, o.root, !a.square && o.rounded, !a.disableGutters && o.gutters]
        }
    })(({
        theme: s
    }) => {
        const o = {
            duration: s.transitions.duration.shortest
        };
        return {
            position: "relative",
            transition: s.transitions.create(["margin"], o),
            overflowAnchor: "none",
            "&::before": {
                position: "absolute",
                left: 0,
                top: -1,
                right: 0,
                height: 1,
                content: '""',
                opacity: 1,
                backgroundColor: (s.vars || s).palette.divider,
                transition: s.transitions.create(["opacity", "background-color"], o)
            },
            "&:first-of-type": {
                "&::before": {
                    display: "none"
                }
            },
            [`&.${accordionClasses.expanded}`]: {
                "&::before": {
                    opacity: 0
                },
                "&:first-of-type": {
                    marginTop: 0
                },
                "&:last-of-type": {
                    marginBottom: 0
                },
                "& + &": {
                    "&::before": {
                        display: "none"
                    }
                }
            },
            [`&.${accordionClasses.disabled}`]: {
                backgroundColor: (s.vars || s).palette.action.disabledBackground
            }
        }
    }, ({
        theme: s
    }) => ({
        variants: [{
            props: o => !o.square,
            style: {
                borderRadius: 0,
                "&:first-of-type": {
                    borderTopLeftRadius: (s.vars || s).shape.borderRadius,
                    borderTopRightRadius: (s.vars || s).shape.borderRadius
                },
                "&:last-of-type": {
                    borderBottomLeftRadius: (s.vars || s).shape.borderRadius,
                    borderBottomRightRadius: (s.vars || s).shape.borderRadius,
                    "@supports (-ms-ime-align: auto)": {
                        borderBottomLeftRadius: 0,
                        borderBottomRightRadius: 0
                    }
                }
            }
        }, {
            props: o => !o.disableGutters,
            style: {
                [`&.${accordionClasses.expanded}`]: {
                    margin: "16px 0"
                }
            }
        }]
    })),
    Accordion = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiAccordion"
            }),
            {
                children: j,
                className: _e,
                defaultExpanded: et = !1,
                disabled: tt = !1,
                disableGutters: nt = !1,
                expanded: rt,
                onChange: ot,
                square: st = !1,
                slots: lt = {},
                slotProps: ft = {},
                TransitionComponent: yt,
                TransitionProps: bt
            } = $,
            ht = _objectWithoutPropertiesLoose$1($, _excluded$Z),
            [vt, wt] = useControlled({
                controlled: rt,
                default: et,
                name: "Accordion",
                state: "expanded"
            }),
            gt = reactExports.useCallback(Ct => {
                wt(!vt), ot && ot(Ct, !vt)
            }, [vt, ot, wt]),
            [At, ...Pt] = reactExports.Children.toArray(j),
            Bt = reactExports.useMemo(() => ({
                expanded: vt,
                disabled: tt,
                disableGutters: nt,
                toggle: gt
            }), [vt, tt, nt, gt]),
            Lt = _extends$4({}, $, {
                square: st,
                disabled: tt,
                disableGutters: nt,
                expanded: vt
            }),
            Nt = useUtilityClasses$N(Lt),
            Ut = _extends$4({
                transition: yt
            }, lt),
            Vt = _extends$4({
                transition: bt
            }, ft),
            [Ft, Wt] = useSlot("transition", {
                elementType: Collapse$1,
                externalForwardedProps: {
                    slots: Ut,
                    slotProps: Vt
                },
                ownerState: Lt
            });
        return jsxRuntimeExports.jsxs(AccordionRoot, _extends$4({
            className: clsx(Nt.root, _e),
            ref: a,
            ownerState: Lt,
            square: st
        }, ht, {
            children: [jsxRuntimeExports.jsx(AccordionContext.Provider, {
                value: Bt,
                children: At
            }), jsxRuntimeExports.jsx(Ft, _extends$4({ in: vt,
                timeout: "auto"
            }, Wt, {
                children: jsxRuntimeExports.jsx("div", {
                    "aria-labelledby": At.props.id,
                    id: At.props["aria-controls"],
                    role: "region",
                    className: Nt.region,
                    children: Pt
                })
            }))]
        }))
    });

function getAccordionActionsUtilityClass(s) {
    return generateUtilityClass("MuiAccordionActions", s)
}
generateUtilityClasses("MuiAccordionActions", ["root", "spacing"]);
const _excluded$Y = ["className", "disableSpacing"],
    useUtilityClasses$M = s => {
        const {
            classes: o,
            disableSpacing: a
        } = s;
        return composeClasses({
            root: ["root", !a && "spacing"]
        }, getAccordionActionsUtilityClass, o)
    },
    AccordionActionsRoot = styled("div", {
        name: "MuiAccordionActions",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, !a.disableSpacing && o.spacing]
        }
    })({
        display: "flex",
        alignItems: "center",
        padding: 8,
        justifyContent: "flex-end",
        variants: [{
            props: s => !s.disableSpacing,
            style: {
                "& > :not(style) ~ :not(style)": {
                    marginLeft: 8
                }
            }
        }]
    }),
    AccordionActions = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiAccordionActions"
            }),
            {
                className: j,
                disableSpacing: _e = !1
            } = $,
            et = _objectWithoutPropertiesLoose$1($, _excluded$Y),
            tt = _extends$4({}, $, {
                disableSpacing: _e
            }),
            nt = useUtilityClasses$M(tt);
        return jsxRuntimeExports.jsx(AccordionActionsRoot, _extends$4({
            className: clsx(nt.root, j),
            ref: a,
            ownerState: tt
        }, et))
    });

function getAccordionDetailsUtilityClass(s) {
    return generateUtilityClass("MuiAccordionDetails", s)
}
generateUtilityClasses("MuiAccordionDetails", ["root"]);
const _excluded$X = ["className"],
    useUtilityClasses$L = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"]
        }, getAccordionDetailsUtilityClass, o)
    },
    AccordionDetailsRoot = styled("div", {
        name: "MuiAccordionDetails",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })(({
        theme: s
    }) => ({
        padding: s.spacing(1, 2, 2)
    })),
    AccordionDetails = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiAccordionDetails"
            }),
            {
                className: j
            } = $,
            _e = _objectWithoutPropertiesLoose$1($, _excluded$X),
            et = $,
            tt = useUtilityClasses$L(et);
        return jsxRuntimeExports.jsx(AccordionDetailsRoot, _extends$4({
            className: clsx(tt.root, j),
            ref: a,
            ownerState: et
        }, _e))
    });

function Ripple(s) {
    const {
        className: o,
        classes: a,
        pulsate: $ = !1,
        rippleX: j,
        rippleY: _e,
        rippleSize: et,
        in: tt,
        onExited: nt,
        timeout: rt
    } = s, [ot, st] = reactExports.useState(!1), lt = clsx(o, a.ripple, a.rippleVisible, $ && a.ripplePulsate), ft = {
        width: et,
        height: et,
        top: -(et / 2) + _e,
        left: -(et / 2) + j
    }, yt = clsx(a.child, ot && a.childLeaving, $ && a.childPulsate);
    return !tt && !ot && st(!0), reactExports.useEffect(() => {
        if (!tt && nt != null) {
            const bt = setTimeout(nt, rt);
            return () => {
                clearTimeout(bt)
            }
        }
    }, [nt, tt, rt]), jsxRuntimeExports.jsx("span", {
        className: lt,
        style: ft,
        children: jsxRuntimeExports.jsx("span", {
            className: yt
        })
    })
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]),
    _excluded$W = ["center", "classes", "className"];
let _ = s => s,
    _t, _t2, _t3, _t4;
const DURATION = 550,
    DELAY_RIPPLE = 80,
    enterKeyframe = keyframes$1(_t || (_t = _ `
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)),
    exitKeyframe = keyframes$1(_t2 || (_t2 = _ `
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)),
    pulsateKeyframe = keyframes$1(_t3 || (_t3 = _ `
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)),
    TouchRippleRoot = styled("span", {
        name: "MuiTouchRipple",
        slot: "Root"
    })({
        overflow: "hidden",
        pointerEvents: "none",
        position: "absolute",
        zIndex: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        borderRadius: "inherit"
    }),
    TouchRippleRipple = styled(Ripple, {
        name: "MuiTouchRipple",
        slot: "Ripple"
    })(_t4 || (_t4 = _ `
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
        theme: s
    }) => s.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
        theme: s
    }) => s.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
        theme: s
    }) => s.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
        theme: s
    }) => s.transitions.easing.easeInOut),
    TouchRipple = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTouchRipple"
            }),
            {
                center: j = !1,
                classes: _e = {},
                className: et
            } = $,
            tt = _objectWithoutPropertiesLoose$1($, _excluded$W),
            [nt, rt] = reactExports.useState([]),
            ot = reactExports.useRef(0),
            st = reactExports.useRef(null);
        reactExports.useEffect(() => {
            st.current && (st.current(), st.current = null)
        }, [nt]);
        const lt = reactExports.useRef(!1),
            ft = useTimeout(),
            yt = reactExports.useRef(null),
            bt = reactExports.useRef(null),
            ht = reactExports.useCallback(At => {
                const {
                    pulsate: Pt,
                    rippleX: Bt,
                    rippleY: Lt,
                    rippleSize: Nt,
                    cb: Ut
                } = At;
                rt(Vt => [...Vt, jsxRuntimeExports.jsx(TouchRippleRipple, {
                    classes: {
                        ripple: clsx(_e.ripple, touchRippleClasses.ripple),
                        rippleVisible: clsx(_e.rippleVisible, touchRippleClasses.rippleVisible),
                        ripplePulsate: clsx(_e.ripplePulsate, touchRippleClasses.ripplePulsate),
                        child: clsx(_e.child, touchRippleClasses.child),
                        childLeaving: clsx(_e.childLeaving, touchRippleClasses.childLeaving),
                        childPulsate: clsx(_e.childPulsate, touchRippleClasses.childPulsate)
                    },
                    timeout: DURATION,
                    pulsate: Pt,
                    rippleX: Bt,
                    rippleY: Lt,
                    rippleSize: Nt
                }, ot.current)]), ot.current += 1, st.current = Ut
            }, [_e]),
            vt = reactExports.useCallback((At = {}, Pt = {}, Bt = () => {}) => {
                const {
                    pulsate: Lt = !1,
                    center: Nt = j || Pt.pulsate,
                    fakeElement: Ut = !1
                } = Pt;
                if ((At == null ? void 0 : At.type) === "mousedown" && lt.current) {
                    lt.current = !1;
                    return
                }(At == null ? void 0 : At.type) === "touchstart" && (lt.current = !0);
                const Vt = Ut ? null : bt.current,
                    Ft = Vt ? Vt.getBoundingClientRect() : {
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    };
                let Wt, Ct, it;
                if (Nt || At === void 0 || At.clientX === 0 && At.clientY === 0 || !At.clientX && !At.touches) Wt = Math.round(Ft.width / 2), Ct = Math.round(Ft.height / 2);
                else {
                    const {
                        clientX: at,
                        clientY: mt
                    } = At.touches && At.touches.length > 0 ? At.touches[0] : At;
                    Wt = Math.round(at - Ft.left), Ct = Math.round(mt - Ft.top)
                }
                if (Nt) it = Math.sqrt((2 * Ft.width ** 2 + Ft.height ** 2) / 3), it % 2 === 0 && (it += 1);
                else {
                    const at = Math.max(Math.abs((Vt ? Vt.clientWidth : 0) - Wt), Wt) * 2 + 2,
                        mt = Math.max(Math.abs((Vt ? Vt.clientHeight : 0) - Ct), Ct) * 2 + 2;
                    it = Math.sqrt(at ** 2 + mt ** 2)
                }
                At != null && At.touches ? yt.current === null && (yt.current = () => {
                    ht({
                        pulsate: Lt,
                        rippleX: Wt,
                        rippleY: Ct,
                        rippleSize: it,
                        cb: Bt
                    })
                }, ft.start(DELAY_RIPPLE, () => {
                    yt.current && (yt.current(), yt.current = null)
                })) : ht({
                    pulsate: Lt,
                    rippleX: Wt,
                    rippleY: Ct,
                    rippleSize: it,
                    cb: Bt
                })
            }, [j, ht, ft]),
            wt = reactExports.useCallback(() => {
                vt({}, {
                    pulsate: !0
                })
            }, [vt]),
            gt = reactExports.useCallback((At, Pt) => {
                if (ft.clear(), (At == null ? void 0 : At.type) === "touchend" && yt.current) {
                    yt.current(), yt.current = null, ft.start(0, () => {
                        gt(At, Pt)
                    });
                    return
                }
                yt.current = null, rt(Bt => Bt.length > 0 ? Bt.slice(1) : Bt), st.current = Pt
            }, [ft]);
        return reactExports.useImperativeHandle(a, () => ({
            pulsate: wt,
            start: vt,
            stop: gt
        }), [wt, vt, gt]), jsxRuntimeExports.jsx(TouchRippleRoot, _extends$4({
            className: clsx(touchRippleClasses.root, _e.root, et),
            ref: bt
        }, tt, {
            children: jsxRuntimeExports.jsx(TransitionGroup, {
                component: null,
                exit: !0,
                children: nt
            })
        }))
    });

function getButtonBaseUtilityClass(s) {
    return generateUtilityClass("MuiButtonBase", s)
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]),
    _excluded$V = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"],
    useUtilityClasses$K = s => {
        const {
            disabled: o,
            focusVisible: a,
            focusVisibleClassName: $,
            classes: j
        } = s, et = composeClasses({
            root: ["root", o && "disabled", a && "focusVisible"]
        }, getButtonBaseUtilityClass, j);
        return a && $ && (et.root += ` ${$}`), et
    },
    ButtonBaseRoot = styled("button", {
        name: "MuiButtonBase",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative",
        boxSizing: "border-box",
        WebkitTapHighlightColor: "transparent",
        backgroundColor: "transparent",
        outline: 0,
        border: 0,
        margin: 0,
        borderRadius: 0,
        padding: 0,
        cursor: "pointer",
        userSelect: "none",
        verticalAlign: "middle",
        MozAppearance: "none",
        WebkitAppearance: "none",
        textDecoration: "none",
        color: "inherit",
        "&::-moz-focus-inner": {
            borderStyle: "none"
        },
        [`&.${buttonBaseClasses.disabled}`]: {
            pointerEvents: "none",
            cursor: "default"
        },
        "@media print": {
            colorAdjust: "exact"
        }
    }),
    ButtonBase = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiButtonBase"
            }),
            {
                action: j,
                centerRipple: _e = !1,
                children: et,
                className: tt,
                component: nt = "button",
                disabled: rt = !1,
                disableRipple: ot = !1,
                disableTouchRipple: st = !1,
                focusRipple: lt = !1,
                LinkComponent: ft = "a",
                onBlur: yt,
                onClick: bt,
                onContextMenu: ht,
                onDragLeave: vt,
                onFocus: wt,
                onFocusVisible: gt,
                onKeyDown: At,
                onKeyUp: Pt,
                onMouseDown: Bt,
                onMouseLeave: Lt,
                onMouseUp: Nt,
                onTouchEnd: Ut,
                onTouchMove: Vt,
                onTouchStart: Ft,
                tabIndex: Wt = 0,
                TouchRippleProps: Ct,
                touchRippleRef: it,
                type: at
            } = $,
            mt = _objectWithoutPropertiesLoose$1($, _excluded$V),
            xt = reactExports.useRef(null),
            $t = reactExports.useRef(null),
            Rt = useForkRef($t, it),
            {
                isFocusVisibleRef: It,
                onFocus: Tt,
                onBlur: dt,
                ref: Et
            } = useIsFocusVisible(),
            [Ot, Mt] = reactExports.useState(!1);
        rt && Ot && Mt(!1), reactExports.useImperativeHandle(j, () => ({
            focusVisible: () => {
                Mt(!0), xt.current.focus()
            }
        }), []);
        const [jt, Qt] = reactExports.useState(!1);
        reactExports.useEffect(() => {
            Qt(!0)
        }, []);
        const Kt = jt && !ot && !rt;
        reactExports.useEffect(() => {
            Ot && lt && !ot && jt && $t.current.pulsate()
        }, [ot, lt, Ot, jt]);

        function qt(pt, kt, Dt = st) {
            return useEventCallback(zt => (kt && kt(zt), !Dt && $t.current && $t.current[pt](zt), !0))
        }
        const Jt = qt("start", Bt),
            Zt = qt("stop", ht),
            en = qt("stop", vt),
            ln = qt("stop", Nt),
            cn = qt("stop", pt => {
                Ot && pt.preventDefault(), Lt && Lt(pt)
            }),
            un = qt("start", Ft),
            Nn = qt("stop", Ut),
            hn = qt("stop", Vt),
            fn = qt("stop", pt => {
                dt(pt), It.current === !1 && Mt(!1), yt && yt(pt)
            }, !1),
            rn = useEventCallback(pt => {
                xt.current || (xt.current = pt.currentTarget), Tt(pt), It.current === !0 && (Mt(!0), gt && gt(pt)), wt && wt(pt)
            }),
            mn = () => {
                const pt = xt.current;
                return nt && nt !== "button" && !(pt.tagName === "A" && pt.href)
            },
            dn = reactExports.useRef(!1),
            vn = useEventCallback(pt => {
                lt && !dn.current && Ot && $t.current && pt.key === " " && (dn.current = !0, $t.current.stop(pt, () => {
                    $t.current.start(pt)
                })), pt.target === pt.currentTarget && mn() && pt.key === " " && pt.preventDefault(), At && At(pt), pt.target === pt.currentTarget && mn() && pt.key === "Enter" && !rt && (pt.preventDefault(), bt && bt(pt))
            }),
            gn = useEventCallback(pt => {
                lt && pt.key === " " && $t.current && Ot && !pt.defaultPrevented && (dn.current = !1, $t.current.stop(pt, () => {
                    $t.current.pulsate(pt)
                })), Pt && Pt(pt), bt && pt.target === pt.currentTarget && mn() && pt.key === " " && !pt.defaultPrevented && bt(pt)
            });
        let Gt = nt;
        Gt === "button" && (mt.href || mt.to) && (Gt = ft);
        const Yt = {};
        Gt === "button" ? (Yt.type = at === void 0 ? "button" : at, Yt.disabled = rt) : (!mt.href && !mt.to && (Yt.role = "button"), rt && (Yt["aria-disabled"] = rt));
        const nn = useForkRef(a, Et, xt),
            St = _extends$4({}, $, {
                centerRipple: _e,
                component: nt,
                disabled: rt,
                disableRipple: ot,
                disableTouchRipple: st,
                focusRipple: lt,
                tabIndex: Wt,
                focusVisible: Ot
            }),
            ct = useUtilityClasses$K(St);
        return jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$4({
            as: Gt,
            className: clsx(ct.root, tt),
            ownerState: St,
            onBlur: fn,
            onClick: bt,
            onContextMenu: Zt,
            onFocus: rn,
            onKeyDown: vn,
            onKeyUp: gn,
            onMouseDown: Jt,
            onMouseLeave: cn,
            onMouseUp: ln,
            onDragLeave: en,
            onTouchEnd: Nn,
            onTouchMove: hn,
            onTouchStart: un,
            ref: nn,
            tabIndex: rt ? -1 : Wt,
            type: at
        }, Yt, mt, {
            children: [et, Kt ? jsxRuntimeExports.jsx(TouchRipple, _extends$4({
                ref: Rt,
                center: _e
            }, Ct)) : null]
        }))
    });

function getAccordionSummaryUtilityClass(s) {
    return generateUtilityClass("MuiAccordionSummary", s)
}
const accordionSummaryClasses = generateUtilityClasses("MuiAccordionSummary", ["root", "expanded", "focusVisible", "disabled", "gutters", "contentGutters", "content", "expandIconWrapper"]),
    _excluded$U = ["children", "className", "expandIcon", "focusVisibleClassName", "onClick"],
    useUtilityClasses$J = s => {
        const {
            classes: o,
            expanded: a,
            disabled: $,
            disableGutters: j
        } = s;
        return composeClasses({
            root: ["root", a && "expanded", $ && "disabled", !j && "gutters"],
            focusVisible: ["focusVisible"],
            content: ["content", a && "expanded", !j && "contentGutters"],
            expandIconWrapper: ["expandIconWrapper", a && "expanded"]
        }, getAccordionSummaryUtilityClass, o)
    },
    AccordionSummaryRoot = styled(ButtonBase, {
        name: "MuiAccordionSummary",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })(({
        theme: s
    }) => {
        const o = {
            duration: s.transitions.duration.shortest
        };
        return {
            display: "flex",
            minHeight: 48,
            padding: s.spacing(0, 2),
            transition: s.transitions.create(["min-height", "background-color"], o),
            [`&.${accordionSummaryClasses.focusVisible}`]: {
                backgroundColor: (s.vars || s).palette.action.focus
            },
            [`&.${accordionSummaryClasses.disabled}`]: {
                opacity: (s.vars || s).palette.action.disabledOpacity
            },
            [`&:hover:not(.${accordionSummaryClasses.disabled})`]: {
                cursor: "pointer"
            },
            variants: [{
                props: a => !a.disableGutters,
                style: {
                    [`&.${accordionSummaryClasses.expanded}`]: {
                        minHeight: 64
                    }
                }
            }]
        }
    }),
    AccordionSummaryContent = styled("div", {
        name: "MuiAccordionSummary",
        slot: "Content",
        overridesResolver: (s, o) => o.content
    })(({
        theme: s
    }) => ({
        display: "flex",
        flexGrow: 1,
        margin: "12px 0",
        variants: [{
            props: o => !o.disableGutters,
            style: {
                transition: s.transitions.create(["margin"], {
                    duration: s.transitions.duration.shortest
                }),
                [`&.${accordionSummaryClasses.expanded}`]: {
                    margin: "20px 0"
                }
            }
        }]
    })),
    AccordionSummaryExpandIconWrapper = styled("div", {
        name: "MuiAccordionSummary",
        slot: "ExpandIconWrapper",
        overridesResolver: (s, o) => o.expandIconWrapper
    })(({
        theme: s
    }) => ({
        display: "flex",
        color: (s.vars || s).palette.action.active,
        transform: "rotate(0deg)",
        transition: s.transitions.create("transform", {
            duration: s.transitions.duration.shortest
        }),
        [`&.${accordionSummaryClasses.expanded}`]: {
            transform: "rotate(180deg)"
        }
    })),
    AccordionSummary = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiAccordionSummary"
            }),
            {
                children: j,
                className: _e,
                expandIcon: et,
                focusVisibleClassName: tt,
                onClick: nt
            } = $,
            rt = _objectWithoutPropertiesLoose$1($, _excluded$U),
            {
                disabled: ot = !1,
                disableGutters: st,
                expanded: lt,
                toggle: ft
            } = reactExports.useContext(AccordionContext),
            yt = vt => {
                ft && ft(vt), nt && nt(vt)
            },
            bt = _extends$4({}, $, {
                expanded: lt,
                disabled: ot,
                disableGutters: st
            }),
            ht = useUtilityClasses$J(bt);
        return jsxRuntimeExports.jsxs(AccordionSummaryRoot, _extends$4({
            focusRipple: !1,
            disableRipple: !0,
            disabled: ot,
            component: "div",
            "aria-expanded": lt,
            className: clsx(ht.root, _e),
            focusVisibleClassName: clsx(ht.focusVisible, tt),
            onClick: yt,
            ref: a,
            ownerState: bt
        }, rt, {
            children: [jsxRuntimeExports.jsx(AccordionSummaryContent, {
                className: ht.content,
                ownerState: bt,
                children: j
            }), et && jsxRuntimeExports.jsx(AccordionSummaryExpandIconWrapper, {
                className: ht.expandIconWrapper,
                ownerState: bt,
                children: et
            })]
        }))
    });

function getIconButtonUtilityClass(s) {
    return generateUtilityClass("MuiIconButton", s)
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]),
    _excluded$T = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"],
    useUtilityClasses$I = s => {
        const {
            classes: o,
            disabled: a,
            color: $,
            edge: j,
            size: _e
        } = s, et = {
            root: ["root", a && "disabled", $ !== "default" && `color${capitalize$1($)}`, j && `edge${capitalize$1(j)}`, `size${capitalize$1(_e)}`]
        };
        return composeClasses(et, getIconButtonUtilityClass, o)
    },
    IconButtonRoot = styled(ButtonBase, {
        name: "MuiIconButton",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.color !== "default" && o[`color${capitalize$1(a.color)}`], a.edge && o[`edge${capitalize$1(a.edge)}`], o[`size${capitalize$1(a.size)}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        textAlign: "center",
        flex: "0 0 auto",
        fontSize: s.typography.pxToRem(24),
        padding: 8,
        borderRadius: "50%",
        overflow: "visible",
        color: (s.vars || s).palette.action.active,
        transition: s.transitions.create("background-color", {
            duration: s.transitions.duration.shortest
        })
    }, !o.disableRipple && {
        "&:hover": {
            backgroundColor: s.vars ? `rgba(${s.vars.palette.action.activeChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(s.palette.action.active, s.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        }
    }, o.edge === "start" && {
        marginLeft: o.size === "small" ? -3 : -12
    }, o.edge === "end" && {
        marginRight: o.size === "small" ? -3 : -12
    }), ({
        theme: s,
        ownerState: o
    }) => {
        var a;
        const $ = (a = (s.vars || s).palette) == null ? void 0 : a[o.color];
        return _extends$4({}, o.color === "inherit" && {
            color: "inherit"
        }, o.color !== "inherit" && o.color !== "default" && _extends$4({
            color: $ == null ? void 0 : $.main
        }, !o.disableRipple && {
            "&:hover": _extends$4({}, $ && {
                backgroundColor: s.vars ? `rgba(${$.mainChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1($.main, s.palette.action.hoverOpacity)
            }, {
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            })
        }), o.size === "small" && {
            padding: 5,
            fontSize: s.typography.pxToRem(18)
        }, o.size === "large" && {
            padding: 12,
            fontSize: s.typography.pxToRem(28)
        }, {
            [`&.${iconButtonClasses.disabled}`]: {
                backgroundColor: "transparent",
                color: (s.vars || s).palette.action.disabled
            }
        })
    }),
    IconButton = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiIconButton"
            }),
            {
                edge: j = !1,
                children: _e,
                className: et,
                color: tt = "default",
                disabled: nt = !1,
                disableFocusRipple: rt = !1,
                size: ot = "medium"
            } = $,
            st = _objectWithoutPropertiesLoose$1($, _excluded$T),
            lt = _extends$4({}, $, {
                edge: j,
                color: tt,
                disabled: nt,
                disableFocusRipple: rt,
                size: ot
            }),
            ft = useUtilityClasses$I(lt);
        return jsxRuntimeExports.jsx(IconButtonRoot, _extends$4({
            className: clsx(ft.root, et),
            centerRipple: !0,
            focusRipple: !rt,
            disabled: nt,
            ref: a
        }, st, {
            ownerState: lt,
            children: _e
        }))
    });

function getTypographyUtilityClass(s) {
    return generateUtilityClass("MuiTypography", s)
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$S = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"],
    useUtilityClasses$H = s => {
        const {
            align: o,
            gutterBottom: a,
            noWrap: $,
            paragraph: j,
            variant: _e,
            classes: et
        } = s, tt = {
            root: ["root", _e, s.align !== "inherit" && `align${capitalize$1(o)}`, a && "gutterBottom", $ && "noWrap", j && "paragraph"]
        };
        return composeClasses(tt, getTypographyUtilityClass, et)
    },
    TypographyRoot = styled("span", {
        name: "MuiTypography",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.variant && o[a.variant], a.align !== "inherit" && o[`align${capitalize$1(a.align)}`], a.noWrap && o.noWrap, a.gutterBottom && o.gutterBottom, a.paragraph && o.paragraph]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        margin: 0
    }, o.variant === "inherit" && {
        font: "inherit"
    }, o.variant !== "inherit" && s.typography[o.variant], o.align !== "inherit" && {
        textAlign: o.align
    }, o.noWrap && {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
    }, o.gutterBottom && {
        marginBottom: "0.35em"
    }, o.paragraph && {
        marginBottom: 16
    })),
    defaultVariantMapping = {
        h1: "h1",
        h2: "h2",
        h3: "h3",
        h4: "h4",
        h5: "h5",
        h6: "h6",
        subtitle1: "h6",
        subtitle2: "h6",
        body1: "p",
        body2: "p",
        inherit: "p"
    },
    colorTransformations = {
        primary: "primary.main",
        textPrimary: "text.primary",
        secondary: "secondary.main",
        textSecondary: "text.secondary",
        error: "error.main"
    },
    transformDeprecatedColors = s => colorTransformations[s] || s,
    Typography = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTypography"
            }),
            j = transformDeprecatedColors($.color),
            _e = extendSxProp(_extends$4({}, $, {
                color: j
            })),
            {
                align: et = "inherit",
                className: tt,
                component: nt,
                gutterBottom: rt = !1,
                noWrap: ot = !1,
                paragraph: st = !1,
                variant: lt = "body1",
                variantMapping: ft = defaultVariantMapping
            } = _e,
            yt = _objectWithoutPropertiesLoose$1(_e, _excluded$S),
            bt = _extends$4({}, _e, {
                align: et,
                color: j,
                className: tt,
                component: nt,
                gutterBottom: rt,
                noWrap: ot,
                paragraph: st,
                variant: lt,
                variantMapping: ft
            }),
            ht = nt || (st ? "p" : ft[lt] || defaultVariantMapping[lt]) || "span",
            vt = useUtilityClasses$H(bt);
        return jsxRuntimeExports.jsx(TypographyRoot, _extends$4({
            as: ht,
            ref: a,
            ownerState: bt,
            className: clsx(vt.root, tt)
        }, yt))
    });
var useThemeWithoutDefault = {};
Object.defineProperty(useThemeWithoutDefault, "__esModule", {
    value: !0
});
var default_1$4 = useThemeWithoutDefault.default = void 0,
    React = _interopRequireWildcard(reactExports),
    _styledEngine = require$$1$2;

function _getRequireWildcardCache(s) {
    if (typeof WeakMap != "function") return null;
    var o = new WeakMap,
        a = new WeakMap;
    return (_getRequireWildcardCache = function($) {
        return $ ? a : o
    })(s)
}

function _interopRequireWildcard(s, o) {
    if (s && s.__esModule) return s;
    if (s === null || typeof s != "object" && typeof s != "function") return {
        default: s
    };
    var a = _getRequireWildcardCache(o);
    if (a && a.has(s)) return a.get(s);
    var $ = {
            __proto__: null
        },
        j = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var _e in s)
        if (_e !== "default" && Object.prototype.hasOwnProperty.call(s, _e)) {
            var et = j ? Object.getOwnPropertyDescriptor(s, _e) : null;
            et && (et.get || et.set) ? Object.defineProperty($, _e, et) : $[_e] = s[_e]
        }
    return $.default = s, a && a.set(s, $), $
}

function isObjectEmpty(s) {
    return Object.keys(s).length === 0
}

function useTheme(s = null) {
    const o = React.useContext(_styledEngine.ThemeContext);
    return !o || isObjectEmpty(o) ? s : o
}
default_1$4 = useThemeWithoutDefault.default = useTheme;
var top = "top",
    bottom = "bottom",
    right = "right",
    left = "left",
    auto$1 = "auto",
    basePlacements = [top, bottom, right, left],
    start = "start",
    end = "end",
    clippingParents = "clippingParents",
    viewport = "viewport",
    popper = "popper",
    reference = "reference",
    variationPlacements = basePlacements.reduce(function(s, o) {
        return s.concat([o + "-" + start, o + "-" + end])
    }, []),
    placements = [].concat(basePlacements, [auto$1]).reduce(function(s, o) {
        return s.concat([o, o + "-" + start, o + "-" + end])
    }, []),
    beforeRead = "beforeRead",
    read = "read",
    afterRead = "afterRead",
    beforeMain = "beforeMain",
    main = "main",
    afterMain = "afterMain",
    beforeWrite = "beforeWrite",
    write = "write",
    afterWrite = "afterWrite",
    modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(s) {
    return s ? (s.nodeName || "").toLowerCase() : null
}

function getWindow(s) {
    if (s == null) return window;
    if (s.toString() !== "[object Window]") {
        var o = s.ownerDocument;
        return o && o.defaultView || window
    }
    return s
}

function isElement(s) {
    var o = getWindow(s).Element;
    return s instanceof o || s instanceof Element
}

function isHTMLElement$1(s) {
    var o = getWindow(s).HTMLElement;
    return s instanceof o || s instanceof HTMLElement
}

function isShadowRoot(s) {
    if (typeof ShadowRoot > "u") return !1;
    var o = getWindow(s).ShadowRoot;
    return s instanceof o || s instanceof ShadowRoot
}

function applyStyles(s) {
    var o = s.state;
    Object.keys(o.elements).forEach(function(a) {
        var $ = o.styles[a] || {},
            j = o.attributes[a] || {},
            _e = o.elements[a];
        !isHTMLElement$1(_e) || !getNodeName(_e) || (Object.assign(_e.style, $), Object.keys(j).forEach(function(et) {
            var tt = j[et];
            tt === !1 ? _e.removeAttribute(et) : _e.setAttribute(et, tt === !0 ? "" : tt)
        }))
    })
}

function effect$2(s) {
    var o = s.state,
        a = {
            popper: {
                position: o.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(o.elements.popper.style, a.popper), o.styles = a, o.elements.arrow && Object.assign(o.elements.arrow.style, a.arrow),
        function() {
            Object.keys(o.elements).forEach(function($) {
                var j = o.elements[$],
                    _e = o.attributes[$] || {},
                    et = Object.keys(o.styles.hasOwnProperty($) ? o.styles[$] : a[$]),
                    tt = et.reduce(function(nt, rt) {
                        return nt[rt] = "", nt
                    }, {});
                !isHTMLElement$1(j) || !getNodeName(j) || (Object.assign(j.style, tt), Object.keys(_e).forEach(function(nt) {
                    j.removeAttribute(nt)
                }))
            })
        }
}
const applyStyles$1 = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"]
};

function getBasePlacement(s) {
    return s.split("-")[0]
}
var max$1 = Math.max,
    min = Math.min,
    round$1 = Math.round;

function getUAString() {
    var s = navigator.userAgentData;
    return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(o) {
        return o.brand + "/" + o.version
    }).join(" ") : navigator.userAgent
}

function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString())
}

function getBoundingClientRect(s, o, a) {
    o === void 0 && (o = !1), a === void 0 && (a = !1);
    var $ = s.getBoundingClientRect(),
        j = 1,
        _e = 1;
    o && isHTMLElement$1(s) && (j = s.offsetWidth > 0 && round$1($.width) / s.offsetWidth || 1, _e = s.offsetHeight > 0 && round$1($.height) / s.offsetHeight || 1);
    var et = isElement(s) ? getWindow(s) : window,
        tt = et.visualViewport,
        nt = !isLayoutViewport() && a,
        rt = ($.left + (nt && tt ? tt.offsetLeft : 0)) / j,
        ot = ($.top + (nt && tt ? tt.offsetTop : 0)) / _e,
        st = $.width / j,
        lt = $.height / _e;
    return {
        width: st,
        height: lt,
        top: ot,
        right: rt + st,
        bottom: ot + lt,
        left: rt,
        x: rt,
        y: ot
    }
}

function getLayoutRect(s) {
    var o = getBoundingClientRect(s),
        a = s.offsetWidth,
        $ = s.offsetHeight;
    return Math.abs(o.width - a) <= 1 && (a = o.width), Math.abs(o.height - $) <= 1 && ($ = o.height), {
        x: s.offsetLeft,
        y: s.offsetTop,
        width: a,
        height: $
    }
}

function contains(s, o) {
    var a = o.getRootNode && o.getRootNode();
    if (s.contains(o)) return !0;
    if (a && isShadowRoot(a)) {
        var $ = o;
        do {
            if ($ && s.isSameNode($)) return !0;
            $ = $.parentNode || $.host
        } while ($)
    }
    return !1
}

function getComputedStyle$1(s) {
    return getWindow(s).getComputedStyle(s)
}

function isTableElement(s) {
    return ["table", "td", "th"].indexOf(getNodeName(s)) >= 0
}

function getDocumentElement(s) {
    return ((isElement(s) ? s.ownerDocument : s.document) || window.document).documentElement
}

function getParentNode(s) {
    return getNodeName(s) === "html" ? s : s.assignedSlot || s.parentNode || (isShadowRoot(s) ? s.host : null) || getDocumentElement(s)
}

function getTrueOffsetParent(s) {
    return !isHTMLElement$1(s) || getComputedStyle$1(s).position === "fixed" ? null : s.offsetParent
}

function getContainingBlock(s) {
    var o = /firefox/i.test(getUAString()),
        a = /Trident/i.test(getUAString());
    if (a && isHTMLElement$1(s)) {
        var $ = getComputedStyle$1(s);
        if ($.position === "fixed") return null
    }
    var j = getParentNode(s);
    for (isShadowRoot(j) && (j = j.host); isHTMLElement$1(j) && ["html", "body"].indexOf(getNodeName(j)) < 0;) {
        var _e = getComputedStyle$1(j);
        if (_e.transform !== "none" || _e.perspective !== "none" || _e.contain === "paint" || ["transform", "perspective"].indexOf(_e.willChange) !== -1 || o && _e.willChange === "filter" || o && _e.filter && _e.filter !== "none") return j;
        j = j.parentNode
    }
    return null
}

function getOffsetParent(s) {
    for (var o = getWindow(s), a = getTrueOffsetParent(s); a && isTableElement(a) && getComputedStyle$1(a).position === "static";) a = getTrueOffsetParent(a);
    return a && (getNodeName(a) === "html" || getNodeName(a) === "body" && getComputedStyle$1(a).position === "static") ? o : a || getContainingBlock(s) || o
}

function getMainAxisFromPlacement(s) {
    return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y"
}

function within(s, o, a) {
    return max$1(s, min(o, a))
}

function withinMaxClamp(s, o, a) {
    var $ = within(s, o, a);
    return $ > a ? a : $
}

function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}

function mergePaddingObject(s) {
    return Object.assign({}, getFreshSideObject(), s)
}

function expandToHashMap(s, o) {
    return o.reduce(function(a, $) {
        return a[$] = s, a
    }, {})
}
var toPaddingObject = function(o, a) {
    return o = typeof o == "function" ? o(Object.assign({}, a.rects, {
        placement: a.placement
    })) : o, mergePaddingObject(typeof o != "number" ? o : expandToHashMap(o, basePlacements))
};

function arrow(s) {
    var o, a = s.state,
        $ = s.name,
        j = s.options,
        _e = a.elements.arrow,
        et = a.modifiersData.popperOffsets,
        tt = getBasePlacement(a.placement),
        nt = getMainAxisFromPlacement(tt),
        rt = [left, right].indexOf(tt) >= 0,
        ot = rt ? "height" : "width";
    if (!(!_e || !et)) {
        var st = toPaddingObject(j.padding, a),
            lt = getLayoutRect(_e),
            ft = nt === "y" ? top : left,
            yt = nt === "y" ? bottom : right,
            bt = a.rects.reference[ot] + a.rects.reference[nt] - et[nt] - a.rects.popper[ot],
            ht = et[nt] - a.rects.reference[nt],
            vt = getOffsetParent(_e),
            wt = vt ? nt === "y" ? vt.clientHeight || 0 : vt.clientWidth || 0 : 0,
            gt = bt / 2 - ht / 2,
            At = st[ft],
            Pt = wt - lt[ot] - st[yt],
            Bt = wt / 2 - lt[ot] / 2 + gt,
            Lt = within(At, Bt, Pt),
            Nt = nt;
        a.modifiersData[$] = (o = {}, o[Nt] = Lt, o.centerOffset = Lt - Bt, o)
    }
}

function effect$1(s) {
    var o = s.state,
        a = s.options,
        $ = a.element,
        j = $ === void 0 ? "[data-popper-arrow]" : $;
    j != null && (typeof j == "string" && (j = o.elements.popper.querySelector(j), !j) || contains(o.elements.popper, j) && (o.elements.arrow = j))
}
const arrow$1 = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};

function getVariation(s) {
    return s.split("-")[1]
}
var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};

function roundOffsetsByDPR(s, o) {
    var a = s.x,
        $ = s.y,
        j = o.devicePixelRatio || 1;
    return {
        x: round$1(a * j) / j || 0,
        y: round$1($ * j) / j || 0
    }
}

function mapToStyles(s) {
    var o, a = s.popper,
        $ = s.popperRect,
        j = s.placement,
        _e = s.variation,
        et = s.offsets,
        tt = s.position,
        nt = s.gpuAcceleration,
        rt = s.adaptive,
        ot = s.roundOffsets,
        st = s.isFixed,
        lt = et.x,
        ft = lt === void 0 ? 0 : lt,
        yt = et.y,
        bt = yt === void 0 ? 0 : yt,
        ht = typeof ot == "function" ? ot({
            x: ft,
            y: bt
        }) : {
            x: ft,
            y: bt
        };
    ft = ht.x, bt = ht.y;
    var vt = et.hasOwnProperty("x"),
        wt = et.hasOwnProperty("y"),
        gt = left,
        At = top,
        Pt = window;
    if (rt) {
        var Bt = getOffsetParent(a),
            Lt = "clientHeight",
            Nt = "clientWidth";
        if (Bt === getWindow(a) && (Bt = getDocumentElement(a), getComputedStyle$1(Bt).position !== "static" && tt === "absolute" && (Lt = "scrollHeight", Nt = "scrollWidth")), Bt = Bt, j === top || (j === left || j === right) && _e === end) {
            At = bottom;
            var Ut = st && Bt === Pt && Pt.visualViewport ? Pt.visualViewport.height : Bt[Lt];
            bt -= Ut - $.height, bt *= nt ? 1 : -1
        }
        if (j === left || (j === top || j === bottom) && _e === end) {
            gt = right;
            var Vt = st && Bt === Pt && Pt.visualViewport ? Pt.visualViewport.width : Bt[Nt];
            ft -= Vt - $.width, ft *= nt ? 1 : -1
        }
    }
    var Ft = Object.assign({
            position: tt
        }, rt && unsetSides),
        Wt = ot === !0 ? roundOffsetsByDPR({
            x: ft,
            y: bt
        }, getWindow(a)) : {
            x: ft,
            y: bt
        };
    if (ft = Wt.x, bt = Wt.y, nt) {
        var Ct;
        return Object.assign({}, Ft, (Ct = {}, Ct[At] = wt ? "0" : "", Ct[gt] = vt ? "0" : "", Ct.transform = (Pt.devicePixelRatio || 1) <= 1 ? "translate(" + ft + "px, " + bt + "px)" : "translate3d(" + ft + "px, " + bt + "px, 0)", Ct))
    }
    return Object.assign({}, Ft, (o = {}, o[At] = wt ? bt + "px" : "", o[gt] = vt ? ft + "px" : "", o.transform = "", o))
}

function computeStyles(s) {
    var o = s.state,
        a = s.options,
        $ = a.gpuAcceleration,
        j = $ === void 0 ? !0 : $,
        _e = a.adaptive,
        et = _e === void 0 ? !0 : _e,
        tt = a.roundOffsets,
        nt = tt === void 0 ? !0 : tt,
        rt = {
            placement: getBasePlacement(o.placement),
            variation: getVariation(o.placement),
            popper: o.elements.popper,
            popperRect: o.rects.popper,
            gpuAcceleration: j,
            isFixed: o.options.strategy === "fixed"
        };
    o.modifiersData.popperOffsets != null && (o.styles.popper = Object.assign({}, o.styles.popper, mapToStyles(Object.assign({}, rt, {
        offsets: o.modifiersData.popperOffsets,
        position: o.options.strategy,
        adaptive: et,
        roundOffsets: nt
    })))), o.modifiersData.arrow != null && (o.styles.arrow = Object.assign({}, o.styles.arrow, mapToStyles(Object.assign({}, rt, {
        offsets: o.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: nt
    })))), o.attributes.popper = Object.assign({}, o.attributes.popper, {
        "data-popper-placement": o.placement
    })
}
const computeStyles$1 = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
};
var passive = {
    passive: !0
};

function effect(s) {
    var o = s.state,
        a = s.instance,
        $ = s.options,
        j = $.scroll,
        _e = j === void 0 ? !0 : j,
        et = $.resize,
        tt = et === void 0 ? !0 : et,
        nt = getWindow(o.elements.popper),
        rt = [].concat(o.scrollParents.reference, o.scrollParents.popper);
    return _e && rt.forEach(function(ot) {
            ot.addEventListener("scroll", a.update, passive)
        }), tt && nt.addEventListener("resize", a.update, passive),
        function() {
            _e && rt.forEach(function(ot) {
                ot.removeEventListener("scroll", a.update, passive)
            }), tt && nt.removeEventListener("resize", a.update, passive)
        }
}
const eventListeners = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect,
    data: {}
};
var hash$4 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};

function getOppositePlacement(s) {
    return s.replace(/left|right|bottom|top/g, function(o) {
        return hash$4[o]
    })
}
var hash$3 = {
    start: "end",
    end: "start"
};

function getOppositeVariationPlacement(s) {
    return s.replace(/start|end/g, function(o) {
        return hash$3[o]
    })
}

function getWindowScroll(s) {
    var o = getWindow(s),
        a = o.pageXOffset,
        $ = o.pageYOffset;
    return {
        scrollLeft: a,
        scrollTop: $
    }
}

function getWindowScrollBarX(s) {
    return getBoundingClientRect(getDocumentElement(s)).left + getWindowScroll(s).scrollLeft
}

function getViewportRect(s, o) {
    var a = getWindow(s),
        $ = getDocumentElement(s),
        j = a.visualViewport,
        _e = $.clientWidth,
        et = $.clientHeight,
        tt = 0,
        nt = 0;
    if (j) {
        _e = j.width, et = j.height;
        var rt = isLayoutViewport();
        (rt || !rt && o === "fixed") && (tt = j.offsetLeft, nt = j.offsetTop)
    }
    return {
        width: _e,
        height: et,
        x: tt + getWindowScrollBarX(s),
        y: nt
    }
}

function getDocumentRect(s) {
    var o, a = getDocumentElement(s),
        $ = getWindowScroll(s),
        j = (o = s.ownerDocument) == null ? void 0 : o.body,
        _e = max$1(a.scrollWidth, a.clientWidth, j ? j.scrollWidth : 0, j ? j.clientWidth : 0),
        et = max$1(a.scrollHeight, a.clientHeight, j ? j.scrollHeight : 0, j ? j.clientHeight : 0),
        tt = -$.scrollLeft + getWindowScrollBarX(s),
        nt = -$.scrollTop;
    return getComputedStyle$1(j || a).direction === "rtl" && (tt += max$1(a.clientWidth, j ? j.clientWidth : 0) - _e), {
        width: _e,
        height: et,
        x: tt,
        y: nt
    }
}

function isScrollParent(s) {
    var o = getComputedStyle$1(s),
        a = o.overflow,
        $ = o.overflowX,
        j = o.overflowY;
    return /auto|scroll|overlay|hidden/.test(a + j + $)
}

function getScrollParent(s) {
    return ["html", "body", "#document"].indexOf(getNodeName(s)) >= 0 ? s.ownerDocument.body : isHTMLElement$1(s) && isScrollParent(s) ? s : getScrollParent(getParentNode(s))
}

function listScrollParents(s, o) {
    var a;
    o === void 0 && (o = []);
    var $ = getScrollParent(s),
        j = $ === ((a = s.ownerDocument) == null ? void 0 : a.body),
        _e = getWindow($),
        et = j ? [_e].concat(_e.visualViewport || [], isScrollParent($) ? $ : []) : $,
        tt = o.concat(et);
    return j ? tt : tt.concat(listScrollParents(getParentNode(et)))
}

function rectToClientRect(s) {
    return Object.assign({}, s, {
        left: s.x,
        top: s.y,
        right: s.x + s.width,
        bottom: s.y + s.height
    })
}

function getInnerBoundingClientRect(s, o) {
    var a = getBoundingClientRect(s, !1, o === "fixed");
    return a.top = a.top + s.clientTop, a.left = a.left + s.clientLeft, a.bottom = a.top + s.clientHeight, a.right = a.left + s.clientWidth, a.width = s.clientWidth, a.height = s.clientHeight, a.x = a.left, a.y = a.top, a
}

function getClientRectFromMixedType(s, o, a) {
    return o === viewport ? rectToClientRect(getViewportRect(s, a)) : isElement(o) ? getInnerBoundingClientRect(o, a) : rectToClientRect(getDocumentRect(getDocumentElement(s)))
}

function getClippingParents(s) {
    var o = listScrollParents(getParentNode(s)),
        a = ["absolute", "fixed"].indexOf(getComputedStyle$1(s).position) >= 0,
        $ = a && isHTMLElement$1(s) ? getOffsetParent(s) : s;
    return isElement($) ? o.filter(function(j) {
        return isElement(j) && contains(j, $) && getNodeName(j) !== "body"
    }) : []
}

function getClippingRect(s, o, a, $) {
    var j = o === "clippingParents" ? getClippingParents(s) : [].concat(o),
        _e = [].concat(j, [a]),
        et = _e[0],
        tt = _e.reduce(function(nt, rt) {
            var ot = getClientRectFromMixedType(s, rt, $);
            return nt.top = max$1(ot.top, nt.top), nt.right = min(ot.right, nt.right), nt.bottom = min(ot.bottom, nt.bottom), nt.left = max$1(ot.left, nt.left), nt
        }, getClientRectFromMixedType(s, et, $));
    return tt.width = tt.right - tt.left, tt.height = tt.bottom - tt.top, tt.x = tt.left, tt.y = tt.top, tt
}

function computeOffsets(s) {
    var o = s.reference,
        a = s.element,
        $ = s.placement,
        j = $ ? getBasePlacement($) : null,
        _e = $ ? getVariation($) : null,
        et = o.x + o.width / 2 - a.width / 2,
        tt = o.y + o.height / 2 - a.height / 2,
        nt;
    switch (j) {
        case top:
            nt = {
                x: et,
                y: o.y - a.height
            };
            break;
        case bottom:
            nt = {
                x: et,
                y: o.y + o.height
            };
            break;
        case right:
            nt = {
                x: o.x + o.width,
                y: tt
            };
            break;
        case left:
            nt = {
                x: o.x - a.width,
                y: tt
            };
            break;
        default:
            nt = {
                x: o.x,
                y: o.y
            }
    }
    var rt = j ? getMainAxisFromPlacement(j) : null;
    if (rt != null) {
        var ot = rt === "y" ? "height" : "width";
        switch (_e) {
            case start:
                nt[rt] = nt[rt] - (o[ot] / 2 - a[ot] / 2);
                break;
            case end:
                nt[rt] = nt[rt] + (o[ot] / 2 - a[ot] / 2);
                break
        }
    }
    return nt
}

function detectOverflow(s, o) {
    o === void 0 && (o = {});
    var a = o,
        $ = a.placement,
        j = $ === void 0 ? s.placement : $,
        _e = a.strategy,
        et = _e === void 0 ? s.strategy : _e,
        tt = a.boundary,
        nt = tt === void 0 ? clippingParents : tt,
        rt = a.rootBoundary,
        ot = rt === void 0 ? viewport : rt,
        st = a.elementContext,
        lt = st === void 0 ? popper : st,
        ft = a.altBoundary,
        yt = ft === void 0 ? !1 : ft,
        bt = a.padding,
        ht = bt === void 0 ? 0 : bt,
        vt = mergePaddingObject(typeof ht != "number" ? ht : expandToHashMap(ht, basePlacements)),
        wt = lt === popper ? reference : popper,
        gt = s.rects.popper,
        At = s.elements[yt ? wt : lt],
        Pt = getClippingRect(isElement(At) ? At : At.contextElement || getDocumentElement(s.elements.popper), nt, ot, et),
        Bt = getBoundingClientRect(s.elements.reference),
        Lt = computeOffsets({
            reference: Bt,
            element: gt,
            strategy: "absolute",
            placement: j
        }),
        Nt = rectToClientRect(Object.assign({}, gt, Lt)),
        Ut = lt === popper ? Nt : Bt,
        Vt = {
            top: Pt.top - Ut.top + vt.top,
            bottom: Ut.bottom - Pt.bottom + vt.bottom,
            left: Pt.left - Ut.left + vt.left,
            right: Ut.right - Pt.right + vt.right
        },
        Ft = s.modifiersData.offset;
    if (lt === popper && Ft) {
        var Wt = Ft[j];
        Object.keys(Vt).forEach(function(Ct) {
            var it = [right, bottom].indexOf(Ct) >= 0 ? 1 : -1,
                at = [top, bottom].indexOf(Ct) >= 0 ? "y" : "x";
            Vt[Ct] += Wt[at] * it
        })
    }
    return Vt
}

function computeAutoPlacement(s, o) {
    o === void 0 && (o = {});
    var a = o,
        $ = a.placement,
        j = a.boundary,
        _e = a.rootBoundary,
        et = a.padding,
        tt = a.flipVariations,
        nt = a.allowedAutoPlacements,
        rt = nt === void 0 ? placements : nt,
        ot = getVariation($),
        st = ot ? tt ? variationPlacements : variationPlacements.filter(function(yt) {
            return getVariation(yt) === ot
        }) : basePlacements,
        lt = st.filter(function(yt) {
            return rt.indexOf(yt) >= 0
        });
    lt.length === 0 && (lt = st);
    var ft = lt.reduce(function(yt, bt) {
        return yt[bt] = detectOverflow(s, {
            placement: bt,
            boundary: j,
            rootBoundary: _e,
            padding: et
        })[getBasePlacement(bt)], yt
    }, {});
    return Object.keys(ft).sort(function(yt, bt) {
        return ft[yt] - ft[bt]
    })
}

function getExpandedFallbackPlacements(s) {
    if (getBasePlacement(s) === auto$1) return [];
    var o = getOppositePlacement(s);
    return [getOppositeVariationPlacement(s), o, getOppositeVariationPlacement(o)]
}

function flip(s) {
    var o = s.state,
        a = s.options,
        $ = s.name;
    if (!o.modifiersData[$]._skip) {
        for (var j = a.mainAxis, _e = j === void 0 ? !0 : j, et = a.altAxis, tt = et === void 0 ? !0 : et, nt = a.fallbackPlacements, rt = a.padding, ot = a.boundary, st = a.rootBoundary, lt = a.altBoundary, ft = a.flipVariations, yt = ft === void 0 ? !0 : ft, bt = a.allowedAutoPlacements, ht = o.options.placement, vt = getBasePlacement(ht), wt = vt === ht, gt = nt || (wt || !yt ? [getOppositePlacement(ht)] : getExpandedFallbackPlacements(ht)), At = [ht].concat(gt).reduce(function(Ot, Mt) {
                return Ot.concat(getBasePlacement(Mt) === auto$1 ? computeAutoPlacement(o, {
                    placement: Mt,
                    boundary: ot,
                    rootBoundary: st,
                    padding: rt,
                    flipVariations: yt,
                    allowedAutoPlacements: bt
                }) : Mt)
            }, []), Pt = o.rects.reference, Bt = o.rects.popper, Lt = new Map, Nt = !0, Ut = At[0], Vt = 0; Vt < At.length; Vt++) {
            var Ft = At[Vt],
                Wt = getBasePlacement(Ft),
                Ct = getVariation(Ft) === start,
                it = [top, bottom].indexOf(Wt) >= 0,
                at = it ? "width" : "height",
                mt = detectOverflow(o, {
                    placement: Ft,
                    boundary: ot,
                    rootBoundary: st,
                    altBoundary: lt,
                    padding: rt
                }),
                xt = it ? Ct ? right : left : Ct ? bottom : top;
            Pt[at] > Bt[at] && (xt = getOppositePlacement(xt));
            var $t = getOppositePlacement(xt),
                Rt = [];
            if (_e && Rt.push(mt[Wt] <= 0), tt && Rt.push(mt[xt] <= 0, mt[$t] <= 0), Rt.every(function(Ot) {
                    return Ot
                })) {
                Ut = Ft, Nt = !1;
                break
            }
            Lt.set(Ft, Rt)
        }
        if (Nt)
            for (var It = yt ? 3 : 1, Tt = function(Mt) {
                    var jt = At.find(function(Qt) {
                        var Kt = Lt.get(Qt);
                        if (Kt) return Kt.slice(0, Mt).every(function(qt) {
                            return qt
                        })
                    });
                    if (jt) return Ut = jt, "break"
                }, dt = It; dt > 0; dt--) {
                var Et = Tt(dt);
                if (Et === "break") break
            }
        o.placement !== Ut && (o.modifiersData[$]._skip = !0, o.placement = Ut, o.reset = !0)
    }
}
const flip$1 = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};

function getSideOffsets(s, o, a) {
    return a === void 0 && (a = {
        x: 0,
        y: 0
    }), {
        top: s.top - o.height - a.y,
        right: s.right - o.width + a.x,
        bottom: s.bottom - o.height + a.y,
        left: s.left - o.width - a.x
    }
}

function isAnySideFullyClipped(s) {
    return [top, right, bottom, left].some(function(o) {
        return s[o] >= 0
    })
}

function hide(s) {
    var o = s.state,
        a = s.name,
        $ = o.rects.reference,
        j = o.rects.popper,
        _e = o.modifiersData.preventOverflow,
        et = detectOverflow(o, {
            elementContext: "reference"
        }),
        tt = detectOverflow(o, {
            altBoundary: !0
        }),
        nt = getSideOffsets(et, $),
        rt = getSideOffsets(tt, j, _e),
        ot = isAnySideFullyClipped(nt),
        st = isAnySideFullyClipped(rt);
    o.modifiersData[a] = {
        referenceClippingOffsets: nt,
        popperEscapeOffsets: rt,
        isReferenceHidden: ot,
        hasPopperEscaped: st
    }, o.attributes.popper = Object.assign({}, o.attributes.popper, {
        "data-popper-reference-hidden": ot,
        "data-popper-escaped": st
    })
}
const hide$1 = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
};

function distanceAndSkiddingToXY(s, o, a) {
    var $ = getBasePlacement(s),
        j = [left, top].indexOf($) >= 0 ? -1 : 1,
        _e = typeof a == "function" ? a(Object.assign({}, o, {
            placement: s
        })) : a,
        et = _e[0],
        tt = _e[1];
    return et = et || 0, tt = (tt || 0) * j, [left, right].indexOf($) >= 0 ? {
        x: tt,
        y: et
    } : {
        x: et,
        y: tt
    }
}

function offset$3(s) {
    var o = s.state,
        a = s.options,
        $ = s.name,
        j = a.offset,
        _e = j === void 0 ? [0, 0] : j,
        et = placements.reduce(function(ot, st) {
            return ot[st] = distanceAndSkiddingToXY(st, o.rects, _e), ot
        }, {}),
        tt = et[o.placement],
        nt = tt.x,
        rt = tt.y;
    o.modifiersData.popperOffsets != null && (o.modifiersData.popperOffsets.x += nt, o.modifiersData.popperOffsets.y += rt), o.modifiersData[$] = et
}
const offset$4 = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset$3
};

function popperOffsets(s) {
    var o = s.state,
        a = s.name;
    o.modifiersData[a] = computeOffsets({
        reference: o.rects.reference,
        element: o.rects.popper,
        strategy: "absolute",
        placement: o.placement
    })
}
const popperOffsets$1 = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: popperOffsets,
    data: {}
};

function getAltAxis(s) {
    return s === "x" ? "y" : "x"
}

function preventOverflow(s) {
    var o = s.state,
        a = s.options,
        $ = s.name,
        j = a.mainAxis,
        _e = j === void 0 ? !0 : j,
        et = a.altAxis,
        tt = et === void 0 ? !1 : et,
        nt = a.boundary,
        rt = a.rootBoundary,
        ot = a.altBoundary,
        st = a.padding,
        lt = a.tether,
        ft = lt === void 0 ? !0 : lt,
        yt = a.tetherOffset,
        bt = yt === void 0 ? 0 : yt,
        ht = detectOverflow(o, {
            boundary: nt,
            rootBoundary: rt,
            padding: st,
            altBoundary: ot
        }),
        vt = getBasePlacement(o.placement),
        wt = getVariation(o.placement),
        gt = !wt,
        At = getMainAxisFromPlacement(vt),
        Pt = getAltAxis(At),
        Bt = o.modifiersData.popperOffsets,
        Lt = o.rects.reference,
        Nt = o.rects.popper,
        Ut = typeof bt == "function" ? bt(Object.assign({}, o.rects, {
            placement: o.placement
        })) : bt,
        Vt = typeof Ut == "number" ? {
            mainAxis: Ut,
            altAxis: Ut
        } : Object.assign({
            mainAxis: 0,
            altAxis: 0
        }, Ut),
        Ft = o.modifiersData.offset ? o.modifiersData.offset[o.placement] : null,
        Wt = {
            x: 0,
            y: 0
        };
    if (Bt) {
        if (_e) {
            var Ct, it = At === "y" ? top : left,
                at = At === "y" ? bottom : right,
                mt = At === "y" ? "height" : "width",
                xt = Bt[At],
                $t = xt + ht[it],
                Rt = xt - ht[at],
                It = ft ? -Nt[mt] / 2 : 0,
                Tt = wt === start ? Lt[mt] : Nt[mt],
                dt = wt === start ? -Nt[mt] : -Lt[mt],
                Et = o.elements.arrow,
                Ot = ft && Et ? getLayoutRect(Et) : {
                    width: 0,
                    height: 0
                },
                Mt = o.modifiersData["arrow#persistent"] ? o.modifiersData["arrow#persistent"].padding : getFreshSideObject(),
                jt = Mt[it],
                Qt = Mt[at],
                Kt = within(0, Lt[mt], Ot[mt]),
                qt = gt ? Lt[mt] / 2 - It - Kt - jt - Vt.mainAxis : Tt - Kt - jt - Vt.mainAxis,
                Jt = gt ? -Lt[mt] / 2 + It + Kt + Qt + Vt.mainAxis : dt + Kt + Qt + Vt.mainAxis,
                Zt = o.elements.arrow && getOffsetParent(o.elements.arrow),
                en = Zt ? At === "y" ? Zt.clientTop || 0 : Zt.clientLeft || 0 : 0,
                ln = (Ct = Ft == null ? void 0 : Ft[At]) != null ? Ct : 0,
                cn = xt + qt - ln - en,
                un = xt + Jt - ln,
                Nn = within(ft ? min($t, cn) : $t, xt, ft ? max$1(Rt, un) : Rt);
            Bt[At] = Nn, Wt[At] = Nn - xt
        }
        if (tt) {
            var hn, fn = At === "x" ? top : left,
                rn = At === "x" ? bottom : right,
                mn = Bt[Pt],
                dn = Pt === "y" ? "height" : "width",
                vn = mn + ht[fn],
                gn = mn - ht[rn],
                Gt = [top, left].indexOf(vt) !== -1,
                Yt = (hn = Ft == null ? void 0 : Ft[Pt]) != null ? hn : 0,
                nn = Gt ? vn : mn - Lt[dn] - Nt[dn] - Yt + Vt.altAxis,
                St = Gt ? mn + Lt[dn] + Nt[dn] - Yt - Vt.altAxis : gn,
                ct = ft && Gt ? withinMaxClamp(nn, mn, St) : within(ft ? nn : vn, mn, ft ? St : gn);
            Bt[Pt] = ct, Wt[Pt] = ct - mn
        }
        o.modifiersData[$] = Wt
    }
}
const preventOverflow$1 = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
};

function getHTMLElementScroll(s) {
    return {
        scrollLeft: s.scrollLeft,
        scrollTop: s.scrollTop
    }
}

function getNodeScroll(s) {
    return s === getWindow(s) || !isHTMLElement$1(s) ? getWindowScroll(s) : getHTMLElementScroll(s)
}

function isElementScaled(s) {
    var o = s.getBoundingClientRect(),
        a = round$1(o.width) / s.offsetWidth || 1,
        $ = round$1(o.height) / s.offsetHeight || 1;
    return a !== 1 || $ !== 1
}

function getCompositeRect(s, o, a) {
    a === void 0 && (a = !1);
    var $ = isHTMLElement$1(o),
        j = isHTMLElement$1(o) && isElementScaled(o),
        _e = getDocumentElement(o),
        et = getBoundingClientRect(s, j, a),
        tt = {
            scrollLeft: 0,
            scrollTop: 0
        },
        nt = {
            x: 0,
            y: 0
        };
    return ($ || !$ && !a) && ((getNodeName(o) !== "body" || isScrollParent(_e)) && (tt = getNodeScroll(o)), isHTMLElement$1(o) ? (nt = getBoundingClientRect(o, !0), nt.x += o.clientLeft, nt.y += o.clientTop) : _e && (nt.x = getWindowScrollBarX(_e))), {
        x: et.left + tt.scrollLeft - nt.x,
        y: et.top + tt.scrollTop - nt.y,
        width: et.width,
        height: et.height
    }
}

function order(s) {
    var o = new Map,
        a = new Set,
        $ = [];
    s.forEach(function(_e) {
        o.set(_e.name, _e)
    });

    function j(_e) {
        a.add(_e.name);
        var et = [].concat(_e.requires || [], _e.requiresIfExists || []);
        et.forEach(function(tt) {
            if (!a.has(tt)) {
                var nt = o.get(tt);
                nt && j(nt)
            }
        }), $.push(_e)
    }
    return s.forEach(function(_e) {
        a.has(_e.name) || j(_e)
    }), $
}

function orderModifiers(s) {
    var o = order(s);
    return modifierPhases.reduce(function(a, $) {
        return a.concat(o.filter(function(j) {
            return j.phase === $
        }))
    }, [])
}

function debounce(s) {
    var o;
    return function() {
        return o || (o = new Promise(function(a) {
            Promise.resolve().then(function() {
                o = void 0, a(s())
            })
        })), o
    }
}

function mergeByName(s) {
    var o = s.reduce(function(a, $) {
        var j = a[$.name];
        return a[$.name] = j ? Object.assign({}, j, $, {
            options: Object.assign({}, j.options, $.options),
            data: Object.assign({}, j.data, $.data)
        }) : $, a
    }, {});
    return Object.keys(o).map(function(a) {
        return o[a]
    })
}
var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};

function areValidElements() {
    for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++) o[a] = arguments[a];
    return !o.some(function($) {
        return !($ && typeof $.getBoundingClientRect == "function")
    })
}

function popperGenerator(s) {
    s === void 0 && (s = {});
    var o = s,
        a = o.defaultModifiers,
        $ = a === void 0 ? [] : a,
        j = o.defaultOptions,
        _e = j === void 0 ? DEFAULT_OPTIONS : j;
    return function(tt, nt, rt) {
        rt === void 0 && (rt = _e);
        var ot = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, DEFAULT_OPTIONS, _e),
                modifiersData: {},
                elements: {
                    reference: tt,
                    popper: nt
                },
                attributes: {},
                styles: {}
            },
            st = [],
            lt = !1,
            ft = {
                state: ot,
                setOptions: function(vt) {
                    var wt = typeof vt == "function" ? vt(ot.options) : vt;
                    bt(), ot.options = Object.assign({}, _e, ot.options, wt), ot.scrollParents = {
                        reference: isElement(tt) ? listScrollParents(tt) : tt.contextElement ? listScrollParents(tt.contextElement) : [],
                        popper: listScrollParents(nt)
                    };
                    var gt = orderModifiers(mergeByName([].concat($, ot.options.modifiers)));
                    return ot.orderedModifiers = gt.filter(function(At) {
                        return At.enabled
                    }), yt(), ft.update()
                },
                forceUpdate: function() {
                    if (!lt) {
                        var vt = ot.elements,
                            wt = vt.reference,
                            gt = vt.popper;
                        if (areValidElements(wt, gt)) {
                            ot.rects = {
                                reference: getCompositeRect(wt, getOffsetParent(gt), ot.options.strategy === "fixed"),
                                popper: getLayoutRect(gt)
                            }, ot.reset = !1, ot.placement = ot.options.placement, ot.orderedModifiers.forEach(function(Vt) {
                                return ot.modifiersData[Vt.name] = Object.assign({}, Vt.data)
                            });
                            for (var At = 0; At < ot.orderedModifiers.length; At++) {
                                if (ot.reset === !0) {
                                    ot.reset = !1, At = -1;
                                    continue
                                }
                                var Pt = ot.orderedModifiers[At],
                                    Bt = Pt.fn,
                                    Lt = Pt.options,
                                    Nt = Lt === void 0 ? {} : Lt,
                                    Ut = Pt.name;
                                typeof Bt == "function" && (ot = Bt({
                                    state: ot,
                                    options: Nt,
                                    name: Ut,
                                    instance: ft
                                }) || ot)
                            }
                        }
                    }
                },
                update: debounce(function() {
                    return new Promise(function(ht) {
                        ft.forceUpdate(), ht(ot)
                    })
                }),
                destroy: function() {
                    bt(), lt = !0
                }
            };
        if (!areValidElements(tt, nt)) return ft;
        ft.setOptions(rt).then(function(ht) {
            !lt && rt.onFirstUpdate && rt.onFirstUpdate(ht)
        });

        function yt() {
            ot.orderedModifiers.forEach(function(ht) {
                var vt = ht.name,
                    wt = ht.options,
                    gt = wt === void 0 ? {} : wt,
                    At = ht.effect;
                if (typeof At == "function") {
                    var Pt = At({
                            state: ot,
                            name: vt,
                            instance: ft,
                            options: gt
                        }),
                        Bt = function() {};
                    st.push(Pt || Bt)
                }
            })
        }

        function bt() {
            st.forEach(function(ht) {
                return ht()
            }), st = []
        }
        return ft
    }
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$4, flip$1, preventOverflow$1, arrow$1, hide$1],
    createPopper = popperGenerator({
        defaultModifiers
    });

function getContainer$1(s) {
    return typeof s == "function" ? s() : s
}
const Portal = reactExports.forwardRef(function(o, a) {
    const {
        children: $,
        container: j,
        disablePortal: _e = !1
    } = o, [et, tt] = reactExports.useState(null), nt = useForkRef(reactExports.isValidElement($) ? $.ref : null, a);
    if (useEnhancedEffect(() => {
            _e || tt(getContainer$1(j) || document.body)
        }, [j, _e]), useEnhancedEffect(() => {
            if (et && !_e) return setRef(a, et), () => {
                setRef(a, null)
            }
        }, [a, et, _e]), _e) {
        if (reactExports.isValidElement($)) {
            const rt = {
                ref: nt
            };
            return reactExports.cloneElement($, rt)
        }
        return jsxRuntimeExports.jsx(reactExports.Fragment, {
            children: $
        })
    }
    return jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: et && reactDomExports.createPortal($, et)
    })
});

function getPopperUtilityClass(s) {
    return generateUtilityClass("MuiPopper", s)
}
generateUtilityClasses("MuiPopper", ["root"]);
const _excluded$R = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"],
    _excluded2$6 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];

function flipPlacement(s, o) {
    if (o === "ltr") return s;
    switch (s) {
        case "bottom-end":
            return "bottom-start";
        case "bottom-start":
            return "bottom-end";
        case "top-end":
            return "top-start";
        case "top-start":
            return "top-end";
        default:
            return s
    }
}

function resolveAnchorEl$1(s) {
    return typeof s == "function" ? s() : s
}

function isHTMLElement(s) {
    return s.nodeType !== void 0
}
const useUtilityClasses$G = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"]
        }, getPopperUtilityClass, o)
    },
    defaultPopperOptions = {},
    PopperTooltip = reactExports.forwardRef(function(o, a) {
        var $;
        const {
            anchorEl: j,
            children: _e,
            direction: et,
            disablePortal: tt,
            modifiers: nt,
            open: rt,
            placement: ot,
            popperOptions: st,
            popperRef: lt,
            slotProps: ft = {},
            slots: yt = {},
            TransitionProps: bt
        } = o, ht = _objectWithoutPropertiesLoose$1(o, _excluded$R), vt = reactExports.useRef(null), wt = useForkRef(vt, a), gt = reactExports.useRef(null), At = useForkRef(gt, lt), Pt = reactExports.useRef(At);
        useEnhancedEffect(() => {
            Pt.current = At
        }, [At]), reactExports.useImperativeHandle(lt, () => gt.current, []);
        const Bt = flipPlacement(ot, et),
            [Lt, Nt] = reactExports.useState(Bt),
            [Ut, Vt] = reactExports.useState(resolveAnchorEl$1(j));
        reactExports.useEffect(() => {
            gt.current && gt.current.forceUpdate()
        }), reactExports.useEffect(() => {
            j && Vt(resolveAnchorEl$1(j))
        }, [j]), useEnhancedEffect(() => {
            if (!Ut || !rt) return;
            const at = $t => {
                Nt($t.placement)
            };
            let mt = [{
                name: "preventOverflow",
                options: {
                    altBoundary: tt
                }
            }, {
                name: "flip",
                options: {
                    altBoundary: tt
                }
            }, {
                name: "onUpdate",
                enabled: !0,
                phase: "afterWrite",
                fn: ({
                    state: $t
                }) => {
                    at($t)
                }
            }];
            nt != null && (mt = mt.concat(nt)), st && st.modifiers != null && (mt = mt.concat(st.modifiers));
            const xt = createPopper(Ut, vt.current, _extends$4({
                placement: Bt
            }, st, {
                modifiers: mt
            }));
            return Pt.current(xt), () => {
                xt.destroy(), Pt.current(null)
            }
        }, [Ut, tt, nt, rt, st, Bt]);
        const Ft = {
            placement: Lt
        };
        bt !== null && (Ft.TransitionProps = bt);
        const Wt = useUtilityClasses$G(o),
            Ct = ($ = yt.root) != null ? $ : "div",
            it = useSlotProps({
                elementType: Ct,
                externalSlotProps: ft.root,
                externalForwardedProps: ht,
                additionalProps: {
                    role: "tooltip",
                    ref: wt
                },
                ownerState: o,
                className: Wt.root
            });
        return jsxRuntimeExports.jsx(Ct, _extends$4({}, it, {
            children: typeof _e == "function" ? _e(Ft) : _e
        }))
    }),
    Popper$1 = reactExports.forwardRef(function(o, a) {
        const {
            anchorEl: $,
            children: j,
            container: _e,
            direction: et = "ltr",
            disablePortal: tt = !1,
            keepMounted: nt = !1,
            modifiers: rt,
            open: ot,
            placement: st = "bottom",
            popperOptions: lt = defaultPopperOptions,
            popperRef: ft,
            style: yt,
            transition: bt = !1,
            slotProps: ht = {},
            slots: vt = {}
        } = o, wt = _objectWithoutPropertiesLoose$1(o, _excluded2$6), [gt, At] = reactExports.useState(!0), Pt = () => {
            At(!1)
        }, Bt = () => {
            At(!0)
        };
        if (!nt && !ot && (!bt || gt)) return null;
        let Lt;
        if (_e) Lt = _e;
        else if ($) {
            const Vt = resolveAnchorEl$1($);
            Lt = Vt && isHTMLElement(Vt) ? ownerDocument(Vt).body : ownerDocument(null).body
        }
        const Nt = !ot && nt && (!bt || gt) ? "none" : void 0,
            Ut = bt ? { in: ot,
                onEnter: Pt,
                onExited: Bt
            } : void 0;
        return jsxRuntimeExports.jsx(Portal, {
            disablePortal: tt,
            container: Lt,
            children: jsxRuntimeExports.jsx(PopperTooltip, _extends$4({
                anchorEl: $,
                direction: et,
                disablePortal: tt,
                modifiers: rt,
                ref: a,
                open: bt ? !gt : ot,
                placement: st,
                popperOptions: lt,
                popperRef: ft,
                slotProps: ht,
                slots: vt
            }, wt, {
                style: _extends$4({
                    position: "fixed",
                    top: 0,
                    left: 0,
                    display: Nt
                }, yt),
                TransitionProps: Ut,
                children: j
            }))
        })
    }),
    _excluded$Q = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"],
    PopperRoot = styled(Popper$1, {
        name: "MuiPopper",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({}),
    Popper = reactExports.forwardRef(function(o, a) {
        var $;
        const j = default_1$4(),
            _e = useDefaultProps({
                props: o,
                name: "MuiPopper"
            }),
            {
                anchorEl: et,
                component: tt,
                components: nt,
                componentsProps: rt,
                container: ot,
                disablePortal: st,
                keepMounted: lt,
                modifiers: ft,
                open: yt,
                placement: bt,
                popperOptions: ht,
                popperRef: vt,
                transition: wt,
                slots: gt,
                slotProps: At
            } = _e,
            Pt = _objectWithoutPropertiesLoose$1(_e, _excluded$Q),
            Bt = ($ = gt == null ? void 0 : gt.root) != null ? $ : nt == null ? void 0 : nt.Root,
            Lt = _extends$4({
                anchorEl: et,
                container: ot,
                disablePortal: st,
                keepMounted: lt,
                modifiers: ft,
                open: yt,
                placement: bt,
                popperOptions: ht,
                popperRef: vt,
                transition: wt
            }, Pt);
        return jsxRuntimeExports.jsx(PopperRoot, _extends$4({
            as: tt,
            direction: j == null ? void 0 : j.direction,
            slots: {
                root: Bt
            },
            slotProps: At ? ? rt
        }, Lt, {
            ref: a
        }))
    }),
    _excluded$P = ["onChange", "maxRows", "minRows", "style", "value"];

function getStyleValue(s) {
    return parseInt(s, 10) || 0
}
const styles$3 = {
    shadow: {
        visibility: "hidden",
        position: "absolute",
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        transform: "translateZ(0)"
    }
};

function isEmpty$1(s) {
    return s == null || Object.keys(s).length === 0 || s.outerHeightStyle === 0 && !s.overflowing
}
const TextareaAutosize = reactExports.forwardRef(function(o, a) {
    const {
        onChange: $,
        maxRows: j,
        minRows: _e = 1,
        style: et,
        value: tt
    } = o, nt = _objectWithoutPropertiesLoose$1(o, _excluded$P), {
        current: rt
    } = reactExports.useRef(tt != null), ot = reactExports.useRef(null), st = useForkRef(a, ot), lt = reactExports.useRef(null), ft = reactExports.useRef(null), yt = reactExports.useCallback(() => {
        const vt = ot.current,
            gt = ownerWindow(vt).getComputedStyle(vt);
        if (gt.width === "0px") return {
            outerHeightStyle: 0,
            overflowing: !1
        };
        const At = ft.current;
        At.style.width = gt.width, At.value = vt.value || o.placeholder || "x", At.value.slice(-1) === `
` && (At.value += " ");
        const Pt = gt.boxSizing,
            Bt = getStyleValue(gt.paddingBottom) + getStyleValue(gt.paddingTop),
            Lt = getStyleValue(gt.borderBottomWidth) + getStyleValue(gt.borderTopWidth),
            Nt = At.scrollHeight;
        At.value = "x";
        const Ut = At.scrollHeight;
        let Vt = Nt;
        _e && (Vt = Math.max(Number(_e) * Ut, Vt)), j && (Vt = Math.min(Number(j) * Ut, Vt)), Vt = Math.max(Vt, Ut);
        const Ft = Vt + (Pt === "border-box" ? Bt + Lt : 0),
            Wt = Math.abs(Vt - Nt) <= 1;
        return {
            outerHeightStyle: Ft,
            overflowing: Wt
        }
    }, [j, _e, o.placeholder]), bt = reactExports.useCallback(() => {
        const vt = yt();
        if (isEmpty$1(vt)) return;
        const wt = vt.outerHeightStyle,
            gt = ot.current;
        lt.current !== wt && (lt.current = wt, gt.style.height = `${wt}px`), gt.style.overflow = vt.overflowing ? "hidden" : ""
    }, [yt]);
    useEnhancedEffect(() => {
        const vt = () => {
            bt()
        };
        let wt;
        const gt = debounce$1(vt),
            At = ot.current,
            Pt = ownerWindow(At);
        Pt.addEventListener("resize", gt);
        let Bt;
        return typeof ResizeObserver < "u" && (Bt = new ResizeObserver(vt), Bt.observe(At)), () => {
            gt.clear(), cancelAnimationFrame(wt), Pt.removeEventListener("resize", gt), Bt && Bt.disconnect()
        }
    }, [yt, bt]), useEnhancedEffect(() => {
        bt()
    });
    const ht = vt => {
        rt || bt(), $ && $(vt)
    };
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [jsxRuntimeExports.jsx("textarea", _extends$4({
            value: tt,
            onChange: ht,
            ref: st,
            rows: _e,
            style: et
        }, nt)), jsxRuntimeExports.jsx("textarea", {
            "aria-hidden": !0,
            className: o.className,
            readOnly: !0,
            ref: ft,
            tabIndex: -1,
            style: _extends$4({}, styles$3.shadow, et, {
                paddingTop: 0,
                paddingBottom: 0
            })
        })]
    })
});

function formControlState({
    props: s,
    states: o,
    muiFormControl: a
}) {
    return o.reduce(($, j) => ($[j] = s[j], a && typeof s[j] > "u" && ($[j] = a[j]), $), {})
}
const FormControlContext = reactExports.createContext(void 0);

function useFormControl() {
    return reactExports.useContext(FormControlContext)
}

function GlobalStyles(s) {
    return jsxRuntimeExports.jsx(GlobalStyles$1, _extends$4({}, s, {
        defaultTheme: defaultTheme$1,
        themeId: THEME_ID
    }))
}

function hasValue(s) {
    return s != null && !(Array.isArray(s) && s.length === 0)
}

function isFilled(s, o = !1) {
    return s && (hasValue(s.value) && s.value !== "" || o && hasValue(s.defaultValue) && s.defaultValue !== "")
}

function isAdornedStart(s) {
    return s.startAdornment
}

function getInputBaseUtilityClass(s) {
    return generateUtilityClass("MuiInputBase", s)
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]),
    _excluded$O = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"],
    rootOverridesResolver = (s, o) => {
        const {
            ownerState: a
        } = s;
        return [o.root, a.formControl && o.formControl, a.startAdornment && o.adornedStart, a.endAdornment && o.adornedEnd, a.error && o.error, a.size === "small" && o.sizeSmall, a.multiline && o.multiline, a.color && o[`color${capitalize$1(a.color)}`], a.fullWidth && o.fullWidth, a.hiddenLabel && o.hiddenLabel]
    },
    inputOverridesResolver = (s, o) => {
        const {
            ownerState: a
        } = s;
        return [o.input, a.size === "small" && o.inputSizeSmall, a.multiline && o.inputMultiline, a.type === "search" && o.inputTypeSearch, a.startAdornment && o.inputAdornedStart, a.endAdornment && o.inputAdornedEnd, a.hiddenLabel && o.inputHiddenLabel]
    },
    useUtilityClasses$F = s => {
        const {
            classes: o,
            color: a,
            disabled: $,
            error: j,
            endAdornment: _e,
            focused: et,
            formControl: tt,
            fullWidth: nt,
            hiddenLabel: rt,
            multiline: ot,
            readOnly: st,
            size: lt,
            startAdornment: ft,
            type: yt
        } = s, bt = {
            root: ["root", `color${capitalize$1(a)}`, $ && "disabled", j && "error", nt && "fullWidth", et && "focused", tt && "formControl", lt && lt !== "medium" && `size${capitalize$1(lt)}`, ot && "multiline", ft && "adornedStart", _e && "adornedEnd", rt && "hiddenLabel", st && "readOnly"],
            input: ["input", $ && "disabled", yt === "search" && "inputTypeSearch", ot && "inputMultiline", lt === "small" && "inputSizeSmall", rt && "inputHiddenLabel", ft && "inputAdornedStart", _e && "inputAdornedEnd", st && "readOnly"]
        };
        return composeClasses(bt, getInputBaseUtilityClass, o)
    },
    InputBaseRoot = styled("div", {
        name: "MuiInputBase",
        slot: "Root",
        overridesResolver: rootOverridesResolver
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({}, s.typography.body1, {
        color: (s.vars || s).palette.text.primary,
        lineHeight: "1.4375em",
        boxSizing: "border-box",
        position: "relative",
        cursor: "text",
        display: "inline-flex",
        alignItems: "center",
        [`&.${inputBaseClasses.disabled}`]: {
            color: (s.vars || s).palette.text.disabled,
            cursor: "default"
        }
    }, o.multiline && _extends$4({
        padding: "4px 0 5px"
    }, o.size === "small" && {
        paddingTop: 1
    }), o.fullWidth && {
        width: "100%"
    })),
    InputBaseComponent = styled("input", {
        name: "MuiInputBase",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })(({
        theme: s,
        ownerState: o
    }) => {
        const a = s.palette.mode === "light",
            $ = _extends$4({
                color: "currentColor"
            }, s.vars ? {
                opacity: s.vars.opacity.inputPlaceholder
            } : {
                opacity: a ? .42 : .5
            }, {
                transition: s.transitions.create("opacity", {
                    duration: s.transitions.duration.shorter
                })
            }),
            j = {
                opacity: "0 !important"
            },
            _e = s.vars ? {
                opacity: s.vars.opacity.inputPlaceholder
            } : {
                opacity: a ? .42 : .5
            };
        return _extends$4({
            font: "inherit",
            letterSpacing: "inherit",
            color: "currentColor",
            padding: "4px 0 5px",
            border: 0,
            boxSizing: "content-box",
            background: "none",
            height: "1.4375em",
            margin: 0,
            WebkitTapHighlightColor: "transparent",
            display: "block",
            minWidth: 0,
            width: "100%",
            animationName: "mui-auto-fill-cancel",
            animationDuration: "10ms",
            "&::-webkit-input-placeholder": $,
            "&::-moz-placeholder": $,
            "&:-ms-input-placeholder": $,
            "&::-ms-input-placeholder": $,
            "&:focus": {
                outline: 0
            },
            "&:invalid": {
                boxShadow: "none"
            },
            "&::-webkit-search-decoration": {
                WebkitAppearance: "none"
            },
            [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
                "&::-webkit-input-placeholder": j,
                "&::-moz-placeholder": j,
                "&:-ms-input-placeholder": j,
                "&::-ms-input-placeholder": j,
                "&:focus::-webkit-input-placeholder": _e,
                "&:focus::-moz-placeholder": _e,
                "&:focus:-ms-input-placeholder": _e,
                "&:focus::-ms-input-placeholder": _e
            },
            [`&.${inputBaseClasses.disabled}`]: {
                opacity: 1,
                WebkitTextFillColor: (s.vars || s).palette.text.disabled
            },
            "&:-webkit-autofill": {
                animationDuration: "5000s",
                animationName: "mui-auto-fill"
            }
        }, o.size === "small" && {
            paddingTop: 1
        }, o.multiline && {
            height: "auto",
            resize: "none",
            padding: 0,
            paddingTop: 0
        }, o.type === "search" && {
            MozAppearance: "textfield"
        })
    }),
    inputGlobalStyles = jsxRuntimeExports.jsx(GlobalStyles, {
        styles: {
            "@keyframes mui-auto-fill": {
                from: {
                    display: "block"
                }
            },
            "@keyframes mui-auto-fill-cancel": {
                from: {
                    display: "block"
                }
            }
        }
    }),
    InputBase = reactExports.forwardRef(function(o, a) {
        var $;
        const j = useDefaultProps({
                props: o,
                name: "MuiInputBase"
            }),
            {
                "aria-describedby": _e,
                autoComplete: et,
                autoFocus: tt,
                className: nt,
                components: rt = {},
                componentsProps: ot = {},
                defaultValue: st,
                disabled: lt,
                disableInjectingGlobalStyles: ft,
                endAdornment: yt,
                fullWidth: bt = !1,
                id: ht,
                inputComponent: vt = "input",
                inputProps: wt = {},
                inputRef: gt,
                maxRows: At,
                minRows: Pt,
                multiline: Bt = !1,
                name: Lt,
                onBlur: Nt,
                onChange: Ut,
                onClick: Vt,
                onFocus: Ft,
                onKeyDown: Wt,
                onKeyUp: Ct,
                placeholder: it,
                readOnly: at,
                renderSuffix: mt,
                rows: xt,
                slotProps: $t = {},
                slots: Rt = {},
                startAdornment: It,
                type: Tt = "text",
                value: dt
            } = j,
            Et = _objectWithoutPropertiesLoose$1(j, _excluded$O),
            Ot = wt.value != null ? wt.value : dt,
            {
                current: Mt
            } = reactExports.useRef(Ot != null),
            jt = reactExports.useRef(),
            Qt = reactExports.useCallback(ct => {}, []),
            Kt = useForkRef(jt, gt, wt.ref, Qt),
            [qt, Jt] = reactExports.useState(!1),
            Zt = useFormControl(),
            en = formControlState({
                props: j,
                muiFormControl: Zt,
                states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
            });
        en.focused = Zt ? Zt.focused : qt, reactExports.useEffect(() => {
            !Zt && lt && qt && (Jt(!1), Nt && Nt())
        }, [Zt, lt, qt, Nt]);
        const ln = Zt && Zt.onFilled,
            cn = Zt && Zt.onEmpty,
            un = reactExports.useCallback(ct => {
                isFilled(ct) ? ln && ln() : cn && cn()
            }, [ln, cn]);
        useEnhancedEffect(() => {
            Mt && un({
                value: Ot
            })
        }, [Ot, un, Mt]);
        const Nn = ct => {
                if (en.disabled) {
                    ct.stopPropagation();
                    return
                }
                Ft && Ft(ct), wt.onFocus && wt.onFocus(ct), Zt && Zt.onFocus ? Zt.onFocus(ct) : Jt(!0)
            },
            hn = ct => {
                Nt && Nt(ct), wt.onBlur && wt.onBlur(ct), Zt && Zt.onBlur ? Zt.onBlur(ct) : Jt(!1)
            },
            fn = (ct, ...pt) => {
                if (!Mt) {
                    const kt = ct.target || jt.current;
                    if (kt == null) throw new Error(formatMuiErrorMessage$1(1));
                    un({
                        value: kt.value
                    })
                }
                wt.onChange && wt.onChange(ct, ...pt), Ut && Ut(ct, ...pt)
            };
        reactExports.useEffect(() => {
            un(jt.current)
        }, []);
        const rn = ct => {
            jt.current && ct.currentTarget === ct.target && jt.current.focus(), Vt && Vt(ct)
        };
        let mn = vt,
            dn = wt;
        Bt && mn === "input" && (xt ? dn = _extends$4({
            type: void 0,
            minRows: xt,
            maxRows: xt
        }, dn) : dn = _extends$4({
            type: void 0,
            maxRows: At,
            minRows: Pt
        }, dn), mn = TextareaAutosize);
        const vn = ct => {
            un(ct.animationName === "mui-auto-fill-cancel" ? jt.current : {
                value: "x"
            })
        };
        reactExports.useEffect(() => {
            Zt && Zt.setAdornedStart(!!It)
        }, [Zt, It]);
        const gn = _extends$4({}, j, {
                color: en.color || "primary",
                disabled: en.disabled,
                endAdornment: yt,
                error: en.error,
                focused: en.focused,
                formControl: Zt,
                fullWidth: bt,
                hiddenLabel: en.hiddenLabel,
                multiline: Bt,
                size: en.size,
                startAdornment: It,
                type: Tt
            }),
            Gt = useUtilityClasses$F(gn),
            Yt = Rt.root || rt.Root || InputBaseRoot,
            nn = $t.root || ot.root || {},
            St = Rt.input || rt.Input || InputBaseComponent;
        return dn = _extends$4({}, dn, ($ = $t.input) != null ? $ : ot.input), jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [!ft && inputGlobalStyles, jsxRuntimeExports.jsxs(Yt, _extends$4({}, nn, !isHostComponent(Yt) && {
                ownerState: _extends$4({}, gn, nn.ownerState)
            }, {
                ref: a,
                onClick: rn
            }, Et, {
                className: clsx(Gt.root, nn.className, nt, at && "MuiInputBase-readOnly"),
                children: [It, jsxRuntimeExports.jsx(FormControlContext.Provider, {
                    value: null,
                    children: jsxRuntimeExports.jsx(St, _extends$4({
                        ownerState: gn,
                        "aria-invalid": en.error,
                        "aria-describedby": _e,
                        autoComplete: et,
                        autoFocus: tt,
                        defaultValue: st,
                        disabled: en.disabled,
                        id: ht,
                        onAnimationStart: vn,
                        name: Lt,
                        placeholder: it,
                        readOnly: at,
                        required: en.required,
                        rows: xt,
                        value: Ot,
                        onKeyDown: Wt,
                        onKeyUp: Ct,
                        type: Tt
                    }, dn, !isHostComponent(St) && {
                        as: mn,
                        ownerState: _extends$4({}, gn, dn.ownerState)
                    }, {
                        ref: Kt,
                        className: clsx(Gt.input, dn.className, at && "MuiInputBase-readOnly"),
                        onBlur: hn,
                        onChange: fn,
                        onFocus: Nn
                    }))
                }), yt, mt ? mt(_extends$4({}, en, {
                    startAdornment: It
                })) : null]
            }))]
        })
    }),
    InputBase$1 = InputBase;

function getInputUtilityClass(s) {
    return generateUtilityClass("MuiInput", s)
}
const inputClasses = _extends$4({}, inputBaseClasses, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));

function getOutlinedInputUtilityClass(s) {
    return generateUtilityClass("MuiOutlinedInput", s)
}
const outlinedInputClasses = _extends$4({}, inputBaseClasses, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));

function getFilledInputUtilityClass(s) {
    return generateUtilityClass("MuiFilledInput", s)
}
const filledInputClasses = _extends$4({}, inputBaseClasses, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"])),
    ArrowDropDownIcon = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown"),
    _excluded$N = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"],
    styles$2 = {
        entering: {
            opacity: 1
        },
        entered: {
            opacity: 1
        }
    },
    Fade = reactExports.forwardRef(function(o, a) {
        const $ = useTheme$1(),
            j = {
                enter: $.transitions.duration.enteringScreen,
                exit: $.transitions.duration.leavingScreen
            },
            {
                addEndListener: _e,
                appear: et = !0,
                children: tt,
                easing: nt,
                in: rt,
                onEnter: ot,
                onEntered: st,
                onEntering: lt,
                onExit: ft,
                onExited: yt,
                onExiting: bt,
                style: ht,
                timeout: vt = j,
                TransitionComponent: wt = Transition
            } = o,
            gt = _objectWithoutPropertiesLoose$1(o, _excluded$N),
            At = reactExports.useRef(null),
            Pt = useForkRef(At, tt.ref, a),
            Bt = it => at => {
                if (it) {
                    const mt = At.current;
                    at === void 0 ? it(mt) : it(mt, at)
                }
            },
            Lt = Bt(lt),
            Nt = Bt((it, at) => {
                reflow(it);
                const mt = getTransitionProps({
                    style: ht,
                    timeout: vt,
                    easing: nt
                }, {
                    mode: "enter"
                });
                it.style.webkitTransition = $.transitions.create("opacity", mt), it.style.transition = $.transitions.create("opacity", mt), ot && ot(it, at)
            }),
            Ut = Bt(st),
            Vt = Bt(bt),
            Ft = Bt(it => {
                const at = getTransitionProps({
                    style: ht,
                    timeout: vt,
                    easing: nt
                }, {
                    mode: "exit"
                });
                it.style.webkitTransition = $.transitions.create("opacity", at), it.style.transition = $.transitions.create("opacity", at), ft && ft(it)
            }),
            Wt = Bt(yt),
            Ct = it => {
                _e && _e(At.current, it)
            };
        return jsxRuntimeExports.jsx(wt, _extends$4({
            appear: et,
            in: rt,
            nodeRef: At,
            onEnter: Nt,
            onEntered: Ut,
            onEntering: Lt,
            onExit: Ft,
            onExited: Wt,
            onExiting: Vt,
            addEndListener: Ct,
            timeout: vt
        }, gt, {
            children: (it, at) => reactExports.cloneElement(tt, _extends$4({
                style: _extends$4({
                    opacity: 0,
                    visibility: it === "exited" && !rt ? "hidden" : void 0
                }, styles$2[it], ht, tt.props.style),
                ref: Pt
            }, at))
        }))
    });

function getBackdropUtilityClass(s) {
    return generateUtilityClass("MuiBackdrop", s)
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$M = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"],
    useUtilityClasses$E = s => {
        const {
            classes: o,
            invisible: a
        } = s;
        return composeClasses({
            root: ["root", a && "invisible"]
        }, getBackdropUtilityClass, o)
    },
    BackdropRoot = styled("div", {
        name: "MuiBackdrop",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.invisible && o.invisible]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        WebkitTapHighlightColor: "transparent"
    }, s.invisible && {
        backgroundColor: "transparent"
    })),
    Backdrop = reactExports.forwardRef(function(o, a) {
        var $, j, _e;
        const et = useDefaultProps({
                props: o,
                name: "MuiBackdrop"
            }),
            {
                children: tt,
                className: nt,
                component: rt = "div",
                components: ot = {},
                componentsProps: st = {},
                invisible: lt = !1,
                open: ft,
                slotProps: yt = {},
                slots: bt = {},
                TransitionComponent: ht = Fade,
                transitionDuration: vt
            } = et,
            wt = _objectWithoutPropertiesLoose$1(et, _excluded$M),
            gt = _extends$4({}, et, {
                component: rt,
                invisible: lt
            }),
            At = useUtilityClasses$E(gt),
            Pt = ($ = yt.root) != null ? $ : st.root;
        return jsxRuntimeExports.jsx(ht, _extends$4({ in: ft,
            timeout: vt
        }, wt, {
            children: jsxRuntimeExports.jsx(BackdropRoot, _extends$4({
                "aria-hidden": !0
            }, Pt, {
                as: (j = (_e = bt.root) != null ? _e : ot.Root) != null ? j : rt,
                className: clsx(At.root, nt, Pt == null ? void 0 : Pt.className),
                ownerState: _extends$4({}, gt, Pt == null ? void 0 : Pt.ownerState),
                classes: At,
                ref: a,
                children: tt
            }))
        }))
    }),
    boxClasses = generateUtilityClasses("MuiBox", ["root"]),
    defaultTheme = createTheme(),
    Box = createBox$1({
        themeId: THEME_ID,
        defaultTheme,
        defaultClassName: boxClasses.root,
        generateClassName: ClassNameGenerator.generate
    });

function getButtonUtilityClass(s) {
    return generateUtilityClass("MuiButton", s)
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]),
    ButtonGroupContext = reactExports.createContext({}),
    ButtonGroupButtonContext = reactExports.createContext(void 0),
    _excluded$L = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"],
    useUtilityClasses$D = s => {
        const {
            color: o,
            disableElevation: a,
            fullWidth: $,
            size: j,
            variant: _e,
            classes: et
        } = s, tt = {
            root: ["root", _e, `${_e}${capitalize$1(o)}`, `size${capitalize$1(j)}`, `${_e}Size${capitalize$1(j)}`, `color${capitalize$1(o)}`, a && "disableElevation", $ && "fullWidth"],
            label: ["label"],
            startIcon: ["icon", "startIcon", `iconSize${capitalize$1(j)}`],
            endIcon: ["icon", "endIcon", `iconSize${capitalize$1(j)}`]
        }, nt = composeClasses(tt, getButtonUtilityClass, et);
        return _extends$4({}, et, nt)
    },
    commonIconStyles = s => _extends$4({}, s.size === "small" && {
        "& > *:nth-of-type(1)": {
            fontSize: 18
        }
    }, s.size === "medium" && {
        "& > *:nth-of-type(1)": {
            fontSize: 20
        }
    }, s.size === "large" && {
        "& > *:nth-of-type(1)": {
            fontSize: 22
        }
    }),
    ButtonRoot = styled(ButtonBase, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiButton",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, o[a.variant], o[`${a.variant}${capitalize$1(a.color)}`], o[`size${capitalize$1(a.size)}`], o[`${a.variant}Size${capitalize$1(a.size)}`], a.color === "inherit" && o.colorInherit, a.disableElevation && o.disableElevation, a.fullWidth && o.fullWidth]
        }
    })(({
        theme: s,
        ownerState: o
    }) => {
        var a, $;
        const j = s.palette.mode === "light" ? s.palette.grey[300] : s.palette.grey[800],
            _e = s.palette.mode === "light" ? s.palette.grey.A100 : s.palette.grey[700];
        return _extends$4({}, s.typography.button, {
            minWidth: 64,
            padding: "6px 16px",
            borderRadius: (s.vars || s).shape.borderRadius,
            transition: s.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
                duration: s.transitions.duration.short
            }),
            "&:hover": _extends$4({
                textDecoration: "none",
                backgroundColor: s.vars ? `rgba(${s.vars.palette.text.primaryChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(s.palette.text.primary, s.palette.action.hoverOpacity),
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }, o.variant === "text" && o.color !== "inherit" && {
                backgroundColor: s.vars ? `rgba(${s.vars.palette[o.color].mainChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(s.palette[o.color].main, s.palette.action.hoverOpacity),
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }, o.variant === "outlined" && o.color !== "inherit" && {
                border: `1px solid ${(s.vars||s).palette[o.color].main}`,
                backgroundColor: s.vars ? `rgba(${s.vars.palette[o.color].mainChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(s.palette[o.color].main, s.palette.action.hoverOpacity),
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }, o.variant === "contained" && {
                backgroundColor: s.vars ? s.vars.palette.Button.inheritContainedHoverBg : _e,
                boxShadow: (s.vars || s).shadows[4],
                "@media (hover: none)": {
                    boxShadow: (s.vars || s).shadows[2],
                    backgroundColor: (s.vars || s).palette.grey[300]
                }
            }, o.variant === "contained" && o.color !== "inherit" && {
                backgroundColor: (s.vars || s).palette[o.color].dark,
                "@media (hover: none)": {
                    backgroundColor: (s.vars || s).palette[o.color].main
                }
            }),
            "&:active": _extends$4({}, o.variant === "contained" && {
                boxShadow: (s.vars || s).shadows[8]
            }),
            [`&.${buttonClasses.focusVisible}`]: _extends$4({}, o.variant === "contained" && {
                boxShadow: (s.vars || s).shadows[6]
            }),
            [`&.${buttonClasses.disabled}`]: _extends$4({
                color: (s.vars || s).palette.action.disabled
            }, o.variant === "outlined" && {
                border: `1px solid ${(s.vars||s).palette.action.disabledBackground}`
            }, o.variant === "contained" && {
                color: (s.vars || s).palette.action.disabled,
                boxShadow: (s.vars || s).shadows[0],
                backgroundColor: (s.vars || s).palette.action.disabledBackground
            })
        }, o.variant === "text" && {
            padding: "6px 8px"
        }, o.variant === "text" && o.color !== "inherit" && {
            color: (s.vars || s).palette[o.color].main
        }, o.variant === "outlined" && {
            padding: "5px 15px",
            border: "1px solid currentColor"
        }, o.variant === "outlined" && o.color !== "inherit" && {
            color: (s.vars || s).palette[o.color].main,
            border: s.vars ? `1px solid rgba(${s.vars.palette[o.color].mainChannel} / 0.5)` : `1px solid ${alpha_1(s.palette[o.color].main,.5)}`
        }, o.variant === "contained" && {
            color: s.vars ? s.vars.palette.text.primary : (a = ($ = s.palette).getContrastText) == null ? void 0 : a.call($, s.palette.grey[300]),
            backgroundColor: s.vars ? s.vars.palette.Button.inheritContainedBg : j,
            boxShadow: (s.vars || s).shadows[2]
        }, o.variant === "contained" && o.color !== "inherit" && {
            color: (s.vars || s).palette[o.color].contrastText,
            backgroundColor: (s.vars || s).palette[o.color].main
        }, o.color === "inherit" && {
            color: "inherit",
            borderColor: "currentColor"
        }, o.size === "small" && o.variant === "text" && {
            padding: "4px 5px",
            fontSize: s.typography.pxToRem(13)
        }, o.size === "large" && o.variant === "text" && {
            padding: "8px 11px",
            fontSize: s.typography.pxToRem(15)
        }, o.size === "small" && o.variant === "outlined" && {
            padding: "3px 9px",
            fontSize: s.typography.pxToRem(13)
        }, o.size === "large" && o.variant === "outlined" && {
            padding: "7px 21px",
            fontSize: s.typography.pxToRem(15)
        }, o.size === "small" && o.variant === "contained" && {
            padding: "4px 10px",
            fontSize: s.typography.pxToRem(13)
        }, o.size === "large" && o.variant === "contained" && {
            padding: "8px 22px",
            fontSize: s.typography.pxToRem(15)
        }, o.fullWidth && {
            width: "100%"
        })
    }, ({
        ownerState: s
    }) => s.disableElevation && {
        boxShadow: "none",
        "&:hover": {
            boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
            boxShadow: "none"
        },
        "&:active": {
            boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
            boxShadow: "none"
        }
    }),
    ButtonStartIcon = styled("span", {
        name: "MuiButton",
        slot: "StartIcon",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.startIcon, o[`iconSize${capitalize$1(a.size)}`]]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        display: "inherit",
        marginRight: 8,
        marginLeft: -4
    }, s.size === "small" && {
        marginLeft: -2
    }, commonIconStyles(s))),
    ButtonEndIcon = styled("span", {
        name: "MuiButton",
        slot: "EndIcon",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.endIcon, o[`iconSize${capitalize$1(a.size)}`]]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        display: "inherit",
        marginRight: -4,
        marginLeft: 8
    }, s.size === "small" && {
        marginRight: -2
    }, commonIconStyles(s))),
    Button$1 = reactExports.forwardRef(function(o, a) {
        const $ = reactExports.useContext(ButtonGroupContext),
            j = reactExports.useContext(ButtonGroupButtonContext),
            _e = resolveProps($, o),
            et = useDefaultProps({
                props: _e,
                name: "MuiButton"
            }),
            {
                children: tt,
                color: nt = "primary",
                component: rt = "button",
                className: ot,
                disabled: st = !1,
                disableElevation: lt = !1,
                disableFocusRipple: ft = !1,
                endIcon: yt,
                focusVisibleClassName: bt,
                fullWidth: ht = !1,
                size: vt = "medium",
                startIcon: wt,
                type: gt,
                variant: At = "text"
            } = et,
            Pt = _objectWithoutPropertiesLoose$1(et, _excluded$L),
            Bt = _extends$4({}, et, {
                color: nt,
                component: rt,
                disabled: st,
                disableElevation: lt,
                disableFocusRipple: ft,
                fullWidth: ht,
                size: vt,
                type: gt,
                variant: At
            }),
            Lt = useUtilityClasses$D(Bt),
            Nt = wt && jsxRuntimeExports.jsx(ButtonStartIcon, {
                className: Lt.startIcon,
                ownerState: Bt,
                children: wt
            }),
            Ut = yt && jsxRuntimeExports.jsx(ButtonEndIcon, {
                className: Lt.endIcon,
                ownerState: Bt,
                children: yt
            }),
            Vt = j || "";
        return jsxRuntimeExports.jsxs(ButtonRoot, _extends$4({
            ownerState: Bt,
            className: clsx($.className, Lt.root, ot, Vt),
            component: rt,
            disabled: st,
            focusRipple: !ft,
            focusVisibleClassName: clsx(Lt.focusVisible, bt),
            ref: a,
            type: gt
        }, Pt, {
            classes: Lt,
            children: [Nt, tt, Ut]
        }))
    });

function getSwitchBaseUtilityClass(s) {
    return generateUtilityClass("PrivateSwitchBase", s)
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const _excluded$K = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"],
    useUtilityClasses$C = s => {
        const {
            classes: o,
            checked: a,
            disabled: $,
            edge: j
        } = s, _e = {
            root: ["root", a && "checked", $ && "disabled", j && `edge${capitalize$1(j)}`],
            input: ["input"]
        };
        return composeClasses(_e, getSwitchBaseUtilityClass, o)
    },
    SwitchBaseRoot = styled(ButtonBase)(({
        ownerState: s
    }) => _extends$4({
        padding: 9,
        borderRadius: "50%"
    }, s.edge === "start" && {
        marginLeft: s.size === "small" ? -3 : -12
    }, s.edge === "end" && {
        marginRight: s.size === "small" ? -3 : -12
    })),
    SwitchBaseInput = styled("input", {
        shouldForwardProp: rootShouldForwardProp
    })({
        cursor: "inherit",
        position: "absolute",
        opacity: 0,
        width: "100%",
        height: "100%",
        top: 0,
        left: 0,
        margin: 0,
        padding: 0,
        zIndex: 1
    }),
    SwitchBase = reactExports.forwardRef(function(o, a) {
        const {
            autoFocus: $,
            checked: j,
            checkedIcon: _e,
            className: et,
            defaultChecked: tt,
            disabled: nt,
            disableFocusRipple: rt = !1,
            edge: ot = !1,
            icon: st,
            id: lt,
            inputProps: ft,
            inputRef: yt,
            name: bt,
            onBlur: ht,
            onChange: vt,
            onFocus: wt,
            readOnly: gt,
            required: At = !1,
            tabIndex: Pt,
            type: Bt,
            value: Lt
        } = o, Nt = _objectWithoutPropertiesLoose$1(o, _excluded$K), [Ut, Vt] = useControlled({
            controlled: j,
            default: !!tt,
            name: "SwitchBase",
            state: "checked"
        }), Ft = useFormControl(), Wt = Rt => {
            wt && wt(Rt), Ft && Ft.onFocus && Ft.onFocus(Rt)
        }, Ct = Rt => {
            ht && ht(Rt), Ft && Ft.onBlur && Ft.onBlur(Rt)
        }, it = Rt => {
            if (Rt.nativeEvent.defaultPrevented) return;
            const It = Rt.target.checked;
            Vt(It), vt && vt(Rt, It)
        };
        let at = nt;
        Ft && typeof at > "u" && (at = Ft.disabled);
        const mt = Bt === "checkbox" || Bt === "radio",
            xt = _extends$4({}, o, {
                checked: Ut,
                disabled: at,
                disableFocusRipple: rt,
                edge: ot
            }),
            $t = useUtilityClasses$C(xt);
        return jsxRuntimeExports.jsxs(SwitchBaseRoot, _extends$4({
            component: "span",
            className: clsx($t.root, et),
            centerRipple: !0,
            focusRipple: !rt,
            disabled: at,
            tabIndex: null,
            role: void 0,
            onFocus: Wt,
            onBlur: Ct,
            ownerState: xt,
            ref: a
        }, Nt, {
            children: [jsxRuntimeExports.jsx(SwitchBaseInput, _extends$4({
                autoFocus: $,
                checked: j,
                defaultChecked: tt,
                className: $t.input,
                disabled: at,
                id: mt ? lt : void 0,
                name: bt,
                onChange: it,
                readOnly: gt,
                ref: yt,
                required: At,
                ownerState: xt,
                tabIndex: Pt,
                type: Bt
            }, Bt === "checkbox" && Lt === void 0 ? {} : {
                value: Lt
            }, ft)), Ut ? _e : st]
        }))
    }),
    CheckBoxOutlineBlankIcon = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    }), "CheckBoxOutlineBlank"),
    CheckBoxIcon = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
    }), "CheckBox"),
    IndeterminateCheckBoxIcon = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
    }), "IndeterminateCheckBox");

function getCheckboxUtilityClass(s) {
    return generateUtilityClass("MuiCheckbox", s)
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]),
    _excluded$J = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"],
    useUtilityClasses$B = s => {
        const {
            classes: o,
            indeterminate: a,
            color: $,
            size: j
        } = s, _e = {
            root: ["root", a && "indeterminate", `color${capitalize$1($)}`, `size${capitalize$1(j)}`]
        }, et = composeClasses(_e, getCheckboxUtilityClass, o);
        return _extends$4({}, o, et)
    },
    CheckboxRoot = styled(SwitchBase, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiCheckbox",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.indeterminate && o.indeterminate, o[`size${capitalize$1(a.size)}`], a.color !== "default" && o[`color${capitalize$1(a.color)}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        color: (s.vars || s).palette.text.secondary
    }, !o.disableRipple && {
        "&:hover": {
            backgroundColor: s.vars ? `rgba(${o.color==="default"?s.vars.palette.action.activeChannel:s.vars.palette[o.color].mainChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(o.color === "default" ? s.palette.action.active : s.palette[o.color].main, s.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        }
    }, o.color !== "default" && {
        [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
            color: (s.vars || s).palette[o.color].main
        },
        [`&.${checkboxClasses.disabled}`]: {
            color: (s.vars || s).palette.action.disabled
        }
    })),
    defaultCheckedIcon$1 = jsxRuntimeExports.jsx(CheckBoxIcon, {}),
    defaultIcon$1 = jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {}),
    defaultIndeterminateIcon = jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {}),
    Checkbox = reactExports.forwardRef(function(o, a) {
        var $, j;
        const _e = useDefaultProps({
                props: o,
                name: "MuiCheckbox"
            }),
            {
                checkedIcon: et = defaultCheckedIcon$1,
                color: tt = "primary",
                icon: nt = defaultIcon$1,
                indeterminate: rt = !1,
                indeterminateIcon: ot = defaultIndeterminateIcon,
                inputProps: st,
                size: lt = "medium",
                className: ft
            } = _e,
            yt = _objectWithoutPropertiesLoose$1(_e, _excluded$J),
            bt = rt ? ot : nt,
            ht = rt ? ot : et,
            vt = _extends$4({}, _e, {
                color: tt,
                indeterminate: rt,
                size: lt
            }),
            wt = useUtilityClasses$B(vt);
        return jsxRuntimeExports.jsx(CheckboxRoot, _extends$4({
            type: "checkbox",
            inputProps: _extends$4({
                "data-indeterminate": rt
            }, st),
            icon: reactExports.cloneElement(bt, {
                fontSize: ($ = bt.props.fontSize) != null ? $ : lt
            }),
            checkedIcon: reactExports.cloneElement(ht, {
                fontSize: (j = ht.props.fontSize) != null ? j : lt
            }),
            ownerState: vt,
            ref: a,
            className: clsx(wt.root, ft)
        }, yt, {
            classes: wt
        }))
    });

function isOverflowing(s) {
    const o = ownerDocument(s);
    return o.body === s ? ownerWindow(s).innerWidth > o.documentElement.clientWidth : s.scrollHeight > s.clientHeight
}

function ariaHidden(s, o) {
    o ? s.setAttribute("aria-hidden", "true") : s.removeAttribute("aria-hidden")
}

function getPaddingRight(s) {
    return parseInt(ownerWindow(s).getComputedStyle(s).paddingRight, 10) || 0
}

function isAriaHiddenForbiddenOnElement(s) {
    const a = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(s.tagName) !== -1,
        $ = s.tagName === "INPUT" && s.getAttribute("type") === "hidden";
    return a || $
}

function ariaHiddenSiblings(s, o, a, $, j) {
    const _e = [o, a, ...$];
    [].forEach.call(s.children, et => {
        const tt = _e.indexOf(et) === -1,
            nt = !isAriaHiddenForbiddenOnElement(et);
        tt && nt && ariaHidden(et, j)
    })
}

function findIndexOf(s, o) {
    let a = -1;
    return s.some(($, j) => o($) ? (a = j, !0) : !1), a
}

function handleContainer(s, o) {
    const a = [],
        $ = s.container;
    if (!o.disableScrollLock) {
        if (isOverflowing($)) {
            const et = getScrollbarSize(ownerDocument($));
            a.push({
                value: $.style.paddingRight,
                property: "padding-right",
                el: $
            }), $.style.paddingRight = `${getPaddingRight($)+et}px`;
            const tt = ownerDocument($).querySelectorAll(".mui-fixed");
            [].forEach.call(tt, nt => {
                a.push({
                    value: nt.style.paddingRight,
                    property: "padding-right",
                    el: nt
                }), nt.style.paddingRight = `${getPaddingRight(nt)+et}px`
            })
        }
        let _e;
        if ($.parentNode instanceof DocumentFragment) _e = ownerDocument($).body;
        else {
            const et = $.parentElement,
                tt = ownerWindow($);
            _e = (et == null ? void 0 : et.nodeName) === "HTML" && tt.getComputedStyle(et).overflowY === "scroll" ? et : $
        }
        a.push({
            value: _e.style.overflow,
            property: "overflow",
            el: _e
        }, {
            value: _e.style.overflowX,
            property: "overflow-x",
            el: _e
        }, {
            value: _e.style.overflowY,
            property: "overflow-y",
            el: _e
        }), _e.style.overflow = "hidden"
    }
    return () => {
        a.forEach(({
            value: _e,
            el: et,
            property: tt
        }) => {
            _e ? et.style.setProperty(tt, _e) : et.style.removeProperty(tt)
        })
    }
}

function getHiddenSiblings(s) {
    const o = [];
    return [].forEach.call(s.children, a => {
        a.getAttribute("aria-hidden") === "true" && o.push(a)
    }), o
}
class ModalManager {
    constructor() {
        this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = []
    }
    add(o, a) {
        let $ = this.modals.indexOf(o);
        if ($ !== -1) return $;
        $ = this.modals.length, this.modals.push(o), o.modalRef && ariaHidden(o.modalRef, !1);
        const j = getHiddenSiblings(a);
        ariaHiddenSiblings(a, o.mount, o.modalRef, j, !0);
        const _e = findIndexOf(this.containers, et => et.container === a);
        return _e !== -1 ? (this.containers[_e].modals.push(o), $) : (this.containers.push({
            modals: [o],
            container: a,
            restore: null,
            hiddenSiblings: j
        }), $)
    }
    mount(o, a) {
        const $ = findIndexOf(this.containers, _e => _e.modals.indexOf(o) !== -1),
            j = this.containers[$];
        j.restore || (j.restore = handleContainer(j, a))
    }
    remove(o, a = !0) {
        const $ = this.modals.indexOf(o);
        if ($ === -1) return $;
        const j = findIndexOf(this.containers, et => et.modals.indexOf(o) !== -1),
            _e = this.containers[j];
        if (_e.modals.splice(_e.modals.indexOf(o), 1), this.modals.splice($, 1), _e.modals.length === 0) _e.restore && _e.restore(), o.modalRef && ariaHidden(o.modalRef, a), ariaHiddenSiblings(_e.container, o.mount, o.modalRef, _e.hiddenSiblings, !1), this.containers.splice(j, 1);
        else {
            const et = _e.modals[_e.modals.length - 1];
            et.modalRef && ariaHidden(et.modalRef, !1)
        }
        return $
    }
    isTopModal(o) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === o
    }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");

function getTabIndex(s) {
    const o = parseInt(s.getAttribute("tabindex") || "", 10);
    return Number.isNaN(o) ? s.contentEditable === "true" || (s.nodeName === "AUDIO" || s.nodeName === "VIDEO" || s.nodeName === "DETAILS") && s.getAttribute("tabindex") === null ? 0 : s.tabIndex : o
}

function isNonTabbableRadio(s) {
    if (s.tagName !== "INPUT" || s.type !== "radio" || !s.name) return !1;
    const o = $ => s.ownerDocument.querySelector(`input[type="radio"]${$}`);
    let a = o(`[name="${s.name}"]:checked`);
    return a || (a = o(`[name="${s.name}"]`)), a !== s
}

function isNodeMatchingSelectorFocusable(s) {
    return !(s.disabled || s.tagName === "INPUT" && s.type === "hidden" || isNonTabbableRadio(s))
}

function defaultGetTabbable(s) {
    const o = [],
        a = [];
    return Array.from(s.querySelectorAll(candidatesSelector)).forEach(($, j) => {
        const _e = getTabIndex($);
        _e === -1 || !isNodeMatchingSelectorFocusable($) || (_e === 0 ? o.push($) : a.push({
            documentOrder: j,
            tabIndex: _e,
            node: $
        }))
    }), a.sort(($, j) => $.tabIndex === j.tabIndex ? $.documentOrder - j.documentOrder : $.tabIndex - j.tabIndex).map($ => $.node).concat(o)
}

function defaultIsEnabled() {
    return !0
}

function FocusTrap(s) {
    const {
        children: o,
        disableAutoFocus: a = !1,
        disableEnforceFocus: $ = !1,
        disableRestoreFocus: j = !1,
        getTabbable: _e = defaultGetTabbable,
        isEnabled: et = defaultIsEnabled,
        open: tt
    } = s, nt = reactExports.useRef(!1), rt = reactExports.useRef(null), ot = reactExports.useRef(null), st = reactExports.useRef(null), lt = reactExports.useRef(null), ft = reactExports.useRef(!1), yt = reactExports.useRef(null), bt = useForkRef(o.ref, yt), ht = reactExports.useRef(null);
    reactExports.useEffect(() => {
        !tt || !yt.current || (ft.current = !a)
    }, [a, tt]), reactExports.useEffect(() => {
        if (!tt || !yt.current) return;
        const gt = ownerDocument(yt.current);
        return yt.current.contains(gt.activeElement) || (yt.current.hasAttribute("tabIndex") || yt.current.setAttribute("tabIndex", "-1"), ft.current && yt.current.focus()), () => {
            j || (st.current && st.current.focus && (nt.current = !0, st.current.focus()), st.current = null)
        }
    }, [tt]), reactExports.useEffect(() => {
        if (!tt || !yt.current) return;
        const gt = ownerDocument(yt.current),
            At = Lt => {
                ht.current = Lt, !($ || !et() || Lt.key !== "Tab") && gt.activeElement === yt.current && Lt.shiftKey && (nt.current = !0, ot.current && ot.current.focus())
            },
            Pt = () => {
                const Lt = yt.current;
                if (Lt === null) return;
                if (!gt.hasFocus() || !et() || nt.current) {
                    nt.current = !1;
                    return
                }
                if (Lt.contains(gt.activeElement) || $ && gt.activeElement !== rt.current && gt.activeElement !== ot.current) return;
                if (gt.activeElement !== lt.current) lt.current = null;
                else if (lt.current !== null) return;
                if (!ft.current) return;
                let Nt = [];
                if ((gt.activeElement === rt.current || gt.activeElement === ot.current) && (Nt = _e(yt.current)), Nt.length > 0) {
                    var Ut, Vt;
                    const Ft = !!((Ut = ht.current) != null && Ut.shiftKey && ((Vt = ht.current) == null ? void 0 : Vt.key) === "Tab"),
                        Wt = Nt[0],
                        Ct = Nt[Nt.length - 1];
                    typeof Wt != "string" && typeof Ct != "string" && (Ft ? Ct.focus() : Wt.focus())
                } else Lt.focus()
            };
        gt.addEventListener("focusin", Pt), gt.addEventListener("keydown", At, !0);
        const Bt = setInterval(() => {
            gt.activeElement && gt.activeElement.tagName === "BODY" && Pt()
        }, 50);
        return () => {
            clearInterval(Bt), gt.removeEventListener("focusin", Pt), gt.removeEventListener("keydown", At, !0)
        }
    }, [a, $, j, et, tt, _e]);
    const vt = gt => {
            st.current === null && (st.current = gt.relatedTarget), ft.current = !0, lt.current = gt.target;
            const At = o.props.onFocus;
            At && At(gt)
        },
        wt = gt => {
            st.current === null && (st.current = gt.relatedTarget), ft.current = !0
        };
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            tabIndex: tt ? 0 : -1,
            onFocus: wt,
            ref: rt,
            "data-testid": "sentinelStart"
        }), reactExports.cloneElement(o, {
            ref: bt,
            onFocus: vt
        }), jsxRuntimeExports.jsx("div", {
            tabIndex: tt ? 0 : -1,
            onFocus: wt,
            ref: ot,
            "data-testid": "sentinelEnd"
        })]
    })
}

function getContainer(s) {
    return typeof s == "function" ? s() : s
}

function getHasTransition(s) {
    return s ? s.props.hasOwnProperty("in") : !1
}
const defaultManager = new ModalManager;

function useModal(s) {
    const {
        container: o,
        disableEscapeKeyDown: a = !1,
        disableScrollLock: $ = !1,
        manager: j = defaultManager,
        closeAfterTransition: _e = !1,
        onTransitionEnter: et,
        onTransitionExited: tt,
        children: nt,
        onClose: rt,
        open: ot,
        rootRef: st
    } = s, lt = reactExports.useRef({}), ft = reactExports.useRef(null), yt = reactExports.useRef(null), bt = useForkRef(yt, st), [ht, vt] = reactExports.useState(!ot), wt = getHasTransition(nt);
    let gt = !0;
    (s["aria-hidden"] === "false" || s["aria-hidden"] === !1) && (gt = !1);
    const At = () => ownerDocument(ft.current),
        Pt = () => (lt.current.modalRef = yt.current, lt.current.mount = ft.current, lt.current),
        Bt = () => {
            j.mount(Pt(), {
                disableScrollLock: $
            }), yt.current && (yt.current.scrollTop = 0)
        },
        Lt = useEventCallback(() => {
            const mt = getContainer(o) || At().body;
            j.add(Pt(), mt), yt.current && Bt()
        }),
        Nt = reactExports.useCallback(() => j.isTopModal(Pt()), [j]),
        Ut = useEventCallback(mt => {
            ft.current = mt, mt && (ot && Nt() ? Bt() : yt.current && ariaHidden(yt.current, gt))
        }),
        Vt = reactExports.useCallback(() => {
            j.remove(Pt(), gt)
        }, [gt, j]);
    reactExports.useEffect(() => () => {
        Vt()
    }, [Vt]), reactExports.useEffect(() => {
        ot ? Lt() : (!wt || !_e) && Vt()
    }, [ot, Vt, wt, _e, Lt]);
    const Ft = mt => xt => {
            var $t;
            ($t = mt.onKeyDown) == null || $t.call(mt, xt), !(xt.key !== "Escape" || xt.which === 229 || !Nt()) && (a || (xt.stopPropagation(), rt && rt(xt, "escapeKeyDown")))
        },
        Wt = mt => xt => {
            var $t;
            ($t = mt.onClick) == null || $t.call(mt, xt), xt.target === xt.currentTarget && rt && rt(xt, "backdropClick")
        };
    return {
        getRootProps: (mt = {}) => {
            const xt = extractEventHandlers(s);
            delete xt.onTransitionEnter, delete xt.onTransitionExited;
            const $t = _extends$4({}, xt, mt);
            return _extends$4({
                role: "presentation"
            }, $t, {
                onKeyDown: Ft($t),
                ref: bt
            })
        },
        getBackdropProps: (mt = {}) => {
            const xt = mt;
            return _extends$4({
                "aria-hidden": !0
            }, xt, {
                onClick: Wt(xt),
                open: ot
            })
        },
        getTransitionProps: () => {
            const mt = () => {
                    vt(!1), et && et()
                },
                xt = () => {
                    vt(!0), tt && tt(), _e && Vt()
                };
            return {
                onEnter: createChainedFunction(mt, nt == null ? void 0 : nt.props.onEnter),
                onExited: createChainedFunction(xt, nt == null ? void 0 : nt.props.onExited)
            }
        },
        rootRef: bt,
        portalRef: Ut,
        isTopModal: Nt,
        exited: ht,
        hasTransition: wt
    }
}

function getModalUtilityClass(s) {
    return generateUtilityClass("MuiModal", s)
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$I = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"],
    useUtilityClasses$A = s => {
        const {
            open: o,
            exited: a,
            classes: $
        } = s;
        return composeClasses({
            root: ["root", !o && a && "hidden"],
            backdrop: ["backdrop"]
        }, getModalUtilityClass, $)
    },
    ModalRoot = styled("div", {
        name: "MuiModal",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, !a.open && a.exited && o.hidden]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        position: "fixed",
        zIndex: (s.vars || s).zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0
    }, !o.open && o.exited && {
        visibility: "hidden"
    })),
    ModalBackdrop = styled(Backdrop, {
        name: "MuiModal",
        slot: "Backdrop",
        overridesResolver: (s, o) => o.backdrop
    })({
        zIndex: -1
    }),
    Modal = reactExports.forwardRef(function(o, a) {
        var $, j, _e, et, tt, nt;
        const rt = useDefaultProps({
                name: "MuiModal",
                props: o
            }),
            {
                BackdropComponent: ot = ModalBackdrop,
                BackdropProps: st,
                className: lt,
                closeAfterTransition: ft = !1,
                children: yt,
                container: bt,
                component: ht,
                components: vt = {},
                componentsProps: wt = {},
                disableAutoFocus: gt = !1,
                disableEnforceFocus: At = !1,
                disableEscapeKeyDown: Pt = !1,
                disablePortal: Bt = !1,
                disableRestoreFocus: Lt = !1,
                disableScrollLock: Nt = !1,
                hideBackdrop: Ut = !1,
                keepMounted: Vt = !1,
                onBackdropClick: Ft,
                open: Wt,
                slotProps: Ct,
                slots: it
            } = rt,
            at = _objectWithoutPropertiesLoose$1(rt, _excluded$I),
            mt = _extends$4({}, rt, {
                closeAfterTransition: ft,
                disableAutoFocus: gt,
                disableEnforceFocus: At,
                disableEscapeKeyDown: Pt,
                disablePortal: Bt,
                disableRestoreFocus: Lt,
                disableScrollLock: Nt,
                hideBackdrop: Ut,
                keepMounted: Vt
            }),
            {
                getRootProps: xt,
                getBackdropProps: $t,
                getTransitionProps: Rt,
                portalRef: It,
                isTopModal: Tt,
                exited: dt,
                hasTransition: Et
            } = useModal(_extends$4({}, mt, {
                rootRef: a
            })),
            Ot = _extends$4({}, mt, {
                exited: dt
            }),
            Mt = useUtilityClasses$A(Ot),
            jt = {};
        if (yt.props.tabIndex === void 0 && (jt.tabIndex = "-1"), Et) {
            const {
                onEnter: ln,
                onExited: cn
            } = Rt();
            jt.onEnter = ln, jt.onExited = cn
        }
        const Qt = ($ = (j = it == null ? void 0 : it.root) != null ? j : vt.Root) != null ? $ : ModalRoot,
            Kt = (_e = (et = it == null ? void 0 : it.backdrop) != null ? et : vt.Backdrop) != null ? _e : ot,
            qt = (tt = Ct == null ? void 0 : Ct.root) != null ? tt : wt.root,
            Jt = (nt = Ct == null ? void 0 : Ct.backdrop) != null ? nt : wt.backdrop,
            Zt = useSlotProps({
                elementType: Qt,
                externalSlotProps: qt,
                externalForwardedProps: at,
                getSlotProps: xt,
                additionalProps: {
                    ref: a,
                    as: ht
                },
                ownerState: Ot,
                className: clsx(lt, qt == null ? void 0 : qt.className, Mt == null ? void 0 : Mt.root, !Ot.open && Ot.exited && (Mt == null ? void 0 : Mt.hidden))
            }),
            en = useSlotProps({
                elementType: Kt,
                externalSlotProps: Jt,
                additionalProps: st,
                getSlotProps: ln => $t(_extends$4({}, ln, {
                    onClick: cn => {
                        Ft && Ft(cn), ln != null && ln.onClick && ln.onClick(cn)
                    }
                })),
                className: clsx(Jt == null ? void 0 : Jt.className, st == null ? void 0 : st.className, Mt == null ? void 0 : Mt.backdrop),
                ownerState: Ot
            });
        return !Vt && !Wt && (!Et || dt) ? null : jsxRuntimeExports.jsx(Portal, {
            ref: It,
            container: bt,
            disablePortal: Bt,
            children: jsxRuntimeExports.jsxs(Qt, _extends$4({}, Zt, {
                children: [!Ut && ot ? jsxRuntimeExports.jsx(Kt, _extends$4({}, en)) : null, jsxRuntimeExports.jsx(FocusTrap, {
                    disableEnforceFocus: At,
                    disableAutoFocus: gt,
                    disableRestoreFocus: Lt,
                    isEnabled: Tt,
                    open: Wt,
                    children: reactExports.cloneElement(yt, jt)
                })]
            }))
        })
    }),
    dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]),
    _excluded$H = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function getTranslateValue(s, o, a) {
    const $ = o.getBoundingClientRect(),
        j = a && a.getBoundingClientRect(),
        _e = ownerWindow(o);
    let et;
    if (o.fakeTransform) et = o.fakeTransform;
    else {
        const rt = _e.getComputedStyle(o);
        et = rt.getPropertyValue("-webkit-transform") || rt.getPropertyValue("transform")
    }
    let tt = 0,
        nt = 0;
    if (et && et !== "none" && typeof et == "string") {
        const rt = et.split("(")[1].split(")")[0].split(",");
        tt = parseInt(rt[4], 10), nt = parseInt(rt[5], 10)
    }
    return s === "left" ? j ? `translateX(${j.right+tt-$.left}px)` : `translateX(${_e.innerWidth+tt-$.left}px)` : s === "right" ? j ? `translateX(-${$.right-j.left-tt}px)` : `translateX(-${$.left+$.width-tt}px)` : s === "up" ? j ? `translateY(${j.bottom+nt-$.top}px)` : `translateY(${_e.innerHeight+nt-$.top}px)` : j ? `translateY(-${$.top-j.top+$.height-nt}px)` : `translateY(-${$.top+$.height-nt}px)`
}

function resolveContainer(s) {
    return typeof s == "function" ? s() : s
}

function setTranslateValue(s, o, a) {
    const $ = resolveContainer(a),
        j = getTranslateValue(s, o, $);
    j && (o.style.webkitTransform = j, o.style.transform = j)
}
const Slide = reactExports.forwardRef(function(o, a) {
    const $ = useTheme$1(),
        j = {
            enter: $.transitions.easing.easeOut,
            exit: $.transitions.easing.sharp
        },
        _e = {
            enter: $.transitions.duration.enteringScreen,
            exit: $.transitions.duration.leavingScreen
        },
        {
            addEndListener: et,
            appear: tt = !0,
            children: nt,
            container: rt,
            direction: ot = "down",
            easing: st = j,
            in: lt,
            onEnter: ft,
            onEntered: yt,
            onEntering: bt,
            onExit: ht,
            onExited: vt,
            onExiting: wt,
            style: gt,
            timeout: At = _e,
            TransitionComponent: Pt = Transition
        } = o,
        Bt = _objectWithoutPropertiesLoose$1(o, _excluded$H),
        Lt = reactExports.useRef(null),
        Nt = useForkRef(nt.ref, Lt, a),
        Ut = $t => Rt => {
            $t && (Rt === void 0 ? $t(Lt.current) : $t(Lt.current, Rt))
        },
        Vt = Ut(($t, Rt) => {
            setTranslateValue(ot, $t, rt), reflow($t), ft && ft($t, Rt)
        }),
        Ft = Ut(($t, Rt) => {
            const It = getTransitionProps({
                timeout: At,
                style: gt,
                easing: st
            }, {
                mode: "enter"
            });
            $t.style.webkitTransition = $.transitions.create("-webkit-transform", _extends$4({}, It)), $t.style.transition = $.transitions.create("transform", _extends$4({}, It)), $t.style.webkitTransform = "none", $t.style.transform = "none", bt && bt($t, Rt)
        }),
        Wt = Ut(yt),
        Ct = Ut(wt),
        it = Ut($t => {
            const Rt = getTransitionProps({
                timeout: At,
                style: gt,
                easing: st
            }, {
                mode: "exit"
            });
            $t.style.webkitTransition = $.transitions.create("-webkit-transform", Rt), $t.style.transition = $.transitions.create("transform", Rt), setTranslateValue(ot, $t, rt), ht && ht($t)
        }),
        at = Ut($t => {
            $t.style.webkitTransition = "", $t.style.transition = "", vt && vt($t)
        }),
        mt = $t => {
            et && et(Lt.current, $t)
        },
        xt = reactExports.useCallback(() => {
            Lt.current && setTranslateValue(ot, Lt.current, rt)
        }, [ot, rt]);
    return reactExports.useEffect(() => {
        if (lt || ot === "down" || ot === "right") return;
        const $t = debounce$1(() => {
                Lt.current && setTranslateValue(ot, Lt.current, rt)
            }),
            Rt = ownerWindow(Lt.current);
        return Rt.addEventListener("resize", $t), () => {
            $t.clear(), Rt.removeEventListener("resize", $t)
        }
    }, [ot, lt, rt]), reactExports.useEffect(() => {
        lt || xt()
    }, [lt, xt]), jsxRuntimeExports.jsx(Pt, _extends$4({
        nodeRef: Lt,
        onEnter: Vt,
        onEntered: Wt,
        onEntering: Ft,
        onExit: it,
        onExited: at,
        onExiting: Ct,
        addEndListener: mt,
        appear: tt,
        in: lt,
        timeout: At
    }, Bt, {
        children: ($t, Rt) => reactExports.cloneElement(nt, _extends$4({
            ref: Nt,
            style: _extends$4({
                visibility: $t === "exited" && !lt ? "hidden" : void 0
            }, gt, nt.props.style)
        }, Rt))
    }))
});

function getDrawerUtilityClass(s) {
    return generateUtilityClass("MuiDrawer", s)
}
generateUtilityClasses("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const _excluded$G = ["BackdropProps"],
    _excluded2$5 = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"],
    overridesResolver$3 = (s, o) => {
        const {
            ownerState: a
        } = s;
        return [o.root, (a.variant === "permanent" || a.variant === "persistent") && o.docked, o.modal]
    },
    useUtilityClasses$z = s => {
        const {
            classes: o,
            anchor: a,
            variant: $
        } = s, j = {
            root: ["root"],
            docked: [($ === "permanent" || $ === "persistent") && "docked"],
            modal: ["modal"],
            paper: ["paper", `paperAnchor${capitalize$1(a)}`, $ !== "temporary" && `paperAnchorDocked${capitalize$1(a)}`]
        };
        return composeClasses(j, getDrawerUtilityClass, o)
    },
    DrawerRoot = styled(Modal, {
        name: "MuiDrawer",
        slot: "Root",
        overridesResolver: overridesResolver$3
    })(({
        theme: s
    }) => ({
        zIndex: (s.vars || s).zIndex.drawer
    })),
    DrawerDockedRoot = styled("div", {
        shouldForwardProp: rootShouldForwardProp,
        name: "MuiDrawer",
        slot: "Docked",
        skipVariantsResolver: !1,
        overridesResolver: overridesResolver$3
    })({
        flex: "0 0 auto"
    }),
    DrawerPaper = styled(Paper, {
        name: "MuiDrawer",
        slot: "Paper",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.paper, o[`paperAnchor${capitalize$1(a.anchor)}`], a.variant !== "temporary" && o[`paperAnchorDocked${capitalize$1(a.anchor)}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        overflowY: "auto",
        display: "flex",
        flexDirection: "column",
        height: "100%",
        flex: "1 0 auto",
        zIndex: (s.vars || s).zIndex.drawer,
        WebkitOverflowScrolling: "touch",
        position: "fixed",
        top: 0,
        outline: 0
    }, o.anchor === "left" && {
        left: 0
    }, o.anchor === "top" && {
        top: 0,
        left: 0,
        right: 0,
        height: "auto",
        maxHeight: "100%"
    }, o.anchor === "right" && {
        right: 0
    }, o.anchor === "bottom" && {
        top: "auto",
        left: 0,
        bottom: 0,
        right: 0,
        height: "auto",
        maxHeight: "100%"
    }, o.anchor === "left" && o.variant !== "temporary" && {
        borderRight: `1px solid ${(s.vars||s).palette.divider}`
    }, o.anchor === "top" && o.variant !== "temporary" && {
        borderBottom: `1px solid ${(s.vars||s).palette.divider}`
    }, o.anchor === "right" && o.variant !== "temporary" && {
        borderLeft: `1px solid ${(s.vars||s).palette.divider}`
    }, o.anchor === "bottom" && o.variant !== "temporary" && {
        borderTop: `1px solid ${(s.vars||s).palette.divider}`
    })),
    oppositeDirection = {
        left: "right",
        right: "left",
        top: "down",
        bottom: "up"
    };

function isHorizontal(s) {
    return ["left", "right"].indexOf(s) !== -1
}

function getAnchor({
    direction: s
}, o) {
    return s === "rtl" && isHorizontal(o) ? oppositeDirection[o] : o
}
const Drawer = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiDrawer"
            }),
            j = useTheme$1(),
            _e = useRtl(),
            et = {
                enter: j.transitions.duration.enteringScreen,
                exit: j.transitions.duration.leavingScreen
            },
            {
                anchor: tt = "left",
                BackdropProps: nt,
                children: rt,
                className: ot,
                elevation: st = 16,
                hideBackdrop: lt = !1,
                ModalProps: {
                    BackdropProps: ft
                } = {},
                onClose: yt,
                open: bt = !1,
                PaperProps: ht = {},
                SlideProps: vt,
                TransitionComponent: wt = Slide,
                transitionDuration: gt = et,
                variant: At = "temporary"
            } = $,
            Pt = _objectWithoutPropertiesLoose$1($.ModalProps, _excluded$G),
            Bt = _objectWithoutPropertiesLoose$1($, _excluded2$5),
            Lt = reactExports.useRef(!1);
        reactExports.useEffect(() => {
            Lt.current = !0
        }, []);
        const Nt = getAnchor({
                direction: _e ? "rtl" : "ltr"
            }, tt),
            Vt = _extends$4({}, $, {
                anchor: tt,
                elevation: st,
                open: bt,
                variant: At
            }, Bt),
            Ft = useUtilityClasses$z(Vt),
            Wt = jsxRuntimeExports.jsx(DrawerPaper, _extends$4({
                elevation: At === "temporary" ? st : 0,
                square: !0
            }, ht, {
                className: clsx(Ft.paper, ht.className),
                ownerState: Vt,
                children: rt
            }));
        if (At === "permanent") return jsxRuntimeExports.jsx(DrawerDockedRoot, _extends$4({
            className: clsx(Ft.root, Ft.docked, ot),
            ownerState: Vt,
            ref: a
        }, Bt, {
            children: Wt
        }));
        const Ct = jsxRuntimeExports.jsx(wt, _extends$4({ in: bt,
            direction: oppositeDirection[Nt],
            timeout: gt,
            appear: Lt.current
        }, vt, {
            children: Wt
        }));
        return At === "persistent" ? jsxRuntimeExports.jsx(DrawerDockedRoot, _extends$4({
            className: clsx(Ft.root, Ft.docked, ot),
            ownerState: Vt,
            ref: a
        }, Bt, {
            children: Ct
        })) : jsxRuntimeExports.jsx(DrawerRoot, _extends$4({
            BackdropProps: _extends$4({}, nt, ft, {
                transitionDuration: gt
            }),
            className: clsx(Ft.root, Ft.modal, ot),
            open: bt,
            ownerState: Vt,
            onClose: yt,
            hideBackdrop: lt,
            ref: a
        }, Bt, Pt, {
            children: Ct
        }))
    }),
    _excluded$F = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"],
    useUtilityClasses$y = s => {
        const {
            classes: o,
            disableUnderline: a
        } = s, j = composeClasses({
            root: ["root", !a && "underline"],
            input: ["input"]
        }, getFilledInputUtilityClass, o);
        return _extends$4({}, o, j)
    },
    FilledInputRoot = styled(InputBaseRoot, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiFilledInput",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [...rootOverridesResolver(s, o), !a.disableUnderline && o.underline]
        }
    })(({
        theme: s,
        ownerState: o
    }) => {
        var a;
        const $ = s.palette.mode === "light",
            j = $ ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
            _e = $ ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
            et = $ ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
            tt = $ ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
        return _extends$4({
            position: "relative",
            backgroundColor: s.vars ? s.vars.palette.FilledInput.bg : _e,
            borderTopLeftRadius: (s.vars || s).shape.borderRadius,
            borderTopRightRadius: (s.vars || s).shape.borderRadius,
            transition: s.transitions.create("background-color", {
                duration: s.transitions.duration.shorter,
                easing: s.transitions.easing.easeOut
            }),
            "&:hover": {
                backgroundColor: s.vars ? s.vars.palette.FilledInput.hoverBg : et,
                "@media (hover: none)": {
                    backgroundColor: s.vars ? s.vars.palette.FilledInput.bg : _e
                }
            },
            [`&.${filledInputClasses.focused}`]: {
                backgroundColor: s.vars ? s.vars.palette.FilledInput.bg : _e
            },
            [`&.${filledInputClasses.disabled}`]: {
                backgroundColor: s.vars ? s.vars.palette.FilledInput.disabledBg : tt
            }
        }, !o.disableUnderline && {
            "&::after": {
                borderBottom: `2px solid ${(a=(s.vars||s).palette[o.color||"primary"])==null?void 0:a.main}`,
                left: 0,
                bottom: 0,
                content: '""',
                position: "absolute",
                right: 0,
                transform: "scaleX(0)",
                transition: s.transitions.create("transform", {
                    duration: s.transitions.duration.shorter,
                    easing: s.transitions.easing.easeOut
                }),
                pointerEvents: "none"
            },
            [`&.${filledInputClasses.focused}:after`]: {
                transform: "scaleX(1) translateX(0)"
            },
            [`&.${filledInputClasses.error}`]: {
                "&::before, &::after": {
                    borderBottomColor: (s.vars || s).palette.error.main
                }
            },
            "&::before": {
                borderBottom: `1px solid ${s.vars?`rgba(${s.vars.palette.common.onBackgroundChannel} / ${s.vars.opacity.inputUnderline})`:j}`,
                left: 0,
                bottom: 0,
                content: '"\\00a0"',
                position: "absolute",
                right: 0,
                transition: s.transitions.create("border-bottom-color", {
                    duration: s.transitions.duration.shorter
                }),
                pointerEvents: "none"
            },
            [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
                borderBottom: `1px solid ${(s.vars||s).palette.text.primary}`
            },
            [`&.${filledInputClasses.disabled}:before`]: {
                borderBottomStyle: "dotted"
            }
        }, o.startAdornment && {
            paddingLeft: 12
        }, o.endAdornment && {
            paddingRight: 12
        }, o.multiline && _extends$4({
            padding: "25px 12px 8px"
        }, o.size === "small" && {
            paddingTop: 21,
            paddingBottom: 4
        }, o.hiddenLabel && {
            paddingTop: 16,
            paddingBottom: 17
        }, o.hiddenLabel && o.size === "small" && {
            paddingTop: 8,
            paddingBottom: 9
        }))
    }),
    FilledInputInput = styled(InputBaseComponent, {
        name: "MuiFilledInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        paddingTop: 25,
        paddingRight: 12,
        paddingBottom: 8,
        paddingLeft: 12
    }, !s.vars && {
        "&:-webkit-autofill": {
            WebkitBoxShadow: s.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: s.palette.mode === "light" ? null : "#fff",
            caretColor: s.palette.mode === "light" ? null : "#fff",
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit"
        }
    }, s.vars && {
        "&:-webkit-autofill": {
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit"
        },
        [s.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
                WebkitBoxShadow: "0 0 0 100px #266798 inset",
                WebkitTextFillColor: "#fff",
                caretColor: "#fff"
            }
        }
    }, o.size === "small" && {
        paddingTop: 21,
        paddingBottom: 4
    }, o.hiddenLabel && {
        paddingTop: 16,
        paddingBottom: 17
    }, o.startAdornment && {
        paddingLeft: 0
    }, o.endAdornment && {
        paddingRight: 0
    }, o.hiddenLabel && o.size === "small" && {
        paddingTop: 8,
        paddingBottom: 9
    }, o.multiline && {
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0
    })),
    FilledInput = reactExports.forwardRef(function(o, a) {
        var $, j, _e, et;
        const tt = useDefaultProps({
                props: o,
                name: "MuiFilledInput"
            }),
            {
                components: nt = {},
                componentsProps: rt,
                fullWidth: ot = !1,
                inputComponent: st = "input",
                multiline: lt = !1,
                slotProps: ft,
                slots: yt = {},
                type: bt = "text"
            } = tt,
            ht = _objectWithoutPropertiesLoose$1(tt, _excluded$F),
            vt = _extends$4({}, tt, {
                fullWidth: ot,
                inputComponent: st,
                multiline: lt,
                type: bt
            }),
            wt = useUtilityClasses$y(tt),
            gt = {
                root: {
                    ownerState: vt
                },
                input: {
                    ownerState: vt
                }
            },
            At = ft ? ? rt ? deepmerge$1(gt, ft ? ? rt) : gt,
            Pt = ($ = (j = yt.root) != null ? j : nt.Root) != null ? $ : FilledInputRoot,
            Bt = (_e = (et = yt.input) != null ? et : nt.Input) != null ? _e : FilledInputInput;
        return jsxRuntimeExports.jsx(InputBase$1, _extends$4({
            slots: {
                root: Pt,
                input: Bt
            },
            componentsProps: At,
            fullWidth: ot,
            inputComponent: st,
            multiline: lt,
            ref: a,
            type: bt
        }, ht, {
            classes: wt
        }))
    });
FilledInput.muiName = "Input";

function getFormControlUtilityClasses(s) {
    return generateUtilityClass("MuiFormControl", s)
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const _excluded$E = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"],
    useUtilityClasses$x = s => {
        const {
            classes: o,
            margin: a,
            fullWidth: $
        } = s, j = {
            root: ["root", a !== "none" && `margin${capitalize$1(a)}`, $ && "fullWidth"]
        };
        return composeClasses(j, getFormControlUtilityClasses, o)
    },
    FormControlRoot = styled("div", {
        name: "MuiFormControl",
        slot: "Root",
        overridesResolver: ({
            ownerState: s
        }, o) => _extends$4({}, o.root, o[`margin${capitalize$1(s.margin)}`], s.fullWidth && o.fullWidth)
    })(({
        ownerState: s
    }) => _extends$4({
        display: "inline-flex",
        flexDirection: "column",
        position: "relative",
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: "top"
    }, s.margin === "normal" && {
        marginTop: 16,
        marginBottom: 8
    }, s.margin === "dense" && {
        marginTop: 8,
        marginBottom: 4
    }, s.fullWidth && {
        width: "100%"
    })),
    FormControl = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiFormControl"
            }),
            {
                children: j,
                className: _e,
                color: et = "primary",
                component: tt = "div",
                disabled: nt = !1,
                error: rt = !1,
                focused: ot,
                fullWidth: st = !1,
                hiddenLabel: lt = !1,
                margin: ft = "none",
                required: yt = !1,
                size: bt = "medium",
                variant: ht = "outlined"
            } = $,
            vt = _objectWithoutPropertiesLoose$1($, _excluded$E),
            wt = _extends$4({}, $, {
                color: et,
                component: tt,
                disabled: nt,
                error: rt,
                fullWidth: st,
                hiddenLabel: lt,
                margin: ft,
                required: yt,
                size: bt,
                variant: ht
            }),
            gt = useUtilityClasses$x(wt),
            [At, Pt] = reactExports.useState(() => {
                let Ct = !1;
                return j && reactExports.Children.forEach(j, it => {
                    if (!isMuiElement(it, ["Input", "Select"])) return;
                    const at = isMuiElement(it, ["Select"]) ? it.props.input : it;
                    at && isAdornedStart(at.props) && (Ct = !0)
                }), Ct
            }),
            [Bt, Lt] = reactExports.useState(() => {
                let Ct = !1;
                return j && reactExports.Children.forEach(j, it => {
                    isMuiElement(it, ["Input", "Select"]) && (isFilled(it.props, !0) || isFilled(it.props.inputProps, !0)) && (Ct = !0)
                }), Ct
            }),
            [Nt, Ut] = reactExports.useState(!1);
        nt && Nt && Ut(!1);
        const Vt = ot !== void 0 && !nt ? ot : Nt;
        let Ft;
        const Wt = reactExports.useMemo(() => ({
            adornedStart: At,
            setAdornedStart: Pt,
            color: et,
            disabled: nt,
            error: rt,
            filled: Bt,
            focused: Vt,
            fullWidth: st,
            hiddenLabel: lt,
            size: bt,
            onBlur: () => {
                Ut(!1)
            },
            onEmpty: () => {
                Lt(!1)
            },
            onFilled: () => {
                Lt(!0)
            },
            onFocus: () => {
                Ut(!0)
            },
            registerEffect: Ft,
            required: yt,
            variant: ht
        }), [At, et, nt, rt, Bt, Vt, st, lt, Ft, yt, bt, ht]);
        return jsxRuntimeExports.jsx(FormControlContext.Provider, {
            value: Wt,
            children: jsxRuntimeExports.jsx(FormControlRoot, _extends$4({
                as: tt,
                ownerState: wt,
                className: clsx(gt.root, _e),
                ref: a
            }, vt, {
                children: j
            }))
        })
    }),
    Stack = createStack({
        createStyledComponent: styled("div", {
            name: "MuiStack",
            slot: "Root",
            overridesResolver: (s, o) => o.root
        }),
        useThemeProps: s => useDefaultProps({
            props: s,
            name: "MuiStack"
        })
    });

function getFormControlLabelUtilityClasses(s) {
    return generateUtilityClass("MuiFormControlLabel", s)
}
const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]),
    _excluded$D = ["checked", "className", "componentsProps", "control", "disabled", "disableTypography", "inputRef", "label", "labelPlacement", "name", "onChange", "required", "slotProps", "value"],
    useUtilityClasses$w = s => {
        const {
            classes: o,
            disabled: a,
            labelPlacement: $,
            error: j,
            required: _e
        } = s, et = {
            root: ["root", a && "disabled", `labelPlacement${capitalize$1($)}`, j && "error", _e && "required"],
            label: ["label", a && "disabled"],
            asterisk: ["asterisk", j && "error"]
        };
        return composeClasses(et, getFormControlLabelUtilityClasses, o)
    },
    FormControlLabelRoot = styled("label", {
        name: "MuiFormControlLabel",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [{
                [`& .${formControlLabelClasses.label}`]: o.label
            }, o.root, o[`labelPlacement${capitalize$1(a.labelPlacement)}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        display: "inline-flex",
        alignItems: "center",
        cursor: "pointer",
        verticalAlign: "middle",
        WebkitTapHighlightColor: "transparent",
        marginLeft: -11,
        marginRight: 16,
        [`&.${formControlLabelClasses.disabled}`]: {
            cursor: "default"
        }
    }, o.labelPlacement === "start" && {
        flexDirection: "row-reverse",
        marginLeft: 16,
        marginRight: -11
    }, o.labelPlacement === "top" && {
        flexDirection: "column-reverse",
        marginLeft: 16
    }, o.labelPlacement === "bottom" && {
        flexDirection: "column",
        marginLeft: 16
    }, {
        [`& .${formControlLabelClasses.label}`]: {
            [`&.${formControlLabelClasses.disabled}`]: {
                color: (s.vars || s).palette.text.disabled
            }
        }
    })),
    AsteriskComponent$1 = styled("span", {
        name: "MuiFormControlLabel",
        slot: "Asterisk",
        overridesResolver: (s, o) => o.asterisk
    })(({
        theme: s
    }) => ({
        [`&.${formControlLabelClasses.error}`]: {
            color: (s.vars || s).palette.error.main
        }
    })),
    FormControlLabel = reactExports.forwardRef(function(o, a) {
        var $, j;
        const _e = useDefaultProps({
                props: o,
                name: "MuiFormControlLabel"
            }),
            {
                className: et,
                componentsProps: tt = {},
                control: nt,
                disabled: rt,
                disableTypography: ot,
                label: st,
                labelPlacement: lt = "end",
                required: ft,
                slotProps: yt = {}
            } = _e,
            bt = _objectWithoutPropertiesLoose$1(_e, _excluded$D),
            ht = useFormControl(),
            vt = ($ = rt ? ? nt.props.disabled) != null ? $ : ht == null ? void 0 : ht.disabled,
            wt = ft ? ? nt.props.required,
            gt = {
                disabled: vt,
                required: wt
            };
        ["checked", "name", "onChange", "value", "inputRef"].forEach(Ut => {
            typeof nt.props[Ut] > "u" && typeof _e[Ut] < "u" && (gt[Ut] = _e[Ut])
        });
        const At = formControlState({
                props: _e,
                muiFormControl: ht,
                states: ["error"]
            }),
            Pt = _extends$4({}, _e, {
                disabled: vt,
                labelPlacement: lt,
                required: wt,
                error: At.error
            }),
            Bt = useUtilityClasses$w(Pt),
            Lt = (j = yt.typography) != null ? j : tt.typography;
        let Nt = st;
        return Nt != null && Nt.type !== Typography && !ot && (Nt = jsxRuntimeExports.jsx(Typography, _extends$4({
            component: "span"
        }, Lt, {
            className: clsx(Bt.label, Lt == null ? void 0 : Lt.className),
            children: Nt
        }))), jsxRuntimeExports.jsxs(FormControlLabelRoot, _extends$4({
            className: clsx(Bt.root, et),
            ownerState: Pt,
            ref: a
        }, bt, {
            children: [reactExports.cloneElement(nt, gt), wt ? jsxRuntimeExports.jsxs(Stack, {
                display: "block",
                children: [Nt, jsxRuntimeExports.jsxs(AsteriskComponent$1, {
                    ownerState: Pt,
                    "aria-hidden": !0,
                    className: Bt.asterisk,
                    children: [" ", "*"]
                })]
            }) : Nt]
        }))
    });

function getFormGroupUtilityClass(s) {
    return generateUtilityClass("MuiFormGroup", s)
}
generateUtilityClasses("MuiFormGroup", ["root", "row", "error"]);
const _excluded$C = ["className", "row"],
    useUtilityClasses$v = s => {
        const {
            classes: o,
            row: a,
            error: $
        } = s;
        return composeClasses({
            root: ["root", a && "row", $ && "error"]
        }, getFormGroupUtilityClass, o)
    },
    FormGroupRoot = styled("div", {
        name: "MuiFormGroup",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.row && o.row]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        display: "flex",
        flexDirection: "column",
        flexWrap: "wrap"
    }, s.row && {
        flexDirection: "row"
    })),
    FormGroup = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiFormGroup"
            }),
            {
                className: j,
                row: _e = !1
            } = $,
            et = _objectWithoutPropertiesLoose$1($, _excluded$C),
            tt = useFormControl(),
            nt = formControlState({
                props: $,
                muiFormControl: tt,
                states: ["error"]
            }),
            rt = _extends$4({}, $, {
                row: _e,
                error: nt.error
            }),
            ot = useUtilityClasses$v(rt);
        return jsxRuntimeExports.jsx(FormGroupRoot, _extends$4({
            className: clsx(ot.root, j),
            ownerState: rt,
            ref: a
        }, et))
    });

function getFormHelperTextUtilityClasses(s) {
    return generateUtilityClass("MuiFormHelperText", s)
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var _span$3;
const _excluded$B = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"],
    useUtilityClasses$u = s => {
        const {
            classes: o,
            contained: a,
            size: $,
            disabled: j,
            error: _e,
            filled: et,
            focused: tt,
            required: nt
        } = s, rt = {
            root: ["root", j && "disabled", _e && "error", $ && `size${capitalize$1($)}`, a && "contained", tt && "focused", et && "filled", nt && "required"]
        };
        return composeClasses(rt, getFormHelperTextUtilityClasses, o)
    },
    FormHelperTextRoot = styled("p", {
        name: "MuiFormHelperText",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.size && o[`size${capitalize$1(a.size)}`], a.contained && o.contained, a.filled && o.filled]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        color: (s.vars || s).palette.text.secondary
    }, s.typography.caption, {
        textAlign: "left",
        marginTop: 3,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        [`&.${formHelperTextClasses.disabled}`]: {
            color: (s.vars || s).palette.text.disabled
        },
        [`&.${formHelperTextClasses.error}`]: {
            color: (s.vars || s).palette.error.main
        }
    }, o.size === "small" && {
        marginTop: 4
    }, o.contained && {
        marginLeft: 14,
        marginRight: 14
    })),
    FormHelperText = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiFormHelperText"
            }),
            {
                children: j,
                className: _e,
                component: et = "p"
            } = $,
            tt = _objectWithoutPropertiesLoose$1($, _excluded$B),
            nt = useFormControl(),
            rt = formControlState({
                props: $,
                muiFormControl: nt,
                states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
            }),
            ot = _extends$4({}, $, {
                component: et,
                contained: rt.variant === "filled" || rt.variant === "outlined",
                variant: rt.variant,
                size: rt.size,
                disabled: rt.disabled,
                error: rt.error,
                filled: rt.filled,
                focused: rt.focused,
                required: rt.required
            }),
            st = useUtilityClasses$u(ot);
        return jsxRuntimeExports.jsx(FormHelperTextRoot, _extends$4({
            as: et,
            ownerState: ot,
            className: clsx(st.root, _e),
            ref: a
        }, tt, {
            children: j === " " ? _span$3 || (_span$3 = jsxRuntimeExports.jsx("span", {
                className: "notranslate",
                children: "​"
            })) : j
        }))
    });

function getFormLabelUtilityClasses(s) {
    return generateUtilityClass("MuiFormLabel", s)
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]),
    _excluded$A = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"],
    useUtilityClasses$t = s => {
        const {
            classes: o,
            color: a,
            focused: $,
            disabled: j,
            error: _e,
            filled: et,
            required: tt
        } = s, nt = {
            root: ["root", `color${capitalize$1(a)}`, j && "disabled", _e && "error", et && "filled", $ && "focused", tt && "required"],
            asterisk: ["asterisk", _e && "error"]
        };
        return composeClasses(nt, getFormLabelUtilityClasses, o)
    },
    FormLabelRoot = styled("label", {
        name: "MuiFormLabel",
        slot: "Root",
        overridesResolver: ({
            ownerState: s
        }, o) => _extends$4({}, o.root, s.color === "secondary" && o.colorSecondary, s.filled && o.filled)
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        color: (s.vars || s).palette.text.secondary
    }, s.typography.body1, {
        lineHeight: "1.4375em",
        padding: 0,
        position: "relative",
        [`&.${formLabelClasses.focused}`]: {
            color: (s.vars || s).palette[o.color].main
        },
        [`&.${formLabelClasses.disabled}`]: {
            color: (s.vars || s).palette.text.disabled
        },
        [`&.${formLabelClasses.error}`]: {
            color: (s.vars || s).palette.error.main
        }
    })),
    AsteriskComponent = styled("span", {
        name: "MuiFormLabel",
        slot: "Asterisk",
        overridesResolver: (s, o) => o.asterisk
    })(({
        theme: s
    }) => ({
        [`&.${formLabelClasses.error}`]: {
            color: (s.vars || s).palette.error.main
        }
    })),
    FormLabel = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiFormLabel"
            }),
            {
                children: j,
                className: _e,
                component: et = "label"
            } = $,
            tt = _objectWithoutPropertiesLoose$1($, _excluded$A),
            nt = useFormControl(),
            rt = formControlState({
                props: $,
                muiFormControl: nt,
                states: ["color", "required", "focused", "disabled", "error", "filled"]
            }),
            ot = _extends$4({}, $, {
                color: rt.color || "primary",
                component: et,
                disabled: rt.disabled,
                error: rt.error,
                filled: rt.filled,
                focused: rt.focused,
                required: rt.required
            }),
            st = useUtilityClasses$t(ot);
        return jsxRuntimeExports.jsxs(FormLabelRoot, _extends$4({
            as: et,
            ownerState: ot,
            className: clsx(st.root, _e),
            ref: a
        }, tt, {
            children: [j, rt.required && jsxRuntimeExports.jsxs(AsteriskComponent, {
                ownerState: ot,
                "aria-hidden": !0,
                className: st.asterisk,
                children: [" ", "*"]
            })]
        }))
    }),
    _excluded$z = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function getScale(s) {
    return `scale(${s}, ${s**2})`
}
const styles$1 = {
        entering: {
            opacity: 1,
            transform: getScale(1)
        },
        entered: {
            opacity: 1,
            transform: "none"
        }
    },
    isWebKit154 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
    Grow = reactExports.forwardRef(function(o, a) {
        const {
            addEndListener: $,
            appear: j = !0,
            children: _e,
            easing: et,
            in: tt,
            onEnter: nt,
            onEntered: rt,
            onEntering: ot,
            onExit: st,
            onExited: lt,
            onExiting: ft,
            style: yt,
            timeout: bt = "auto",
            TransitionComponent: ht = Transition
        } = o, vt = _objectWithoutPropertiesLoose$1(o, _excluded$z), wt = useTimeout(), gt = reactExports.useRef(), At = useTheme$1(), Pt = reactExports.useRef(null), Bt = useForkRef(Pt, _e.ref, a), Lt = at => mt => {
            if (at) {
                const xt = Pt.current;
                mt === void 0 ? at(xt) : at(xt, mt)
            }
        }, Nt = Lt(ot), Ut = Lt((at, mt) => {
            reflow(at);
            const {
                duration: xt,
                delay: $t,
                easing: Rt
            } = getTransitionProps({
                style: yt,
                timeout: bt,
                easing: et
            }, {
                mode: "enter"
            });
            let It;
            bt === "auto" ? (It = At.transitions.getAutoHeightDuration(at.clientHeight), gt.current = It) : It = xt, at.style.transition = [At.transitions.create("opacity", {
                duration: It,
                delay: $t
            }), At.transitions.create("transform", {
                duration: isWebKit154 ? It : It * .666,
                delay: $t,
                easing: Rt
            })].join(","), nt && nt(at, mt)
        }), Vt = Lt(rt), Ft = Lt(ft), Wt = Lt(at => {
            const {
                duration: mt,
                delay: xt,
                easing: $t
            } = getTransitionProps({
                style: yt,
                timeout: bt,
                easing: et
            }, {
                mode: "exit"
            });
            let Rt;
            bt === "auto" ? (Rt = At.transitions.getAutoHeightDuration(at.clientHeight), gt.current = Rt) : Rt = mt, at.style.transition = [At.transitions.create("opacity", {
                duration: Rt,
                delay: xt
            }), At.transitions.create("transform", {
                duration: isWebKit154 ? Rt : Rt * .666,
                delay: isWebKit154 ? xt : xt || Rt * .333,
                easing: $t
            })].join(","), at.style.opacity = 0, at.style.transform = getScale(.75), st && st(at)
        }), Ct = Lt(lt), it = at => {
            bt === "auto" && wt.start(gt.current || 0, at), $ && $(Pt.current, at)
        };
        return jsxRuntimeExports.jsx(ht, _extends$4({
            appear: j,
            in: tt,
            nodeRef: Pt,
            onEnter: Ut,
            onEntered: Vt,
            onEntering: Nt,
            onExit: Wt,
            onExited: Ct,
            onExiting: Ft,
            addEndListener: it,
            timeout: bt === "auto" ? null : bt
        }, vt, {
            children: (at, mt) => reactExports.cloneElement(_e, _extends$4({
                style: _extends$4({
                    opacity: 0,
                    transform: getScale(.75),
                    visibility: at === "exited" && !tt ? "hidden" : void 0
                }, styles$1[at], yt, _e.props.style),
                ref: Bt
            }, mt))
        }))
    });
Grow.muiSupportAuto = !0;
const _excluded$y = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"],
    useUtilityClasses$s = s => {
        const {
            classes: o,
            disableUnderline: a
        } = s, j = composeClasses({
            root: ["root", !a && "underline"],
            input: ["input"]
        }, getInputUtilityClass, o);
        return _extends$4({}, o, j)
    },
    InputRoot = styled(InputBaseRoot, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiInput",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [...rootOverridesResolver(s, o), !a.disableUnderline && o.underline]
        }
    })(({
        theme: s,
        ownerState: o
    }) => {
        let $ = s.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
        return s.vars && ($ = `rgba(${s.vars.palette.common.onBackgroundChannel} / ${s.vars.opacity.inputUnderline})`), _extends$4({
            position: "relative"
        }, o.formControl && {
            "label + &": {
                marginTop: 16
            }
        }, !o.disableUnderline && {
            "&::after": {
                borderBottom: `2px solid ${(s.vars||s).palette[o.color].main}`,
                left: 0,
                bottom: 0,
                content: '""',
                position: "absolute",
                right: 0,
                transform: "scaleX(0)",
                transition: s.transitions.create("transform", {
                    duration: s.transitions.duration.shorter,
                    easing: s.transitions.easing.easeOut
                }),
                pointerEvents: "none"
            },
            [`&.${inputClasses.focused}:after`]: {
                transform: "scaleX(1) translateX(0)"
            },
            [`&.${inputClasses.error}`]: {
                "&::before, &::after": {
                    borderBottomColor: (s.vars || s).palette.error.main
                }
            },
            "&::before": {
                borderBottom: `1px solid ${$}`,
                left: 0,
                bottom: 0,
                content: '"\\00a0"',
                position: "absolute",
                right: 0,
                transition: s.transitions.create("border-bottom-color", {
                    duration: s.transitions.duration.shorter
                }),
                pointerEvents: "none"
            },
            [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
                borderBottom: `2px solid ${(s.vars||s).palette.text.primary}`,
                "@media (hover: none)": {
                    borderBottom: `1px solid ${$}`
                }
            },
            [`&.${inputClasses.disabled}:before`]: {
                borderBottomStyle: "dotted"
            }
        })
    }),
    InputInput = styled(InputBaseComponent, {
        name: "MuiInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })({}),
    Input = reactExports.forwardRef(function(o, a) {
        var $, j, _e, et;
        const tt = useDefaultProps({
                props: o,
                name: "MuiInput"
            }),
            {
                disableUnderline: nt,
                components: rt = {},
                componentsProps: ot,
                fullWidth: st = !1,
                inputComponent: lt = "input",
                multiline: ft = !1,
                slotProps: yt,
                slots: bt = {},
                type: ht = "text"
            } = tt,
            vt = _objectWithoutPropertiesLoose$1(tt, _excluded$y),
            wt = useUtilityClasses$s(tt),
            At = {
                root: {
                    ownerState: {
                        disableUnderline: nt
                    }
                }
            },
            Pt = yt ? ? ot ? deepmerge$1(yt ? ? ot, At) : At,
            Bt = ($ = (j = bt.root) != null ? j : rt.Root) != null ? $ : InputRoot,
            Lt = (_e = (et = bt.input) != null ? et : rt.Input) != null ? _e : InputInput;
        return jsxRuntimeExports.jsx(InputBase$1, _extends$4({
            slots: {
                root: Bt,
                input: Lt
            },
            slotProps: Pt,
            fullWidth: st,
            inputComponent: lt,
            multiline: ft,
            ref: a,
            type: ht
        }, vt, {
            classes: wt
        }))
    });
Input.muiName = "Input";

function getInputAdornmentUtilityClass(s) {
    return generateUtilityClass("MuiInputAdornment", s)
}
const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var _span$2;
const _excluded$x = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"],
    overridesResolver$2 = (s, o) => {
        const {
            ownerState: a
        } = s;
        return [o.root, o[`position${capitalize$1(a.position)}`], a.disablePointerEvents === !0 && o.disablePointerEvents, o[a.variant]]
    },
    useUtilityClasses$r = s => {
        const {
            classes: o,
            disablePointerEvents: a,
            hiddenLabel: $,
            position: j,
            size: _e,
            variant: et
        } = s, tt = {
            root: ["root", a && "disablePointerEvents", j && `position${capitalize$1(j)}`, et, $ && "hiddenLabel", _e && `size${capitalize$1(_e)}`]
        };
        return composeClasses(tt, getInputAdornmentUtilityClass, o)
    },
    InputAdornmentRoot = styled("div", {
        name: "MuiInputAdornment",
        slot: "Root",
        overridesResolver: overridesResolver$2
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        display: "flex",
        height: "0.01em",
        maxHeight: "2em",
        alignItems: "center",
        whiteSpace: "nowrap",
        color: (s.vars || s).palette.action.active
    }, o.variant === "filled" && {
        [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
            marginTop: 16
        }
    }, o.position === "start" && {
        marginRight: 8
    }, o.position === "end" && {
        marginLeft: 8
    }, o.disablePointerEvents === !0 && {
        pointerEvents: "none"
    })),
    InputAdornment = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiInputAdornment"
            }),
            {
                children: j,
                className: _e,
                component: et = "div",
                disablePointerEvents: tt = !1,
                disableTypography: nt = !1,
                position: rt,
                variant: ot
            } = $,
            st = _objectWithoutPropertiesLoose$1($, _excluded$x),
            lt = useFormControl() || {};
        let ft = ot;
        ot && lt.variant, lt && !ft && (ft = lt.variant);
        const yt = _extends$4({}, $, {
                hiddenLabel: lt.hiddenLabel,
                size: lt.size,
                disablePointerEvents: tt,
                position: rt,
                variant: ft
            }),
            bt = useUtilityClasses$r(yt);
        return jsxRuntimeExports.jsx(FormControlContext.Provider, {
            value: null,
            children: jsxRuntimeExports.jsx(InputAdornmentRoot, _extends$4({
                as: et,
                ownerState: yt,
                className: clsx(bt.root, _e),
                ref: a
            }, st, {
                children: typeof j == "string" && !nt ? jsxRuntimeExports.jsx(Typography, {
                    color: "text.secondary",
                    children: j
                }) : jsxRuntimeExports.jsxs(reactExports.Fragment, {
                    children: [rt === "start" ? _span$2 || (_span$2 = jsxRuntimeExports.jsx("span", {
                        className: "notranslate",
                        children: "​"
                    })) : null, j]
                })
            }))
        })
    });

function getInputLabelUtilityClasses(s) {
    return generateUtilityClass("MuiInputLabel", s)
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const _excluded$w = ["disableAnimation", "margin", "shrink", "variant", "className"],
    useUtilityClasses$q = s => {
        const {
            classes: o,
            formControl: a,
            size: $,
            shrink: j,
            disableAnimation: _e,
            variant: et,
            required: tt
        } = s, nt = {
            root: ["root", a && "formControl", !_e && "animated", j && "shrink", $ && $ !== "normal" && `size${capitalize$1($)}`, et],
            asterisk: [tt && "asterisk"]
        }, rt = composeClasses(nt, getInputLabelUtilityClasses, o);
        return _extends$4({}, o, rt)
    },
    InputLabelRoot = styled(FormLabel, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiInputLabel",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [{
                [`& .${formLabelClasses.asterisk}`]: o.asterisk
            }, o.root, a.formControl && o.formControl, a.size === "small" && o.sizeSmall, a.shrink && o.shrink, !a.disableAnimation && o.animated, a.focused && o.focused, o[a.variant]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        display: "block",
        transformOrigin: "top left",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        maxWidth: "100%"
    }, o.formControl && {
        position: "absolute",
        left: 0,
        top: 0,
        transform: "translate(0, 20px) scale(1)"
    }, o.size === "small" && {
        transform: "translate(0, 17px) scale(1)"
    }, o.shrink && {
        transform: "translate(0, -1.5px) scale(0.75)",
        transformOrigin: "top left",
        maxWidth: "133%"
    }, !o.disableAnimation && {
        transition: s.transitions.create(["color", "transform", "max-width"], {
            duration: s.transitions.duration.shorter,
            easing: s.transitions.easing.easeOut
        })
    }, o.variant === "filled" && _extends$4({
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(12px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
    }, o.size === "small" && {
        transform: "translate(12px, 13px) scale(1)"
    }, o.shrink && _extends$4({
        userSelect: "none",
        pointerEvents: "auto",
        transform: "translate(12px, 7px) scale(0.75)",
        maxWidth: "calc(133% - 24px)"
    }, o.size === "small" && {
        transform: "translate(12px, 4px) scale(0.75)"
    })), o.variant === "outlined" && _extends$4({
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(14px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
    }, o.size === "small" && {
        transform: "translate(14px, 9px) scale(1)"
    }, o.shrink && {
        userSelect: "none",
        pointerEvents: "auto",
        maxWidth: "calc(133% - 32px)",
        transform: "translate(14px, -9px) scale(0.75)"
    }))),
    InputLabel = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                name: "MuiInputLabel",
                props: o
            }),
            {
                disableAnimation: j = !1,
                shrink: _e,
                className: et
            } = $,
            tt = _objectWithoutPropertiesLoose$1($, _excluded$w),
            nt = useFormControl();
        let rt = _e;
        typeof rt > "u" && nt && (rt = nt.filled || nt.focused || nt.adornedStart);
        const ot = formControlState({
                props: $,
                muiFormControl: nt,
                states: ["size", "variant", "required", "focused"]
            }),
            st = _extends$4({}, $, {
                disableAnimation: j,
                formControl: nt,
                shrink: rt,
                size: ot.size,
                variant: ot.variant,
                required: ot.required,
                focused: ot.focused
            }),
            lt = useUtilityClasses$q(st);
        return jsxRuntimeExports.jsx(InputLabelRoot, _extends$4({
            "data-shrink": rt,
            ownerState: st,
            ref: a,
            className: clsx(lt.root, et)
        }, tt, {
            classes: lt
        }))
    }),
    ListContext = reactExports.createContext({});

function getListUtilityClass(s) {
    return generateUtilityClass("MuiList", s)
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$v = ["children", "className", "component", "dense", "disablePadding", "subheader"],
    useUtilityClasses$p = s => {
        const {
            classes: o,
            disablePadding: a,
            dense: $,
            subheader: j
        } = s;
        return composeClasses({
            root: ["root", !a && "padding", $ && "dense", j && "subheader"]
        }, getListUtilityClass, o)
    },
    ListRoot = styled("ul", {
        name: "MuiList",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, !a.disablePadding && o.padding, a.dense && o.dense, a.subheader && o.subheader]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        listStyle: "none",
        margin: 0,
        padding: 0,
        position: "relative"
    }, !s.disablePadding && {
        paddingTop: 8,
        paddingBottom: 8
    }, s.subheader && {
        paddingTop: 0
    })),
    List = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiList"
            }),
            {
                children: j,
                className: _e,
                component: et = "ul",
                dense: tt = !1,
                disablePadding: nt = !1,
                subheader: rt
            } = $,
            ot = _objectWithoutPropertiesLoose$1($, _excluded$v),
            st = reactExports.useMemo(() => ({
                dense: tt
            }), [tt]),
            lt = _extends$4({}, $, {
                component: et,
                dense: tt,
                disablePadding: nt
            }),
            ft = useUtilityClasses$p(lt);
        return jsxRuntimeExports.jsx(ListContext.Provider, {
            value: st,
            children: jsxRuntimeExports.jsxs(ListRoot, _extends$4({
                as: et,
                className: clsx(ft.root, _e),
                ref: a,
                ownerState: lt
            }, ot, {
                children: [rt, j]
            }))
        })
    });

function getListItemUtilityClass(s) {
    return generateUtilityClass("MuiListItem", s)
}
const listItemClasses = generateUtilityClasses("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]),
    listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);

function getListItemSecondaryActionClassesUtilityClass(s) {
    return generateUtilityClass("MuiListItemSecondaryAction", s)
}
generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const _excluded$u = ["className"],
    useUtilityClasses$o = s => {
        const {
            disableGutters: o,
            classes: a
        } = s;
        return composeClasses({
            root: ["root", o && "disableGutters"]
        }, getListItemSecondaryActionClassesUtilityClass, a)
    },
    ListItemSecondaryActionRoot = styled("div", {
        name: "MuiListItemSecondaryAction",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.disableGutters && o.disableGutters]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        position: "absolute",
        right: 16,
        top: "50%",
        transform: "translateY(-50%)"
    }, s.disableGutters && {
        right: 0
    })),
    ListItemSecondaryAction = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiListItemSecondaryAction"
            }),
            {
                className: j
            } = $,
            _e = _objectWithoutPropertiesLoose$1($, _excluded$u),
            et = reactExports.useContext(ListContext),
            tt = _extends$4({}, $, {
                disableGutters: et.disableGutters
            }),
            nt = useUtilityClasses$o(tt);
        return jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, _extends$4({
            className: clsx(nt.root, j),
            ownerState: tt,
            ref: a
        }, _e))
    });
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const _excluded$t = ["className"],
    _excluded2$4 = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"],
    overridesResolver$1 = (s, o) => {
        const {
            ownerState: a
        } = s;
        return [o.root, a.dense && o.dense, a.alignItems === "flex-start" && o.alignItemsFlexStart, a.divider && o.divider, !a.disableGutters && o.gutters, !a.disablePadding && o.padding, a.button && o.button, a.hasSecondaryAction && o.secondaryAction]
    },
    useUtilityClasses$n = s => {
        const {
            alignItems: o,
            button: a,
            classes: $,
            dense: j,
            disabled: _e,
            disableGutters: et,
            disablePadding: tt,
            divider: nt,
            hasSecondaryAction: rt,
            selected: ot
        } = s;
        return composeClasses({
            root: ["root", j && "dense", !et && "gutters", !tt && "padding", nt && "divider", _e && "disabled", a && "button", o === "flex-start" && "alignItemsFlexStart", rt && "secondaryAction", ot && "selected"],
            container: ["container"]
        }, getListItemUtilityClass, $)
    },
    ListItemRoot = styled("div", {
        name: "MuiListItem",
        slot: "Root",
        overridesResolver: overridesResolver$1
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        display: "flex",
        justifyContent: "flex-start",
        alignItems: "center",
        position: "relative",
        textDecoration: "none",
        width: "100%",
        boxSizing: "border-box",
        textAlign: "left"
    }, !o.disablePadding && _extends$4({
        paddingTop: 8,
        paddingBottom: 8
    }, o.dense && {
        paddingTop: 4,
        paddingBottom: 4
    }, !o.disableGutters && {
        paddingLeft: 16,
        paddingRight: 16
    }, !!o.secondaryAction && {
        paddingRight: 48
    }), !!o.secondaryAction && {
        [`& > .${listItemButtonClasses.root}`]: {
            paddingRight: 48
        }
    }, {
        [`&.${listItemClasses.focusVisible}`]: {
            backgroundColor: (s.vars || s).palette.action.focus
        },
        [`&.${listItemClasses.selected}`]: {
            backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / ${s.vars.palette.action.selectedOpacity})` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity),
            [`&.${listItemClasses.focusVisible}`]: {
                backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / calc(${s.vars.palette.action.selectedOpacity} + ${s.vars.palette.action.focusOpacity}))` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity + s.palette.action.focusOpacity)
            }
        },
        [`&.${listItemClasses.disabled}`]: {
            opacity: (s.vars || s).palette.action.disabledOpacity
        }
    }, o.alignItems === "flex-start" && {
        alignItems: "flex-start"
    }, o.divider && {
        borderBottom: `1px solid ${(s.vars||s).palette.divider}`,
        backgroundClip: "padding-box"
    }, o.button && {
        transition: s.transitions.create("background-color", {
            duration: s.transitions.duration.shortest
        }),
        "&:hover": {
            textDecoration: "none",
            backgroundColor: (s.vars || s).palette.action.hover,
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        },
        [`&.${listItemClasses.selected}:hover`]: {
            backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / calc(${s.vars.palette.action.selectedOpacity} + ${s.vars.palette.action.hoverOpacity}))` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity + s.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / ${s.vars.palette.action.selectedOpacity})` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity)
            }
        }
    }, o.hasSecondaryAction && {
        paddingRight: 48
    })),
    ListItemContainer = styled("li", {
        name: "MuiListItem",
        slot: "Container",
        overridesResolver: (s, o) => o.container
    })({
        position: "relative"
    }),
    ListItem = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiListItem"
            }),
            {
                alignItems: j = "center",
                autoFocus: _e = !1,
                button: et = !1,
                children: tt,
                className: nt,
                component: rt,
                components: ot = {},
                componentsProps: st = {},
                ContainerComponent: lt = "li",
                ContainerProps: {
                    className: ft
                } = {},
                dense: yt = !1,
                disabled: bt = !1,
                disableGutters: ht = !1,
                disablePadding: vt = !1,
                divider: wt = !1,
                focusVisibleClassName: gt,
                secondaryAction: At,
                selected: Pt = !1,
                slotProps: Bt = {},
                slots: Lt = {}
            } = $,
            Nt = _objectWithoutPropertiesLoose$1($.ContainerProps, _excluded$t),
            Ut = _objectWithoutPropertiesLoose$1($, _excluded2$4),
            Vt = reactExports.useContext(ListContext),
            Ft = reactExports.useMemo(() => ({
                dense: yt || Vt.dense || !1,
                alignItems: j,
                disableGutters: ht
            }), [j, Vt.dense, yt, ht]),
            Wt = reactExports.useRef(null);
        useEnhancedEffect(() => {
            _e && Wt.current && Wt.current.focus()
        }, [_e]);
        const Ct = reactExports.Children.toArray(tt),
            it = Ct.length && isMuiElement(Ct[Ct.length - 1], ["ListItemSecondaryAction"]),
            at = _extends$4({}, $, {
                alignItems: j,
                autoFocus: _e,
                button: et,
                dense: Ft.dense,
                disabled: bt,
                disableGutters: ht,
                disablePadding: vt,
                divider: wt,
                hasSecondaryAction: it,
                selected: Pt
            }),
            mt = useUtilityClasses$n(at),
            xt = useForkRef(Wt, a),
            $t = Lt.root || ot.Root || ListItemRoot,
            Rt = Bt.root || st.root || {},
            It = _extends$4({
                className: clsx(mt.root, Rt.className, nt),
                disabled: bt
            }, Ut);
        let Tt = rt || "li";
        return et && (It.component = rt || "div", It.focusVisibleClassName = clsx(listItemClasses.focusVisible, gt), Tt = ButtonBase), it ? (Tt = !It.component && !rt ? "div" : Tt, lt === "li" && (Tt === "li" ? Tt = "div" : It.component === "li" && (It.component = "div")), jsxRuntimeExports.jsx(ListContext.Provider, {
            value: Ft,
            children: jsxRuntimeExports.jsxs(ListItemContainer, _extends$4({
                as: lt,
                className: clsx(mt.container, ft),
                ref: xt,
                ownerState: at
            }, Nt, {
                children: [jsxRuntimeExports.jsx($t, _extends$4({}, Rt, !isHostComponent($t) && {
                    as: Tt,
                    ownerState: _extends$4({}, at, Rt.ownerState)
                }, It, {
                    children: Ct
                })), Ct.pop()]
            }))
        })) : jsxRuntimeExports.jsx(ListContext.Provider, {
            value: Ft,
            children: jsxRuntimeExports.jsxs($t, _extends$4({}, Rt, {
                as: Tt,
                ref: xt
            }, !isHostComponent($t) && {
                ownerState: _extends$4({}, at, Rt.ownerState)
            }, It, {
                children: [Ct, At && jsxRuntimeExports.jsx(ListItemSecondaryAction, {
                    children: At
                })]
            }))
        })
    }),
    listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]),
    listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]),
    _excluded$s = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];

function nextItem$1(s, o, a) {
    return s === o ? s.firstChild : o && o.nextElementSibling ? o.nextElementSibling : a ? null : s.firstChild
}

function previousItem$1(s, o, a) {
    return s === o ? a ? s.firstChild : s.lastChild : o && o.previousElementSibling ? o.previousElementSibling : a ? null : s.lastChild
}

function textCriteriaMatches(s, o) {
    if (o === void 0) return !0;
    let a = s.innerText;
    return a === void 0 && (a = s.textContent), a = a.trim().toLowerCase(), a.length === 0 ? !1 : o.repeating ? a[0] === o.keys[0] : a.indexOf(o.keys.join("")) === 0
}

function moveFocus$1(s, o, a, $, j, _e) {
    let et = !1,
        tt = j(s, o, o ? a : !1);
    for (; tt;) {
        if (tt === s.firstChild) {
            if (et) return !1;
            et = !0
        }
        const nt = $ ? !1 : tt.disabled || tt.getAttribute("aria-disabled") === "true";
        if (!tt.hasAttribute("tabindex") || !textCriteriaMatches(tt, _e) || nt) tt = j(s, tt, a);
        else return tt.focus(), !0
    }
    return !1
}
const MenuList = reactExports.forwardRef(function(o, a) {
    const {
        actions: $,
        autoFocus: j = !1,
        autoFocusItem: _e = !1,
        children: et,
        className: tt,
        disabledItemsFocusable: nt = !1,
        disableListWrap: rt = !1,
        onKeyDown: ot,
        variant: st = "selectedMenu"
    } = o, lt = _objectWithoutPropertiesLoose$1(o, _excluded$s), ft = reactExports.useRef(null), yt = reactExports.useRef({
        keys: [],
        repeating: !0,
        previousKeyMatched: !0,
        lastTime: null
    });
    useEnhancedEffect(() => {
        j && ft.current.focus()
    }, [j]), reactExports.useImperativeHandle($, () => ({
        adjustStyleForScrollbar: (gt, {
            direction: At
        }) => {
            const Pt = !ft.current.style.width;
            if (gt.clientHeight < ft.current.clientHeight && Pt) {
                const Bt = `${getScrollbarSize(ownerDocument(gt))}px`;
                ft.current.style[At === "rtl" ? "paddingLeft" : "paddingRight"] = Bt, ft.current.style.width = `calc(100% + ${Bt})`
            }
            return ft.current
        }
    }), []);
    const bt = gt => {
            const At = ft.current,
                Pt = gt.key,
                Bt = ownerDocument(At).activeElement;
            if (Pt === "ArrowDown") gt.preventDefault(), moveFocus$1(At, Bt, rt, nt, nextItem$1);
            else if (Pt === "ArrowUp") gt.preventDefault(), moveFocus$1(At, Bt, rt, nt, previousItem$1);
            else if (Pt === "Home") gt.preventDefault(), moveFocus$1(At, null, rt, nt, nextItem$1);
            else if (Pt === "End") gt.preventDefault(), moveFocus$1(At, null, rt, nt, previousItem$1);
            else if (Pt.length === 1) {
                const Lt = yt.current,
                    Nt = Pt.toLowerCase(),
                    Ut = performance.now();
                Lt.keys.length > 0 && (Ut - Lt.lastTime > 500 ? (Lt.keys = [], Lt.repeating = !0, Lt.previousKeyMatched = !0) : Lt.repeating && Nt !== Lt.keys[0] && (Lt.repeating = !1)), Lt.lastTime = Ut, Lt.keys.push(Nt);
                const Vt = Bt && !Lt.repeating && textCriteriaMatches(Bt, Lt);
                Lt.previousKeyMatched && (Vt || moveFocus$1(At, Bt, !1, nt, nextItem$1, Lt)) ? gt.preventDefault() : Lt.previousKeyMatched = !1
            }
            ot && ot(gt)
        },
        ht = useForkRef(ft, a);
    let vt = -1;
    reactExports.Children.forEach(et, (gt, At) => {
        if (!reactExports.isValidElement(gt)) {
            vt === At && (vt += 1, vt >= et.length && (vt = -1));
            return
        }
        gt.props.disabled || (st === "selectedMenu" && gt.props.selected || vt === -1) && (vt = At), vt === At && (gt.props.disabled || gt.props.muiSkipListHighlight || gt.type.muiSkipListHighlight) && (vt += 1, vt >= et.length && (vt = -1))
    });
    const wt = reactExports.Children.map(et, (gt, At) => {
        if (At === vt) {
            const Pt = {};
            return _e && (Pt.autoFocus = !0), gt.props.tabIndex === void 0 && st === "selectedMenu" && (Pt.tabIndex = 0), reactExports.cloneElement(gt, Pt)
        }
        return gt
    });
    return jsxRuntimeExports.jsx(List, _extends$4({
        role: "menu",
        ref: ht,
        className: tt,
        onKeyDown: bt,
        tabIndex: j ? 0 : -1
    }, lt, {
        children: wt
    }))
});

function getPopoverUtilityClass(s) {
    return generateUtilityClass("MuiPopover", s)
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$r = ["onEntering"],
    _excluded2$3 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"],
    _excluded3 = ["slotProps"];

function getOffsetTop(s, o) {
    let a = 0;
    return typeof o == "number" ? a = o : o === "center" ? a = s.height / 2 : o === "bottom" && (a = s.height), a
}

function getOffsetLeft(s, o) {
    let a = 0;
    return typeof o == "number" ? a = o : o === "center" ? a = s.width / 2 : o === "right" && (a = s.width), a
}

function getTransformOriginValue(s) {
    return [s.horizontal, s.vertical].map(o => typeof o == "number" ? `${o}px` : o).join(" ")
}

function resolveAnchorEl(s) {
    return typeof s == "function" ? s() : s
}
const useUtilityClasses$m = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"],
            paper: ["paper"]
        }, getPopoverUtilityClass, o)
    },
    PopoverRoot = styled(Modal, {
        name: "MuiPopover",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({}),
    PopoverPaper = styled(Paper, {
        name: "MuiPopover",
        slot: "Paper",
        overridesResolver: (s, o) => o.paper
    })({
        position: "absolute",
        overflowY: "auto",
        overflowX: "hidden",
        minWidth: 16,
        minHeight: 16,
        maxWidth: "calc(100% - 32px)",
        maxHeight: "calc(100% - 32px)",
        outline: 0
    }),
    Popover = reactExports.forwardRef(function(o, a) {
        var $, j, _e;
        const et = useDefaultProps({
                props: o,
                name: "MuiPopover"
            }),
            {
                action: tt,
                anchorEl: nt,
                anchorOrigin: rt = {
                    vertical: "top",
                    horizontal: "left"
                },
                anchorPosition: ot,
                anchorReference: st = "anchorEl",
                children: lt,
                className: ft,
                container: yt,
                elevation: bt = 8,
                marginThreshold: ht = 16,
                open: vt,
                PaperProps: wt = {},
                slots: gt,
                slotProps: At,
                transformOrigin: Pt = {
                    vertical: "top",
                    horizontal: "left"
                },
                TransitionComponent: Bt = Grow,
                transitionDuration: Lt = "auto",
                TransitionProps: {
                    onEntering: Nt
                } = {},
                disableScrollLock: Ut = !1
            } = et,
            Vt = _objectWithoutPropertiesLoose$1(et.TransitionProps, _excluded$r),
            Ft = _objectWithoutPropertiesLoose$1(et, _excluded2$3),
            Wt = ($ = At == null ? void 0 : At.paper) != null ? $ : wt,
            Ct = reactExports.useRef(),
            it = useForkRef(Ct, Wt.ref),
            at = _extends$4({}, et, {
                anchorOrigin: rt,
                anchorReference: st,
                elevation: bt,
                marginThreshold: ht,
                externalPaperSlotProps: Wt,
                transformOrigin: Pt,
                TransitionComponent: Bt,
                transitionDuration: Lt,
                TransitionProps: Vt
            }),
            mt = useUtilityClasses$m(at),
            xt = reactExports.useCallback(() => {
                if (st === "anchorPosition") return ot;
                const ln = resolveAnchorEl(nt),
                    un = (ln && ln.nodeType === 1 ? ln : ownerDocument(Ct.current).body).getBoundingClientRect();
                return {
                    top: un.top + getOffsetTop(un, rt.vertical),
                    left: un.left + getOffsetLeft(un, rt.horizontal)
                }
            }, [nt, rt.horizontal, rt.vertical, ot, st]),
            $t = reactExports.useCallback(ln => ({
                vertical: getOffsetTop(ln, Pt.vertical),
                horizontal: getOffsetLeft(ln, Pt.horizontal)
            }), [Pt.horizontal, Pt.vertical]),
            Rt = reactExports.useCallback(ln => {
                const cn = {
                        width: ln.offsetWidth,
                        height: ln.offsetHeight
                    },
                    un = $t(cn);
                if (st === "none") return {
                    top: null,
                    left: null,
                    transformOrigin: getTransformOriginValue(un)
                };
                const Nn = xt();
                let hn = Nn.top - un.vertical,
                    fn = Nn.left - un.horizontal;
                const rn = hn + cn.height,
                    mn = fn + cn.width,
                    dn = ownerWindow(resolveAnchorEl(nt)),
                    vn = dn.innerHeight - ht,
                    gn = dn.innerWidth - ht;
                if (ht !== null && hn < ht) {
                    const Gt = hn - ht;
                    hn -= Gt, un.vertical += Gt
                } else if (ht !== null && rn > vn) {
                    const Gt = rn - vn;
                    hn -= Gt, un.vertical += Gt
                }
                if (ht !== null && fn < ht) {
                    const Gt = fn - ht;
                    fn -= Gt, un.horizontal += Gt
                } else if (mn > gn) {
                    const Gt = mn - gn;
                    fn -= Gt, un.horizontal += Gt
                }
                return {
                    top: `${Math.round(hn)}px`,
                    left: `${Math.round(fn)}px`,
                    transformOrigin: getTransformOriginValue(un)
                }
            }, [nt, st, xt, $t, ht]),
            [It, Tt] = reactExports.useState(vt),
            dt = reactExports.useCallback(() => {
                const ln = Ct.current;
                if (!ln) return;
                const cn = Rt(ln);
                cn.top !== null && (ln.style.top = cn.top), cn.left !== null && (ln.style.left = cn.left), ln.style.transformOrigin = cn.transformOrigin, Tt(!0)
            }, [Rt]);
        reactExports.useEffect(() => (Ut && window.addEventListener("scroll", dt), () => window.removeEventListener("scroll", dt)), [nt, Ut, dt]);
        const Et = (ln, cn) => {
                Nt && Nt(ln, cn), dt()
            },
            Ot = () => {
                Tt(!1)
            };
        reactExports.useEffect(() => {
            vt && dt()
        }), reactExports.useImperativeHandle(tt, () => vt ? {
            updatePosition: () => {
                dt()
            }
        } : null, [vt, dt]), reactExports.useEffect(() => {
            if (!vt) return;
            const ln = debounce$1(() => {
                    dt()
                }),
                cn = ownerWindow(nt);
            return cn.addEventListener("resize", ln), () => {
                ln.clear(), cn.removeEventListener("resize", ln)
            }
        }, [nt, vt, dt]);
        let Mt = Lt;
        Lt === "auto" && !Bt.muiSupportAuto && (Mt = void 0);
        const jt = yt || (nt ? ownerDocument(resolveAnchorEl(nt)).body : void 0),
            Qt = (j = gt == null ? void 0 : gt.root) != null ? j : PopoverRoot,
            Kt = (_e = gt == null ? void 0 : gt.paper) != null ? _e : PopoverPaper,
            qt = useSlotProps({
                elementType: Kt,
                externalSlotProps: _extends$4({}, Wt, {
                    style: It ? Wt.style : _extends$4({}, Wt.style, {
                        opacity: 0
                    })
                }),
                additionalProps: {
                    elevation: bt,
                    ref: it
                },
                ownerState: at,
                className: clsx(mt.paper, Wt == null ? void 0 : Wt.className)
            }),
            Jt = useSlotProps({
                elementType: Qt,
                externalSlotProps: (At == null ? void 0 : At.root) || {},
                externalForwardedProps: Ft,
                additionalProps: {
                    ref: a,
                    slotProps: {
                        backdrop: {
                            invisible: !0
                        }
                    },
                    container: jt,
                    open: vt
                },
                ownerState: at,
                className: clsx(mt.root, ft)
            }),
            {
                slotProps: Zt
            } = Jt,
            en = _objectWithoutPropertiesLoose$1(Jt, _excluded3);
        return jsxRuntimeExports.jsx(Qt, _extends$4({}, en, !isHostComponent(Qt) && {
            slotProps: Zt,
            disableScrollLock: Ut
        }, {
            children: jsxRuntimeExports.jsx(Bt, _extends$4({
                appear: !0,
                in: vt,
                onEntering: Et,
                onExited: Ot,
                timeout: Mt
            }, Vt, {
                children: jsxRuntimeExports.jsx(Kt, _extends$4({}, qt, {
                    children: lt
                }))
            }))
        }))
    });

function getMenuUtilityClass(s) {
    return generateUtilityClass("MuiMenu", s)
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$q = ["onEntering"],
    _excluded2$2 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"],
    RTL_ORIGIN = {
        vertical: "top",
        horizontal: "right"
    },
    LTR_ORIGIN = {
        vertical: "top",
        horizontal: "left"
    },
    useUtilityClasses$l = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"],
            paper: ["paper"],
            list: ["list"]
        }, getMenuUtilityClass, o)
    },
    MenuRoot = styled(Popover, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiMenu",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({}),
    MenuPaper = styled(PopoverPaper, {
        name: "MuiMenu",
        slot: "Paper",
        overridesResolver: (s, o) => o.paper
    })({
        maxHeight: "calc(100% - 96px)",
        WebkitOverflowScrolling: "touch"
    }),
    MenuMenuList = styled(MenuList, {
        name: "MuiMenu",
        slot: "List",
        overridesResolver: (s, o) => o.list
    })({
        outline: 0
    }),
    Menu = reactExports.forwardRef(function(o, a) {
        var $, j;
        const _e = useDefaultProps({
                props: o,
                name: "MuiMenu"
            }),
            {
                autoFocus: et = !0,
                children: tt,
                className: nt,
                disableAutoFocusItem: rt = !1,
                MenuListProps: ot = {},
                onClose: st,
                open: lt,
                PaperProps: ft = {},
                PopoverClasses: yt,
                transitionDuration: bt = "auto",
                TransitionProps: {
                    onEntering: ht
                } = {},
                variant: vt = "selectedMenu",
                slots: wt = {},
                slotProps: gt = {}
            } = _e,
            At = _objectWithoutPropertiesLoose$1(_e.TransitionProps, _excluded$q),
            Pt = _objectWithoutPropertiesLoose$1(_e, _excluded2$2),
            Bt = useRtl(),
            Lt = _extends$4({}, _e, {
                autoFocus: et,
                disableAutoFocusItem: rt,
                MenuListProps: ot,
                onEntering: ht,
                PaperProps: ft,
                transitionDuration: bt,
                TransitionProps: At,
                variant: vt
            }),
            Nt = useUtilityClasses$l(Lt),
            Ut = et && !rt && lt,
            Vt = reactExports.useRef(null),
            Ft = ($t, Rt) => {
                Vt.current && Vt.current.adjustStyleForScrollbar($t, {
                    direction: Bt ? "rtl" : "ltr"
                }), ht && ht($t, Rt)
            },
            Wt = $t => {
                $t.key === "Tab" && ($t.preventDefault(), st && st($t, "tabKeyDown"))
            };
        let Ct = -1;
        reactExports.Children.map(tt, ($t, Rt) => {
            reactExports.isValidElement($t) && ($t.props.disabled || (vt === "selectedMenu" && $t.props.selected || Ct === -1) && (Ct = Rt))
        });
        const it = ($ = wt.paper) != null ? $ : MenuPaper,
            at = (j = gt.paper) != null ? j : ft,
            mt = useSlotProps({
                elementType: wt.root,
                externalSlotProps: gt.root,
                ownerState: Lt,
                className: [Nt.root, nt]
            }),
            xt = useSlotProps({
                elementType: it,
                externalSlotProps: at,
                ownerState: Lt,
                className: Nt.paper
            });
        return jsxRuntimeExports.jsx(MenuRoot, _extends$4({
            onClose: st,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: Bt ? "right" : "left"
            },
            transformOrigin: Bt ? RTL_ORIGIN : LTR_ORIGIN,
            slots: {
                paper: it,
                root: wt.root
            },
            slotProps: {
                root: mt,
                paper: xt
            },
            open: lt,
            ref: a,
            transitionDuration: bt,
            TransitionProps: _extends$4({
                onEntering: Ft
            }, At),
            ownerState: Lt
        }, Pt, {
            classes: yt,
            children: jsxRuntimeExports.jsx(MenuMenuList, _extends$4({
                onKeyDown: Wt,
                actions: Vt,
                autoFocus: et && (Ct === -1 || rt),
                autoFocusItem: Ut,
                variant: vt
            }, ot, {
                className: clsx(Nt.list, ot.className),
                children: tt
            }))
        }))
    });

function getMenuItemUtilityClass(s) {
    return generateUtilityClass("MuiMenuItem", s)
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]),
    _excluded$p = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"],
    overridesResolver = (s, o) => {
        const {
            ownerState: a
        } = s;
        return [o.root, a.dense && o.dense, a.divider && o.divider, !a.disableGutters && o.gutters]
    },
    useUtilityClasses$k = s => {
        const {
            disabled: o,
            dense: a,
            divider: $,
            disableGutters: j,
            selected: _e,
            classes: et
        } = s, nt = composeClasses({
            root: ["root", a && "dense", o && "disabled", !j && "gutters", $ && "divider", _e && "selected"]
        }, getMenuItemUtilityClass, et);
        return _extends$4({}, et, nt)
    },
    MenuItemRoot = styled(ButtonBase, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiMenuItem",
        slot: "Root",
        overridesResolver
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({}, s.typography.body1, {
        display: "flex",
        justifyContent: "flex-start",
        alignItems: "center",
        position: "relative",
        textDecoration: "none",
        minHeight: 48,
        paddingTop: 6,
        paddingBottom: 6,
        boxSizing: "border-box",
        whiteSpace: "nowrap"
    }, !o.disableGutters && {
        paddingLeft: 16,
        paddingRight: 16
    }, o.divider && {
        borderBottom: `1px solid ${(s.vars||s).palette.divider}`,
        backgroundClip: "padding-box"
    }, {
        "&:hover": {
            textDecoration: "none",
            backgroundColor: (s.vars || s).palette.action.hover,
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        },
        [`&.${menuItemClasses.selected}`]: {
            backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / ${s.vars.palette.action.selectedOpacity})` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity),
            [`&.${menuItemClasses.focusVisible}`]: {
                backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / calc(${s.vars.palette.action.selectedOpacity} + ${s.vars.palette.action.focusOpacity}))` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity + s.palette.action.focusOpacity)
            }
        },
        [`&.${menuItemClasses.selected}:hover`]: {
            backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / calc(${s.vars.palette.action.selectedOpacity} + ${s.vars.palette.action.hoverOpacity}))` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity + s.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / ${s.vars.palette.action.selectedOpacity})` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity)
            }
        },
        [`&.${menuItemClasses.focusVisible}`]: {
            backgroundColor: (s.vars || s).palette.action.focus
        },
        [`&.${menuItemClasses.disabled}`]: {
            opacity: (s.vars || s).palette.action.disabledOpacity
        },
        [`& + .${dividerClasses.root}`]: {
            marginTop: s.spacing(1),
            marginBottom: s.spacing(1)
        },
        [`& + .${dividerClasses.inset}`]: {
            marginLeft: 52
        },
        [`& .${listItemTextClasses.root}`]: {
            marginTop: 0,
            marginBottom: 0
        },
        [`& .${listItemTextClasses.inset}`]: {
            paddingLeft: 36
        },
        [`& .${listItemIconClasses.root}`]: {
            minWidth: 36
        }
    }, !o.dense && {
        [s.breakpoints.up("sm")]: {
            minHeight: "auto"
        }
    }, o.dense && _extends$4({
        minHeight: 32,
        paddingTop: 4,
        paddingBottom: 4
    }, s.typography.body2, {
        [`& .${listItemIconClasses.root} svg`]: {
            fontSize: "1.25rem"
        }
    }))),
    MenuItem = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiMenuItem"
            }),
            {
                autoFocus: j = !1,
                component: _e = "li",
                dense: et = !1,
                divider: tt = !1,
                disableGutters: nt = !1,
                focusVisibleClassName: rt,
                role: ot = "menuitem",
                tabIndex: st,
                className: lt
            } = $,
            ft = _objectWithoutPropertiesLoose$1($, _excluded$p),
            yt = reactExports.useContext(ListContext),
            bt = reactExports.useMemo(() => ({
                dense: et || yt.dense || !1,
                disableGutters: nt
            }), [yt.dense, et, nt]),
            ht = reactExports.useRef(null);
        useEnhancedEffect(() => {
            j && ht.current && ht.current.focus()
        }, [j]);
        const vt = _extends$4({}, $, {
                dense: bt.dense,
                divider: tt,
                disableGutters: nt
            }),
            wt = useUtilityClasses$k($),
            gt = useForkRef(ht, a);
        let At;
        return $.disabled || (At = st !== void 0 ? st : -1), jsxRuntimeExports.jsx(ListContext.Provider, {
            value: bt,
            children: jsxRuntimeExports.jsx(MenuItemRoot, _extends$4({
                ref: gt,
                role: ot,
                tabIndex: At,
                component: _e,
                focusVisibleClassName: clsx(wt.focusVisible, rt),
                className: clsx(wt.root, lt)
            }, ft, {
                ownerState: vt,
                classes: wt
            }))
        })
    });

function getNativeSelectUtilityClasses(s) {
    return generateUtilityClass("MuiNativeSelect", s)
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]),
    _excluded$o = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"],
    useUtilityClasses$j = s => {
        const {
            classes: o,
            variant: a,
            disabled: $,
            multiple: j,
            open: _e,
            error: et
        } = s, tt = {
            select: ["select", a, $ && "disabled", j && "multiple", et && "error"],
            icon: ["icon", `icon${capitalize$1(a)}`, _e && "iconOpen", $ && "disabled"]
        };
        return composeClasses(tt, getNativeSelectUtilityClasses, o)
    },
    nativeSelectSelectStyles = ({
        ownerState: s,
        theme: o
    }) => _extends$4({
        MozAppearance: "none",
        WebkitAppearance: "none",
        userSelect: "none",
        borderRadius: 0,
        cursor: "pointer",
        "&:focus": _extends$4({}, o.vars ? {
            backgroundColor: `rgba(${o.vars.palette.common.onBackgroundChannel} / 0.05)`
        } : {
            backgroundColor: o.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
        }, {
            borderRadius: 0
        }),
        "&::-ms-expand": {
            display: "none"
        },
        [`&.${nativeSelectClasses.disabled}`]: {
            cursor: "default"
        },
        "&[multiple]": {
            height: "auto"
        },
        "&:not([multiple]) option, &:not([multiple]) optgroup": {
            backgroundColor: (o.vars || o).palette.background.paper
        },
        "&&&": {
            paddingRight: 24,
            minWidth: 16
        }
    }, s.variant === "filled" && {
        "&&&": {
            paddingRight: 32
        }
    }, s.variant === "outlined" && {
        borderRadius: (o.vars || o).shape.borderRadius,
        "&:focus": {
            borderRadius: (o.vars || o).shape.borderRadius
        },
        "&&&": {
            paddingRight: 32
        }
    }),
    NativeSelectSelect = styled("select", {
        name: "MuiNativeSelect",
        slot: "Select",
        shouldForwardProp: rootShouldForwardProp,
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.select, o[a.variant], a.error && o.error, {
                [`&.${nativeSelectClasses.multiple}`]: o.multiple
            }]
        }
    })(nativeSelectSelectStyles),
    nativeSelectIconStyles = ({
        ownerState: s,
        theme: o
    }) => _extends$4({
        position: "absolute",
        right: 0,
        top: "calc(50% - .5em)",
        pointerEvents: "none",
        color: (o.vars || o).palette.action.active,
        [`&.${nativeSelectClasses.disabled}`]: {
            color: (o.vars || o).palette.action.disabled
        }
    }, s.open && {
        transform: "rotate(180deg)"
    }, s.variant === "filled" && {
        right: 7
    }, s.variant === "outlined" && {
        right: 7
    }),
    NativeSelectIcon = styled("svg", {
        name: "MuiNativeSelect",
        slot: "Icon",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.icon, a.variant && o[`icon${capitalize$1(a.variant)}`], a.open && o.iconOpen]
        }
    })(nativeSelectIconStyles),
    NativeSelectInput = reactExports.forwardRef(function(o, a) {
        const {
            className: $,
            disabled: j,
            error: _e,
            IconComponent: et,
            inputRef: tt,
            variant: nt = "standard"
        } = o, rt = _objectWithoutPropertiesLoose$1(o, _excluded$o), ot = _extends$4({}, o, {
            disabled: j,
            variant: nt,
            error: _e
        }), st = useUtilityClasses$j(ot);
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [jsxRuntimeExports.jsx(NativeSelectSelect, _extends$4({
                ownerState: ot,
                className: clsx(st.select, $),
                disabled: j,
                ref: tt || a
            }, rt)), o.multiple ? null : jsxRuntimeExports.jsx(NativeSelectIcon, {
                as: et,
                ownerState: ot,
                className: st.icon
            })]
        })
    });

function NoSsr(s) {
    const {
        children: o,
        defer: a = !1,
        fallback: $ = null
    } = s, [j, _e] = reactExports.useState(!1);
    return useEnhancedEffect(() => {
        a || _e(!0)
    }, [a]), reactExports.useEffect(() => {
        a && _e(!0)
    }, [a]), jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: j ? o : $
    })
}
var _span$1;
const _excluded$n = ["children", "classes", "className", "label", "notched"],
    NotchedOutlineRoot$1 = styled("fieldset", {
        shouldForwardProp: rootShouldForwardProp
    })({
        textAlign: "left",
        position: "absolute",
        bottom: 0,
        right: 0,
        top: -5,
        left: 0,
        margin: 0,
        padding: "0 8px",
        pointerEvents: "none",
        borderRadius: "inherit",
        borderStyle: "solid",
        borderWidth: 1,
        overflow: "hidden",
        minWidth: "0%"
    }),
    NotchedOutlineLegend = styled("legend", {
        shouldForwardProp: rootShouldForwardProp
    })(({
        ownerState: s,
        theme: o
    }) => _extends$4({
        float: "unset",
        width: "auto",
        overflow: "hidden"
    }, !s.withLabel && {
        padding: 0,
        lineHeight: "11px",
        transition: o.transitions.create("width", {
            duration: 150,
            easing: o.transitions.easing.easeOut
        })
    }, s.withLabel && _extends$4({
        display: "block",
        padding: 0,
        height: 11,
        fontSize: "0.75em",
        visibility: "hidden",
        maxWidth: .01,
        transition: o.transitions.create("max-width", {
            duration: 50,
            easing: o.transitions.easing.easeOut
        }),
        whiteSpace: "nowrap",
        "& > span": {
            paddingLeft: 5,
            paddingRight: 5,
            display: "inline-block",
            opacity: 0,
            visibility: "visible"
        }
    }, s.notched && {
        maxWidth: "100%",
        transition: o.transitions.create("max-width", {
            duration: 100,
            easing: o.transitions.easing.easeOut,
            delay: 50
        })
    })));

function NotchedOutline(s) {
    const {
        className: o,
        label: a,
        notched: $
    } = s, j = _objectWithoutPropertiesLoose$1(s, _excluded$n), _e = a != null && a !== "", et = _extends$4({}, s, {
        notched: $,
        withLabel: _e
    });
    return jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$4({
        "aria-hidden": !0,
        className: o,
        ownerState: et
    }, j, {
        children: jsxRuntimeExports.jsx(NotchedOutlineLegend, {
            ownerState: et,
            children: _e ? jsxRuntimeExports.jsx("span", {
                children: a
            }) : _span$1 || (_span$1 = jsxRuntimeExports.jsx("span", {
                className: "notranslate",
                children: "​"
            }))
        })
    }))
}
const _excluded$m = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"],
    useUtilityClasses$i = s => {
        const {
            classes: o
        } = s, $ = composeClasses({
            root: ["root"],
            notchedOutline: ["notchedOutline"],
            input: ["input"]
        }, getOutlinedInputUtilityClass, o);
        return _extends$4({}, o, $)
    },
    OutlinedInputRoot = styled(InputBaseRoot, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiOutlinedInput",
        slot: "Root",
        overridesResolver: rootOverridesResolver
    })(({
        theme: s,
        ownerState: o
    }) => {
        const a = s.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
        return _extends$4({
            position: "relative",
            borderRadius: (s.vars || s).shape.borderRadius,
            [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                borderColor: (s.vars || s).palette.text.primary
            },
            "@media (hover: none)": {
                [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                    borderColor: s.vars ? `rgba(${s.vars.palette.common.onBackgroundChannel} / 0.23)` : a
                }
            },
            [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
                borderColor: (s.vars || s).palette[o.color].main,
                borderWidth: 2
            },
            [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
                borderColor: (s.vars || s).palette.error.main
            },
            [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
                borderColor: (s.vars || s).palette.action.disabled
            }
        }, o.startAdornment && {
            paddingLeft: 14
        }, o.endAdornment && {
            paddingRight: 14
        }, o.multiline && _extends$4({
            padding: "16.5px 14px"
        }, o.size === "small" && {
            padding: "8.5px 14px"
        }))
    }),
    NotchedOutlineRoot = styled(NotchedOutline, {
        name: "MuiOutlinedInput",
        slot: "NotchedOutline",
        overridesResolver: (s, o) => o.notchedOutline
    })(({
        theme: s
    }) => {
        const o = s.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
        return {
            borderColor: s.vars ? `rgba(${s.vars.palette.common.onBackgroundChannel} / 0.23)` : o
        }
    }),
    OutlinedInputInput = styled(InputBaseComponent, {
        name: "MuiOutlinedInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        padding: "16.5px 14px"
    }, !s.vars && {
        "&:-webkit-autofill": {
            WebkitBoxShadow: s.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: s.palette.mode === "light" ? null : "#fff",
            caretColor: s.palette.mode === "light" ? null : "#fff",
            borderRadius: "inherit"
        }
    }, s.vars && {
        "&:-webkit-autofill": {
            borderRadius: "inherit"
        },
        [s.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
                WebkitBoxShadow: "0 0 0 100px #266798 inset",
                WebkitTextFillColor: "#fff",
                caretColor: "#fff"
            }
        }
    }, o.size === "small" && {
        padding: "8.5px 14px"
    }, o.multiline && {
        padding: 0
    }, o.startAdornment && {
        paddingLeft: 0
    }, o.endAdornment && {
        paddingRight: 0
    })),
    OutlinedInput = reactExports.forwardRef(function(o, a) {
        var $, j, _e, et, tt;
        const nt = useDefaultProps({
                props: o,
                name: "MuiOutlinedInput"
            }),
            {
                components: rt = {},
                fullWidth: ot = !1,
                inputComponent: st = "input",
                label: lt,
                multiline: ft = !1,
                notched: yt,
                slots: bt = {},
                type: ht = "text"
            } = nt,
            vt = _objectWithoutPropertiesLoose$1(nt, _excluded$m),
            wt = useUtilityClasses$i(nt),
            gt = useFormControl(),
            At = formControlState({
                props: nt,
                muiFormControl: gt,
                states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
            }),
            Pt = _extends$4({}, nt, {
                color: At.color || "primary",
                disabled: At.disabled,
                error: At.error,
                focused: At.focused,
                formControl: gt,
                fullWidth: ot,
                hiddenLabel: At.hiddenLabel,
                multiline: ft,
                size: At.size,
                type: ht
            }),
            Bt = ($ = (j = bt.root) != null ? j : rt.Root) != null ? $ : OutlinedInputRoot,
            Lt = (_e = (et = bt.input) != null ? et : rt.Input) != null ? _e : OutlinedInputInput;
        return jsxRuntimeExports.jsx(InputBase$1, _extends$4({
            slots: {
                root: Bt,
                input: Lt
            },
            renderSuffix: Nt => jsxRuntimeExports.jsx(NotchedOutlineRoot, {
                ownerState: Pt,
                className: wt.notchedOutline,
                label: lt != null && lt !== "" && At.required ? tt || (tt = jsxRuntimeExports.jsxs(reactExports.Fragment, {
                    children: [lt, " ", "*"]
                })) : lt,
                notched: typeof yt < "u" ? yt : !!(Nt.startAdornment || Nt.filled || Nt.focused)
            }),
            fullWidth: ot,
            inputComponent: st,
            multiline: ft,
            ref: a,
            type: ht
        }, vt, {
            classes: _extends$4({}, wt, {
                notchedOutline: null
            })
        }))
    });
OutlinedInput.muiName = "Input";
const FirstPageIconDefault = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
    }), "FirstPage"),
    LastPageIconDefault = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
    }), "LastPage"),
    RadioButtonUncheckedIcon = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), "RadioButtonUnchecked"),
    RadioButtonCheckedIcon = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
    }), "RadioButtonChecked"),
    RadioButtonIconRoot = styled("span", {
        shouldForwardProp: rootShouldForwardProp
    })({
        position: "relative",
        display: "flex"
    }),
    RadioButtonIconBackground = styled(RadioButtonUncheckedIcon)({
        transform: "scale(1)"
    }),
    RadioButtonIconDot = styled(RadioButtonCheckedIcon)(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        left: 0,
        position: "absolute",
        transform: "scale(0)",
        transition: s.transitions.create("transform", {
            easing: s.transitions.easing.easeIn,
            duration: s.transitions.duration.shortest
        })
    }, o.checked && {
        transform: "scale(1)",
        transition: s.transitions.create("transform", {
            easing: s.transitions.easing.easeOut,
            duration: s.transitions.duration.shortest
        })
    }));

function RadioButtonIcon(s) {
    const {
        checked: o = !1,
        classes: a = {},
        fontSize: $
    } = s, j = _extends$4({}, s, {
        checked: o
    });
    return jsxRuntimeExports.jsxs(RadioButtonIconRoot, {
        className: a.root,
        ownerState: j,
        children: [jsxRuntimeExports.jsx(RadioButtonIconBackground, {
            fontSize: $,
            className: a.background,
            ownerState: j
        }), jsxRuntimeExports.jsx(RadioButtonIconDot, {
            fontSize: $,
            className: a.dot,
            ownerState: j
        })]
    })
}
const RadioGroupContext = reactExports.createContext(void 0);

function useRadioGroup() {
    return reactExports.useContext(RadioGroupContext)
}

function getRadioUtilityClass(s) {
    return generateUtilityClass("MuiRadio", s)
}
const radioClasses = generateUtilityClasses("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]),
    _excluded$l = ["checked", "checkedIcon", "color", "icon", "name", "onChange", "size", "className"],
    useUtilityClasses$h = s => {
        const {
            classes: o,
            color: a,
            size: $
        } = s, j = {
            root: ["root", `color${capitalize$1(a)}`, $ !== "medium" && `size${capitalize$1($)}`]
        };
        return _extends$4({}, o, composeClasses(j, getRadioUtilityClass, o))
    },
    RadioRoot = styled(SwitchBase, {
        shouldForwardProp: s => rootShouldForwardProp(s) || s === "classes",
        name: "MuiRadio",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.size !== "medium" && o[`size${capitalize$1(a.size)}`], o[`color${capitalize$1(a.color)}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        color: (s.vars || s).palette.text.secondary
    }, !o.disableRipple && {
        "&:hover": {
            backgroundColor: s.vars ? `rgba(${o.color==="default"?s.vars.palette.action.activeChannel:s.vars.palette[o.color].mainChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(o.color === "default" ? s.palette.action.active : s.palette[o.color].main, s.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        }
    }, o.color !== "default" && {
        [`&.${radioClasses.checked}`]: {
            color: (s.vars || s).palette[o.color].main
        }
    }, {
        [`&.${radioClasses.disabled}`]: {
            color: (s.vars || s).palette.action.disabled
        }
    }));

function areEqualValues$1(s, o) {
    return typeof o == "object" && o !== null ? s === o : String(s) === String(o)
}
const defaultCheckedIcon = jsxRuntimeExports.jsx(RadioButtonIcon, {
        checked: !0
    }),
    defaultIcon = jsxRuntimeExports.jsx(RadioButtonIcon, {}),
    Radio = reactExports.forwardRef(function(o, a) {
        var $, j;
        const _e = useDefaultProps({
                props: o,
                name: "MuiRadio"
            }),
            {
                checked: et,
                checkedIcon: tt = defaultCheckedIcon,
                color: nt = "primary",
                icon: rt = defaultIcon,
                name: ot,
                onChange: st,
                size: lt = "medium",
                className: ft
            } = _e,
            yt = _objectWithoutPropertiesLoose$1(_e, _excluded$l),
            bt = _extends$4({}, _e, {
                color: nt,
                size: lt
            }),
            ht = useUtilityClasses$h(bt),
            vt = useRadioGroup();
        let wt = et;
        const gt = createChainedFunction(st, vt && vt.onChange);
        let At = ot;
        return vt && (typeof wt > "u" && (wt = areEqualValues$1(vt.value, _e.value)), typeof At > "u" && (At = vt.name)), jsxRuntimeExports.jsx(RadioRoot, _extends$4({
            type: "radio",
            icon: reactExports.cloneElement(rt, {
                fontSize: ($ = defaultIcon.props.fontSize) != null ? $ : lt
            }),
            checkedIcon: reactExports.cloneElement(tt, {
                fontSize: (j = defaultCheckedIcon.props.fontSize) != null ? j : lt
            }),
            ownerState: bt,
            classes: ht,
            name: At,
            checked: wt,
            onChange: gt,
            ref: a,
            className: clsx(ht.root, ft)
        }, yt))
    });

function getRadioGroupUtilityClass(s) {
    return generateUtilityClass("MuiRadioGroup", s)
}
generateUtilityClasses("MuiRadioGroup", ["root", "row", "error"]);
const _excluded$k = ["actions", "children", "className", "defaultValue", "name", "onChange", "value"],
    useUtilityClasses$g = s => {
        const {
            classes: o,
            row: a,
            error: $
        } = s;
        return composeClasses({
            root: ["root", a && "row", $ && "error"]
        }, getRadioGroupUtilityClass, o)
    },
    RadioGroup = reactExports.forwardRef(function(o, a) {
        const {
            actions: $,
            children: j,
            className: _e,
            defaultValue: et,
            name: tt,
            onChange: nt,
            value: rt
        } = o, ot = _objectWithoutPropertiesLoose$1(o, _excluded$k), st = reactExports.useRef(null), lt = useUtilityClasses$g(o), [ft, yt] = useControlled({
            controlled: rt,
            default: et,
            name: "RadioGroup"
        });
        reactExports.useImperativeHandle($, () => ({
            focus: () => {
                let wt = st.current.querySelector("input:not(:disabled):checked");
                wt || (wt = st.current.querySelector("input:not(:disabled)")), wt && wt.focus()
            }
        }), []);
        const bt = useForkRef(a, st),
            ht = useId(tt),
            vt = reactExports.useMemo(() => ({
                name: ht,
                onChange(wt) {
                    yt(wt.target.value), nt && nt(wt, wt.target.value)
                },
                value: ft
            }), [ht, nt, yt, ft]);
        return jsxRuntimeExports.jsx(RadioGroupContext.Provider, {
            value: vt,
            children: jsxRuntimeExports.jsx(FormGroup, _extends$4({
                role: "radiogroup",
                ref: bt,
                className: clsx(lt.root, _e)
            }, ot, {
                children: j
            }))
        })
    });

function getSelectUtilityClasses(s) {
    return generateUtilityClass("MuiSelect", s)
}
const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var _span;
const _excluded$j = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"],
    SelectSelect = styled("div", {
        name: "MuiSelect",
        slot: "Select",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [{
                [`&.${selectClasses.select}`]: o.select
            }, {
                [`&.${selectClasses.select}`]: o[a.variant]
            }, {
                [`&.${selectClasses.error}`]: o.error
            }, {
                [`&.${selectClasses.multiple}`]: o.multiple
            }]
        }
    })(nativeSelectSelectStyles, {
        [`&.${selectClasses.select}`]: {
            height: "auto",
            minHeight: "1.4375em",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            overflow: "hidden"
        }
    }),
    SelectIcon = styled("svg", {
        name: "MuiSelect",
        slot: "Icon",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.icon, a.variant && o[`icon${capitalize$1(a.variant)}`], a.open && o.iconOpen]
        }
    })(nativeSelectIconStyles),
    SelectNativeInput = styled("input", {
        shouldForwardProp: s => slotShouldForwardProp(s) && s !== "classes",
        name: "MuiSelect",
        slot: "NativeInput",
        overridesResolver: (s, o) => o.nativeInput
    })({
        bottom: 0,
        left: 0,
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        width: "100%",
        boxSizing: "border-box"
    });

function areEqualValues(s, o) {
    return typeof o == "object" && o !== null ? s === o : String(s) === String(o)
}

function isEmpty(s) {
    return s == null || typeof s == "string" && !s.trim()
}
const useUtilityClasses$f = s => {
        const {
            classes: o,
            variant: a,
            disabled: $,
            multiple: j,
            open: _e,
            error: et
        } = s, tt = {
            select: ["select", a, $ && "disabled", j && "multiple", et && "error"],
            icon: ["icon", `icon${capitalize$1(a)}`, _e && "iconOpen", $ && "disabled"],
            nativeInput: ["nativeInput"]
        };
        return composeClasses(tt, getSelectUtilityClasses, o)
    },
    SelectInput = reactExports.forwardRef(function(o, a) {
        var $;
        const {
            "aria-describedby": j,
            "aria-label": _e,
            autoFocus: et,
            autoWidth: tt,
            children: nt,
            className: rt,
            defaultOpen: ot,
            defaultValue: st,
            disabled: lt,
            displayEmpty: ft,
            error: yt = !1,
            IconComponent: bt,
            inputRef: ht,
            labelId: vt,
            MenuProps: wt = {},
            multiple: gt,
            name: At,
            onBlur: Pt,
            onChange: Bt,
            onClose: Lt,
            onFocus: Nt,
            onOpen: Ut,
            open: Vt,
            readOnly: Ft,
            renderValue: Wt,
            SelectDisplayProps: Ct = {},
            tabIndex: it,
            value: at,
            variant: mt = "standard"
        } = o, xt = _objectWithoutPropertiesLoose$1(o, _excluded$j), [$t, Rt] = useControlled({
            controlled: at,
            default: st,
            name: "Select"
        }), [It, Tt] = useControlled({
            controlled: Vt,
            default: ot,
            name: "Select"
        }), dt = reactExports.useRef(null), Et = reactExports.useRef(null), [Ot, Mt] = reactExports.useState(null), {
            current: jt
        } = reactExports.useRef(Vt != null), [Qt, Kt] = reactExports.useState(), qt = useForkRef(a, ht), Jt = reactExports.useCallback(Ht => {
            Et.current = Ht, Ht && Mt(Ht)
        }, []), Zt = Ot == null ? void 0 : Ot.parentNode;
        reactExports.useImperativeHandle(qt, () => ({
            focus: () => {
                Et.current.focus()
            },
            node: dt.current,
            value: $t
        }), [$t]), reactExports.useEffect(() => {
            ot && It && Ot && !jt && (Kt(tt ? null : Zt.clientWidth), Et.current.focus())
        }, [Ot, tt]), reactExports.useEffect(() => {
            et && Et.current.focus()
        }, [et]), reactExports.useEffect(() => {
            if (!vt) return;
            const Ht = ownerDocument(Et.current).getElementById(vt);
            if (Ht) {
                const an = () => {
                    getSelection().isCollapsed && Et.current.focus()
                };
                return Ht.addEventListener("click", an), () => {
                    Ht.removeEventListener("click", an)
                }
            }
        }, [vt]);
        const en = (Ht, an) => {
                Ht ? Ut && Ut(an) : Lt && Lt(an), jt || (Kt(tt ? null : Zt.clientWidth), Tt(Ht))
            },
            ln = Ht => {
                Ht.button === 0 && (Ht.preventDefault(), Et.current.focus(), en(!0, Ht))
            },
            cn = Ht => {
                en(!1, Ht)
            },
            un = reactExports.Children.toArray(nt),
            Nn = Ht => {
                const an = un.find(Xt => Xt.props.value === Ht.target.value);
                an !== void 0 && (Rt(an.props.value), Bt && Bt(Ht, an))
            },
            hn = Ht => an => {
                let Xt;
                if (an.currentTarget.hasAttribute("tabindex")) {
                    if (gt) {
                        Xt = Array.isArray($t) ? $t.slice() : [];
                        const tn = $t.indexOf(Ht.props.value);
                        tn === -1 ? Xt.push(Ht.props.value) : Xt.splice(tn, 1)
                    } else Xt = Ht.props.value;
                    if (Ht.props.onClick && Ht.props.onClick(an), $t !== Xt && (Rt(Xt), Bt)) {
                        const tn = an.nativeEvent || an,
                            pn = new tn.constructor(tn.type, tn);
                        Object.defineProperty(pn, "target", {
                            writable: !0,
                            value: {
                                value: Xt,
                                name: At
                            }
                        }), Bt(pn, Ht)
                    }
                    gt || en(!1, an)
                }
            },
            fn = Ht => {
                Ft || [" ", "ArrowUp", "ArrowDown", "Enter"].indexOf(Ht.key) !== -1 && (Ht.preventDefault(), en(!0, Ht))
            },
            rn = Ot !== null && It,
            mn = Ht => {
                !rn && Pt && (Object.defineProperty(Ht, "target", {
                    writable: !0,
                    value: {
                        value: $t,
                        name: At
                    }
                }), Pt(Ht))
            };
        delete xt["aria-invalid"];
        let dn, vn;
        const gn = [];
        let Gt = !1;
        (isFilled({
            value: $t
        }) || ft) && (Wt ? dn = Wt($t) : Gt = !0);
        const Yt = un.map(Ht => {
            if (!reactExports.isValidElement(Ht)) return null;
            let an;
            if (gt) {
                if (!Array.isArray($t)) throw new Error(formatMuiErrorMessage$1(2));
                an = $t.some(Xt => areEqualValues(Xt, Ht.props.value)), an && Gt && gn.push(Ht.props.children)
            } else an = areEqualValues($t, Ht.props.value), an && Gt && (vn = Ht.props.children);
            return reactExports.cloneElement(Ht, {
                "aria-selected": an ? "true" : "false",
                onClick: hn(Ht),
                onKeyUp: Xt => {
                    Xt.key === " " && Xt.preventDefault(), Ht.props.onKeyUp && Ht.props.onKeyUp(Xt)
                },
                role: "option",
                selected: an,
                value: void 0,
                "data-value": Ht.props.value
            })
        });
        Gt && (gt ? gn.length === 0 ? dn = null : dn = gn.reduce((Ht, an, Xt) => (Ht.push(an), Xt < gn.length - 1 && Ht.push(", "), Ht), []) : dn = vn);
        let nn = Qt;
        !tt && jt && Ot && (nn = Zt.clientWidth);
        let St;
        typeof it < "u" ? St = it : St = lt ? null : 0;
        const ct = Ct.id || (At ? `mui-component-select-${At}` : void 0),
            pt = _extends$4({}, o, {
                variant: mt,
                value: $t,
                open: rn,
                error: yt
            }),
            kt = useUtilityClasses$f(pt),
            Dt = _extends$4({}, wt.PaperProps, ($ = wt.slotProps) == null ? void 0 : $.paper),
            zt = useId();
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [jsxRuntimeExports.jsx(SelectSelect, _extends$4({
                ref: Jt,
                tabIndex: St,
                role: "combobox",
                "aria-controls": zt,
                "aria-disabled": lt ? "true" : void 0,
                "aria-expanded": rn ? "true" : "false",
                "aria-haspopup": "listbox",
                "aria-label": _e,
                "aria-labelledby": [vt, ct].filter(Boolean).join(" ") || void 0,
                "aria-describedby": j,
                onKeyDown: fn,
                onMouseDown: lt || Ft ? null : ln,
                onBlur: mn,
                onFocus: Nt
            }, Ct, {
                ownerState: pt,
                className: clsx(Ct.className, kt.select, rt),
                id: ct,
                children: isEmpty(dn) ? _span || (_span = jsxRuntimeExports.jsx("span", {
                    className: "notranslate",
                    children: "​"
                })) : dn
            })), jsxRuntimeExports.jsx(SelectNativeInput, _extends$4({
                "aria-invalid": yt,
                value: Array.isArray($t) ? $t.join(",") : $t,
                name: At,
                ref: dt,
                "aria-hidden": !0,
                onChange: Nn,
                tabIndex: -1,
                disabled: lt,
                className: kt.nativeInput,
                autoFocus: et,
                ownerState: pt
            }, xt)), jsxRuntimeExports.jsx(SelectIcon, {
                as: bt,
                className: kt.icon,
                ownerState: pt
            }), jsxRuntimeExports.jsx(Menu, _extends$4({
                id: `menu-${At||""}`,
                anchorEl: Zt,
                open: rn,
                onClose: cn,
                anchorOrigin: {
                    vertical: "bottom",
                    horizontal: "center"
                },
                transformOrigin: {
                    vertical: "top",
                    horizontal: "center"
                }
            }, wt, {
                MenuListProps: _extends$4({
                    "aria-labelledby": vt,
                    role: "listbox",
                    "aria-multiselectable": gt ? "true" : void 0,
                    disableListWrap: !0,
                    id: zt
                }, wt.MenuListProps),
                slotProps: _extends$4({}, wt.slotProps, {
                    paper: _extends$4({}, Dt, {
                        style: _extends$4({
                            minWidth: nn
                        }, Dt != null ? Dt.style : null)
                    })
                }),
                children: Yt
            }))]
        })
    }),
    _excluded$i = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"],
    _excluded2$1 = ["root"],
    useUtilityClasses$e = s => {
        const {
            classes: o
        } = s;
        return o
    },
    styledRootConfig = {
        name: "MuiSelect",
        overridesResolver: (s, o) => o.root,
        shouldForwardProp: s => rootShouldForwardProp(s) && s !== "variant",
        slot: "Root"
    },
    StyledInput = styled(Input, styledRootConfig)(""),
    StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)(""),
    StyledFilledInput = styled(FilledInput, styledRootConfig)(""),
    Select = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                name: "MuiSelect",
                props: o
            }),
            {
                autoWidth: j = !1,
                children: _e,
                classes: et = {},
                className: tt,
                defaultOpen: nt = !1,
                displayEmpty: rt = !1,
                IconComponent: ot = ArrowDropDownIcon,
                id: st,
                input: lt,
                inputProps: ft,
                label: yt,
                labelId: bt,
                MenuProps: ht,
                multiple: vt = !1,
                native: wt = !1,
                onClose: gt,
                onOpen: At,
                open: Pt,
                renderValue: Bt,
                SelectDisplayProps: Lt,
                variant: Nt = "outlined"
            } = $,
            Ut = _objectWithoutPropertiesLoose$1($, _excluded$i),
            Vt = wt ? NativeSelectInput : SelectInput,
            Ft = useFormControl(),
            Wt = formControlState({
                props: $,
                muiFormControl: Ft,
                states: ["variant", "error"]
            }),
            Ct = Wt.variant || Nt,
            it = _extends$4({}, $, {
                variant: Ct,
                classes: et
            }),
            at = useUtilityClasses$e(it),
            mt = _objectWithoutPropertiesLoose$1(at, _excluded2$1),
            xt = lt || {
                standard: jsxRuntimeExports.jsx(StyledInput, {
                    ownerState: it
                }),
                outlined: jsxRuntimeExports.jsx(StyledOutlinedInput, {
                    label: yt,
                    ownerState: it
                }),
                filled: jsxRuntimeExports.jsx(StyledFilledInput, {
                    ownerState: it
                })
            }[Ct],
            $t = useForkRef(a, xt.ref);
        return jsxRuntimeExports.jsx(reactExports.Fragment, {
            children: reactExports.cloneElement(xt, _extends$4({
                inputComponent: Vt,
                inputProps: _extends$4({
                    children: _e,
                    error: Wt.error,
                    IconComponent: ot,
                    variant: Ct,
                    type: void 0,
                    multiple: vt
                }, wt ? {
                    id: st
                } : {
                    autoWidth: j,
                    defaultOpen: nt,
                    displayEmpty: rt,
                    labelId: bt,
                    MenuProps: ht,
                    onClose: gt,
                    onOpen: At,
                    open: Pt,
                    renderValue: Bt,
                    SelectDisplayProps: _extends$4({
                        id: st
                    }, Lt)
                }, ft, {
                    classes: ft ? deepmerge$1(mt, ft.classes) : mt
                }, lt ? lt.props.inputProps : {})
            }, (vt && wt || rt) && Ct === "outlined" ? {
                notched: !0
            } : {}, {
                ref: $t,
                className: clsx(xt.props.className, tt, at.root)
            }, !lt && {
                variant: Ct
            }, Ut))
        })
    });
Select.muiName = "Select";

function getTooltipUtilityClass(s) {
    return generateUtilityClass("MuiTooltip", s)
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]),
    _excluded$h = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];

function round(s) {
    return Math.round(s * 1e5) / 1e5
}
const useUtilityClasses$d = s => {
        const {
            classes: o,
            disableInteractive: a,
            arrow: $,
            touch: j,
            placement: _e
        } = s, et = {
            popper: ["popper", !a && "popperInteractive", $ && "popperArrow"],
            tooltip: ["tooltip", $ && "tooltipArrow", j && "touch", `tooltipPlacement${capitalize$1(_e.split("-")[0])}`],
            arrow: ["arrow"]
        };
        return composeClasses(et, getTooltipUtilityClass, o)
    },
    TooltipPopper = styled(Popper, {
        name: "MuiTooltip",
        slot: "Popper",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.popper, !a.disableInteractive && o.popperInteractive, a.arrow && o.popperArrow, !a.open && o.popperClose]
        }
    })(({
        theme: s,
        ownerState: o,
        open: a
    }) => _extends$4({
        zIndex: (s.vars || s).zIndex.tooltip,
        pointerEvents: "none"
    }, !o.disableInteractive && {
        pointerEvents: "auto"
    }, !a && {
        pointerEvents: "none"
    }, o.arrow && {
        [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
            top: 0,
            marginTop: "-0.71em",
            "&::before": {
                transformOrigin: "0 100%"
            }
        },
        [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
            bottom: 0,
            marginBottom: "-0.71em",
            "&::before": {
                transformOrigin: "100% 0"
            }
        },
        [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: _extends$4({}, o.isRtl ? {
            right: 0,
            marginRight: "-0.71em"
        } : {
            left: 0,
            marginLeft: "-0.71em"
        }, {
            height: "1em",
            width: "0.71em",
            "&::before": {
                transformOrigin: "100% 100%"
            }
        }),
        [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: _extends$4({}, o.isRtl ? {
            left: 0,
            marginLeft: "-0.71em"
        } : {
            right: 0,
            marginRight: "-0.71em"
        }, {
            height: "1em",
            width: "0.71em",
            "&::before": {
                transformOrigin: "0 0"
            }
        })
    })),
    TooltipTooltip = styled("div", {
        name: "MuiTooltip",
        slot: "Tooltip",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.tooltip, a.touch && o.touch, a.arrow && o.tooltipArrow, o[`tooltipPlacement${capitalize$1(a.placement.split("-")[0])}`]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        backgroundColor: s.vars ? s.vars.palette.Tooltip.bg : alpha_1(s.palette.grey[700], .92),
        borderRadius: (s.vars || s).shape.borderRadius,
        color: (s.vars || s).palette.common.white,
        fontFamily: s.typography.fontFamily,
        padding: "4px 8px",
        fontSize: s.typography.pxToRem(11),
        maxWidth: 300,
        margin: 2,
        wordWrap: "break-word",
        fontWeight: s.typography.fontWeightMedium
    }, o.arrow && {
        position: "relative",
        margin: 0
    }, o.touch && {
        padding: "8px 16px",
        fontSize: s.typography.pxToRem(14),
        lineHeight: `${round(16/14)}em`,
        fontWeight: s.typography.fontWeightRegular
    }, {
        [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: _extends$4({
            transformOrigin: "right center"
        }, o.isRtl ? _extends$4({
            marginLeft: "14px"
        }, o.touch && {
            marginLeft: "24px"
        }) : _extends$4({
            marginRight: "14px"
        }, o.touch && {
            marginRight: "24px"
        })),
        [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: _extends$4({
            transformOrigin: "left center"
        }, o.isRtl ? _extends$4({
            marginRight: "14px"
        }, o.touch && {
            marginRight: "24px"
        }) : _extends$4({
            marginLeft: "14px"
        }, o.touch && {
            marginLeft: "24px"
        })),
        [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: _extends$4({
            transformOrigin: "center bottom",
            marginBottom: "14px"
        }, o.touch && {
            marginBottom: "24px"
        }),
        [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: _extends$4({
            transformOrigin: "center top",
            marginTop: "14px"
        }, o.touch && {
            marginTop: "24px"
        })
    })),
    TooltipArrow = styled("span", {
        name: "MuiTooltip",
        slot: "Arrow",
        overridesResolver: (s, o) => o.arrow
    })(({
        theme: s
    }) => ({
        overflow: "hidden",
        position: "absolute",
        width: "1em",
        height: "0.71em",
        boxSizing: "border-box",
        color: s.vars ? s.vars.palette.Tooltip.bg : alpha_1(s.palette.grey[700], .9),
        "&::before": {
            content: '""',
            margin: "auto",
            display: "block",
            width: "100%",
            height: "100%",
            backgroundColor: "currentColor",
            transform: "rotate(45deg)"
        }
    }));
let hystersisOpen = !1;
const hystersisTimer = new Timeout;
let cursorPosition = {
    x: 0,
    y: 0
};

function composeEventHandler(s, o) {
    return (a, ...$) => {
        o && o(a, ...$), s(a, ...$)
    }
}
const Tooltip = reactExports.forwardRef(function(o, a) {
        var $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht, vt, wt, gt, At, Pt;
        const Bt = useDefaultProps({
                props: o,
                name: "MuiTooltip"
            }),
            {
                arrow: Lt = !1,
                children: Nt,
                components: Ut = {},
                componentsProps: Vt = {},
                describeChild: Ft = !1,
                disableFocusListener: Wt = !1,
                disableHoverListener: Ct = !1,
                disableInteractive: it = !1,
                disableTouchListener: at = !1,
                enterDelay: mt = 100,
                enterNextDelay: xt = 0,
                enterTouchDelay: $t = 700,
                followCursor: Rt = !1,
                id: It,
                leaveDelay: Tt = 0,
                leaveTouchDelay: dt = 1500,
                onClose: Et,
                onOpen: Ot,
                open: Mt,
                placement: jt = "bottom",
                PopperComponent: Qt,
                PopperProps: Kt = {},
                slotProps: qt = {},
                slots: Jt = {},
                title: Zt,
                TransitionComponent: en = Grow,
                TransitionProps: ln
            } = Bt,
            cn = _objectWithoutPropertiesLoose$1(Bt, _excluded$h),
            un = reactExports.isValidElement(Nt) ? Nt : jsxRuntimeExports.jsx("span", {
                children: Nt
            }),
            Nn = useTheme$1(),
            hn = useRtl(),
            [fn, rn] = reactExports.useState(),
            [mn, dn] = reactExports.useState(null),
            vn = reactExports.useRef(!1),
            gn = it || Rt,
            Gt = useTimeout(),
            Yt = useTimeout(),
            nn = useTimeout(),
            St = useTimeout(),
            [ct, pt] = useControlled({
                controlled: Mt,
                default: !1,
                name: "Tooltip",
                state: "open"
            });
        let kt = ct;
        const Dt = useId(It),
            zt = reactExports.useRef(),
            Ht = useEventCallback(() => {
                zt.current !== void 0 && (document.body.style.WebkitUserSelect = zt.current, zt.current = void 0), St.clear()
            });
        reactExports.useEffect(() => Ht, [Ht]);
        const an = In => {
                hystersisTimer.clear(), hystersisOpen = !0, pt(!0), Ot && !kt && Ot(In)
            },
            Xt = useEventCallback(In => {
                hystersisTimer.start(800 + Tt, () => {
                    hystersisOpen = !1
                }), pt(!1), Et && kt && Et(In), Gt.start(Nn.transitions.duration.shortest, () => {
                    vn.current = !1
                })
            }),
            tn = In => {
                vn.current && In.type !== "touchstart" || (fn && fn.removeAttribute("title"), Yt.clear(), nn.clear(), mt || hystersisOpen && xt ? Yt.start(hystersisOpen ? xt : mt, () => {
                    an(In)
                }) : an(In))
            },
            pn = In => {
                Yt.clear(), nn.start(Tt, () => {
                    Xt(In)
                })
            },
            {
                isFocusVisibleRef: sn,
                onBlur: yn,
                onFocus: Dn,
                ref: wn
            } = useIsFocusVisible(),
            [, _n] = reactExports.useState(!1),
            Un = In => {
                yn(In), sn.current === !1 && (_n(!1), pn(In))
            },
            $n = In => {
                fn || rn(In.currentTarget), Dn(In), sn.current === !0 && (_n(!0), tn(In))
            },
            An = In => {
                vn.current = !0;
                const Fn = un.props;
                Fn.onTouchStart && Fn.onTouchStart(In)
            },
            Gn = In => {
                An(In), nn.clear(), Gt.clear(), Ht(), zt.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", St.start($t, () => {
                    document.body.style.WebkitUserSelect = zt.current, tn(In)
                })
            },
            Pn = In => {
                un.props.onTouchEnd && un.props.onTouchEnd(In), Ht(), nn.start(dt, () => {
                    Xt(In)
                })
            };
        reactExports.useEffect(() => {
            if (!kt) return;

            function In(Fn) {
                (Fn.key === "Escape" || Fn.key === "Esc") && Xt(Fn)
            }
            return document.addEventListener("keydown", In), () => {
                document.removeEventListener("keydown", In)
            }
        }, [Xt, kt]);
        const Bn = useForkRef(un.ref, wn, rn, a);
        !Zt && Zt !== 0 && (kt = !1);
        const zn = reactExports.useRef(),
            Ln = In => {
                const Fn = un.props;
                Fn.onMouseMove && Fn.onMouseMove(In), cursorPosition = {
                    x: In.clientX,
                    y: In.clientY
                }, zn.current && zn.current.update()
            },
            En = {},
            Wn = typeof Zt == "string";
        Ft ? (En.title = !kt && Wn && !Ct ? Zt : null, En["aria-describedby"] = kt ? Dt : null) : (En["aria-label"] = Wn ? Zt : null, En["aria-labelledby"] = kt && !Wn ? Dt : null);
        const xn = _extends$4({}, En, cn, un.props, {
                className: clsx(cn.className, un.props.className),
                onTouchStart: An,
                ref: Bn
            }, Rt ? {
                onMouseMove: Ln
            } : {}),
            Sn = {};
        at || (xn.onTouchStart = Gn, xn.onTouchEnd = Pn), Ct || (xn.onMouseOver = composeEventHandler(tn, xn.onMouseOver), xn.onMouseLeave = composeEventHandler(pn, xn.onMouseLeave), gn || (Sn.onMouseOver = tn, Sn.onMouseLeave = pn)), Wt || (xn.onFocus = composeEventHandler($n, xn.onFocus), xn.onBlur = composeEventHandler(Un, xn.onBlur), gn || (Sn.onFocus = $n, Sn.onBlur = Un));
        const Qn = reactExports.useMemo(() => {
                var In;
                let Fn = [{
                    name: "arrow",
                    enabled: !!mn,
                    options: {
                        element: mn,
                        padding: 4
                    }
                }];
                return (In = Kt.popperOptions) != null && In.modifiers && (Fn = Fn.concat(Kt.popperOptions.modifiers)), _extends$4({}, Kt.popperOptions, {
                    modifiers: Fn
                })
            }, [mn, Kt]),
            Tn = _extends$4({}, Bt, {
                isRtl: hn,
                arrow: Lt,
                disableInteractive: gn,
                placement: jt,
                PopperComponentProp: Qt,
                touch: vn.current
            }),
            Rn = useUtilityClasses$d(Tn),
            Kn = ($ = (j = Jt.popper) != null ? j : Ut.Popper) != null ? $ : TooltipPopper,
            Cn = (_e = (et = (tt = Jt.transition) != null ? tt : Ut.Transition) != null ? et : en) != null ? _e : Grow,
            kn = (nt = (rt = Jt.tooltip) != null ? rt : Ut.Tooltip) != null ? nt : TooltipTooltip,
            qn = (ot = (st = Jt.arrow) != null ? st : Ut.Arrow) != null ? ot : TooltipArrow,
            On = appendOwnerState(Kn, _extends$4({}, Kt, (lt = qt.popper) != null ? lt : Vt.popper, {
                className: clsx(Rn.popper, Kt == null ? void 0 : Kt.className, (ft = (yt = qt.popper) != null ? yt : Vt.popper) == null ? void 0 : ft.className)
            }), Tn),
            Mn = appendOwnerState(Cn, _extends$4({}, ln, (bt = qt.transition) != null ? bt : Vt.transition), Tn),
            Hn = appendOwnerState(kn, _extends$4({}, (ht = qt.tooltip) != null ? ht : Vt.tooltip, {
                className: clsx(Rn.tooltip, (vt = (wt = qt.tooltip) != null ? wt : Vt.tooltip) == null ? void 0 : vt.className)
            }), Tn),
            Vn = appendOwnerState(qn, _extends$4({}, (gt = qt.arrow) != null ? gt : Vt.arrow, {
                className: clsx(Rn.arrow, (At = (Pt = qt.arrow) != null ? Pt : Vt.arrow) == null ? void 0 : At.className)
            }), Tn);
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [reactExports.cloneElement(un, xn), jsxRuntimeExports.jsx(Kn, _extends$4({
                as: Qt ? ? Popper,
                placement: jt,
                anchorEl: Rt ? {
                    getBoundingClientRect: () => ({
                        top: cursorPosition.y,
                        left: cursorPosition.x,
                        right: cursorPosition.x,
                        bottom: cursorPosition.y,
                        width: 0,
                        height: 0
                    })
                } : fn,
                popperRef: zn,
                open: fn ? kt : !1,
                id: Dt,
                transition: !0
            }, Sn, On, {
                popperOptions: Qn,
                children: ({
                    TransitionProps: In
                }) => jsxRuntimeExports.jsx(Cn, _extends$4({
                    timeout: Nn.transitions.duration.shorter
                }, In, Mn, {
                    children: jsxRuntimeExports.jsxs(kn, _extends$4({}, Hn, {
                        children: [Zt, Lt ? jsxRuntimeExports.jsx(qn, _extends$4({}, Vn, {
                            ref: dn
                        })) : null]
                    }))
                }))
            }))]
        })
    }),
    _excluded$g = ["anchor", "classes", "className", "width", "style"],
    SwipeAreaRoot = styled("div", {
        shouldForwardProp: rootShouldForwardProp
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        position: "fixed",
        top: 0,
        left: 0,
        bottom: 0,
        zIndex: s.zIndex.drawer - 1
    }, o.anchor === "left" && {
        right: "auto"
    }, o.anchor === "right" && {
        left: "auto",
        right: 0
    }, o.anchor === "top" && {
        bottom: "auto",
        right: 0
    }, o.anchor === "bottom" && {
        top: "auto",
        bottom: 0,
        right: 0
    })),
    SwipeArea = reactExports.forwardRef(function(o, a) {
        const {
            anchor: $,
            classes: j = {},
            className: _e,
            width: et,
            style: tt
        } = o, nt = _objectWithoutPropertiesLoose$1(o, _excluded$g), rt = o;
        return jsxRuntimeExports.jsx(SwipeAreaRoot, _extends$4({
            className: clsx("PrivateSwipeArea-root", j.root, j[`anchor${capitalize$1($)}`], _e),
            ref: a,
            style: _extends$4({
                [isHorizontal($) ? "width" : "height"]: et
            }, tt),
            ownerState: rt
        }, nt))
    }),
    _excluded$f = ["BackdropProps"],
    _excluded2 = ["anchor", "disableBackdropTransition", "disableDiscovery", "disableSwipeToOpen", "hideBackdrop", "hysteresis", "allowSwipeInChildren", "minFlingVelocity", "ModalProps", "onClose", "onOpen", "open", "PaperProps", "SwipeAreaProps", "swipeAreaWidth", "transitionDuration", "variant"],
    UNCERTAINTY_THRESHOLD = 3,
    DRAG_STARTED_SIGNAL = 20;
let claimedSwipeInstance = null;

function calculateCurrentX(s, o, a) {
    return s === "right" ? a.body.offsetWidth - o[0].pageX : o[0].pageX
}

function calculateCurrentY(s, o, a) {
    return s === "bottom" ? a.innerHeight - o[0].clientY : o[0].clientY
}

function getMaxTranslate(s, o) {
    return s ? o.clientWidth : o.clientHeight
}

function getTranslate(s, o, a, $) {
    return Math.min(Math.max(a ? o - s : $ + o - s, 0), $)
}

function getDomTreeShapes(s, o) {
    const a = [];
    for (; s && s !== o.parentElement;) {
        const $ = ownerWindow(o).getComputedStyle(s);
        $.getPropertyValue("position") === "absolute" || $.getPropertyValue("overflow-x") === "hidden" || (s.clientWidth > 0 && s.scrollWidth > s.clientWidth || s.clientHeight > 0 && s.scrollHeight > s.clientHeight) && a.push(s), s = s.parentElement
    }
    return a
}

function computeHasNativeHandler({
    domTreeShapes: s,
    start: o,
    current: a,
    anchor: $
}) {
    const j = {
        scrollPosition: {
            x: "scrollLeft",
            y: "scrollTop"
        },
        scrollLength: {
            x: "scrollWidth",
            y: "scrollHeight"
        },
        clientLength: {
            x: "clientWidth",
            y: "clientHeight"
        }
    };
    return s.some(_e => {
        let et = a >= o;
        ($ === "top" || $ === "left") && (et = !et);
        const tt = $ === "left" || $ === "right" ? "x" : "y",
            nt = Math.round(_e[j.scrollPosition[tt]]),
            rt = nt > 0,
            ot = nt + _e[j.clientLength[tt]] < _e[j.scrollLength[tt]];
        return !!(et && ot || !et && rt)
    })
}
const iOS = typeof navigator < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent),
    SwipeableDrawer = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                name: "MuiSwipeableDrawer",
                props: o
            }),
            j = useTheme$1(),
            _e = {
                enter: j.transitions.duration.enteringScreen,
                exit: j.transitions.duration.leavingScreen
            },
            {
                anchor: et = "left",
                disableBackdropTransition: tt = !1,
                disableDiscovery: nt = !1,
                disableSwipeToOpen: rt = iOS,
                hideBackdrop: ot,
                hysteresis: st = .52,
                allowSwipeInChildren: lt = !1,
                minFlingVelocity: ft = 450,
                ModalProps: {
                    BackdropProps: yt
                } = {},
                onClose: bt,
                onOpen: ht,
                open: vt = !1,
                PaperProps: wt = {},
                SwipeAreaProps: gt,
                swipeAreaWidth: At = 20,
                transitionDuration: Pt = _e,
                variant: Bt = "temporary"
            } = $,
            Lt = _objectWithoutPropertiesLoose$1($.ModalProps, _excluded$f),
            Nt = _objectWithoutPropertiesLoose$1($, _excluded2),
            [Ut, Vt] = reactExports.useState(!1),
            Ft = reactExports.useRef({
                isSwiping: null
            }),
            Wt = reactExports.useRef(),
            Ct = reactExports.useRef(),
            it = reactExports.useRef(),
            at = useForkRef(wt.ref, it),
            mt = reactExports.useRef(!1),
            xt = reactExports.useRef();
        useEnhancedEffect(() => {
            xt.current = null
        }, [vt]);
        const $t = reactExports.useCallback((Et, Ot = {}) => {
                const {
                    mode: Mt = null,
                    changeTransition: jt = !0
                } = Ot, Qt = getAnchor(j, et), Kt = ["right", "bottom"].indexOf(Qt) !== -1 ? 1 : -1, qt = isHorizontal(et), Jt = qt ? `translate(${Kt*Et}px, 0)` : `translate(0, ${Kt*Et}px)`, Zt = it.current.style;
                Zt.webkitTransform = Jt, Zt.transform = Jt;
                let en = "";
                if (Mt && (en = j.transitions.create("all", getTransitionProps({
                        easing: void 0,
                        style: void 0,
                        timeout: Pt
                    }, {
                        mode: Mt
                    }))), jt && (Zt.webkitTransition = en, Zt.transition = en), !tt && !ot) {
                    const ln = Ct.current.style;
                    ln.opacity = 1 - Et / getMaxTranslate(qt, it.current), jt && (ln.webkitTransition = en, ln.transition = en)
                }
            }, [et, tt, ot, j, Pt]),
            Rt = useEventCallback(Et => {
                if (!mt.current) return;
                if (claimedSwipeInstance = null, mt.current = !1, reactDomExports.flushSync(() => {
                        Vt(!1)
                    }), !Ft.current.isSwiping) {
                    Ft.current.isSwiping = null;
                    return
                }
                Ft.current.isSwiping = null;
                const Ot = getAnchor(j, et),
                    Mt = isHorizontal(et);
                let jt;
                Mt ? jt = calculateCurrentX(Ot, Et.changedTouches, ownerDocument(Et.currentTarget)) : jt = calculateCurrentY(Ot, Et.changedTouches, ownerWindow(Et.currentTarget));
                const Qt = Mt ? Ft.current.startX : Ft.current.startY,
                    Kt = getMaxTranslate(Mt, it.current),
                    qt = getTranslate(jt, Qt, vt, Kt),
                    Jt = qt / Kt;
                if (Math.abs(Ft.current.velocity) > ft && (xt.current = Math.abs((Kt - qt) / Ft.current.velocity) * 1e3), vt) {
                    Ft.current.velocity > ft || Jt > st ? bt() : $t(0, {
                        mode: "exit"
                    });
                    return
                }
                Ft.current.velocity < -ft || 1 - Jt > st ? ht() : $t(getMaxTranslate(Mt, it.current), {
                    mode: "enter"
                })
            }),
            It = (Et = !1) => {
                if (!Ut) {
                    (Et || !(nt && lt)) && reactDomExports.flushSync(() => {
                        Vt(!0)
                    });
                    const Ot = isHorizontal(et);
                    !vt && it.current && $t(getMaxTranslate(Ot, it.current) + (nt ? 15 : -DRAG_STARTED_SIGNAL), {
                        changeTransition: !1
                    }), Ft.current.velocity = 0, Ft.current.lastTime = null, Ft.current.lastTranslate = null, Ft.current.paperHit = !1, mt.current = !0
                }
            },
            Tt = useEventCallback(Et => {
                if (!it.current || !mt.current || claimedSwipeInstance !== null && claimedSwipeInstance !== Ft.current) return;
                It(!0);
                const Ot = getAnchor(j, et),
                    Mt = isHorizontal(et),
                    jt = calculateCurrentX(Ot, Et.touches, ownerDocument(Et.currentTarget)),
                    Qt = calculateCurrentY(Ot, Et.touches, ownerWindow(Et.currentTarget));
                if (vt && it.current.contains(Et.target) && claimedSwipeInstance === null) {
                    const en = getDomTreeShapes(Et.target, it.current);
                    if (computeHasNativeHandler({
                            domTreeShapes: en,
                            start: Mt ? Ft.current.startX : Ft.current.startY,
                            current: Mt ? jt : Qt,
                            anchor: et
                        })) {
                        claimedSwipeInstance = !0;
                        return
                    }
                    claimedSwipeInstance = Ft.current
                }
                if (Ft.current.isSwiping == null) {
                    const en = Math.abs(jt - Ft.current.startX),
                        ln = Math.abs(Qt - Ft.current.startY),
                        cn = Mt ? en > ln && en > UNCERTAINTY_THRESHOLD : ln > en && ln > UNCERTAINTY_THRESHOLD;
                    if (cn && Et.cancelable && Et.preventDefault(), cn === !0 || (Mt ? ln > UNCERTAINTY_THRESHOLD : en > UNCERTAINTY_THRESHOLD)) {
                        if (Ft.current.isSwiping = cn, !cn) {
                            Rt(Et);
                            return
                        }
                        Ft.current.startX = jt, Ft.current.startY = Qt, !nt && !vt && (Mt ? Ft.current.startX -= DRAG_STARTED_SIGNAL : Ft.current.startY -= DRAG_STARTED_SIGNAL)
                    }
                }
                if (!Ft.current.isSwiping) return;
                const Kt = getMaxTranslate(Mt, it.current);
                let qt = Mt ? Ft.current.startX : Ft.current.startY;
                vt && !Ft.current.paperHit && (qt = Math.min(qt, Kt));
                const Jt = getTranslate(Mt ? jt : Qt, qt, vt, Kt);
                if (vt)
                    if (Ft.current.paperHit) Jt === 0 && (Ft.current.startX = jt, Ft.current.startY = Qt);
                    else if (Mt ? jt < Kt : Qt < Kt) Ft.current.paperHit = !0, Ft.current.startX = jt, Ft.current.startY = Qt;
                else return;
                Ft.current.lastTranslate === null && (Ft.current.lastTranslate = Jt, Ft.current.lastTime = performance.now() + 1);
                const Zt = (Jt - Ft.current.lastTranslate) / (performance.now() - Ft.current.lastTime) * 1e3;
                Ft.current.velocity = Ft.current.velocity * .4 + Zt * .6, Ft.current.lastTranslate = Jt, Ft.current.lastTime = performance.now(), Et.cancelable && Et.preventDefault(), $t(Jt)
            }),
            dt = useEventCallback(Et => {
                if (Et.defaultPrevented || Et.defaultMuiPrevented || vt && (ot || !Ct.current.contains(Et.target)) && !it.current.contains(Et.target)) return;
                const Ot = getAnchor(j, et),
                    Mt = isHorizontal(et),
                    jt = calculateCurrentX(Ot, Et.touches, ownerDocument(Et.currentTarget)),
                    Qt = calculateCurrentY(Ot, Et.touches, ownerWindow(Et.currentTarget));
                if (!vt) {
                    var Kt;
                    if (rt || !(Et.target === Wt.current || (Kt = it.current) != null && Kt.contains(Et.target) && (typeof lt == "function" ? lt(Et, Wt.current, it.current) : lt))) return;
                    if (Mt) {
                        if (jt > At) return
                    } else if (Qt > At) return
                }
                Et.defaultMuiPrevented = !0, claimedSwipeInstance = null, Ft.current.startX = jt, Ft.current.startY = Qt, It()
            });
        return reactExports.useEffect(() => {
            if (Bt === "temporary") {
                const Et = ownerDocument(it.current);
                return Et.addEventListener("touchstart", dt), Et.addEventListener("touchmove", Tt, {
                    passive: !vt
                }), Et.addEventListener("touchend", Rt), () => {
                    Et.removeEventListener("touchstart", dt), Et.removeEventListener("touchmove", Tt, {
                        passive: !vt
                    }), Et.removeEventListener("touchend", Rt)
                }
            }
        }, [Bt, vt, dt, Tt, Rt]), reactExports.useEffect(() => () => {
            claimedSwipeInstance === Ft.current && (claimedSwipeInstance = null)
        }, []), reactExports.useEffect(() => {
            vt || Vt(!1)
        }, [vt]), jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [jsxRuntimeExports.jsx(Drawer, _extends$4({
                open: Bt === "temporary" && Ut ? !0 : vt,
                variant: Bt,
                ModalProps: _extends$4({
                    BackdropProps: _extends$4({}, yt, {
                        ref: Ct
                    })
                }, Bt === "temporary" && {
                    keepMounted: !0
                }, Lt),
                hideBackdrop: ot,
                PaperProps: _extends$4({}, wt, {
                    style: _extends$4({
                        pointerEvents: Bt === "temporary" && !vt && !lt ? "none" : ""
                    }, wt.style),
                    ref: at
                }),
                anchor: et,
                transitionDuration: xt.current || Pt,
                onClose: bt,
                ref: a
            }, Nt)), !rt && Bt === "temporary" && jsxRuntimeExports.jsx(NoSsr, {
                children: jsxRuntimeExports.jsx(SwipeArea, _extends$4({
                    anchor: et,
                    ref: Wt,
                    width: At
                }, gt))
            })]
        })
    });

function getSwitchUtilityClass(s) {
    return generateUtilityClass("MuiSwitch", s)
}
const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]),
    _excluded$e = ["className", "color", "edge", "size", "sx"],
    useUtilityClasses$c = s => {
        const {
            classes: o,
            edge: a,
            size: $,
            color: j,
            checked: _e,
            disabled: et
        } = s, tt = {
            root: ["root", a && `edge${capitalize$1(a)}`, `size${capitalize$1($)}`],
            switchBase: ["switchBase", `color${capitalize$1(j)}`, _e && "checked", et && "disabled"],
            thumb: ["thumb"],
            track: ["track"],
            input: ["input"]
        }, nt = composeClasses(tt, getSwitchUtilityClass, o);
        return _extends$4({}, o, nt)
    },
    SwitchRoot = styled("span", {
        name: "MuiSwitch",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.edge && o[`edge${capitalize$1(a.edge)}`], o[`size${capitalize$1(a.size)}`]]
        }
    })({
        display: "inline-flex",
        width: 34 + 12 * 2,
        height: 14 + 12 * 2,
        overflow: "hidden",
        padding: 12,
        boxSizing: "border-box",
        position: "relative",
        flexShrink: 0,
        zIndex: 0,
        verticalAlign: "middle",
        "@media print": {
            colorAdjust: "exact"
        },
        variants: [{
            props: {
                edge: "start"
            },
            style: {
                marginLeft: -8
            }
        }, {
            props: {
                edge: "end"
            },
            style: {
                marginRight: -8
            }
        }, {
            props: {
                size: "small"
            },
            style: {
                width: 40,
                height: 24,
                padding: 7,
                [`& .${switchClasses.thumb}`]: {
                    width: 16,
                    height: 16
                },
                [`& .${switchClasses.switchBase}`]: {
                    padding: 4,
                    [`&.${switchClasses.checked}`]: {
                        transform: "translateX(16px)"
                    }
                }
            }
        }]
    }),
    SwitchSwitchBase = styled(SwitchBase, {
        name: "MuiSwitch",
        slot: "SwitchBase",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.switchBase, {
                [`& .${switchClasses.input}`]: o.input
            }, a.color !== "default" && o[`color${capitalize$1(a.color)}`]]
        }
    })(({
        theme: s
    }) => ({
        position: "absolute",
        top: 0,
        left: 0,
        zIndex: 1,
        color: s.vars ? s.vars.palette.Switch.defaultColor : `${s.palette.mode==="light"?s.palette.common.white:s.palette.grey[300]}`,
        transition: s.transitions.create(["left", "transform"], {
            duration: s.transitions.duration.shortest
        }),
        [`&.${switchClasses.checked}`]: {
            transform: "translateX(20px)"
        },
        [`&.${switchClasses.disabled}`]: {
            color: s.vars ? s.vars.palette.Switch.defaultDisabledColor : `${s.palette.mode==="light"?s.palette.grey[100]:s.palette.grey[600]}`
        },
        [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
            opacity: .5
        },
        [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
            opacity: s.vars ? s.vars.opacity.switchTrackDisabled : `${s.palette.mode==="light"?.12:.2}`
        },
        [`& .${switchClasses.input}`]: {
            left: "-100%",
            width: "300%"
        }
    }), ({
        theme: s
    }) => ({
        "&:hover": {
            backgroundColor: s.vars ? `rgba(${s.vars.palette.action.activeChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(s.palette.action.active, s.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        },
        variants: [...Object.entries(s.palette).filter(([, o]) => o.main && o.light).map(([o]) => ({
            props: {
                color: o
            },
            style: {
                [`&.${switchClasses.checked}`]: {
                    color: (s.vars || s).palette[o].main,
                    "&:hover": {
                        backgroundColor: s.vars ? `rgba(${s.vars.palette[o].mainChannel} / ${s.vars.palette.action.hoverOpacity})` : alpha_1(s.palette[o].main, s.palette.action.hoverOpacity),
                        "@media (hover: none)": {
                            backgroundColor: "transparent"
                        }
                    },
                    [`&.${switchClasses.disabled}`]: {
                        color: s.vars ? s.vars.palette.Switch[`${o}DisabledColor`] : `${s.palette.mode==="light"?lighten_1(s.palette[o].main,.62):darken_1(s.palette[o].main,.55)}`
                    }
                },
                [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
                    backgroundColor: (s.vars || s).palette[o].main
                }
            }
        }))]
    })),
    SwitchTrack = styled("span", {
        name: "MuiSwitch",
        slot: "Track",
        overridesResolver: (s, o) => o.track
    })(({
        theme: s
    }) => ({
        height: "100%",
        width: "100%",
        borderRadius: 14 / 2,
        zIndex: -1,
        transition: s.transitions.create(["opacity", "background-color"], {
            duration: s.transitions.duration.shortest
        }),
        backgroundColor: s.vars ? s.vars.palette.common.onBackground : `${s.palette.mode==="light"?s.palette.common.black:s.palette.common.white}`,
        opacity: s.vars ? s.vars.opacity.switchTrack : `${s.palette.mode==="light"?.38:.3}`
    })),
    SwitchThumb = styled("span", {
        name: "MuiSwitch",
        slot: "Thumb",
        overridesResolver: (s, o) => o.thumb
    })(({
        theme: s
    }) => ({
        boxShadow: (s.vars || s).shadows[1],
        backgroundColor: "currentColor",
        width: 20,
        height: 20,
        borderRadius: "50%"
    })),
    Switch = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiSwitch"
            }),
            {
                className: j,
                color: _e = "primary",
                edge: et = !1,
                size: tt = "medium",
                sx: nt
            } = $,
            rt = _objectWithoutPropertiesLoose$1($, _excluded$e),
            ot = _extends$4({}, $, {
                color: _e,
                edge: et,
                size: tt
            }),
            st = useUtilityClasses$c(ot),
            lt = jsxRuntimeExports.jsx(SwitchThumb, {
                className: st.thumb,
                ownerState: ot
            });
        return jsxRuntimeExports.jsxs(SwitchRoot, {
            className: clsx(st.root, j),
            sx: nt,
            ownerState: ot,
            children: [jsxRuntimeExports.jsx(SwitchSwitchBase, _extends$4({
                type: "checkbox",
                icon: lt,
                checkedIcon: lt,
                ref: a,
                ownerState: ot
            }, rt, {
                classes: _extends$4({}, st, {
                    root: st.switchBase
                })
            })), jsxRuntimeExports.jsx(SwitchTrack, {
                className: st.track,
                ownerState: ot
            })]
        })
    });

function getTabUtilityClass(s) {
    return generateUtilityClass("MuiTab", s)
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]),
    _excluded$d = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"],
    useUtilityClasses$b = s => {
        const {
            classes: o,
            textColor: a,
            fullWidth: $,
            wrapped: j,
            icon: _e,
            label: et,
            selected: tt,
            disabled: nt
        } = s, rt = {
            root: ["root", _e && et && "labelIcon", `textColor${capitalize$1(a)}`, $ && "fullWidth", j && "wrapped", tt && "selected", nt && "disabled"],
            iconWrapper: ["iconWrapper"]
        };
        return composeClasses(rt, getTabUtilityClass, o)
    },
    TabRoot = styled(ButtonBase, {
        name: "MuiTab",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.label && a.icon && o.labelIcon, o[`textColor${capitalize$1(a.textColor)}`], a.fullWidth && o.fullWidth, a.wrapped && o.wrapped, {
                [`& .${tabClasses.iconWrapper}`]: o.iconWrapper
            }]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({}, s.typography.button, {
        maxWidth: 360,
        minWidth: 90,
        position: "relative",
        minHeight: 48,
        flexShrink: 0,
        padding: "12px 16px",
        overflow: "hidden",
        whiteSpace: "normal",
        textAlign: "center"
    }, o.label && {
        flexDirection: o.iconPosition === "top" || o.iconPosition === "bottom" ? "column" : "row"
    }, {
        lineHeight: 1.25
    }, o.icon && o.label && {
        minHeight: 72,
        paddingTop: 9,
        paddingBottom: 9,
        [`& > .${tabClasses.iconWrapper}`]: _extends$4({}, o.iconPosition === "top" && {
            marginBottom: 6
        }, o.iconPosition === "bottom" && {
            marginTop: 6
        }, o.iconPosition === "start" && {
            marginRight: s.spacing(1)
        }, o.iconPosition === "end" && {
            marginLeft: s.spacing(1)
        })
    }, o.textColor === "inherit" && {
        color: "inherit",
        opacity: .6,
        [`&.${tabClasses.selected}`]: {
            opacity: 1
        },
        [`&.${tabClasses.disabled}`]: {
            opacity: (s.vars || s).palette.action.disabledOpacity
        }
    }, o.textColor === "primary" && {
        color: (s.vars || s).palette.text.secondary,
        [`&.${tabClasses.selected}`]: {
            color: (s.vars || s).palette.primary.main
        },
        [`&.${tabClasses.disabled}`]: {
            color: (s.vars || s).palette.text.disabled
        }
    }, o.textColor === "secondary" && {
        color: (s.vars || s).palette.text.secondary,
        [`&.${tabClasses.selected}`]: {
            color: (s.vars || s).palette.secondary.main
        },
        [`&.${tabClasses.disabled}`]: {
            color: (s.vars || s).palette.text.disabled
        }
    }, o.fullWidth && {
        flexShrink: 1,
        flexGrow: 1,
        flexBasis: 0,
        maxWidth: "none"
    }, o.wrapped && {
        fontSize: s.typography.pxToRem(12)
    })),
    Tab = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTab"
            }),
            {
                className: j,
                disabled: _e = !1,
                disableFocusRipple: et = !1,
                fullWidth: tt,
                icon: nt,
                iconPosition: rt = "top",
                indicator: ot,
                label: st,
                onChange: lt,
                onClick: ft,
                onFocus: yt,
                selected: bt,
                selectionFollowsFocus: ht,
                textColor: vt = "inherit",
                value: wt,
                wrapped: gt = !1
            } = $,
            At = _objectWithoutPropertiesLoose$1($, _excluded$d),
            Pt = _extends$4({}, $, {
                disabled: _e,
                disableFocusRipple: et,
                selected: bt,
                icon: !!nt,
                iconPosition: rt,
                label: !!st,
                fullWidth: tt,
                textColor: vt,
                wrapped: gt
            }),
            Bt = useUtilityClasses$b(Pt),
            Lt = nt && st && reactExports.isValidElement(nt) ? reactExports.cloneElement(nt, {
                className: clsx(Bt.iconWrapper, nt.props.className)
            }) : nt,
            Nt = Vt => {
                !bt && lt && lt(Vt, wt), ft && ft(Vt)
            },
            Ut = Vt => {
                ht && !bt && lt && lt(Vt, wt), yt && yt(Vt)
            };
        return jsxRuntimeExports.jsxs(TabRoot, _extends$4({
            focusRipple: !et,
            className: clsx(Bt.root, j),
            ref: a,
            role: "tab",
            "aria-selected": bt,
            disabled: _e,
            onClick: Nt,
            onFocus: Ut,
            ownerState: Pt,
            tabIndex: bt ? 0 : -1
        }, At, {
            children: [rt === "top" || rt === "start" ? jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [Lt, st]
            }) : jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [st, Lt]
            }), ot]
        }))
    }),
    TableContext = reactExports.createContext();

function getTableUtilityClass(s) {
    return generateUtilityClass("MuiTable", s)
}
generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
const _excluded$c = ["className", "component", "padding", "size", "stickyHeader"],
    useUtilityClasses$a = s => {
        const {
            classes: o,
            stickyHeader: a
        } = s;
        return composeClasses({
            root: ["root", a && "stickyHeader"]
        }, getTableUtilityClass, o)
    },
    TableRoot = styled("table", {
        name: "MuiTable",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.stickyHeader && o.stickyHeader]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        display: "table",
        width: "100%",
        borderCollapse: "collapse",
        borderSpacing: 0,
        "& caption": _extends$4({}, s.typography.body2, {
            padding: s.spacing(2),
            color: (s.vars || s).palette.text.secondary,
            textAlign: "left",
            captionSide: "bottom"
        })
    }, o.stickyHeader && {
        borderCollapse: "separate"
    })),
    defaultComponent$3 = "table",
    Table = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTable"
            }),
            {
                className: j,
                component: _e = defaultComponent$3,
                padding: et = "normal",
                size: tt = "medium",
                stickyHeader: nt = !1
            } = $,
            rt = _objectWithoutPropertiesLoose$1($, _excluded$c),
            ot = _extends$4({}, $, {
                component: _e,
                padding: et,
                size: tt,
                stickyHeader: nt
            }),
            st = useUtilityClasses$a(ot),
            lt = reactExports.useMemo(() => ({
                padding: et,
                size: tt,
                stickyHeader: nt
            }), [et, tt, nt]);
        return jsxRuntimeExports.jsx(TableContext.Provider, {
            value: lt,
            children: jsxRuntimeExports.jsx(TableRoot, _extends$4({
                as: _e,
                role: _e === defaultComponent$3 ? null : "table",
                ref: a,
                className: clsx(st.root, j),
                ownerState: ot
            }, rt))
        })
    }),
    Tablelvl2Context = reactExports.createContext();

function getTableBodyUtilityClass(s) {
    return generateUtilityClass("MuiTableBody", s)
}
generateUtilityClasses("MuiTableBody", ["root"]);
const _excluded$b = ["className", "component"],
    useUtilityClasses$9 = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"]
        }, getTableBodyUtilityClass, o)
    },
    TableBodyRoot = styled("tbody", {
        name: "MuiTableBody",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({
        display: "table-row-group"
    }),
    tablelvl2$1 = {
        variant: "body"
    },
    defaultComponent$2 = "tbody",
    TableBody = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTableBody"
            }),
            {
                className: j,
                component: _e = defaultComponent$2
            } = $,
            et = _objectWithoutPropertiesLoose$1($, _excluded$b),
            tt = _extends$4({}, $, {
                component: _e
            }),
            nt = useUtilityClasses$9(tt);
        return jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
            value: tablelvl2$1,
            children: jsxRuntimeExports.jsx(TableBodyRoot, _extends$4({
                className: clsx(nt.root, j),
                as: _e,
                ref: a,
                role: _e === defaultComponent$2 ? null : "rowgroup",
                ownerState: tt
            }, et))
        })
    });

function getTableCellUtilityClass(s) {
    return generateUtilityClass("MuiTableCell", s)
}
const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]),
    _excluded$a = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"],
    useUtilityClasses$8 = s => {
        const {
            classes: o,
            variant: a,
            align: $,
            padding: j,
            size: _e,
            stickyHeader: et
        } = s, tt = {
            root: ["root", a, et && "stickyHeader", $ !== "inherit" && `align${capitalize$1($)}`, j !== "normal" && `padding${capitalize$1(j)}`, `size${capitalize$1(_e)}`]
        };
        return composeClasses(tt, getTableCellUtilityClass, o)
    },
    TableCellRoot = styled("td", {
        name: "MuiTableCell",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, o[a.variant], o[`size${capitalize$1(a.size)}`], a.padding !== "normal" && o[`padding${capitalize$1(a.padding)}`], a.align !== "inherit" && o[`align${capitalize$1(a.align)}`], a.stickyHeader && o.stickyHeader]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({}, s.typography.body2, {
        display: "table-cell",
        verticalAlign: "inherit",
        borderBottom: s.vars ? `1px solid ${s.vars.palette.TableCell.border}` : `1px solid
    ${s.palette.mode==="light"?lighten_1(alpha_1(s.palette.divider,1),.88):darken_1(alpha_1(s.palette.divider,1),.68)}`,
        textAlign: "left",
        padding: 16
    }, o.variant === "head" && {
        color: (s.vars || s).palette.text.primary,
        lineHeight: s.typography.pxToRem(24),
        fontWeight: s.typography.fontWeightMedium
    }, o.variant === "body" && {
        color: (s.vars || s).palette.text.primary
    }, o.variant === "footer" && {
        color: (s.vars || s).palette.text.secondary,
        lineHeight: s.typography.pxToRem(21),
        fontSize: s.typography.pxToRem(12)
    }, o.size === "small" && {
        padding: "6px 16px",
        [`&.${tableCellClasses.paddingCheckbox}`]: {
            width: 24,
            padding: "0 12px 0 16px",
            "& > *": {
                padding: 0
            }
        }
    }, o.padding === "checkbox" && {
        width: 48,
        padding: "0 0 0 4px"
    }, o.padding === "none" && {
        padding: 0
    }, o.align === "left" && {
        textAlign: "left"
    }, o.align === "center" && {
        textAlign: "center"
    }, o.align === "right" && {
        textAlign: "right",
        flexDirection: "row-reverse"
    }, o.align === "justify" && {
        textAlign: "justify"
    }, o.stickyHeader && {
        position: "sticky",
        top: 0,
        zIndex: 2,
        backgroundColor: (s.vars || s).palette.background.default
    })),
    TableCell = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTableCell"
            }),
            {
                align: j = "inherit",
                className: _e,
                component: et,
                padding: tt,
                scope: nt,
                size: rt,
                sortDirection: ot,
                variant: st
            } = $,
            lt = _objectWithoutPropertiesLoose$1($, _excluded$a),
            ft = reactExports.useContext(TableContext),
            yt = reactExports.useContext(Tablelvl2Context),
            bt = yt && yt.variant === "head";
        let ht;
        et ? ht = et : ht = bt ? "th" : "td";
        let vt = nt;
        ht === "td" ? vt = void 0 : !vt && bt && (vt = "col");
        const wt = st || yt && yt.variant,
            gt = _extends$4({}, $, {
                align: j,
                component: ht,
                padding: tt || (ft && ft.padding ? ft.padding : "normal"),
                size: rt || (ft && ft.size ? ft.size : "medium"),
                sortDirection: ot,
                stickyHeader: wt === "head" && ft && ft.stickyHeader,
                variant: wt
            }),
            At = useUtilityClasses$8(gt);
        let Pt = null;
        return ot && (Pt = ot === "asc" ? "ascending" : "descending"), jsxRuntimeExports.jsx(TableCellRoot, _extends$4({
            as: ht,
            ref: a,
            className: clsx(At.root, _e),
            "aria-sort": Pt,
            scope: vt,
            ownerState: gt
        }, lt))
    });

function getTableContainerUtilityClass(s) {
    return generateUtilityClass("MuiTableContainer", s)
}
generateUtilityClasses("MuiTableContainer", ["root"]);
const _excluded$9 = ["className", "component"],
    useUtilityClasses$7 = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"]
        }, getTableContainerUtilityClass, o)
    },
    TableContainerRoot = styled("div", {
        name: "MuiTableContainer",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({
        width: "100%",
        overflowX: "auto"
    }),
    TableContainer = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTableContainer"
            }),
            {
                className: j,
                component: _e = "div"
            } = $,
            et = _objectWithoutPropertiesLoose$1($, _excluded$9),
            tt = _extends$4({}, $, {
                component: _e
            }),
            nt = useUtilityClasses$7(tt);
        return jsxRuntimeExports.jsx(TableContainerRoot, _extends$4({
            ref: a,
            as: _e,
            className: clsx(nt.root, j),
            ownerState: tt
        }, et))
    });

function getTableHeadUtilityClass(s) {
    return generateUtilityClass("MuiTableHead", s)
}
generateUtilityClasses("MuiTableHead", ["root"]);
const _excluded$8 = ["className", "component"],
    useUtilityClasses$6 = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"]
        }, getTableHeadUtilityClass, o)
    },
    TableHeadRoot = styled("thead", {
        name: "MuiTableHead",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({
        display: "table-header-group"
    }),
    tablelvl2 = {
        variant: "head"
    },
    defaultComponent$1 = "thead",
    TableHead = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTableHead"
            }),
            {
                className: j,
                component: _e = defaultComponent$1
            } = $,
            et = _objectWithoutPropertiesLoose$1($, _excluded$8),
            tt = _extends$4({}, $, {
                component: _e
            }),
            nt = useUtilityClasses$6(tt);
        return jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
            value: tablelvl2,
            children: jsxRuntimeExports.jsx(TableHeadRoot, _extends$4({
                as: _e,
                className: clsx(nt.root, j),
                ref: a,
                role: _e === defaultComponent$1 ? null : "rowgroup",
                ownerState: tt
            }, et))
        })
    });

function getToolbarUtilityClass(s) {
    return generateUtilityClass("MuiToolbar", s)
}
generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const _excluded$7 = ["className", "component", "disableGutters", "variant"],
    useUtilityClasses$5 = s => {
        const {
            classes: o,
            disableGutters: a,
            variant: $
        } = s;
        return composeClasses({
            root: ["root", !a && "gutters", $]
        }, getToolbarUtilityClass, o)
    },
    ToolbarRoot = styled("div", {
        name: "MuiToolbar",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, !a.disableGutters && o.gutters, o[a.variant]]
        }
    })(({
        theme: s,
        ownerState: o
    }) => _extends$4({
        position: "relative",
        display: "flex",
        alignItems: "center"
    }, !o.disableGutters && {
        paddingLeft: s.spacing(2),
        paddingRight: s.spacing(2),
        [s.breakpoints.up("sm")]: {
            paddingLeft: s.spacing(3),
            paddingRight: s.spacing(3)
        }
    }, o.variant === "dense" && {
        minHeight: 48
    }), ({
        theme: s,
        ownerState: o
    }) => o.variant === "regular" && s.mixins.toolbar),
    Toolbar = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiToolbar"
            }),
            {
                className: j,
                component: _e = "div",
                disableGutters: et = !1,
                variant: tt = "regular"
            } = $,
            nt = _objectWithoutPropertiesLoose$1($, _excluded$7),
            rt = _extends$4({}, $, {
                component: _e,
                disableGutters: et,
                variant: tt
            }),
            ot = useUtilityClasses$5(rt);
        return jsxRuntimeExports.jsx(ToolbarRoot, _extends$4({
            as: _e,
            className: clsx(ot.root, j),
            ref: a,
            ownerState: rt
        }, nt))
    }),
    KeyboardArrowLeft = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
    }), "KeyboardArrowLeft"),
    KeyboardArrowRight = createSvgIcon$1(jsxRuntimeExports.jsx("path", {
        d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
    }), "KeyboardArrowRight"),
    _excluded$6 = ["backIconButtonProps", "count", "disabled", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton", "slots", "slotProps"],
    TablePaginationActions = reactExports.forwardRef(function(o, a) {
        var $, j, _e, et, tt, nt, rt, ot;
        const {
            backIconButtonProps: st,
            count: lt,
            disabled: ft = !1,
            getItemAriaLabel: yt,
            nextIconButtonProps: bt,
            onPageChange: ht,
            page: vt,
            rowsPerPage: wt,
            showFirstButton: gt,
            showLastButton: At,
            slots: Pt = {},
            slotProps: Bt = {}
        } = o, Lt = _objectWithoutPropertiesLoose$1(o, _excluded$6), Nt = useRtl(), Ut = qt => {
            ht(qt, 0)
        }, Vt = qt => {
            ht(qt, vt - 1)
        }, Ft = qt => {
            ht(qt, vt + 1)
        }, Wt = qt => {
            ht(qt, Math.max(0, Math.ceil(lt / wt) - 1))
        }, Ct = ($ = Pt.firstButton) != null ? $ : IconButton, it = (j = Pt.lastButton) != null ? j : IconButton, at = (_e = Pt.nextButton) != null ? _e : IconButton, mt = (et = Pt.previousButton) != null ? et : IconButton, xt = (tt = Pt.firstButtonIcon) != null ? tt : FirstPageIconDefault, $t = (nt = Pt.lastButtonIcon) != null ? nt : LastPageIconDefault, Rt = (rt = Pt.nextButtonIcon) != null ? rt : KeyboardArrowRight, It = (ot = Pt.previousButtonIcon) != null ? ot : KeyboardArrowLeft, Tt = Nt ? it : Ct, dt = Nt ? at : mt, Et = Nt ? mt : at, Ot = Nt ? Ct : it, Mt = Nt ? Bt.lastButton : Bt.firstButton, jt = Nt ? Bt.nextButton : Bt.previousButton, Qt = Nt ? Bt.previousButton : Bt.nextButton, Kt = Nt ? Bt.firstButton : Bt.lastButton;
        return jsxRuntimeExports.jsxs("div", _extends$4({
            ref: a
        }, Lt, {
            children: [gt && jsxRuntimeExports.jsx(Tt, _extends$4({
                onClick: Ut,
                disabled: ft || vt === 0,
                "aria-label": yt("first", vt),
                title: yt("first", vt)
            }, Mt, {
                children: Nt ? jsxRuntimeExports.jsx($t, _extends$4({}, Bt.lastButtonIcon)) : jsxRuntimeExports.jsx(xt, _extends$4({}, Bt.firstButtonIcon))
            })), jsxRuntimeExports.jsx(dt, _extends$4({
                onClick: Vt,
                disabled: ft || vt === 0,
                color: "inherit",
                "aria-label": yt("previous", vt),
                title: yt("previous", vt)
            }, jt ? ? st, {
                children: Nt ? jsxRuntimeExports.jsx(Rt, _extends$4({}, Bt.nextButtonIcon)) : jsxRuntimeExports.jsx(It, _extends$4({}, Bt.previousButtonIcon))
            })), jsxRuntimeExports.jsx(Et, _extends$4({
                onClick: Ft,
                disabled: ft || (lt !== -1 ? vt >= Math.ceil(lt / wt) - 1 : !1),
                color: "inherit",
                "aria-label": yt("next", vt),
                title: yt("next", vt)
            }, Qt ? ? bt, {
                children: Nt ? jsxRuntimeExports.jsx(It, _extends$4({}, Bt.previousButtonIcon)) : jsxRuntimeExports.jsx(Rt, _extends$4({}, Bt.nextButtonIcon))
            })), At && jsxRuntimeExports.jsx(Ot, _extends$4({
                onClick: Wt,
                disabled: ft || vt >= Math.ceil(lt / wt) - 1,
                "aria-label": yt("last", vt),
                title: yt("last", vt)
            }, Kt, {
                children: Nt ? jsxRuntimeExports.jsx(xt, _extends$4({}, Bt.firstButtonIcon)) : jsxRuntimeExports.jsx($t, _extends$4({}, Bt.lastButtonIcon))
            }))]
        }))
    });

function getTablePaginationUtilityClass(s) {
    return generateUtilityClass("MuiTablePagination", s)
}
const tablePaginationClasses = generateUtilityClasses("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
var _InputBase;
const _excluded$5 = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "disabled", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton", "slotProps", "slots"],
    TablePaginationRoot = styled(TableCell, {
        name: "MuiTablePagination",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })(({
        theme: s
    }) => ({
        overflow: "auto",
        color: (s.vars || s).palette.text.primary,
        fontSize: s.typography.pxToRem(14),
        "&:last-child": {
            padding: 0
        }
    })),
    TablePaginationToolbar = styled(Toolbar, {
        name: "MuiTablePagination",
        slot: "Toolbar",
        overridesResolver: (s, o) => _extends$4({
            [`& .${tablePaginationClasses.actions}`]: o.actions
        }, o.toolbar)
    })(({
        theme: s
    }) => ({
        minHeight: 52,
        paddingRight: 2,
        [`${s.breakpoints.up("xs")} and (orientation: landscape)`]: {
            minHeight: 52
        },
        [s.breakpoints.up("sm")]: {
            minHeight: 52,
            paddingRight: 2
        },
        [`& .${tablePaginationClasses.actions}`]: {
            flexShrink: 0,
            marginLeft: 20
        }
    })),
    TablePaginationSpacer = styled("div", {
        name: "MuiTablePagination",
        slot: "Spacer",
        overridesResolver: (s, o) => o.spacer
    })({
        flex: "1 1 100%"
    }),
    TablePaginationSelectLabel = styled("p", {
        name: "MuiTablePagination",
        slot: "SelectLabel",
        overridesResolver: (s, o) => o.selectLabel
    })(({
        theme: s
    }) => _extends$4({}, s.typography.body2, {
        flexShrink: 0
    })),
    TablePaginationSelect = styled(Select, {
        name: "MuiTablePagination",
        slot: "Select",
        overridesResolver: (s, o) => _extends$4({
            [`& .${tablePaginationClasses.selectIcon}`]: o.selectIcon,
            [`& .${tablePaginationClasses.select}`]: o.select
        }, o.input, o.selectRoot)
    })({
        color: "inherit",
        fontSize: "inherit",
        flexShrink: 0,
        marginRight: 32,
        marginLeft: 8,
        [`& .${tablePaginationClasses.select}`]: {
            paddingLeft: 8,
            paddingRight: 24,
            textAlign: "right",
            textAlignLast: "right"
        }
    }),
    TablePaginationMenuItem = styled(MenuItem, {
        name: "MuiTablePagination",
        slot: "MenuItem",
        overridesResolver: (s, o) => o.menuItem
    })({}),
    TablePaginationDisplayedRows = styled("p", {
        name: "MuiTablePagination",
        slot: "DisplayedRows",
        overridesResolver: (s, o) => o.displayedRows
    })(({
        theme: s
    }) => _extends$4({}, s.typography.body2, {
        flexShrink: 0
    }));

function defaultLabelDisplayedRows({
    from: s,
    to: o,
    count: a
}) {
    return `${s}–${o} of ${a!==-1?a:`more than ${o}`}`
}

function defaultGetAriaLabel(s) {
    return `Go to ${s} page`
}
const useUtilityClasses$4 = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"],
            toolbar: ["toolbar"],
            spacer: ["spacer"],
            selectLabel: ["selectLabel"],
            select: ["select"],
            input: ["input"],
            selectIcon: ["selectIcon"],
            menuItem: ["menuItem"],
            displayedRows: ["displayedRows"],
            actions: ["actions"]
        }, getTablePaginationUtilityClass, o)
    },
    TablePagination = reactExports.forwardRef(function(o, a) {
        var $;
        const j = useDefaultProps({
                props: o,
                name: "MuiTablePagination"
            }),
            {
                ActionsComponent: _e = TablePaginationActions,
                backIconButtonProps: et,
                className: tt,
                colSpan: nt,
                component: rt = TableCell,
                count: ot,
                disabled: st = !1,
                getItemAriaLabel: lt = defaultGetAriaLabel,
                labelDisplayedRows: ft = defaultLabelDisplayedRows,
                labelRowsPerPage: yt = "Rows per page:",
                nextIconButtonProps: bt,
                onPageChange: ht,
                onRowsPerPageChange: vt,
                page: wt,
                rowsPerPage: gt,
                rowsPerPageOptions: At = [10, 25, 50, 100],
                SelectProps: Pt = {},
                showFirstButton: Bt = !1,
                showLastButton: Lt = !1,
                slotProps: Nt = {},
                slots: Ut = {}
            } = j,
            Vt = _objectWithoutPropertiesLoose$1(j, _excluded$5),
            Ft = j,
            Wt = useUtilityClasses$4(Ft),
            Ct = ($ = Nt == null ? void 0 : Nt.select) != null ? $ : Pt,
            it = Ct.native ? "option" : TablePaginationMenuItem;
        let at;
        (rt === TableCell || rt === "td") && (at = nt || 1e3);
        const mt = useId(Ct.id),
            xt = useId(Ct.labelId),
            $t = () => ot === -1 ? (wt + 1) * gt : gt === -1 ? ot : Math.min(ot, (wt + 1) * gt);
        return jsxRuntimeExports.jsx(TablePaginationRoot, _extends$4({
            colSpan: at,
            ref: a,
            as: rt,
            ownerState: Ft,
            className: clsx(Wt.root, tt)
        }, Vt, {
            children: jsxRuntimeExports.jsxs(TablePaginationToolbar, {
                className: Wt.toolbar,
                children: [jsxRuntimeExports.jsx(TablePaginationSpacer, {
                    className: Wt.spacer
                }), At.length > 1 && jsxRuntimeExports.jsx(TablePaginationSelectLabel, {
                    className: Wt.selectLabel,
                    id: xt,
                    children: yt
                }), At.length > 1 && jsxRuntimeExports.jsx(TablePaginationSelect, _extends$4({
                    variant: "standard"
                }, !Ct.variant && {
                    input: _InputBase || (_InputBase = jsxRuntimeExports.jsx(InputBase$1, {}))
                }, {
                    value: gt,
                    onChange: vt,
                    id: mt,
                    labelId: xt
                }, Ct, {
                    classes: _extends$4({}, Ct.classes, {
                        root: clsx(Wt.input, Wt.selectRoot, (Ct.classes || {}).root),
                        select: clsx(Wt.select, (Ct.classes || {}).select),
                        icon: clsx(Wt.selectIcon, (Ct.classes || {}).icon)
                    }),
                    disabled: st,
                    children: At.map(Rt => reactExports.createElement(it, _extends$4({}, !isHostComponent(it) && {
                        ownerState: Ft
                    }, {
                        className: Wt.menuItem,
                        key: Rt.label ? Rt.label : Rt,
                        value: Rt.value ? Rt.value : Rt
                    }), Rt.label ? Rt.label : Rt))
                })), jsxRuntimeExports.jsx(TablePaginationDisplayedRows, {
                    className: Wt.displayedRows,
                    children: ft({
                        from: ot === 0 ? 0 : wt * gt + 1,
                        to: $t(),
                        count: ot === -1 ? -1 : ot,
                        page: wt
                    })
                }), jsxRuntimeExports.jsx(_e, {
                    className: Wt.actions,
                    backIconButtonProps: et,
                    count: ot,
                    nextIconButtonProps: bt,
                    onPageChange: ht,
                    page: wt,
                    rowsPerPage: gt,
                    showFirstButton: Bt,
                    showLastButton: Lt,
                    slotProps: Nt.actions,
                    slots: Ut.actions,
                    getItemAriaLabel: lt,
                    disabled: st
                })]
            })
        }))
    });

function getTableRowUtilityClass(s) {
    return generateUtilityClass("MuiTableRow", s)
}
const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]),
    _excluded$4 = ["className", "component", "hover", "selected"],
    useUtilityClasses$3 = s => {
        const {
            classes: o,
            selected: a,
            hover: $,
            head: j,
            footer: _e
        } = s;
        return composeClasses({
            root: ["root", a && "selected", $ && "hover", j && "head", _e && "footer"]
        }, getTableRowUtilityClass, o)
    },
    TableRowRoot = styled("tr", {
        name: "MuiTableRow",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.head && o.head, a.footer && o.footer]
        }
    })(({
        theme: s
    }) => ({
        color: "inherit",
        display: "table-row",
        verticalAlign: "middle",
        outline: 0,
        [`&.${tableRowClasses.hover}:hover`]: {
            backgroundColor: (s.vars || s).palette.action.hover
        },
        [`&.${tableRowClasses.selected}`]: {
            backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / ${s.vars.palette.action.selectedOpacity})` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity),
            "&:hover": {
                backgroundColor: s.vars ? `rgba(${s.vars.palette.primary.mainChannel} / calc(${s.vars.palette.action.selectedOpacity} + ${s.vars.palette.action.hoverOpacity}))` : alpha_1(s.palette.primary.main, s.palette.action.selectedOpacity + s.palette.action.hoverOpacity)
            }
        }
    })),
    defaultComponent = "tr",
    TableRow = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTableRow"
            }),
            {
                className: j,
                component: _e = defaultComponent,
                hover: et = !1,
                selected: tt = !1
            } = $,
            nt = _objectWithoutPropertiesLoose$1($, _excluded$4),
            rt = reactExports.useContext(Tablelvl2Context),
            ot = _extends$4({}, $, {
                component: _e,
                hover: et,
                selected: tt,
                head: rt && rt.variant === "head",
                footer: rt && rt.variant === "footer"
            }),
            st = useUtilityClasses$3(ot);
        return jsxRuntimeExports.jsx(TableRowRoot, _extends$4({
            as: _e,
            ref: a,
            className: clsx(st.root, j),
            role: _e === defaultComponent ? null : "row",
            ownerState: ot
        }, nt))
    });

function easeInOutSin(s) {
    return (1 + Math.sin(Math.PI * s - Math.PI / 2)) / 2
}

function animate(s, o, a, $ = {}, j = () => {}) {
    const {
        ease: _e = easeInOutSin,
        duration: et = 300
    } = $;
    let tt = null;
    const nt = o[s];
    let rt = !1;
    const ot = () => {
            rt = !0
        },
        st = lt => {
            if (rt) {
                j(new Error("Animation cancelled"));
                return
            }
            tt === null && (tt = lt);
            const ft = Math.min(1, (lt - tt) / et);
            if (o[s] = _e(ft) * (a - nt) + nt, ft >= 1) {
                requestAnimationFrame(() => {
                    j(null)
                });
                return
            }
            requestAnimationFrame(st)
        };
    return nt === a ? (j(new Error("Element already at target position")), ot) : (requestAnimationFrame(st), ot)
}
const _excluded$3 = ["onChange"],
    styles = {
        width: 99,
        height: 99,
        position: "absolute",
        top: -9999,
        overflow: "scroll"
    };

function ScrollbarSize(s) {
    const {
        onChange: o
    } = s, a = _objectWithoutPropertiesLoose$1(s, _excluded$3), $ = reactExports.useRef(), j = reactExports.useRef(null), _e = () => {
        $.current = j.current.offsetHeight - j.current.clientHeight
    };
    return useEnhancedEffect(() => {
        const et = debounce$1(() => {
                const nt = $.current;
                _e(), nt !== $.current && o($.current)
            }),
            tt = ownerWindow(j.current);
        return tt.addEventListener("resize", et), () => {
            et.clear(), tt.removeEventListener("resize", et)
        }
    }, [o]), reactExports.useEffect(() => {
        _e(), o($.current)
    }, [o]), jsxRuntimeExports.jsx("div", _extends$4({
        style: styles,
        ref: j
    }, a))
}

function getTabScrollButtonUtilityClass(s) {
    return generateUtilityClass("MuiTabScrollButton", s)
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]),
    _excluded$2 = ["className", "slots", "slotProps", "direction", "orientation", "disabled"],
    useUtilityClasses$2 = s => {
        const {
            classes: o,
            orientation: a,
            disabled: $
        } = s;
        return composeClasses({
            root: ["root", a, $ && "disabled"]
        }, getTabScrollButtonUtilityClass, o)
    },
    TabScrollButtonRoot = styled(ButtonBase, {
        name: "MuiTabScrollButton",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.root, a.orientation && o[a.orientation]]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        width: 40,
        flexShrink: 0,
        opacity: .8,
        [`&.${tabScrollButtonClasses.disabled}`]: {
            opacity: 0
        }
    }, s.orientation === "vertical" && {
        width: "100%",
        height: 40,
        "& svg": {
            transform: `rotate(${s.isRtl?-90:90}deg)`
        }
    })),
    TabScrollButton = reactExports.forwardRef(function(o, a) {
        var $, j;
        const _e = useDefaultProps({
                props: o,
                name: "MuiTabScrollButton"
            }),
            {
                className: et,
                slots: tt = {},
                slotProps: nt = {},
                direction: rt
            } = _e,
            ot = _objectWithoutPropertiesLoose$1(_e, _excluded$2),
            st = useRtl(),
            lt = _extends$4({
                isRtl: st
            }, _e),
            ft = useUtilityClasses$2(lt),
            yt = ($ = tt.StartScrollButtonIcon) != null ? $ : KeyboardArrowLeft,
            bt = (j = tt.EndScrollButtonIcon) != null ? j : KeyboardArrowRight,
            ht = useSlotProps({
                elementType: yt,
                externalSlotProps: nt.startScrollButtonIcon,
                additionalProps: {
                    fontSize: "small"
                },
                ownerState: lt
            }),
            vt = useSlotProps({
                elementType: bt,
                externalSlotProps: nt.endScrollButtonIcon,
                additionalProps: {
                    fontSize: "small"
                },
                ownerState: lt
            });
        return jsxRuntimeExports.jsx(TabScrollButtonRoot, _extends$4({
            component: "div",
            className: clsx(ft.root, et),
            ref: a,
            role: null,
            ownerState: lt,
            tabIndex: null
        }, ot, {
            children: rt === "left" ? jsxRuntimeExports.jsx(yt, _extends$4({}, ht)) : jsxRuntimeExports.jsx(bt, _extends$4({}, vt))
        }))
    });

function getTabsUtilityClass(s) {
    return generateUtilityClass("MuiTabs", s)
}
const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]),
    _excluded$1 = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"],
    nextItem = (s, o) => s === o ? s.firstChild : o && o.nextElementSibling ? o.nextElementSibling : s.firstChild,
    previousItem = (s, o) => s === o ? s.lastChild : o && o.previousElementSibling ? o.previousElementSibling : s.lastChild,
    moveFocus = (s, o, a) => {
        let $ = !1,
            j = a(s, o);
        for (; j;) {
            if (j === s.firstChild) {
                if ($) return;
                $ = !0
            }
            const _e = j.disabled || j.getAttribute("aria-disabled") === "true";
            if (!j.hasAttribute("tabindex") || _e) j = a(s, j);
            else {
                j.focus();
                return
            }
        }
    },
    useUtilityClasses$1 = s => {
        const {
            vertical: o,
            fixed: a,
            hideScrollbar: $,
            scrollableX: j,
            scrollableY: _e,
            centered: et,
            scrollButtonsHideMobile: tt,
            classes: nt
        } = s;
        return composeClasses({
            root: ["root", o && "vertical"],
            scroller: ["scroller", a && "fixed", $ && "hideScrollbar", j && "scrollableX", _e && "scrollableY"],
            flexContainer: ["flexContainer", o && "flexContainerVertical", et && "centered"],
            indicator: ["indicator"],
            scrollButtons: ["scrollButtons", tt && "scrollButtonsHideMobile"],
            scrollableX: [j && "scrollableX"],
            hideScrollbar: [$ && "hideScrollbar"]
        }, getTabsUtilityClass, nt)
    },
    TabsRoot = styled("div", {
        name: "MuiTabs",
        slot: "Root",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [{
                [`& .${tabsClasses.scrollButtons}`]: o.scrollButtons
            }, {
                [`& .${tabsClasses.scrollButtons}`]: a.scrollButtonsHideMobile && o.scrollButtonsHideMobile
            }, o.root, a.vertical && o.vertical]
        }
    })(({
        ownerState: s,
        theme: o
    }) => _extends$4({
        overflow: "hidden",
        minHeight: 48,
        WebkitOverflowScrolling: "touch",
        display: "flex"
    }, s.vertical && {
        flexDirection: "column"
    }, s.scrollButtonsHideMobile && {
        [`& .${tabsClasses.scrollButtons}`]: {
            [o.breakpoints.down("sm")]: {
                display: "none"
            }
        }
    })),
    TabsScroller = styled("div", {
        name: "MuiTabs",
        slot: "Scroller",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.scroller, a.fixed && o.fixed, a.hideScrollbar && o.hideScrollbar, a.scrollableX && o.scrollableX, a.scrollableY && o.scrollableY]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        position: "relative",
        display: "inline-block",
        flex: "1 1 auto",
        whiteSpace: "nowrap"
    }, s.fixed && {
        overflowX: "hidden",
        width: "100%"
    }, s.hideScrollbar && {
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
            display: "none"
        }
    }, s.scrollableX && {
        overflowX: "auto",
        overflowY: "hidden"
    }, s.scrollableY && {
        overflowY: "auto",
        overflowX: "hidden"
    })),
    FlexContainer = styled("div", {
        name: "MuiTabs",
        slot: "FlexContainer",
        overridesResolver: (s, o) => {
            const {
                ownerState: a
            } = s;
            return [o.flexContainer, a.vertical && o.flexContainerVertical, a.centered && o.centered]
        }
    })(({
        ownerState: s
    }) => _extends$4({
        display: "flex"
    }, s.vertical && {
        flexDirection: "column"
    }, s.centered && {
        justifyContent: "center"
    })),
    TabsIndicator = styled("span", {
        name: "MuiTabs",
        slot: "Indicator",
        overridesResolver: (s, o) => o.indicator
    })(({
        ownerState: s,
        theme: o
    }) => _extends$4({
        position: "absolute",
        height: 2,
        bottom: 0,
        width: "100%",
        transition: o.transitions.create()
    }, s.indicatorColor === "primary" && {
        backgroundColor: (o.vars || o).palette.primary.main
    }, s.indicatorColor === "secondary" && {
        backgroundColor: (o.vars || o).palette.secondary.main
    }, s.vertical && {
        height: "100%",
        width: 2,
        right: 0
    })),
    TabsScrollbarSize = styled(ScrollbarSize)({
        overflowX: "auto",
        overflowY: "hidden",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
            display: "none"
        }
    }),
    defaultIndicatorStyle = {},
    Tabs = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTabs"
            }),
            j = useTheme$1(),
            _e = useRtl(),
            {
                "aria-label": et,
                "aria-labelledby": tt,
                action: nt,
                centered: rt = !1,
                children: ot,
                className: st,
                component: lt = "div",
                allowScrollButtonsMobile: ft = !1,
                indicatorColor: yt = "primary",
                onChange: bt,
                orientation: ht = "horizontal",
                ScrollButtonComponent: vt = TabScrollButton,
                scrollButtons: wt = "auto",
                selectionFollowsFocus: gt,
                slots: At = {},
                slotProps: Pt = {},
                TabIndicatorProps: Bt = {},
                TabScrollButtonProps: Lt = {},
                textColor: Nt = "primary",
                value: Ut,
                variant: Vt = "standard",
                visibleScrollbar: Ft = !1
            } = $,
            Wt = _objectWithoutPropertiesLoose$1($, _excluded$1),
            Ct = Vt === "scrollable",
            it = ht === "vertical",
            at = it ? "scrollTop" : "scrollLeft",
            mt = it ? "top" : "left",
            xt = it ? "bottom" : "right",
            $t = it ? "clientHeight" : "clientWidth",
            Rt = it ? "height" : "width",
            It = _extends$4({}, $, {
                component: lt,
                allowScrollButtonsMobile: ft,
                indicatorColor: yt,
                orientation: ht,
                vertical: it,
                scrollButtons: wt,
                textColor: Nt,
                variant: Vt,
                visibleScrollbar: Ft,
                fixed: !Ct,
                hideScrollbar: Ct && !Ft,
                scrollableX: Ct && !it,
                scrollableY: Ct && it,
                centered: rt && !Ct,
                scrollButtonsHideMobile: !ft
            }),
            Tt = useUtilityClasses$1(It),
            dt = useSlotProps({
                elementType: At.StartScrollButtonIcon,
                externalSlotProps: Pt.startScrollButtonIcon,
                ownerState: It
            }),
            Et = useSlotProps({
                elementType: At.EndScrollButtonIcon,
                externalSlotProps: Pt.endScrollButtonIcon,
                ownerState: It
            }),
            [Ot, Mt] = reactExports.useState(!1),
            [jt, Qt] = reactExports.useState(defaultIndicatorStyle),
            [Kt, qt] = reactExports.useState(!1),
            [Jt, Zt] = reactExports.useState(!1),
            [en, ln] = reactExports.useState(!1),
            [cn, un] = reactExports.useState({
                overflow: "hidden",
                scrollbarWidth: 0
            }),
            Nn = new Map,
            hn = reactExports.useRef(null),
            fn = reactExports.useRef(null),
            rn = () => {
                const Xt = hn.current;
                let tn;
                if (Xt) {
                    const sn = Xt.getBoundingClientRect();
                    tn = {
                        clientWidth: Xt.clientWidth,
                        scrollLeft: Xt.scrollLeft,
                        scrollTop: Xt.scrollTop,
                        scrollLeftNormalized: getNormalizedScrollLeft(Xt, _e ? "rtl" : "ltr"),
                        scrollWidth: Xt.scrollWidth,
                        top: sn.top,
                        bottom: sn.bottom,
                        left: sn.left,
                        right: sn.right
                    }
                }
                let pn;
                if (Xt && Ut !== !1) {
                    const sn = fn.current.children;
                    if (sn.length > 0) {
                        const yn = sn[Nn.get(Ut)];
                        pn = yn ? yn.getBoundingClientRect() : null
                    }
                }
                return {
                    tabsMeta: tn,
                    tabMeta: pn
                }
            },
            mn = useEventCallback(() => {
                const {
                    tabsMeta: Xt,
                    tabMeta: tn
                } = rn();
                let pn = 0,
                    sn;
                if (it) sn = "top", tn && Xt && (pn = tn.top - Xt.top + Xt.scrollTop);
                else if (sn = _e ? "right" : "left", tn && Xt) {
                    const Dn = _e ? Xt.scrollLeftNormalized + Xt.clientWidth - Xt.scrollWidth : Xt.scrollLeft;
                    pn = (_e ? -1 : 1) * (tn[sn] - Xt[sn] + Dn)
                }
                const yn = {
                    [sn]: pn,
                    [Rt]: tn ? tn[Rt] : 0
                };
                if (isNaN(jt[sn]) || isNaN(jt[Rt])) Qt(yn);
                else {
                    const Dn = Math.abs(jt[sn] - yn[sn]),
                        wn = Math.abs(jt[Rt] - yn[Rt]);
                    (Dn >= 1 || wn >= 1) && Qt(yn)
                }
            }),
            dn = (Xt, {
                animation: tn = !0
            } = {}) => {
                tn ? animate(at, hn.current, Xt, {
                    duration: j.transitions.duration.standard
                }) : hn.current[at] = Xt
            },
            vn = Xt => {
                let tn = hn.current[at];
                it ? tn += Xt : (tn += Xt * (_e ? -1 : 1), tn *= _e && detectScrollType() === "reverse" ? -1 : 1), dn(tn)
            },
            gn = () => {
                const Xt = hn.current[$t];
                let tn = 0;
                const pn = Array.from(fn.current.children);
                for (let sn = 0; sn < pn.length; sn += 1) {
                    const yn = pn[sn];
                    if (tn + yn[$t] > Xt) {
                        sn === 0 && (tn = Xt);
                        break
                    }
                    tn += yn[$t]
                }
                return tn
            },
            Gt = () => {
                vn(-1 * gn())
            },
            Yt = () => {
                vn(gn())
            },
            nn = reactExports.useCallback(Xt => {
                un({
                    overflow: null,
                    scrollbarWidth: Xt
                })
            }, []),
            St = () => {
                const Xt = {};
                Xt.scrollbarSizeListener = Ct ? jsxRuntimeExports.jsx(TabsScrollbarSize, {
                    onChange: nn,
                    className: clsx(Tt.scrollableX, Tt.hideScrollbar)
                }) : null;
                const pn = Ct && (wt === "auto" && (Kt || Jt) || wt === !0);
                return Xt.scrollButtonStart = pn ? jsxRuntimeExports.jsx(vt, _extends$4({
                    slots: {
                        StartScrollButtonIcon: At.StartScrollButtonIcon
                    },
                    slotProps: {
                        startScrollButtonIcon: dt
                    },
                    orientation: ht,
                    direction: _e ? "right" : "left",
                    onClick: Gt,
                    disabled: !Kt
                }, Lt, {
                    className: clsx(Tt.scrollButtons, Lt.className)
                })) : null, Xt.scrollButtonEnd = pn ? jsxRuntimeExports.jsx(vt, _extends$4({
                    slots: {
                        EndScrollButtonIcon: At.EndScrollButtonIcon
                    },
                    slotProps: {
                        endScrollButtonIcon: Et
                    },
                    orientation: ht,
                    direction: _e ? "left" : "right",
                    onClick: Yt,
                    disabled: !Jt
                }, Lt, {
                    className: clsx(Tt.scrollButtons, Lt.className)
                })) : null, Xt
            },
            ct = useEventCallback(Xt => {
                const {
                    tabsMeta: tn,
                    tabMeta: pn
                } = rn();
                if (!(!pn || !tn)) {
                    if (pn[mt] < tn[mt]) {
                        const sn = tn[at] + (pn[mt] - tn[mt]);
                        dn(sn, {
                            animation: Xt
                        })
                    } else if (pn[xt] > tn[xt]) {
                        const sn = tn[at] + (pn[xt] - tn[xt]);
                        dn(sn, {
                            animation: Xt
                        })
                    }
                }
            }),
            pt = useEventCallback(() => {
                Ct && wt !== !1 && ln(!en)
            });
        reactExports.useEffect(() => {
            const Xt = debounce$1(() => {
                hn.current && mn()
            });
            let tn;
            const pn = Dn => {
                    Dn.forEach(wn => {
                        wn.removedNodes.forEach(_n => {
                            var Un;
                            (Un = tn) == null || Un.unobserve(_n)
                        }), wn.addedNodes.forEach(_n => {
                            var Un;
                            (Un = tn) == null || Un.observe(_n)
                        })
                    }), Xt(), pt()
                },
                sn = ownerWindow(hn.current);
            sn.addEventListener("resize", Xt);
            let yn;
            return typeof ResizeObserver < "u" && (tn = new ResizeObserver(Xt), Array.from(fn.current.children).forEach(Dn => {
                tn.observe(Dn)
            })), typeof MutationObserver < "u" && (yn = new MutationObserver(pn), yn.observe(fn.current, {
                childList: !0
            })), () => {
                var Dn, wn;
                Xt.clear(), sn.removeEventListener("resize", Xt), (Dn = yn) == null || Dn.disconnect(), (wn = tn) == null || wn.disconnect()
            }
        }, [mn, pt]), reactExports.useEffect(() => {
            const Xt = Array.from(fn.current.children),
                tn = Xt.length;
            if (typeof IntersectionObserver < "u" && tn > 0 && Ct && wt !== !1) {
                const pn = Xt[0],
                    sn = Xt[tn - 1],
                    yn = {
                        root: hn.current,
                        threshold: .99
                    },
                    Dn = $n => {
                        qt(!$n[0].isIntersecting)
                    },
                    wn = new IntersectionObserver(Dn, yn);
                wn.observe(pn);
                const _n = $n => {
                        Zt(!$n[0].isIntersecting)
                    },
                    Un = new IntersectionObserver(_n, yn);
                return Un.observe(sn), () => {
                    wn.disconnect(), Un.disconnect()
                }
            }
        }, [Ct, wt, en, ot == null ? void 0 : ot.length]), reactExports.useEffect(() => {
            Mt(!0)
        }, []), reactExports.useEffect(() => {
            mn()
        }), reactExports.useEffect(() => {
            ct(defaultIndicatorStyle !== jt)
        }, [ct, jt]), reactExports.useImperativeHandle(nt, () => ({
            updateIndicator: mn,
            updateScrollButtons: pt
        }), [mn, pt]);
        const kt = jsxRuntimeExports.jsx(TabsIndicator, _extends$4({}, Bt, {
            className: clsx(Tt.indicator, Bt.className),
            ownerState: It,
            style: _extends$4({}, jt, Bt.style)
        }));
        let Dt = 0;
        const zt = reactExports.Children.map(ot, Xt => {
                if (!reactExports.isValidElement(Xt)) return null;
                const tn = Xt.props.value === void 0 ? Dt : Xt.props.value;
                Nn.set(tn, Dt);
                const pn = tn === Ut;
                return Dt += 1, reactExports.cloneElement(Xt, _extends$4({
                    fullWidth: Vt === "fullWidth",
                    indicator: pn && !Ot && kt,
                    selected: pn,
                    selectionFollowsFocus: gt,
                    onChange: bt,
                    textColor: Nt,
                    value: tn
                }, Dt === 1 && Ut === !1 && !Xt.props.tabIndex ? {
                    tabIndex: 0
                } : {}))
            }),
            Ht = Xt => {
                const tn = fn.current,
                    pn = ownerDocument(tn).activeElement;
                if (pn.getAttribute("role") !== "tab") return;
                let yn = ht === "horizontal" ? "ArrowLeft" : "ArrowUp",
                    Dn = ht === "horizontal" ? "ArrowRight" : "ArrowDown";
                switch (ht === "horizontal" && _e && (yn = "ArrowRight", Dn = "ArrowLeft"), Xt.key) {
                    case yn:
                        Xt.preventDefault(), moveFocus(tn, pn, previousItem);
                        break;
                    case Dn:
                        Xt.preventDefault(), moveFocus(tn, pn, nextItem);
                        break;
                    case "Home":
                        Xt.preventDefault(), moveFocus(tn, null, nextItem);
                        break;
                    case "End":
                        Xt.preventDefault(), moveFocus(tn, null, previousItem);
                        break
                }
            },
            an = St();
        return jsxRuntimeExports.jsxs(TabsRoot, _extends$4({
            className: clsx(Tt.root, st),
            ownerState: It,
            ref: a,
            as: lt
        }, Wt, {
            children: [an.scrollButtonStart, an.scrollbarSizeListener, jsxRuntimeExports.jsxs(TabsScroller, {
                className: Tt.scroller,
                ownerState: It,
                style: {
                    overflow: cn.overflow,
                    [it ? `margin${_e?"Left":"Right"}` : "marginBottom"]: Ft ? void 0 : -cn.scrollbarWidth
                },
                ref: hn,
                children: [jsxRuntimeExports.jsx(FlexContainer, {
                    "aria-label": et,
                    "aria-labelledby": tt,
                    "aria-orientation": ht === "vertical" ? "vertical" : null,
                    className: Tt.flexContainer,
                    ownerState: It,
                    onKeyDown: Ht,
                    ref: fn,
                    role: "tablist",
                    children: zt
                }), Ot && kt]
            }), an.scrollButtonEnd]
        }))
    });

function getTextFieldUtilityClass(s) {
    return generateUtilityClass("MuiTextField", s)
}
generateUtilityClasses("MuiTextField", ["root"]);
const _excluded = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"],
    variantComponent = {
        standard: Input,
        filled: FilledInput,
        outlined: OutlinedInput
    },
    useUtilityClasses = s => {
        const {
            classes: o
        } = s;
        return composeClasses({
            root: ["root"]
        }, getTextFieldUtilityClass, o)
    },
    TextFieldRoot = styled(FormControl, {
        name: "MuiTextField",
        slot: "Root",
        overridesResolver: (s, o) => o.root
    })({}),
    TextField = reactExports.forwardRef(function(o, a) {
        const $ = useDefaultProps({
                props: o,
                name: "MuiTextField"
            }),
            {
                autoComplete: j,
                autoFocus: _e = !1,
                children: et,
                className: tt,
                color: nt = "primary",
                defaultValue: rt,
                disabled: ot = !1,
                error: st = !1,
                FormHelperTextProps: lt,
                fullWidth: ft = !1,
                helperText: yt,
                id: bt,
                InputLabelProps: ht,
                inputProps: vt,
                InputProps: wt,
                inputRef: gt,
                label: At,
                maxRows: Pt,
                minRows: Bt,
                multiline: Lt = !1,
                name: Nt,
                onBlur: Ut,
                onChange: Vt,
                onFocus: Ft,
                placeholder: Wt,
                required: Ct = !1,
                rows: it,
                select: at = !1,
                SelectProps: mt,
                type: xt,
                value: $t,
                variant: Rt = "outlined"
            } = $,
            It = _objectWithoutPropertiesLoose$1($, _excluded),
            Tt = _extends$4({}, $, {
                autoFocus: _e,
                color: nt,
                disabled: ot,
                error: st,
                fullWidth: ft,
                multiline: Lt,
                required: Ct,
                select: at,
                variant: Rt
            }),
            dt = useUtilityClasses(Tt),
            Et = {};
        Rt === "outlined" && (ht && typeof ht.shrink < "u" && (Et.notched = ht.shrink), Et.label = At), at && ((!mt || !mt.native) && (Et.id = void 0), Et["aria-describedby"] = void 0);
        const Ot = useId(bt),
            Mt = yt && Ot ? `${Ot}-helper-text` : void 0,
            jt = At && Ot ? `${Ot}-label` : void 0,
            Qt = variantComponent[Rt],
            Kt = jsxRuntimeExports.jsx(Qt, _extends$4({
                "aria-describedby": Mt,
                autoComplete: j,
                autoFocus: _e,
                defaultValue: rt,
                fullWidth: ft,
                multiline: Lt,
                name: Nt,
                rows: it,
                maxRows: Pt,
                minRows: Bt,
                type: xt,
                value: $t,
                id: Ot,
                inputRef: gt,
                onBlur: Ut,
                onChange: Vt,
                onFocus: Ft,
                placeholder: Wt,
                inputProps: vt
            }, Et, wt));
        return jsxRuntimeExports.jsxs(TextFieldRoot, _extends$4({
            className: clsx(dt.root, tt),
            disabled: ot,
            error: st,
            fullWidth: ft,
            ref: a,
            required: Ct,
            color: nt,
            variant: Rt,
            ownerState: Tt
        }, It, {
            children: [At != null && At !== "" && jsxRuntimeExports.jsx(InputLabel, _extends$4({
                htmlFor: Ot,
                id: jt
            }, ht, {
                children: At
            })), at ? jsxRuntimeExports.jsx(Select, _extends$4({
                "aria-describedby": Mt,
                id: Ot,
                labelId: jt,
                value: $t,
                input: Kt
            }, mt, {
                children: et
            })) : Kt, yt && jsxRuntimeExports.jsx(FormHelperText, _extends$4({
                id: Mt
            }, lt, {
                children: yt
            }))]
        }))
    });
var Visibility = {},
    createSvgIcon = {};
const require$$0$1 = getAugmentedNamespace(utils);
var hasRequiredCreateSvgIcon;

function requireCreateSvgIcon() {
    return hasRequiredCreateSvgIcon || (hasRequiredCreateSvgIcon = 1, function(s) {
        "use client";
        Object.defineProperty(s, "__esModule", {
            value: !0
        }), Object.defineProperty(s, "default", {
            enumerable: !0,
            get: function() {
                return o.createSvgIcon
            }
        });
        var o = require$$0$1
    }(createSvgIcon)), createSvgIcon
}
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(Visibility, "__esModule", {
    value: !0
});
var default_1$3 = Visibility.default = void 0,
    _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon()),
    _jsxRuntime$3 = jsxRuntimeExports;
default_1$3 = Visibility.default = (0, _createSvgIcon$3.default)((0, _jsxRuntime$3.jsx)("path", {
    d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5m0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"
}), "Visibility");
var VisibilityOff = {},
    _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(VisibilityOff, "__esModule", {
    value: !0
});
var default_1$2 = VisibilityOff.default = void 0,
    _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon()),
    _jsxRuntime$2 = jsxRuntimeExports;
default_1$2 = VisibilityOff.default = (0, _createSvgIcon$2.default)((0, _jsxRuntime$2.jsx)("path", {
    d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7M2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2m4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3z"
}), "VisibilityOff");
var ExpandLess = {},
    _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(ExpandLess, "__esModule", {
    value: !0
});
var default_1$1 = ExpandLess.default = void 0,
    _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon()),
    _jsxRuntime$1 = jsxRuntimeExports;
default_1$1 = ExpandLess.default = (0, _createSvgIcon$1.default)((0, _jsxRuntime$1.jsx)("path", {
    d: "m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
}), "ExpandLess");
var ExpandMore = {},
    _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(ExpandMore, "__esModule", {
    value: !0
});
var default_1 = ExpandMore.default = void 0,
    _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon()),
    _jsxRuntime = jsxRuntimeExports;
default_1 = ExpandMore.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
    d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
var OwlCarousel$1 = {
    exports: {}
};
(function(module, exports) {
    (function(o, a) {
        module.exports = a(reactExports)
    })(commonjsGlobal$1, function(__WEBPACK_EXTERNAL_MODULE_12__) {
        return function(s) {
            var o = {};

            function a($) {
                if (o[$]) return o[$].exports;
                var j = o[$] = {
                    i: $,
                    l: !1,
                    exports: {}
                };
                return s[$].call(j.exports, j, j.exports, a), j.l = !0, j.exports
            }
            return a.m = s, a.c = o, a.i = function($) {
                return $
            }, a.d = function($, j, _e) {
                a.o($, j) || Object.defineProperty($, j, {
                    configurable: !1,
                    enumerable: !0,
                    get: _e
                })
            }, a.n = function($) {
                var j = $ && $.__esModule ? function() {
                    return $.default
                } : function() {
                    return $
                };
                return a.d(j, "a", j), j
            }, a.o = function($, j) {
                return Object.prototype.hasOwnProperty.call($, j)
            }, a.p = "", a(a.s = 13)
        }([function(module, exports) {
            eval(`// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


//////////////////
// WEBPACK FOOTER
// ./~/node-libs-browser/~/process/browser.js
// module id = 0
// module chunks = 0

//# sourceURL=webpack:///./~/node-libs-browser/~/process/browser.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper \`window\`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a \`window\` with a \`document\`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real \`window\`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., \`typeof document.createElement( "object" ) === "function"\`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., \`Object.create( null )\`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// \`in\` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +
		"*\\\\]",

	pseudos = ":(" + identifier + ")(?:\\\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +
		// 2. simple (capture 6)
		"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]'\\"]*?)" + whitespace + "*\\\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in \`select\`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +
			whitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\\d$/i,

	rnative = /^[^{]+\\{\\s*\\[native \\w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\\0" ) {
				return "\\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever \`document.activeElement\` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\\r\\\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\\"\\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page \`selector#id sibling-combinator selector\` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on \`parent\`
						if ( forward && useCache ) {

							// Seek \`elem\` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking \`elem\` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on \`parent\` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek \`elem\` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by \`matcher\`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element \`*\`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// \`i\` is now the count of elements visited above, and adding it to \`matchedCount\`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., \`matchedCount\`
			// equals \`i\`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" \`i\` allows \`i\` to remain a string only in that
			// case, which will result in a "00" \`matchedCount\` that differs from \`i\` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide \`match\` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control \`resolve\` arguments by letting Array#slice cast boolean \`noValue\` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve \`then\` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// \`value\` parameter was not undefined. An empty jQuery object
			// will result in \`undefined\` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );

var rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// \`name\` and \`type\` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have \`button\` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,
	rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so \`.stop().toggle()\` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use \`1 - ( 0.5 || 0 )\` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed \`false\`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for \`focus(in | out)\` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\\[\\]$/,
	rCRLF = /\\r?\\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\\/\\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\\bxml\\b/,
			html: /\\bhtml/,
			json: /\\bjson\\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\\b(?:java|ecma)script\\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\\?(?=&|$)|\\?\\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
		return jQuery;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


//////////////////
// WEBPACK FOOTER
// ./~/jquery/dist/jquery.js
// module id = 1
// module chunks = 0

//# sourceURL=webpack:///./~/jquery/dist/jquery.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

//////////////////
// WEBPACK FOOTER
// ./~/fbjs/lib/emptyFunction.js
// module id = 2
// module chunks = 0

//# sourceURL=webpack:///./~/fbjs/lib/emptyFunction.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

//////////////////
// WEBPACK FOOTER
// ./~/fbjs/lib/invariant.js
// module id = 3
// module chunks = 0

//# sourceURL=webpack:///./~/fbjs/lib/invariant.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


//////////////////
// WEBPACK FOOTER
// ./~/prop-types/lib/ReactPropTypesSecret.js
// module id = 4
// module chunks = 0

//# sourceURL=webpack:///./~/prop-types/lib/ReactPropTypesSecret.js?`)
        }, function(module, exports) {
            eval(`/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');
	}

	return [content].join('\\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


//////////////////
// WEBPACK FOOTER
// ./~/css-loader/lib/css-base.js
// module id = 5
// module chunks = 0

//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(2);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('\`warning(condition, format, ...args)\` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

//////////////////
// WEBPACK FOOTER
// ./~/fbjs/lib/warning.js
// module id = 6
// module chunks = 0

//# sourceURL=webpack:///./~/fbjs/lib/warning.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(22);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list, options);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list, options) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove, transformResult;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    transformResult = options.transform(obj.css);
	    
	    if (transformResult) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = transformResult;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css. 
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


//////////////////
// WEBPACK FOOTER
// ./~/style-loader/addStyles.js
// module id = 7
// module chunks = 0

//# sourceURL=webpack:///./~/style-loader/addStyles.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {/**
 * Owl Carousel v2.2.0
 * Copyright 2013-2016 David Deutsch
 * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)
 */
/**
 * Owl carousel
 * @version 2.1.6
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 * @todo Lazy Load Icon
 * @todo prevent animationend bubling
 * @todo itemsScaleUp
 * @todo Test Zepto
 * @todo stagePadding calculate wrong active classes
 */
;(function($, window, document, undefined) {

	/**
	 * Creates a carousel.
	 * @class The Owl Carousel.
	 * @public
	 * @param {HTMLElement|jQuery} element - The element to create the carousel for.
	 * @param {Object} [options] - The options
	 */
	function Owl(element, options) {

		/**
		 * Current settings for the carousel.
		 * @public
		 */
		this.settings = null;

		/**
		 * Current options set by the caller including defaults.
		 * @public
		 */
		this.options = $.extend({}, Owl.Defaults, options);

		/**
		 * Plugin element.
		 * @public
		 */
		this.$element = $(element);

		/**
		 * Proxied event handlers.
		 * @protected
		 */
		this._handlers = {};

		/**
		 * References to the running plugins of this carousel.
		 * @protected
		 */
		this._plugins = {};

		/**
		 * Currently suppressed events to prevent them from beeing retriggered.
		 * @protected
		 */
		this._supress = {};

		/**
		 * Absolute current position.
		 * @protected
		 */
		this._current = null;

		/**
		 * Animation speed in milliseconds.
		 * @protected
		 */
		this._speed = null;

		/**
		 * Coordinates of all items in pixel.
		 * @todo The name of this member is missleading.
		 * @protected
		 */
		this._coordinates = [];

		/**
		 * Current breakpoint.
		 * @todo Real media queries would be nice.
		 * @protected
		 */
		this._breakpoint = null;

		/**
		 * Current width of the plugin element.
		 */
		this._width = null;

		/**
		 * All real items.
		 * @protected
		 */
		this._items = [];

		/**
		 * All cloned items.
		 * @protected
		 */
		this._clones = [];

		/**
		 * Merge values of all items.
		 * @todo Maybe this could be part of a plugin.
		 * @protected
		 */
		this._mergers = [];

		/**
		 * Widths of all items.
		 */
		this._widths = [];

		/**
		 * Invalidated parts within the update process.
		 * @protected
		 */
		this._invalidated = {};

		/**
		 * Ordered list of workers for the update process.
		 * @protected
		 */
		this._pipe = [];

		/**
		 * Current state information for the drag operation.
		 * @todo #261
		 * @protected
		 */
		this._drag = {
			time: null,
			target: null,
			pointer: null,
			stage: {
				start: null,
				current: null
			},
			direction: null
		};

		/**
		 * Current state information and their tags.
		 * @type {Object}
		 * @protected
		 */
		this._states = {
			current: {},
			tags: {
				'initializing': [ 'busy' ],
				'animating': [ 'busy' ],
				'dragging': [ 'interacting' ]
			}
		};

		$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {
			this._handlers[handler] = $.proxy(this[handler], this);
		}, this));

		$.each(Owl.Plugins, $.proxy(function(key, plugin) {
			this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
				= new plugin(this);
		}, this));

		$.each(Owl.Workers, $.proxy(function(priority, worker) {
			this._pipe.push({
				'filter': worker.filter,
				'run': $.proxy(worker.run, this)
			});
		}, this));

		this.setup();
		this.initialize();
	}

	/**
	 * Default options for the carousel.
	 * @public
	 */
	Owl.Defaults = {
		items: 3,
		loop: false,
		center: false,
		rewind: false,

		mouseDrag: true,
		touchDrag: true,
		pullDrag: true,
		freeDrag: false,

		margin: 0,
		stagePadding: 0,

		merge: false,
		mergeFit: true,
		autoWidth: false,

		startPosition: 0,
		rtl: false,

		smartSpeed: 250,
		fluidSpeed: false,
		dragEndSpeed: false,

		responsive: {},
		responsiveRefreshRate: 200,
		responsiveBaseElement: window,

		fallbackEasing: 'swing',

		info: false,

		nestedItemSelector: false,
		itemElement: 'div',
		stageElement: 'div',

		refreshClass: 'owl-refresh',
		loadedClass: 'owl-loaded',
		loadingClass: 'owl-loading',
		rtlClass: 'owl-rtl',
		responsiveClass: 'owl-responsive',
		dragClass: 'owl-drag',
		itemClass: 'owl-item',
		stageClass: 'owl-stage',
		stageOuterClass: 'owl-stage-outer',
		grabClass: 'owl-grab'
	};

	/**
	 * Enumeration for width.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
	Owl.Width = {
		Default: 'default',
		Inner: 'inner',
		Outer: 'outer'
	};

	/**
	 * Enumeration for types.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
	Owl.Type = {
		Event: 'event',
		State: 'state'
	};

	/**
	 * Contains all registered plugins.
	 * @public
	 */
	Owl.Plugins = {};

	/**
	 * List of workers involved in the update process.
	 */
	Owl.Workers = [ {
		filter: [ 'width', 'settings' ],
		run: function() {
			this._width = this.$element.width();
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			cache.current = this._items && this._items[this.relative(this._current)];
		}
	}, {
		filter: [ 'items', 'settings' ],
		run: function() {
			this.$stage.children('.cloned').remove();
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var margin = this.settings.margin || '',
				grid = !this.settings.autoWidth,
				rtl = this.settings.rtl,
				css = {
					'width': 'auto',
					'margin-left': rtl ? margin : '',
					'margin-right': rtl ? '' : margin
				};

			!grid && this.$stage.children().css(css);

			cache.css = css;
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
				merge = null,
				iterator = this._items.length,
				grid = !this.settings.autoWidth,
				widths = [];

			cache.items = {
				merge: false,
				width: width
			};

			while (iterator--) {
				merge = this._mergers[iterator];
				merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

				cache.items.merge = merge > 1 || cache.items.merge;

				widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
			}

			this._widths = widths;
		}
	}, {
		filter: [ 'items', 'settings' ],
		run: function() {
			var clones = [],
				items = this._items,
				settings = this.settings,
				view = Math.max(settings.items * 2, 4),
				size = Math.ceil(items.length / 2) * 2,
				repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
				append = '',
				prepend = '';

			repeat /= 2;

			while (repeat--) {
				clones.push(this.normalize(clones.length / 2, true));
				append = append + items[clones[clones.length - 1]][0].outerHTML;
				clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
				prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
			}

			this._clones = clones;

			$(append).addClass('cloned').appendTo(this.$stage);
			$(prepend).addClass('cloned').prependTo(this.$stage);
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function() {
			var rtl = this.settings.rtl ? 1 : -1,
				size = this._clones.length + this._items.length,
				iterator = -1,
				previous = 0,
				current = 0,
				coordinates = [];

			while (++iterator < size) {
				previous = coordinates[iterator - 1] || 0;
				current = this._widths[this.relative(iterator)] + this.settings.margin;
				coordinates.push(previous + current * rtl);
			}

			this._coordinates = coordinates;
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function() {
			var padding = this.settings.stagePadding,
				coordinates = this._coordinates,
				css = {
					'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
					'padding-left': padding || '',
					'padding-right': padding || ''
				};

			this.$stage.css(css);
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var iterator = this._coordinates.length,
				grid = !this.settings.autoWidth,
				items = this.$stage.children();

			if (grid && cache.items.merge) {
				while (iterator--) {
					cache.css.width = this._widths[this.relative(iterator)];
					items.eq(iterator).css(cache.css);
				}
			} else if (grid) {
				cache.css.width = cache.items.width;
				items.css(cache.css);
			}
		}
	}, {
		filter: [ 'items' ],
		run: function() {
			this._coordinates.length < 1 && this.$stage.removeAttr('style');
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
			cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
			this.reset(cache.current);
		}
	}, {
		filter: [ 'position' ],
		run: function() {
			this.animate(this.coordinates(this._current));
		}
	}, {
		filter: [ 'width', 'position', 'items', 'settings' ],
		run: function() {
			var rtl = this.settings.rtl ? 1 : -1,
				padding = this.settings.stagePadding * 2,
				begin = this.coordinates(this.current()) + padding,
				end = begin + this.width() * rtl,
				inner, outer, matches = [], i, n;

			for (i = 0, n = this._coordinates.length; i < n; i++) {
				inner = this._coordinates[i - 1] || 0;
				outer = Math.abs(this._coordinates[i]) + padding * rtl;

				if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
					|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
					matches.push(i);
				}
			}

			this.$stage.children('.active').removeClass('active');
			this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

			if (this.settings.center) {
				this.$stage.children('.center').removeClass('center');
				this.$stage.children().eq(this.current()).addClass('center');
			}
		}
	} ];

	/**
	 * Initializes the carousel.
	 * @protected
	 */
	Owl.prototype.initialize = function() {
		this.enter('initializing');
		this.trigger('initialize');

		this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

		if (this.settings.autoWidth && !this.is('pre-loading')) {
			var imgs, nestedSelector, width;
			imgs = this.$element.find('img');
			nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
			width = this.$element.children(nestedSelector).width();

			if (imgs.length && width <= 0) {
				this.preloadAutoWidthImages(imgs);
			}
		}

		this.$element.addClass(this.options.loadingClass);

		// create stage
		this.$stage = $('<' + this.settings.stageElement + ' class="' + this.settings.stageClass + '"/>')
			.wrap('<div class="' + this.settings.stageOuterClass + '"/>');

		// append stage
		this.$element.append(this.$stage.parent());

		// append content
		this.replace(this.$element.children().not(this.$stage.parent()));

		// check visibility
		if (this.$element.is(':visible')) {
			// update view
			this.refresh();
		} else {
			// invalidate width
			this.invalidate('width');
		}

		this.$element
			.removeClass(this.options.loadingClass)
			.addClass(this.options.loadedClass);

		// register event handlers
		this.registerEventHandlers();

		this.leave('initializing');
		this.trigger('initialized');
	};

	/**
	 * Setups the current settings.
	 * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
	 * @todo Support for media queries by using \`matchMedia\` would be nice.
	 * @public
	 */
	Owl.prototype.setup = function() {
		var viewport = this.viewport(),
			overwrites = this.options.responsive,
			match = -1,
			settings = null;

		if (!overwrites) {
			settings = $.extend({}, this.options);
		} else {
			$.each(overwrites, function(breakpoint) {
				if (breakpoint <= viewport && breakpoint > match) {
					match = Number(breakpoint);
				}
			});

			settings = $.extend({}, this.options, overwrites[match]);
			if (typeof settings.stagePadding === 'function') {
				settings.stagePadding = settings.stagePadding();
			}
			delete settings.responsive;

			// responsive class
			if (settings.responsiveClass) {
				this.$element.attr('class',
					this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)
				);
			}
		}

		this.trigger('change', { property: { name: 'settings', value: settings } });
		this._breakpoint = match;
		this.settings = settings;
		this.invalidate('settings');
		this.trigger('changed', { property: { name: 'settings', value: this.settings } });
	};

	/**
	 * Updates option logic if necessery.
	 * @protected
	 */
	Owl.prototype.optionsLogic = function() {
		if (this.settings.autoWidth) {
			this.settings.stagePadding = false;
			this.settings.merge = false;
		}
	};

	/**
	 * Prepares an item before add.
	 * @todo Rename event parameter \`content\` to \`item\`.
	 * @protected
	 * @returns {jQuery|HTMLElement} - The item container.
	 */
	Owl.prototype.prepare = function(item) {
		var event = this.trigger('prepare', { content: item });

		if (!event.data) {
			event.data = $('<' + this.settings.itemElement + '/>')
				.addClass(this.options.itemClass).append(item)
		}

		this.trigger('prepared', { content: event.data });

		return event.data;
	};

	/**
	 * Updates the view.
	 * @public
	 */
	Owl.prototype.update = function() {
		var i = 0,
			n = this._pipe.length,
			filter = $.proxy(function(p) { return this[p] }, this._invalidated),
			cache = {};

		while (i < n) {
			if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
				this._pipe[i].run(cache);
			}
			i++;
		}

		this._invalidated = {};

		!this.is('valid') && this.enter('valid');
	};

	/**
	 * Gets the width of the view.
	 * @public
	 * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
	 * @returns {Number} - The width of the view in pixel.
	 */
	Owl.prototype.width = function(dimension) {
		dimension = dimension || Owl.Width.Default;
		switch (dimension) {
			case Owl.Width.Inner:
			case Owl.Width.Outer:
				return this._width;
			default:
				return this._width - this.settings.stagePadding * 2 + this.settings.margin;
		}
	};

	/**
	 * Refreshes the carousel primarily for adaptive purposes.
	 * @public
	 */
	Owl.prototype.refresh = function() {
		this.enter('refreshing');
		this.trigger('refresh');

		this.setup();

		this.optionsLogic();

		this.$element.addClass(this.options.refreshClass);

		this.update();

		this.$element.removeClass(this.options.refreshClass);

		this.leave('refreshing');
		this.trigger('refreshed');
	};

	/**
	 * Checks window \`resize\` event.
	 * @protected
	 */
	Owl.prototype.onThrottledResize = function() {
		window.clearTimeout(this.resizeTimer);
		this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
	};

	/**
	 * Checks window \`resize\` event.
	 * @protected
	 */
	Owl.prototype.onResize = function() {
		if (!this._items.length) {
			return false;
		}

		if (this._width === this.$element.width()) {
			return false;
		}

		if (!this.$element.is(':visible')) {
			return false;
		}

		this.enter('resizing');

		if (this.trigger('resize').isDefaultPrevented()) {
			this.leave('resizing');
			return false;
		}

		this.invalidate('width');

		this.refresh();

		this.leave('resizing');
		this.trigger('resized');
	};

	/**
	 * Registers event handlers.
	 * @todo Check \`msPointerEnabled\`
	 * @todo #261
	 * @protected
	 */
	Owl.prototype.registerEventHandlers = function() {
		if ($.support.transition) {
			this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
		}

		if (this.settings.responsive !== false) {
			this.on(window, 'resize', this._handlers.onThrottledResize);
		}

		if (this.settings.mouseDrag) {
			this.$element.addClass(this.options.dragClass);
			this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
			this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });
		}

		if (this.settings.touchDrag){
			this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
			this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
		}
	};

	/**
	 * Handles \`touchstart\` and \`mousedown\` events.
	 * @todo Horizontal swipe threshold as option
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragStart = function(event) {
		var stage = null;

		if (event.which === 3) {
			return;
		}

		if ($.support.transform) {
			stage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');
			stage = {
				x: stage[stage.length === 16 ? 12 : 4],
				y: stage[stage.length === 16 ? 13 : 5]
			};
		} else {
			stage = this.$stage.position();
			stage = {
				x: this.settings.rtl ?
					stage.left + this.$stage.width() - this.width() + this.settings.margin :
					stage.left,
				y: stage.top
			};
		}

		if (this.is('animating')) {
			$.support.transform ? this.animate(stage.x) : this.$stage.stop()
			this.invalidate('position');
		}

		this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

		this.speed(0);

		this._drag.time = new Date().getTime();
		this._drag.target = $(event.target);
		this._drag.stage.start = stage;
		this._drag.stage.current = stage;
		this._drag.pointer = this.pointer(event);

		$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

		$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
			var delta = this.difference(this._drag.pointer, this.pointer(event));

			$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

			if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
				return;
			}

			event.preventDefault();

			this.enter('dragging');
			this.trigger('drag');
		}, this));
	};

	/**
	 * Handles the \`touchmove\` and \`mousemove\` events.
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragMove = function(event) {
		var minimum = null,
			maximum = null,
			pull = null,
			delta = this.difference(this._drag.pointer, this.pointer(event)),
			stage = this.difference(this._drag.stage.start, delta);

		if (!this.is('dragging')) {
			return;
		}

		event.preventDefault();

		if (this.settings.loop) {
			minimum = this.coordinates(this.minimum());
			maximum = this.coordinates(this.maximum() + 1) - minimum;
			stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
		} else {
			minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
			maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
			pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
			stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
		}

		this._drag.stage.current = stage;

		this.animate(stage.x);
	};

	/**
	 * Handles the \`touchend\` and \`mouseup\` events.
	 * @todo #261
	 * @todo Threshold for click event
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragEnd = function(event) {
		var delta = this.difference(this._drag.pointer, this.pointer(event)),
			stage = this._drag.stage.current,
			direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

		$(document).off('.owl.core');

		this.$element.removeClass(this.options.grabClass);

		if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
			this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
			this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
			this.invalidate('position');
			this.update();

			this._drag.direction = direction;

			if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
				this._drag.target.one('click.owl.core', function() { return false; });
			}
		}

		if (!this.is('dragging')) {
			return;
		}

		this.leave('dragging');
		this.trigger('dragged');
	};

	/**
	 * Gets absolute position of the closest item for a coordinate.
	 * @todo Setting \`freeDrag\` makes \`closest\` not reusable. See #165.
	 * @protected
	 * @param {Number} coordinate - The coordinate in pixel.
	 * @param {String} direction - The direction to check for the closest item. Ether \`left\` or \`right\`.
	 * @return {Number} - The absolute position of the closest item.
	 */
	Owl.prototype.closest = function(coordinate, direction) {
		var position = -1,
			pull = 30,
			width = this.width(),
			coordinates = this.coordinates();

		if (!this.settings.freeDrag) {
			// check closest item
			$.each(coordinates, $.proxy(function(index, value) {
				// on a left pull, check on current index
				if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
					position = index;
				// on a right pull, check on previous index
				// to do so, subtract width from value and set position = index + 1
				} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
					position = index + 1;
				} else if (this.op(coordinate, '<', value)
					&& this.op(coordinate, '>', coordinates[index + 1] || value - width)) {
					position = direction === 'left' ? index + 1 : index;
				}
				return position === -1;
			}, this));
		}

		if (!this.settings.loop) {
			// non loop boundries
			if (this.op(coordinate, '>', coordinates[this.minimum()])) {
				position = coordinate = this.minimum();
			} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
				position = coordinate = this.maximum();
			}
		}

		return position;
	};

	/**
	 * Animates the stage.
	 * @todo #270
	 * @public
	 * @param {Number} coordinate - The coordinate in pixels.
	 */
	Owl.prototype.animate = function(coordinate) {
		var animate = this.speed() > 0;

		this.is('animating') && this.onTransitionEnd();

		if (animate) {
			this.enter('animating');
			this.trigger('translate');
		}

		if ($.support.transform3d && $.support.transition) {
			this.$stage.css({
				transform: 'translate3d(' + coordinate + 'px,0px,0px)',
				transition: (this.speed() / 1000) + 's'
			});
		} else if (animate) {
			this.$stage.animate({
				left: coordinate + 'px'
			}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
		} else {
			this.$stage.css({
				left: coordinate + 'px'
			});
		}
	};

	/**
	 * Checks whether the carousel is in a specific state or not.
	 * @param {String} state - The state to check.
	 * @returns {Boolean} - The flag which indicates if the carousel is busy.
	 */
	Owl.prototype.is = function(state) {
		return this._states.current[state] && this._states.current[state] > 0;
	};

	/**
	 * Sets the absolute position of the current item.
	 * @public
	 * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
	 * @returns {Number} - The absolute position of the current item.
	 */
	Owl.prototype.current = function(position) {
		if (position === undefined) {
			return this._current;
		}

		if (this._items.length === 0) {
			return undefined;
		}

		position = this.normalize(position);

		if (this._current !== position) {
			var event = this.trigger('change', { property: { name: 'position', value: position } });

			if (event.data !== undefined) {
				position = this.normalize(event.data);
			}

			this._current = position;

			this.invalidate('position');

			this.trigger('changed', { property: { name: 'position', value: this._current } });
		}

		return this._current;
	};

	/**
	 * Invalidates the given part of the update routine.
	 * @param {String} [part] - The part to invalidate.
	 * @returns {Array.<String>} - The invalidated parts.
	 */
	Owl.prototype.invalidate = function(part) {
		if ($.type(part) === 'string') {
			this._invalidated[part] = true;
			this.is('valid') && this.leave('valid');
		}
		return $.map(this._invalidated, function(v, i) { return i });
	};

	/**
	 * Resets the absolute position of the current item.
	 * @public
	 * @param {Number} position - The absolute position of the new item.
	 */
	Owl.prototype.reset = function(position) {
		position = this.normalize(position);

		if (position === undefined) {
			return;
		}

		this._speed = 0;
		this._current = position;

		this.suppress([ 'translate', 'translated' ]);

		this.animate(this.coordinates(position));

		this.release([ 'translate', 'translated' ]);
	};

	/**
	 * Normalizes an absolute or a relative position of an item.
	 * @public
	 * @param {Number} position - The absolute or relative position to normalize.
	 * @param {Boolean} [relative=false] - Whether the given position is relative or not.
	 * @returns {Number} - The normalized position.
	 */
	Owl.prototype.normalize = function(position, relative) {
		var n = this._items.length,
			m = relative ? 0 : this._clones.length;

		if (!this.isNumeric(position) || n < 1) {
			position = undefined;
		} else if (position < 0 || position >= n + m) {
			position = ((position - m / 2) % n + n) % n + m / 2;
		}

		return position;
	};

	/**
	 * Converts an absolute position of an item into a relative one.
	 * @public
	 * @param {Number} position - The absolute position to convert.
	 * @returns {Number} - The converted position.
	 */
	Owl.prototype.relative = function(position) {
		position -= this._clones.length / 2;
		return this.normalize(position, true);
	};

	/**
	 * Gets the maximum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
	Owl.prototype.maximum = function(relative) {
		var settings = this.settings,
			maximum = this._coordinates.length,
			iterator,
			reciprocalItemsWidth,
			elementWidth;

		if (settings.loop) {
			maximum = this._clones.length / 2 + this._items.length - 1;
		} else if (settings.autoWidth || settings.merge) {
			iterator = this._items.length;
			reciprocalItemsWidth = this._items[--iterator].width();
			elementWidth = this.$element.width();
			while (iterator--) {
				reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
				if (reciprocalItemsWidth > elementWidth) {
					break;
				}
			}
			maximum = iterator + 1;
		} else if (settings.center) {
			maximum = this._items.length - 1;
		} else {
			maximum = this._items.length - settings.items;
		}

		if (relative) {
			maximum -= this._clones.length / 2;
		}

		return Math.max(maximum, 0);
	};

	/**
	 * Gets the minimum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
	Owl.prototype.minimum = function(relative) {
		return relative ? 0 : this._clones.length / 2;
	};

	/**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
	Owl.prototype.items = function(position) {
		if (position === undefined) {
			return this._items.slice();
		}

		position = this.normalize(position, true);
		return this._items[position];
	};

	/**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
	Owl.prototype.mergers = function(position) {
		if (position === undefined) {
			return this._mergers.slice();
		}

		position = this.normalize(position, true);
		return this._mergers[position];
	};

	/**
	 * Gets the absolute positions of clones for an item.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
	 */
	Owl.prototype.clones = function(position) {
		var odd = this._clones.length / 2,
			even = odd + this._items.length,
			map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };

		if (position === undefined) {
			return $.map(this._clones, function(v, i) { return map(i) });
		}

		return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });
	};

	/**
	 * Sets the current animation speed.
	 * @public
	 * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
	 * @returns {Number} - The current animation speed in milliseconds.
	 */
	Owl.prototype.speed = function(speed) {
		if (speed !== undefined) {
			this._speed = speed;
		}

		return this._speed;
	};

	/**
	 * Gets the coordinate of an item.
	 * @todo The name of this method is missleanding.
	 * @public
	 * @param {Number} position - The absolute position of the item within \`minimum()\` and \`maximum()\`.
	 * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
	 */
	Owl.prototype.coordinates = function(position) {
		var multiplier = 1,
			newPosition = position - 1,
			coordinate;

		if (position === undefined) {
			return $.map(this._coordinates, $.proxy(function(coordinate, index) {
				return this.coordinates(index);
			}, this));
		}

		if (this.settings.center) {
			if (this.settings.rtl) {
				multiplier = -1;
				newPosition = position + 1;
			}

			coordinate = this._coordinates[position];
			coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
		} else {
			coordinate = this._coordinates[newPosition] || 0;
		}

		coordinate = Math.ceil(coordinate);

		return coordinate;
	};

	/**
	 * Calculates the speed for a translation.
	 * @protected
	 * @param {Number} from - The absolute position of the start item.
	 * @param {Number} to - The absolute position of the target item.
	 * @param {Number} [factor=undefined] - The time factor in milliseconds.
	 * @returns {Number} - The time in milliseconds for the translation.
	 */
	Owl.prototype.duration = function(from, to, factor) {
		if (factor === 0) {
			return 0;
		}

		return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
	};

	/**
	 * Slides to the specified item.
	 * @public
	 * @param {Number} position - The position of the item.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.to = function(position, speed) {
		var current = this.current(),
			revert = null,
			distance = position - this.relative(current),
			direction = (distance > 0) - (distance < 0),
			items = this._items.length,
			minimum = this.minimum(),
			maximum = this.maximum();

		if (this.settings.loop) {
			if (!this.settings.rewind && Math.abs(distance) > items / 2) {
				distance += direction * -1 * items;
			}

			position = current + distance;
			revert = ((position - minimum) % items + items) % items + minimum;

			if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
				current = revert - distance;
				position = revert;
				this.reset(current);
			}
		} else if (this.settings.rewind) {
			maximum += 1;
			position = (position % maximum + maximum) % maximum;
		} else {
			position = Math.max(minimum, Math.min(maximum, position));
		}

		this.speed(this.duration(current, position, speed));
		this.current(position);

		if (this.$element.is(':visible')) {
			this.update();
		}
	};

	/**
	 * Slides to the next item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.next = function(speed) {
		speed = speed || false;
		this.to(this.relative(this.current()) + 1, speed);
	};

	/**
	 * Slides to the previous item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.prev = function(speed) {
		speed = speed || false;
		this.to(this.relative(this.current()) - 1, speed);
	};

	/**
	 * Handles the end of an animation.
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onTransitionEnd = function(event) {

		// if css2 animation then event object is undefined
		if (event !== undefined) {
			event.stopPropagation();

			// Catch only owl-stage transitionEnd event
			if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
				return false;
			}
		}

		this.leave('animating');
		this.trigger('translated');
	};

	/**
	 * Gets viewport width.
	 * @protected
	 * @return {Number} - The width in pixel.
	 */
	Owl.prototype.viewport = function() {
		var width;
		if (this.options.responsiveBaseElement !== window) {
			width = $(this.options.responsiveBaseElement).width();
		} else if (window.innerWidth) {
			width = window.innerWidth;
		} else if (document.documentElement && document.documentElement.clientWidth) {
			width = document.documentElement.clientWidth;
		} else {
			throw 'Can not detect viewport width.';
		}
		return width;
	};

	/**
	 * Replaces the current content.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The new content.
	 */
	Owl.prototype.replace = function(content) {
		this.$stage.empty();
		this._items = [];

		if (content) {
			content = (content instanceof jQuery) ? content : $(content);
		}

		if (this.settings.nestedItemSelector) {
			content = content.find('.' + this.settings.nestedItemSelector);
		}

		content.filter(function() {
			return this.nodeType === 1;
		}).each($.proxy(function(index, item) {
			item = this.prepare(item);
			this.$stage.append(item);
			this._items.push(item);
			this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		}, this));

		this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

		this.invalidate('items');
	};

	/**
	 * Adds an item.
	 * @todo Use \`item\` instead of \`content\` for the event arguments.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The item content to add.
	 * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
	 */
	Owl.prototype.add = function(content, position) {
		var current = this.relative(this._current);

		position = position === undefined ? this._items.length : this.normalize(position, true);
		content = content instanceof jQuery ? content : $(content);

		this.trigger('add', { content: content, position: position });

		content = this.prepare(content);

		if (this._items.length === 0 || position === this._items.length) {
			this._items.length === 0 && this.$stage.append(content);
			this._items.length !== 0 && this._items[position - 1].after(content);
			this._items.push(content);
			this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		} else {
			this._items[position].before(content);
			this._items.splice(position, 0, content);
			this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		}

		this._items[current] && this.reset(this._items[current].index());

		this.invalidate('items');

		this.trigger('added', { content: content, position: position });
	};

	/**
	 * Removes an item by its position.
	 * @todo Use \`item\` instead of \`content\` for the event arguments.
	 * @public
	 * @param {Number} position - The relative position of the item to remove.
	 */
	Owl.prototype.remove = function(position) {
		position = this.normalize(position, true);

		if (position === undefined) {
			return;
		}

		this.trigger('remove', { content: this._items[position], position: position });

		this._items[position].remove();
		this._items.splice(position, 1);
		this._mergers.splice(position, 1);

		this.invalidate('items');

		this.trigger('removed', { content: null, position: position });
	};

	/**
	 * Preloads images with auto width.
	 * @todo Replace by a more generic approach
	 * @protected
	 */
	Owl.prototype.preloadAutoWidthImages = function(images) {
		images.each($.proxy(function(i, element) {
			this.enter('pre-loading');
			element = $(element);
			$(new Image()).one('load', $.proxy(function(e) {
				element.attr('src', e.target.src);
				element.css('opacity', 1);
				this.leave('pre-loading');
				!this.is('pre-loading') && !this.is('initializing') && this.refresh();
			}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
		}, this));
	};

	/**
	 * Destroys the carousel.
	 * @public
	 */
	Owl.prototype.destroy = function() {

		this.$element.off('.owl.core');
		this.$stage.off('.owl.core');
		$(document).off('.owl.core');

		if (this.settings.responsive !== false) {
			window.clearTimeout(this.resizeTimer);
			this.off(window, 'resize', this._handlers.onThrottledResize);
		}

		for (var i in this._plugins) {
			this._plugins[i].destroy();
		}

		this.$stage.children('.cloned').remove();

		this.$stage.unwrap();
		this.$stage.children().contents().unwrap();
		this.$stage.children().unwrap();

		this.$element
			.removeClass(this.options.refreshClass)
			.removeClass(this.options.loadingClass)
			.removeClass(this.options.loadedClass)
			.removeClass(this.options.rtlClass)
			.removeClass(this.options.dragClass)
			.removeClass(this.options.grabClass)
			.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))
			.removeData('owl.carousel');
	};

	/**
	 * Operators to calculate right-to-left and left-to-right.
	 * @protected
	 * @param {Number} [a] - The left side operand.
	 * @param {String} [o] - The operator.
	 * @param {Number} [b] - The right side operand.
	 */
	Owl.prototype.op = function(a, o, b) {
		var rtl = this.settings.rtl;
		switch (o) {
			case '<':
				return rtl ? a > b : a < b;
			case '>':
				return rtl ? a < b : a > b;
			case '>=':
				return rtl ? a <= b : a >= b;
			case '<=':
				return rtl ? a >= b : a <= b;
			default:
				break;
		}
	};

	/**
	 * Attaches to an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The event handler to attach.
	 * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
	 */
	Owl.prototype.on = function(element, event, listener, capture) {
		if (element.addEventListener) {
			element.addEventListener(event, listener, capture);
		} else if (element.attachEvent) {
			element.attachEvent('on' + event, listener);
		}
	};

	/**
	 * Detaches from an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The attached event handler to detach.
	 * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
	 */
	Owl.prototype.off = function(element, event, listener, capture) {
		if (element.removeEventListener) {
			element.removeEventListener(event, listener, capture);
		} else if (element.detachEvent) {
			element.detachEvent('on' + event, listener);
		}
	};

	/**
	 * Triggers a public event.
	 * @todo Remove \`status\`, \`relatedTarget\` should be used instead.
	 * @protected
	 * @param {String} name - The event name.
	 * @param {*} [data=null] - The event data.
	 * @param {String} [namespace=carousel] - The event namespace.
	 * @param {String} [state] - The state which is associated with the event.
	 * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
	 * @returns {Event} - The event arguments.
	 */
	Owl.prototype.trigger = function(name, data, namespace, state, enter) {
		var status = {
			item: { count: this._items.length, index: this.current() }
		}, handler = $.camelCase(
			$.grep([ 'on', name, namespace ], function(v) { return v })
				.join('-').toLowerCase()
		), event = $.Event(
			[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),
			$.extend({ relatedTarget: this }, status, data)
		);

		if (!this._supress[name]) {
			$.each(this._plugins, function(name, plugin) {
				if (plugin.onTrigger) {
					plugin.onTrigger(event);
				}
			});

			this.register({ type: Owl.Type.Event, name: name });
			this.$element.trigger(event);

			if (this.settings && typeof this.settings[handler] === 'function') {
				this.settings[handler].call(this, event);
			}
		}

		return event;
	};

	/**
	 * Enters a state.
	 * @param name - The state name.
	 */
	Owl.prototype.enter = function(name) {
		$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
			if (this._states.current[name] === undefined) {
				this._states.current[name] = 0;
			}

			this._states.current[name]++;
		}, this));
	};

	/**
	 * Leaves a state.
	 * @param name - The state name.
	 */
	Owl.prototype.leave = function(name) {
		$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
			this._states.current[name]--;
		}, this));
	};

	/**
	 * Registers an event or state.
	 * @public
	 * @param {Object} object - The event or state to register.
	 */
	Owl.prototype.register = function(object) {
		if (object.type === Owl.Type.Event) {
			if (!$.event.special[object.name]) {
				$.event.special[object.name] = {};
			}

			if (!$.event.special[object.name].owl) {
				var _default = $.event.special[object.name]._default;
				$.event.special[object.name]._default = function(e) {
					if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
						return _default.apply(this, arguments);
					}
					return e.namespace && e.namespace.indexOf('owl') > -1;
				};
				$.event.special[object.name].owl = true;
			}
		} else if (object.type === Owl.Type.State) {
			if (!this._states.tags[object.name]) {
				this._states.tags[object.name] = object.tags;
			} else {
				this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
			}

			this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
				return $.inArray(tag, this._states.tags[object.name]) === i;
			}, this));
		}
	};

	/**
	 * Suppresses events.
	 * @protected
	 * @param {Array.<String>} events - The events to suppress.
	 */
	Owl.prototype.suppress = function(events) {
		$.each(events, $.proxy(function(index, event) {
			this._supress[event] = true;
		}, this));
	};

	/**
	 * Releases suppressed events.
	 * @protected
	 * @param {Array.<String>} events - The events to release.
	 */
	Owl.prototype.release = function(events) {
		$.each(events, $.proxy(function(index, event) {
			delete this._supress[event];
		}, this));
	};

	/**
	 * Gets unified pointer coordinates from event.
	 * @todo #261
	 * @protected
	 * @param {Event} - The \`mousedown\` or \`touchstart\` event.
	 * @returns {Object} - Contains \`x\` and \`y\` coordinates of current pointer position.
	 */
	Owl.prototype.pointer = function(event) {
		var result = { x: null, y: null };

		event = event.originalEvent || event || window.event;

		event = event.touches && event.touches.length ?
			event.touches[0] : event.changedTouches && event.changedTouches.length ?
				event.changedTouches[0] : event;

		if (event.pageX) {
			result.x = event.pageX;
			result.y = event.pageY;
		} else {
			result.x = event.clientX;
			result.y = event.clientY;
		}

		return result;
	};

	/**
	 * Determines if the input is a Number or something that can be coerced to a Number
	 * @protected
	 * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
	 * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
	 */
	Owl.prototype.isNumeric = function(number) {
		return !isNaN(parseFloat(number));
	};

	/**
	 * Gets the difference of two vectors.
	 * @todo #261
	 * @protected
	 * @param {Object} - The first vector.
	 * @param {Object} - The second vector.
	 * @returns {Object} - The difference.
	 */
	Owl.prototype.difference = function(first, second) {
		return {
			x: first.x - second.x,
			y: first.y - second.y
		};
	};

	/**
	 * The jQuery Plugin for the Owl Carousel
	 * @todo Navigation plugin \`next\` and \`prev\`
	 * @public
	 */
	$.fn.owlCarousel = function(option) {
		var args = Array.prototype.slice.call(arguments, 1);

		return this.each(function() {
			var $this = $(this),
				data = $this.data('owl.carousel');

			if (!data) {
				data = new Owl(this, typeof option == 'object' && option);
				$this.data('owl.carousel', data);

				$.each([
					'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
				], function(i, event) {
					data.register({ type: Owl.Type.Event, name: event });
					data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {
						if (e.namespace && e.relatedTarget !== this) {
							this.suppress([ event ]);
							data[event].apply(this, [].slice.call(arguments, 1));
							this.release([ event ]);
						}
					}, data));
				});
			}

			if (typeof option == 'string' && option.charAt(0) !== '_') {
				data[option].apply(data, args);
			}
		});
	};

	/**
	 * The constructor for the jQuery Plugin
	 * @public
	 */
	$.fn.owlCarousel.Constructor = Owl;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * AutoRefresh Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the auto refresh plugin.
	 * @class The Auto Refresh Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var AutoRefresh = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Refresh interval.
		 * @protected
		 * @type {number}
		 */
		this._interval = null;

		/**
		 * Whether the element is currently visible or not.
		 * @protected
		 * @type {Boolean}
		 */
		this._visible = null;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoRefresh) {
					this.watch();
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	AutoRefresh.Defaults = {
		autoRefresh: true,
		autoRefreshInterval: 500
	};

	/**
	 * Watches the element.
	 */
	AutoRefresh.prototype.watch = function() {
		if (this._interval) {
			return;
		}

		this._visible = this._core.$element.is(':visible');
		this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
	};

	/**
	 * Refreshes the element.
	 */
	AutoRefresh.prototype.refresh = function() {
		if (this._core.$element.is(':visible') === this._visible) {
			return;
		}

		this._visible = !this._visible;

		this._core.$element.toggleClass('owl-hidden', !this._visible);

		this._visible && (this._core.invalidate('width') && this._core.refresh());
	};

	/**
	 * Destroys the plugin.
	 */
	AutoRefresh.prototype.destroy = function() {
		var handler, property;

		window.clearInterval(this._interval);

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * Lazy Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the lazy plugin.
	 * @class The Lazy Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Lazy = function(carousel) {

		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Already loaded items.
		 * @protected
		 * @type {Array.<jQuery>}
		 */
		this._loaded = [];

		/**
		 * Event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {
				if (!e.namespace) {
					return;
				}

				if (!this._core.settings || !this._core.settings.lazyLoad) {
					return;
				}

				if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
					var settings = this._core.settings,
						n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
						i = ((settings.center && n * -1) || 0),
						position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
						clones = this._core.clones().length,
						load = $.proxy(function(i, v) { this.load(v) }, this);

					while (i++ < n) {
						this.load(clones / 2 + this._core.relative(position));
						clones && $.each(this._core.clones(this._core.relative(position)), load);
						position++;
					}
				}
			}, this)
		};

		// set the default options
		this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

		// register event handler
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	Lazy.Defaults = {
		lazyLoad: false
	};

	/**
	 * Loads all resources of an item at the specified position.
	 * @param {Number} position - The absolute position of the item.
	 * @protected
	 */
	Lazy.prototype.load = function(position) {
		var $item = this._core.$stage.children().eq(position),
			$elements = $item && $item.find('.owl-lazy');

		if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
			return;
		}

		$elements.each($.proxy(function(index, element) {
			var $element = $(element), image,
				url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');

			this._core.trigger('load', { element: $element, url: url }, 'lazy');

			if ($element.is('img')) {
				$element.one('load.owl.lazy', $.proxy(function() {
					$element.css('opacity', 1);
					this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
				}, this)).attr('src', url);
			} else {
				image = new Image();
				image.onload = $.proxy(function() {
					$element.css({
						'background-image': 'url(' + url + ')',
						'opacity': '1'
					});
					this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
				}, this);
				image.src = url;
			}
		}, this));

		this._loaded.push($item.get(0));
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Lazy.prototype.destroy = function() {
		var handler, property;

		for (handler in this.handlers) {
			this._core.$element.off(handler, this.handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * AutoHeight Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the auto height plugin.
	 * @class The Auto Height Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var AutoHeight = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight) {
					this.update();
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight && e.property.name == 'position'){
					this.update();
				}
			}, this),
			'loaded.owl.lazy': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight
					&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
					this.update();
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	AutoHeight.Defaults = {
		autoHeight: false,
		autoHeightClass: 'owl-height'
	};

	/**
	 * Updates the view.
	 */
	AutoHeight.prototype.update = function() {
		var start = this._core._current,
			end = start + this._core.settings.items,
			visible = this._core.$stage.children().toArray().slice(start, end),
			heights = [],
			maxheight = 0;

		$.each(visible, function(index, item) {
			heights.push($(item).height());
		});

		maxheight = Math.max.apply(null, heights);

		this._core.$stage.parent()
			.height(maxheight)
			.addClass(this._core.settings.autoHeightClass);
	};

	AutoHeight.prototype.destroy = function() {
		var handler, property;

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * Video Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the video plugin.
	 * @class The Video Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Video = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Cache all video URLs.
		 * @protected
		 * @type {Object}
		 */
		this._videos = {};

		/**
		 * Current playing item.
		 * @protected
		 * @type {jQuery}
		 */
		this._playing = null;

		/**
		 * All event handlers.
		 * @todo The cloned content removale is too late
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					this._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });
				}
			}, this),
			'resize.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
					e.preventDefault();
				}
			}, this),
			'refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.is('resizing')) {
					this._core.$stage.find('.cloned .owl-video-frame').remove();
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'position' && this._playing) {
					this.stop();
				}
			}, this),
			'prepared.owl.carousel': $.proxy(function(e) {
				if (!e.namespace) {
					return;
				}

				var $element = $(e.content).find('.owl-video');

				if ($element.length) {
					$element.css('display', 'none');
					this.fetch($element, $(e.content));
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Video.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);

		this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
			this.play(e);
		}, this));
	};

	/**
	 * Default options.
	 * @public
	 */
	Video.Defaults = {
		video: false,
		videoHeight: false,
		videoWidth: false
	};

	/**
	 * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {jQuery} item - The item containing the video.
	 */
	Video.prototype.fetch = function(target, item) {
			var type = (function() {
					if (target.attr('data-vimeo-id')) {
						return 'vimeo';
					} else if (target.attr('data-vzaar-id')) {
						return 'vzaar'
					} else {
						return 'youtube';
					}
				})(),
				id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
				width = target.attr('data-width') || this._core.settings.videoWidth,
				height = target.attr('data-height') || this._core.settings.videoHeight,
				url = target.attr('href');

		if (url) {

			/*
					Parses the id's out of the following urls (and probably more):
					https://www.youtube.com/watch?v=:id
					https://youtu.be/:id
					https://vimeo.com/:id
					https://vimeo.com/channels/:channel/:id
					https://vimeo.com/groups/:group/videos/:id
					https://app.vzaar.com/videos/:id

					Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
			*/

			id = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);

			if (id[3].indexOf('youtu') > -1) {
				type = 'youtube';
			} else if (id[3].indexOf('vimeo') > -1) {
				type = 'vimeo';
			} else if (id[3].indexOf('vzaar') > -1) {
				type = 'vzaar';
			} else {
				throw new Error('Video URL not supported.');
			}
			id = id[6];
		} else {
			throw new Error('Missing video URL.');
		}

		this._videos[url] = {
			type: type,
			id: id,
			width: width,
			height: height
		};

		item.attr('data-video', url);

		this.thumbnail(target, this._videos[url]);
	};

	/**
	 * Creates video thumbnail.
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {Object} info - The video info object.
	 * @see \`fetch\`
	 */
	Video.prototype.thumbnail = function(target, video) {
		var tnLink,
			icon,
			path,
			dimensions = video.width && video.height ? 'style="width:' + video.width + 'px;height:' + video.height + 'px;"' : '',
			customTn = target.find('img'),
			srcType = 'src',
			lazyClass = '',
			settings = this._core.settings,
			create = function(path) {
				icon = '<div class="owl-video-play-icon"></div>';

				if (settings.lazyLoad) {
					tnLink = '<div class="owl-video-tn ' + lazyClass + '" ' + srcType + '="' + path + '"></div>';
				} else {
					tnLink = '<div class="owl-video-tn" style="opacity:1;background-image:url(' + path + ')"></div>';
				}
				target.after(tnLink);
				target.after(icon);
			};

		// wrap video content into owl-video-wrapper div
		target.wrap('<div class="owl-video-wrapper"' + dimensions + '></div>');

		if (this._core.settings.lazyLoad) {
			srcType = 'data-src';
			lazyClass = 'owl-lazy';
		}

		// custom thumbnail
		if (customTn.length) {
			create(customTn.attr(srcType));
			customTn.remove();
			return false;
		}

		if (video.type === 'youtube') {
			path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
			create(path);
		} else if (video.type === 'vimeo') {
			$.ajax({
				type: 'GET',
				url: '//vimeo.com/api/v2/video/' + video.id + '.json',
				jsonp: 'callback',
				dataType: 'jsonp',
				success: function(data) {
					path = data[0].thumbnail_large;
					create(path);
				}
			});
		} else if (video.type === 'vzaar') {
			$.ajax({
				type: 'GET',
				url: '//vzaar.com/api/videos/' + video.id + '.json',
				jsonp: 'callback',
				dataType: 'jsonp',
				success: function(data) {
					path = data.framegrab_url;
					create(path);
				}
			});
		}
	};

	/**
	 * Stops the current video.
	 * @public
	 */
	Video.prototype.stop = function() {
		this._core.trigger('stop', null, 'video');
		this._playing.find('.owl-video-frame').remove();
		this._playing.removeClass('owl-video-playing');
		this._playing = null;
		this._core.leave('playing');
		this._core.trigger('stopped', null, 'video');
	};

	/**
	 * Starts the current video.
	 * @public
	 * @param {Event} event - The event arguments.
	 */
	Video.prototype.play = function(event) {
		var target = $(event.target),
			item = target.closest('.' + this._core.settings.itemClass),
			video = this._videos[item.attr('data-video')],
			width = video.width || '100%',
			height = video.height || this._core.$stage.height(),
			html;

		if (this._playing) {
			return;
		}

		this._core.enter('playing');
		this._core.trigger('play', null, 'video');

		item = this._core.items(this._core.relative(item.index()));

		this._core.reset(item.index());

		if (video.type === 'youtube') {
			html = '<iframe width="' + width + '" height="' + height + '" src="//www.youtube.com/embed/' +
				video.id + '?autoplay=1&v=' + video.id + '" frameborder="0" allowfullscreen></iframe>';
		} else if (video.type === 'vimeo') {
			html = '<iframe src="//player.vimeo.com/video/' + video.id +
				'?autoplay=1" width="' + width + '" height="' + height +
				'" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
		} else if (video.type === 'vzaar') {
			html = '<iframe frameborder="0"' + 'height="' + height + '"' + 'width="' + width +
				'" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +
				'src="//view.vzaar.com/' + video.id + '/player?autoplay=true"></iframe>';
		}

		$('<div class="owl-video-frame">' + html + '</div>').insertAfter(item.find('.owl-video'));

		this._playing = item.addClass('owl-video-playing');
	};

	/**
	 * Checks whether an video is currently in full screen mode or not.
	 * @todo Bad style because looks like a readonly method but changes members.
	 * @protected
	 * @returns {Boolean}
	 */
	Video.prototype.isInFullScreen = function() {
		var element = document.fullscreenElement || document.mozFullScreenElement ||
				document.webkitFullscreenElement;

		return element && $(element).parent().hasClass('owl-video-frame');
	};

	/**
	 * Destroys the plugin.
	 */
	Video.prototype.destroy = function() {
		var handler, property;

		this._core.$element.off('click.owl.video');

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Video = Video;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * Animate Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the animate plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
	var Animate = function(scope) {
		this.core = scope;
		this.core.options = $.extend({}, Animate.Defaults, this.core.options);
		this.swapping = true;
		this.previous = undefined;
		this.next = undefined;

		this.handlers = {
			'change.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name == 'position') {
					this.previous = this.core.current();
					this.next = e.property.value;
				}
			}, this),
			'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					this.swapping = e.type == 'translated';
				}
			}, this),
			'translate.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
					this.swap();
				}
			}, this)
		};

		this.core.$element.on(this.handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	Animate.Defaults = {
		animateOut: false,
		animateIn: false
	};

	/**
	 * Toggles the animation classes whenever an translations starts.
	 * @protected
	 * @returns {Boolean|undefined}
	 */
	Animate.prototype.swap = function() {

		if (this.core.settings.items !== 1) {
			return;
		}

		if (!$.support.animation || !$.support.transition) {
			return;
		}

		this.core.speed(0);

		var left,
			clear = $.proxy(this.clear, this),
			previous = this.core.$stage.children().eq(this.previous),
			next = this.core.$stage.children().eq(this.next),
			incoming = this.core.settings.animateIn,
			outgoing = this.core.settings.animateOut;

		if (this.core.current() === this.previous) {
			return;
		}

		if (outgoing) {
			left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
			previous.one($.support.animation.end, clear)
				.css( { 'left': left + 'px' } )
				.addClass('animated owl-animated-out')
				.addClass(outgoing);
		}

		if (incoming) {
			next.one($.support.animation.end, clear)
				.addClass('animated owl-animated-in')
				.addClass(incoming);
		}
	};

	Animate.prototype.clear = function(e) {
		$(e.target).css( { 'left': '' } )
			.removeClass('animated owl-animated-out owl-animated-in')
			.removeClass(this.core.settings.animateIn)
			.removeClass(this.core.settings.animateOut);
		this.core.onTransitionEnd();
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Animate.prototype.destroy = function() {
		var handler, property;

		for (handler in this.handlers) {
			this.core.$element.off(handler, this.handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * Autoplay Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the autoplay plugin.
	 * @class The Autoplay Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
	var Autoplay = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * The autoplay timeout.
		 * @type {Timeout}
		 */
		this._timeout = null;

		/**
		 * Indicates whenever the autoplay is paused.
		 * @type {Boolean}
		 */
		this._paused = false;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'settings') {
					if (this._core.settings.autoplay) {
						this.play();
					} else {
						this.stop();
					}
				} else if (e.namespace && e.property.name === 'position') {
					//console.log('play?', e);
					if (this._core.settings.autoplay) {
						this._setAutoPlayInterval();
					}
				}
			}, this),
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoplay) {
					this.play();
				}
			}, this),
			'play.owl.autoplay': $.proxy(function(e, t, s) {
				if (e.namespace) {
					this.play(t, s);
				}
			}, this),
			'stop.owl.autoplay': $.proxy(function(e) {
				if (e.namespace) {
					this.stop();
				}
			}, this),
			'mouseover.owl.autoplay': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.pause();
				}
			}, this),
			'mouseleave.owl.autoplay': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.play();
				}
			}, this),
			'touchstart.owl.core': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.pause();
				}
			}, this),
			'touchend.owl.core': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause) {
					this.play();
				}
			}, this)
		};

		// register event handlers
		this._core.$element.on(this._handlers);

		// set default options
		this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
	};

	/**
	 * Default options.
	 * @public
	 */
	Autoplay.Defaults = {
		autoplay: false,
		autoplayTimeout: 5000,
		autoplayHoverPause: false,
		autoplaySpeed: false
	};

	/**
	 * Starts the autoplay.
	 * @public
	 * @param {Number} [timeout] - The interval before the next animation starts.
	 * @param {Number} [speed] - The animation speed for the animations.
	 */
	Autoplay.prototype.play = function(timeout, speed) {
		this._paused = false;

		if (this._core.is('rotating')) {
			return;
		}

		this._core.enter('rotating');

		this._setAutoPlayInterval();
	};

	/**
	 * Gets a new timeout
	 * @private
	 * @param {Number} [timeout] - The interval before the next animation starts.
	 * @param {Number} [speed] - The animation speed for the animations.
	 * @return {Timeout}
	 */
	Autoplay.prototype._getNextTimeout = function(timeout, speed) {
		if ( this._timeout ) {
			window.clearTimeout(this._timeout);
		}
		return window.setTimeout($.proxy(function() {
			if (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {
				return;
			}
			this._core.next(speed || this._core.settings.autoplaySpeed);
		}, this), timeout || this._core.settings.autoplayTimeout);
	};

	/**
	 * Sets autoplay in motion.
	 * @private
	 */
	Autoplay.prototype._setAutoPlayInterval = function() {
		this._timeout = this._getNextTimeout();
	};

	/**
	 * Stops the autoplay.
	 * @public
	 */
	Autoplay.prototype.stop = function() {
		if (!this._core.is('rotating')) {
			return;
		}

		window.clearTimeout(this._timeout);
		this._core.leave('rotating');
	};

	/**
	 * Stops the autoplay.
	 * @public
	 */
	Autoplay.prototype.pause = function() {
		if (!this._core.is('rotating')) {
			return;
		}

		this._paused = true;
	};

	/**
	 * Destroys the plugin.
	 */
	Autoplay.prototype.destroy = function() {
		var handler, property;

		this.stop();

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * Navigation Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
	'use strict';

	/**
	 * Creates the navigation plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} carousel - The Owl Carousel.
	 */
	var Navigation = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Indicates whether the plugin is initialized or not.
		 * @protected
		 * @type {Boolean}
		 */
		this._initialized = false;

		/**
		 * The current paging indexes.
		 * @protected
		 * @type {Array}
		 */
		this._pages = [];

		/**
		 * All DOM elements of the user interface.
		 * @protected
		 * @type {Object}
		 */
		this._controls = {};

		/**
		 * Markup for an indicator.
		 * @protected
		 * @type {Array.<String>}
		 */
		this._templates = [];

		/**
		 * The carousel element.
		 * @type {jQuery}
		 */
		this.$element = this._core.$element;

		/**
		 * Overridden methods of the carousel.
		 * @protected
		 * @type {Object}
		 */
		this._overrides = {
			next: this._core.next,
			prev: this._core.prev,
			to: this._core.to
		};

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'prepared.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
						$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
				}
			}, this),
			'added.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.splice(e.position, 0, this._templates.pop());
				}
			}, this),
			'remove.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.splice(e.position, 1);
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name == 'position') {
					this.draw();
				}
			}, this),
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && !this._initialized) {
					this._core.trigger('initialize', null, 'navigation');
					this.initialize();
					this.update();
					this.draw();
					this._initialized = true;
					this._core.trigger('initialized', null, 'navigation');
				}
			}, this),
			'refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._initialized) {
					this._core.trigger('refresh', null, 'navigation');
					this.update();
					this.draw();
					this._core.trigger('refreshed', null, 'navigation');
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

		// register event handlers
		this.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 * @todo Rename \`slideBy\` to \`navBy\`
	 */
	Navigation.Defaults = {
		nav: false,
		navText: [ 'prev', 'next' ],
		navSpeed: false,
		navElement: 'div',
		navContainer: false,
		navContainerClass: 'owl-nav',
		navClass: [ 'owl-prev', 'owl-next' ],
		slideBy: 1,
		dotClass: 'owl-dot',
		dotsClass: 'owl-dots',
		dots: true,
		dotsEach: false,
		dotsData: false,
		dotsSpeed: false,
		dotsContainer: false
	};

	/**
	 * Initializes the layout of the plugin and extends the carousel.
	 * @protected
	 */
	Navigation.prototype.initialize = function() {
		var override,
			settings = this._core.settings;

		// create DOM structure for relative navigation
		this._controls.$relative = (settings.navContainer ? $(settings.navContainer)
			: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');

		this._controls.$previous = $('<' + settings.navElement + '>')
			.addClass(settings.navClass[0])
			.html(settings.navText[0])
			.prependTo(this._controls.$relative)
			.on('click', $.proxy(function(e) {
				this.prev(settings.navSpeed);
			}, this));
		this._controls.$next = $('<' + settings.navElement + '>')
			.addClass(settings.navClass[1])
			.html(settings.navText[1])
			.appendTo(this._controls.$relative)
			.on('click', $.proxy(function(e) {
				this.next(settings.navSpeed);
			}, this));

		// create DOM structure for absolute navigation
		if (!settings.dotsData) {
			this._templates = [ $('<div>')
				.addClass(settings.dotClass)
				.append($('<span>'))
				.prop('outerHTML') ];
		}

		this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)
			: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

		this._controls.$absolute.on('click', 'div', $.proxy(function(e) {
			var index = $(e.target).parent().is(this._controls.$absolute)
				? $(e.target).index() : $(e.target).parent().index();

			e.preventDefault();

			this.to(index, settings.dotsSpeed);
		}, this));

		// override public methods of the carousel
		for (override in this._overrides) {
			this._core[override] = $.proxy(this[override], this);
		}
	};

	/**
	 * Destroys the plugin.
	 * @protected
	 */
	Navigation.prototype.destroy = function() {
		var handler, control, property, override;

		for (handler in this._handlers) {
			this.$element.off(handler, this._handlers[handler]);
		}
		for (control in this._controls) {
			this._controls[control].remove();
		}
		for (override in this.overides) {
			this._core[override] = this._overrides[override];
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	/**
	 * Updates the internal state.
	 * @protected
	 */
	Navigation.prototype.update = function() {
		var i, j, k,
			lower = this._core.clones().length / 2,
			upper = lower + this._core.items().length,
			maximum = this._core.maximum(true),
			settings = this._core.settings,
			size = settings.center || settings.autoWidth || settings.dotsData
				? 1 : settings.dotsEach || settings.items;

		if (settings.slideBy !== 'page') {
			settings.slideBy = Math.min(settings.slideBy, settings.items);
		}

		if (settings.dots || settings.slideBy == 'page') {
			this._pages = [];

			for (i = lower, j = 0, k = 0; i < upper; i++) {
				if (j >= size || j === 0) {
					this._pages.push({
						start: Math.min(maximum, i - lower),
						end: i - lower + size - 1
					});
					if (Math.min(maximum, i - lower) === maximum) {
						break;
					}
					j = 0, ++k;
				}
				j += this._core.mergers(this._core.relative(i));
			}
		}
	};

	/**
	 * Draws the user interface.
	 * @todo The option \`dotsData\` wont work.
	 * @protected
	 */
	Navigation.prototype.draw = function() {
		var difference,
			settings = this._core.settings,
			disabled = this._core.items().length <= settings.items,
			index = this._core.relative(this._core.current()),
			loop = settings.loop || settings.rewind;

		this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

		if (settings.nav) {
			this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
			this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
		}

		this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

		if (settings.dots) {
			difference = this._pages.length - this._controls.$absolute.children().length;

			if (settings.dotsData && difference !== 0) {
				this._controls.$absolute.html(this._templates.join(''));
			} else if (difference > 0) {
				this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
			} else if (difference < 0) {
				this._controls.$absolute.children().slice(difference).remove();
			}

			this._controls.$absolute.find('.active').removeClass('active');
			this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
		}
	};

	/**
	 * Extends event data.
	 * @protected
	 * @param {Event} event - The event object which gets thrown.
	 */
	Navigation.prototype.onTrigger = function(event) {
		var settings = this._core.settings;

		event.page = {
			index: $.inArray(this.current(), this._pages),
			count: this._pages.length,
			size: settings && (settings.center || settings.autoWidth || settings.dotsData
				? 1 : settings.dotsEach || settings.items)
		};
	};

	/**
	 * Gets the current page position of the carousel.
	 * @protected
	 * @returns {Number}
	 */
	Navigation.prototype.current = function() {
		var current = this._core.relative(this._core.current());
		return $.grep(this._pages, $.proxy(function(page, index) {
			return page.start <= current && page.end >= current;
		}, this)).pop();
	};

	/**
	 * Gets the current succesor/predecessor position.
	 * @protected
	 * @returns {Number}
	 */
	Navigation.prototype.getPosition = function(successor) {
		var position, length,
			settings = this._core.settings;

		if (settings.slideBy == 'page') {
			position = $.inArray(this.current(), this._pages);
			length = this._pages.length;
			successor ? ++position : --position;
			position = this._pages[((position % length) + length) % length].start;
		} else {
			position = this._core.relative(this._core.current());
			length = this._core.items().length;
			successor ? position += settings.slideBy : position -= settings.slideBy;
		}

		return position;
	};

	/**
	 * Slides to the next item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
	Navigation.prototype.next = function(speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
	};

	/**
	 * Slides to the previous item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
	Navigation.prototype.prev = function(speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
	};

	/**
	 * Slides to the specified item or page.
	 * @public
	 * @param {Number} position - The position of the item or page.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
	 */
	Navigation.prototype.to = function(position, speed, standard) {
		var length;

		if (!standard && this._pages.length) {
			length = this._pages.length;
			$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
		} else {
			$.proxy(this._overrides.to, this._core)(position, speed);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * Hash Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
	'use strict';

	/**
	 * Creates the hash plugin.
	 * @class The Hash Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Hash = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Hash index for the items.
		 * @protected
		 * @type {Object}
		 */
		this._hashes = {};

		/**
		 * The carousel element.
		 * @type {jQuery}
		 */
		this.$element = this._core.$element;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.startPosition === 'URLHash') {
					$(window).trigger('hashchange.owl.navigation');
				}
			}, this),
			'prepared.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

					if (!hash) {
						return;
					}

					this._hashes[hash] = e.content;
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'position') {
					var current = this._core.items(this._core.relative(this._core.current())),
						hash = $.map(this._hashes, function(item, hash) {
							return item === current ? hash : null;
						}).join();

					if (!hash || window.location.hash.slice(1) === hash) {
						return;
					}

					window.location.hash = hash;
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Hash.Defaults, this._core.options);

		// register the event handlers
		this.$element.on(this._handlers);

		// register event listener for hash navigation
		$(window).on('hashchange.owl.navigation', $.proxy(function(e) {
			var hash = window.location.hash.substring(1),
				items = this._core.$stage.children(),
				position = this._hashes[hash] && items.index(this._hashes[hash]);

			if (position === undefined || position === this._core.current()) {
				return;
			}

			this._core.to(this._core.relative(position), false, true);
		}, this));
	};

	/**
	 * Default options.
	 * @public
	 */
	Hash.Defaults = {
		URLhashListener: false
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Hash.prototype.destroy = function() {
		var handler, property;

		$(window).off('hashchange.owl.navigation');

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/**
 * Support Plugin
 *
 * @version 2.1.0
 * @author Vivid Planet Software GmbH
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	var style = $('<support>').get(0).style,
		prefixes = 'Webkit Moz O ms'.split(' '),
		events = {
			transition: {
				end: {
					WebkitTransition: 'webkitTransitionEnd',
					MozTransition: 'transitionend',
					OTransition: 'oTransitionEnd',
					transition: 'transitionend'
				}
			},
			animation: {
				end: {
					WebkitAnimation: 'webkitAnimationEnd',
					MozAnimation: 'animationend',
					OAnimation: 'oAnimationEnd',
					animation: 'animationend'
				}
			}
		},
		tests = {
			csstransforms: function() {
				return !!test('transform');
			},
			csstransforms3d: function() {
				return !!test('perspective');
			},
			csstransitions: function() {
				return !!test('transition');
			},
			cssanimations: function() {
				return !!test('animation');
			}
		};

	function test(property, prefixed) {
		var result = false,
			upper = property.charAt(0).toUpperCase() + property.slice(1);

		$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {
			if (style[property] !== undefined) {
				result = prefixed ? property : true;
				return false;
			}
		});

		return result;
	}

	function prefixed(property) {
		return test(property, true);
	}

	if (tests.csstransitions()) {
		/* jshint -W053 */
		$.support.transition = new String(prefixed('transition'))
		$.support.transition.end = events.transition.end[ $.support.transition ];
	}

	if (tests.cssanimations()) {
		/* jshint -W053 */
		$.support.animation = new String(prefixed('animation'))
		$.support.animation.end = events.animation.end[ $.support.animation ];
	}

	if (tests.csstransforms()) {
		/* jshint -W053 */
		$.support.transform = new String(prefixed('transform'));
		$.support.transform3d = tests.csstransforms3d();
	}

})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))

//////////////////
// WEBPACK FOOTER
// ./~/owl.carousel/dist/owl.carousel.js
// module id = 8
// module chunks = 0

//# sourceURL=webpack:///./~/owl.carousel/dist/owl.carousel.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using \`prop-types\` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(21)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using \`prop-types\` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(20)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

//////////////////
// WEBPACK FOOTER
// ./~/prop-types/index.js
// module id = 9
// module chunks = 0

//# sourceURL=webpack:///./~/prop-types/index.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(14);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!./owl.carousel.min.css", function() {
			var newContent = require("!!../../../css-loader/index.js!./owl.carousel.min.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

//////////////////
// WEBPACK FOOTER
// ./~/owl.carousel/dist/assets/owl.carousel.min.css
// module id = 10
// module chunks = 0

//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?`)
        }, function(module, exports, __webpack_require__) {
            eval(`// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(15);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!./owl.theme.default.min.css", function() {
			var newContent = require("!!../../../css-loader/index.js!./owl.theme.default.min.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

//////////////////
// WEBPACK FOOTER
// ./~/owl.carousel/dist/assets/owl.theme.default.min.css
// module id = 11
// module chunks = 0

//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?`)
        }, function(module, exports) {
            eval(`module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

//////////////////
// WEBPACK FOOTER
// external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"}
// module id = 12
// module chunks = 0

//# sourceURL=webpack:///external_%7B%22root%22:%22React%22,%22commonjs2%22:%22react%22,%22commonjs%22:%22react%22,%22amd%22:%22react%22%7D?`)
        }, function(module, __webpack_exports__, __webpack_require__) {
            eval(`Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var Owl_Carousel_Options = {

    // options
    items: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
    margin: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
    loop: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    center: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    mouseDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    touchDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    pullDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    freeDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    stagePadding: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
    merge: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    mergeFit: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    autoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    startPosition: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),
    URLhashListener: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    nav: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    rewind: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    navText: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string), __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element)]),
    navElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    slideBy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),
    dots: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    dotsEach: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    dotData: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    lazyLoad: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    lazyContent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    autoplay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    autoplayTimeout: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
    autoplayHoverPause: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    smartSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
    fluidSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    autoplaySpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    navSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    dotsSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    dragEndSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    callbacks: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    responsive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
    responsiveRefreshRate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
    responsiveBaseElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,
    video: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
    videoHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    videoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    animateOut: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    animateIn: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    fallbackEasing: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    info: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    nestedItemSelector: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    itemElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    stageElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    navContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
    dotsContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),

    // dom class
    refreshClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    loadingClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    loadedClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    rtlClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    dragClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    grabClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    stageClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    stageOuterClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    navContainerClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    navClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string),
    controlsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    dotClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    dotsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    autoHeightClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
    responsiveClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),

    // event
    onInitialize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onInitialized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onResize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onResized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onRefresh: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onRefreshed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onDragged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onTranslate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onTranslated: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onChanged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onLoadLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onLoadedLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onStopVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
    onPlayVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
};

var OwlCarousel = function (_Component) {
    _inherits(OwlCarousel, _Component);

    function OwlCarousel(props, context) {
        _classCallCheck(this, OwlCarousel);

        var _this = _possibleConstructorReturn(this, (OwlCarousel.__proto__ || Object.getPrototypeOf(OwlCarousel)).call(this, props, context));

        _this.next = _this.next.bind(_this);
        _this.prev = _this.prev.bind(_this);
        _this.to = _this.to.bind(_this);
        _this.create = _this.create.bind(_this);
        _this.destory = _this.destory.bind(_this);
        _this.play = _this.play.bind(_this);
        _this.stop = _this.stop.bind(_this);
        return _this;
    }

    _createClass(OwlCarousel, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            __webpack_require__(10);
            __webpack_require__(11);
            __webpack_require__(8);

            this._filterProps(this.props);
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.owlCarousel = $(this.inst);
            this.owlCarousel.owlCarousel(this.options);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            this._filterProps(nextProps);
            this.destory();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.owlCarousel = $(this.inst);
            this.owlCarousel.owlCarousel(this.options);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.destory();
        }
    }, {
        key: 'next',
        value: function next(speed) {
            if (typeof speed == 'number') {
                this.owlCarousel.trigger('next.owl.carousel', [speed]);
            } else {
                this.owlCarousel.trigger('next.owl.carousel');
            }
        }
    }, {
        key: 'prev',
        value: function prev(speed) {
            if (typeof speed == 'number') {
                this.owlCarousel.trigger('prev.owl.carousel', [speed]);
            } else {
                this.owlCarousel.trigger('prev.owl.carousel');
            }
        }

        // refresh(event, speed) {
        // }

    }, {
        key: 'to',
        value: function to(position, speed) {
            if (typeof position == 'number' && typeof speed == 'number') {
                this.owlCarousel.trigger('to.owl.carousel', [position, speed]);
            } else {
                this.owlCarousel.trigger('to.owl.carousel');
            }
        }
    }, {
        key: 'create',
        value: function create() {
            this.owlCarousel.owlCarousel(this.options);
        }
    }, {
        key: 'destory',
        value: function destory() {
            this.owlCarousel.trigger('destroy.owl.carousel');
        }

        // replace(data) {

        // }

        // add(data, position) {

        // }

        // remove(position) {

        // }

    }, {
        key: 'play',
        value: function play(timeout, speed) {
            if (typeof timeout == 'number' && typeof speed == 'number') {
                this.owlCarousel.trigger('play.owl.autoplay', [timeout, speed]);
            } else {
                this.owlCarousel.trigger('play.owl.autoplay');
            }
        }
    }, {
        key: 'stop',
        value: function stop() {
            this.owlCarousel.trigger('stop.owl.autoplay');
        }
    }, {
        key: '_filterProps',
        value: function _filterProps(props) {
            var _this2 = this;

            this.options = {};
            this.propsWithoutOptions = {};
            Object.keys(props).forEach(function (key) {
                if (Owl_Carousel_Options.hasOwnProperty(key)) {
                    _this2.options[key] = props[key];
                } else {
                    _this2.propsWithoutOptions[key] = props[key];
                }
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var _propsWithoutOptions = this.propsWithoutOptions,
                className = _propsWithoutOptions.className,
                children = _propsWithoutOptions.children,
                props = _objectWithoutProperties(_propsWithoutOptions, ['className', 'children']);

            return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                'div',
                _extends({
                    className: 'owl-carousel ' + className,
                    ref: function ref(inst) {
                        return _this3.inst = inst;
                    }
                }, props),
                children
            );
        }
    }]);

    return OwlCarousel;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

OwlCarousel.propTypes = Owl_Carousel_Options;

OwlCarousel.defaultProps = {
    className: ''
};

/* harmony default export */ __webpack_exports__["default"] = (OwlCarousel);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

//////////////////
// WEBPACK FOOTER
// ./components/OwlCarousel.jsx
// module id = 13
// module chunks = 0

//# sourceURL=webpack:///./components/OwlCarousel.jsx?`)
        }, function(module, exports, __webpack_require__) {
            eval(`var escape = __webpack_require__(16);
exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, "/**\\n * Owl Carousel v2.2.0\\n * Copyright 2013-2016 David Deutsch\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\n */\\n.owl-carousel,.owl-carousel .owl-item{-webkit-tap-highlight-color:transparent;position:relative}.owl-carousel{display:none;width:100%;z-index:1}.owl-carousel .owl-stage{position:relative;-ms-touch-action:pan-Y}.owl-carousel .owl-stage:after{content:\\".\\";display:block;clear:both;visibility:hidden;line-height:0;height:0}.owl-carousel .owl-stage-outer{position:relative;overflow:hidden;-webkit-transform:translate3d(0,0,0)}.owl-carousel .owl-item{min-height:1px;float:left;-webkit-backface-visibility:hidden;-webkit-touch-callout:none}.owl-carousel .owl-item img{display:block;width:100%;-webkit-transform-style:preserve-3d}.owl-carousel .owl-dots.disabled,.owl-carousel .owl-nav.disabled{display:none}.no-js .owl-carousel,.owl-carousel.owl-loaded{display:block}.owl-carousel .owl-dot,.owl-carousel .owl-nav .owl-next,.owl-carousel .owl-nav .owl-prev{cursor:pointer;cursor:hand;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-loading{opacity:0;display:block}.owl-carousel.owl-hidden{opacity:0}.owl-carousel.owl-refresh .owl-item{visibility:hidden}.owl-carousel.owl-drag .owl-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-grab{cursor:move;cursor:grab}.owl-carousel.owl-rtl{direction:rtl}.owl-carousel.owl-rtl .owl-item{float:right}.owl-carousel .animated{-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.owl-carousel .owl-animated-in{z-index:0}.owl-carousel .owl-animated-out{z-index:1}.owl-carousel .fadeOut{-webkit-animation-name:fadeOut;animation-name:fadeOut}@-webkit-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}@keyframes fadeOut{0%{opacity:1}100%{opacity:0}}.owl-height{transition:height .5s ease-in-out}.owl-carousel .owl-item .owl-lazy{opacity:0;transition:opacity .4s ease}.owl-carousel .owl-item img.owl-lazy{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.owl-carousel .owl-video-wrapper{position:relative;height:100%;background:#000}.owl-carousel .owl-video-play-icon{position:absolute;height:80px;width:80px;left:50%;top:50%;margin-left:-40px;margin-top:-40px;background:url(" + escape(__webpack_require__(17)) + ") no-repeat;cursor:pointer;z-index:1;-webkit-backface-visibility:hidden;transition:-webkit-transform .1s ease;transition:transform .1s ease}.owl-carousel .owl-video-play-icon:hover{-webkit-transform:scale(1.3,1.3);-ms-transform:scale(1.3,1.3);transform:scale(1.3,1.3)}.owl-carousel .owl-video-playing .owl-video-play-icon,.owl-carousel .owl-video-playing .owl-video-tn{display:none}.owl-carousel .owl-video-tn{opacity:0;height:100%;background-position:center center;background-repeat:no-repeat;background-size:contain;transition:opacity .4s ease}.owl-carousel .owl-video-frame{position:relative;z-index:1;height:100%;width:100%}", ""]);

// exports


//////////////////
// WEBPACK FOOTER
// ./~/css-loader!./~/owl.carousel/dist/assets/owl.carousel.min.css
// module id = 14
// module chunks = 0

//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?./~/css-loader`)
        }, function(module, exports, __webpack_require__) {
            eval(`exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, "/**\\n * Owl Carousel v2.2.0\\n * Copyright 2013-2016 David Deutsch\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\n */\\n.owl-theme .owl-dots,.owl-theme .owl-nav{text-align:center;-webkit-tap-highlight-color:transparent}.owl-theme .owl-nav{margin-top:10px}.owl-theme .owl-nav [class*=owl-]{color:#FFF;font-size:14px;margin:5px;padding:4px 7px;background:#D6D6D6;display:inline-block;cursor:pointer;border-radius:3px}.owl-theme .owl-nav [class*=owl-]:hover{background:#869791;color:#FFF;text-decoration:none}.owl-theme .owl-nav .disabled{opacity:.5;cursor:default}.owl-theme .owl-nav.disabled+.owl-dots{margin-top:10px}.owl-theme .owl-dots .owl-dot{display:inline-block;zoom:1}.owl-theme .owl-dots .owl-dot span{width:10px;height:10px;margin:5px 7px;background:#D6D6D6;display:block;-webkit-backface-visibility:visible;transition:opacity .2s ease;border-radius:30px}.owl-theme .owl-dots .owl-dot.active span,.owl-theme .owl-dots .owl-dot:hover span{background:#869791}", ""]);

// exports


//////////////////
// WEBPACK FOOTER
// ./~/css-loader!./~/owl.carousel/dist/assets/owl.theme.default.min.css
// module id = 15
// module chunks = 0

//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?./~/css-loader`)
        }, function(module, exports) {
            eval(`module.exports = function escape(url) {
    if (typeof url !== 'string') {
        return url
    }
    // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        url = url.slice(1, -1);
    }
    // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \\t\\n]/.test(url)) {
        return '"' + url.replace(/"/g, '\\\\"').replace(/\\n/g, '\\\\n') + '"'
    }

    return url
}


//////////////////
// WEBPACK FOOTER
// ./~/css-loader/lib/url/escape.js
// module id = 16
// module chunks = 0

//# sourceURL=webpack:///./~/css-loader/lib/url/escape.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`module.exports = __webpack_require__.p + "4a37f8008959c75f619bf0a3a4e2d7a2.png";

//////////////////
// WEBPACK FOOTER
// ./~/owl.carousel/dist/assets/owl.video.play.png
// module id = 17
// module chunks = 0

//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.video.play.png?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


//////////////////
// WEBPACK FOOTER
// ./~/object-assign/index.js
// module id = 18
// module chunks = 0

//# sourceURL=webpack:///./~/object-assign/index.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(3);
  var warning = __webpack_require__(6);
  var ReactPropTypesSecret = __webpack_require__(4);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type \`%s\` is invalid; it must be a function, usually from ' + 'the \`prop-types\` package, but received \`%s\`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s \`%s\` is invalid; the type checker ' + 'function must return \`null\` or an \`Error\` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

//////////////////
// WEBPACK FOOTER
// ./~/prop-types/checkPropTypes.js
// module id = 19
// module chunks = 0

//# sourceURL=webpack:///./~/prop-types/checkPropTypes.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(2);
var invariant = __webpack_require__(3);
var ReactPropTypesSecret = __webpack_require__(4);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the \`prop-types\` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in \`./factoryWithTypeCheckers.js\`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


//////////////////
// WEBPACK FOOTER
// ./~/prop-types/factoryWithThrowingShims.js
// module id = 20
// module chunks = 0

//# sourceURL=webpack:///./~/prop-types/factoryWithThrowingShims.js?`)
        }, function(module, exports, __webpack_require__) {
            eval(`/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(2);
var invariant = __webpack_require__(3);
var warning = __webpack_require__(6);
var assign = __webpack_require__(18);

var ReactPropTypesSecret = __webpack_require__(4);
var checkPropTypes = __webpack_require__(19);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in \`./factoryWithThrowingShims.js\`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make \`instanceof Error\` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of \`prop-types\` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the \`prop-types\` package. ' +
            'Use \`PropTypes.checkPropTypes()\` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the \`%s\` prop on \`%s\`. This is deprecated ' +
              'and will throw in the standalone \`prop-types\` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' \`' + propFullName + '\` is marked as required ' + ('in \`' + componentName + '\`, but its value is \`null\`.'));
          }
          return new PropTypeError('The ' + location + ' \`' + propFullName + '\` is marked as required in ' + ('\`' + componentName + '\`, but its value is \`undefined\`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // \`propValue\` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type \`object\`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of type ' + ('\`' + preciseType + '\` supplied to \`' + componentName + '\`, expected ') + ('\`' + expectedType + '\`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property \`' + propFullName + '\` of component \`' + componentName + '\` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of type ' + ('\`' + propType + '\` supplied to \`' + componentName + '\`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of type ' + ('\`' + propType + '\` supplied to \`' + componentName + '\`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of type ' + ('\`' + actualClassName + '\` supplied to \`' + componentName + '\`, expected ') + ('instance of \`' + expectedClassName + '\`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of value \`' + propValue + '\` ' + ('supplied to \`' + componentName + '\`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property \`' + propFullName + '\` of component \`' + componentName + '\` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of type ' + ('\`' + propType + '\` supplied to \`' + componentName + '\`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` supplied to ' + ('\`' + componentName + '\`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` supplied to ' + ('\`' + componentName + '\`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of type \`' + propType + '\` ' + ('supplied to \`' + componentName + '\`, expected \`object\`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' \`' + propFullName + '\` of type \`' + propType + '\` ' + ('supplied to \`' + componentName + '\`, expected \`object\`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' \`' + propFullName + '\` key \`' + key + '\` supplied to \`' + componentName + '\`.' +
            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of \`typeof\` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than \`getPropType\`. Only used for error messages.
  // See \`createPrimitiveTypeChecker\`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

//////////////////
// WEBPACK FOOTER
// ./~/prop-types/factoryWithTypeCheckers.js
// module id = 21
// module chunks = 0

//# sourceURL=webpack:///./~/prop-types/factoryWithTypeCheckers.js?`)
        }, function(module, exports) {
            eval(`
/**
 * When source maps are enabled, \`style-loader\` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at \`test/fixUrls.js\` and can be run via the \`npm test\` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \\(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \\(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \\)  = Match a end parentheses
	             )  = End Group
              *\\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \\)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


//////////////////
// WEBPACK FOOTER
// ./~/style-loader/fixUrls.js
// module id = 22
// module chunks = 0

//# sourceURL=webpack:///./~/style-loader/fixUrls.js?`)
        }])
    })
})(OwlCarousel$1);
var OwlCarouselExports = OwlCarousel$1.exports;
const OwlCarousel = getDefaultExportFromCjs$3(OwlCarouselExports),
    MotionConfigContext = reactExports.createContext({
        transformPagePoint: s => s,
        isStatic: !1,
        reducedMotion: "never"
    }),
    MotionContext = reactExports.createContext({}),
    PresenceContext = reactExports.createContext(null),
    isBrowser = typeof window < "u",
    useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect,
    LazyContext = reactExports.createContext({
        strict: !1
    }),
    camelToDash = s => s.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
    optimizedAppearDataId = "framerAppearId",
    optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId),
    MotionGlobalConfig = {
        skipAnimations: !1,
        useManualTiming: !1
    };

function createRenderStep(s) {
    let o = new Set,
        a = new Set,
        $ = !1,
        j = !1;
    const _e = new WeakSet;
    let et = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };

    function tt(rt) {
        _e.has(rt) && (nt.schedule(rt), s()), rt(et)
    }
    const nt = {
        schedule: (rt, ot = !1, st = !1) => {
            const ft = st && $ ? o : a;
            return ot && _e.add(rt), ft.has(rt) || ft.add(rt), rt
        },
        cancel: rt => {
            a.delete(rt), _e.delete(rt)
        },
        process: rt => {
            if (et = rt, $) {
                j = !0;
                return
            }
            $ = !0, [o, a] = [a, o], a.clear(), o.forEach(tt), $ = !1, j && (j = !1, nt.process(rt))
        }
    };
    return nt
}
const stepsOrder = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"],
    maxElapsed = 40;

function createRenderBatcher(s, o) {
    let a = !1,
        $ = !0;
    const j = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        },
        _e = () => a = !0,
        et = stepsOrder.reduce((vt, wt) => (vt[wt] = createRenderStep(_e), vt), {}),
        {
            read: tt,
            resolveKeyframes: nt,
            update: rt,
            preRender: ot,
            render: st,
            postRender: lt
        } = et,
        ft = () => {
            const vt = performance.now();
            a = !1, j.delta = $ ? 1e3 / 60 : Math.max(Math.min(vt - j.timestamp, maxElapsed), 1), j.timestamp = vt, j.isProcessing = !0, tt.process(j), nt.process(j), rt.process(j), ot.process(j), st.process(j), lt.process(j), j.isProcessing = !1, a && o && ($ = !1, s(ft))
        },
        yt = () => {
            a = !0, $ = !0, j.isProcessing || s(ft)
        };
    return {
        schedule: stepsOrder.reduce((vt, wt) => {
            const gt = et[wt];
            return vt[wt] = (At, Pt = !1, Bt = !1) => (a || yt(), gt.schedule(At, Pt, Bt)), vt
        }, {}),
        cancel: vt => {
            for (let wt = 0; wt < stepsOrder.length; wt++) et[stepsOrder[wt]].cancel(vt)
        },
        state: j,
        steps: et
    }
}
const {
    schedule: microtask,
    cancel: cancelMicrotask
} = createRenderBatcher(queueMicrotask, !1);

function isRefObject(s) {
    return s && typeof s == "object" && Object.prototype.hasOwnProperty.call(s, "current")
}
const SwitchLayoutGroupContext = reactExports.createContext({});
let scheduleHandoffComplete = !1;

function useVisualElement(s, o, a, $, j) {
    const {
        visualElement: _e
    } = reactExports.useContext(MotionContext), et = reactExports.useContext(LazyContext), tt = reactExports.useContext(PresenceContext), nt = reactExports.useContext(MotionConfigContext).reducedMotion, rt = reactExports.useRef();
    $ = $ || et.renderer, !rt.current && $ && (rt.current = $(s, {
        visualState: o,
        parent: _e,
        props: a,
        presenceContext: tt,
        blockInitialAnimation: tt ? tt.initial === !1 : !1,
        reducedMotionConfig: nt
    }));
    const ot = rt.current,
        st = reactExports.useContext(SwitchLayoutGroupContext);
    ot && !ot.projection && j && (ot.type === "html" || ot.type === "svg") && createProjectionNode$1(rt.current, a, j, st), reactExports.useInsertionEffect(() => {
        ot && ot.update(a, tt)
    });
    const lt = reactExports.useRef(!!(a[optimizedAppearDataAttribute] && !window.HandoffComplete));
    return useIsomorphicLayoutEffect(() => {
        ot && (ot.updateFeatures(), microtask.render(ot.render), lt.current && ot.animationState && ot.animationState.animateChanges())
    }), reactExports.useEffect(() => {
        ot && (!lt.current && ot.animationState && ot.animationState.animateChanges(), lt.current && (lt.current = !1, scheduleHandoffComplete || (scheduleHandoffComplete = !0, queueMicrotask(completeHandoff))))
    }), ot
}

function completeHandoff() {
    window.HandoffComplete = !0
}

function createProjectionNode$1(s, o, a, $) {
    const {
        layoutId: j,
        layout: _e,
        drag: et,
        dragConstraints: tt,
        layoutScroll: nt,
        layoutRoot: rt
    } = o;
    s.projection = new a(s.latestValues, o["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(s.parent)), s.projection.setOptions({
        layoutId: j,
        layout: _e,
        alwaysMeasureLayout: !!et || tt && isRefObject(tt),
        visualElement: s,
        animationType: typeof _e == "string" ? _e : "both",
        initialPromotionConfig: $,
        layoutScroll: nt,
        layoutRoot: rt
    })
}

function getClosestProjectingNode(s) {
    if (s) return s.options.allowProjection !== !1 ? s.projection : getClosestProjectingNode(s.parent)
}

function useMotionRef(s, o, a) {
    return reactExports.useCallback($ => {
        $ && s.mount && s.mount($), o && ($ ? o.mount($) : o.unmount()), a && (typeof a == "function" ? a($) : isRefObject(a) && (a.current = $))
    }, [o])
}

function isVariantLabel(s) {
    return typeof s == "string" || Array.isArray(s)
}

function isAnimationControls(s) {
    return s !== null && typeof s == "object" && typeof s.start == "function"
}
const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
    variantProps = ["initial", ...variantPriorityOrder];

function isControllingVariants(s) {
    return isAnimationControls(s.animate) || variantProps.some(o => isVariantLabel(s[o]))
}

function isVariantNode(s) {
    return !!(isControllingVariants(s) || s.variants)
}

function getCurrentTreeVariants(s, o) {
    if (isControllingVariants(s)) {
        const {
            initial: a,
            animate: $
        } = s;
        return {
            initial: a === !1 || isVariantLabel(a) ? a : void 0,
            animate: isVariantLabel($) ? $ : void 0
        }
    }
    return s.inherit !== !1 ? o : {}
}

function useCreateMotionContext(s) {
    const {
        initial: o,
        animate: a
    } = getCurrentTreeVariants(s, reactExports.useContext(MotionContext));
    return reactExports.useMemo(() => ({
        initial: o,
        animate: a
    }), [variantLabelsAsDependency(o), variantLabelsAsDependency(a)])
}

function variantLabelsAsDependency(s) {
    return Array.isArray(s) ? s.join(" ") : s
}
const featureProps = {
        animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
        exit: ["exit"],
        drag: ["drag", "dragControls"],
        focus: ["whileFocus"],
        hover: ["whileHover", "onHoverStart", "onHoverEnd"],
        tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
        pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
        inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
        layout: ["layout", "layoutId"]
    },
    featureDefinitions = {};
for (const s in featureProps) featureDefinitions[s] = {
    isEnabled: o => featureProps[s].some(a => !!o[a])
};

function loadFeatures(s) {
    for (const o in s) featureDefinitions[o] = { ...featureDefinitions[o],
        ...s[o]
    }
}
const LayoutGroupContext = reactExports.createContext({}),
    motionComponentSymbol = Symbol.for("motionComponentSymbol"),
    noop$1 = s => s;
let invariant = noop$1;

function createMotionComponent({
    preloadedFeatures: s,
    createVisualElement: o,
    useRender: a,
    useVisualState: $,
    Component: j
}) {
    s && loadFeatures(s);

    function _e(tt, nt) {
        let rt;
        const ot = { ...reactExports.useContext(MotionConfigContext),
                ...tt,
                layoutId: useLayoutId(tt)
            },
            {
                isStatic: st
            } = ot,
            lt = useCreateMotionContext(tt),
            ft = $(tt, st);
        if (!st && isBrowser) {
            useStrictMode();
            const yt = getProjectionFunctionality(ot);
            rt = yt.MeasureLayout, lt.visualElement = useVisualElement(j, ft, ot, o, yt.ProjectionNode)
        }
        return jsxRuntimeExports.jsxs(MotionContext.Provider, {
            value: lt,
            children: [rt && lt.visualElement ? jsxRuntimeExports.jsx(rt, {
                visualElement: lt.visualElement,
                ...ot
            }) : null, a(j, tt, useMotionRef(ft, lt.visualElement, nt), ft, st, lt.visualElement)]
        })
    }
    const et = reactExports.forwardRef(_e);
    return et[motionComponentSymbol] = j, et
}

function useLayoutId({
    layoutId: s
}) {
    const o = reactExports.useContext(LayoutGroupContext).id;
    return o && s !== void 0 ? o + "-" + s : s
}

function useStrictMode(s, o) {
    reactExports.useContext(LazyContext).strict
}

function getProjectionFunctionality(s) {
    const {
        drag: o,
        layout: a
    } = featureDefinitions;
    if (!o && !a) return {};
    const $ = { ...o,
        ...a
    };
    return {
        MeasureLayout: o != null && o.isEnabled(s) || a != null && a.isEnabled(s) ? $.MeasureLayout : void 0,
        ProjectionNode: $.ProjectionNode
    }
}

function createMotionProxy(s) {
    function o($, j = {}) {
        return createMotionComponent(s($, j))
    }
    if (typeof Proxy > "u") return o;
    const a = new Map;
    return new Proxy(o, {
        get: ($, j) => (a.has(j) || a.set(j, o(j)), a.get(j))
    })
}
const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function isSVGComponent(s) {
    return typeof s != "string" || s.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(s) > -1 || /[A-Z]/u.test(s))
}
const scaleCorrectors = {};

function addScaleCorrector(s) {
    Object.assign(scaleCorrectors, s)
}
const transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    transformProps = new Set(transformPropOrder);

function isForcedMotionValue(s, {
    layout: o,
    layoutId: a
}) {
    return transformProps.has(s) || s.startsWith("origin") || (o || a !== void 0) && (!!scaleCorrectors[s] || s === "opacity")
}
const isMotionValue = s => !!(s && s.getVelocity),
    getValueAsType = (s, o) => o && typeof s == "number" ? o.transform(s) : s,
    clamp = (s, o, a) => a > o ? o : a < s ? s : a,
    number$5 = {
        test: s => typeof s == "number",
        parse: parseFloat,
        transform: s => s
    },
    alpha = { ...number$5,
        transform: s => clamp(0, 1, s)
    },
    scale = { ...number$5,
        default: 1
    },
    sanitize = s => Math.round(s * 1e5) / 1e5,
    floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
    colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
    singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

function isString(s) {
    return typeof s == "string"
}

function isNullish(s) {
    return s == null
}
const createUnitType = s => ({
        test: o => isString(o) && o.endsWith(s) && o.split(" ").length === 1,
        parse: parseFloat,
        transform: o => `${o}${s}`
    }),
    degrees = createUnitType("deg"),
    percent = createUnitType("%"),
    px = createUnitType("px"),
    vh = createUnitType("vh"),
    vw = createUnitType("vw"),
    progressPercentage = { ...percent,
        parse: s => percent.parse(s) / 100,
        transform: s => percent.transform(s * 100)
    },
    int = { ...number$5,
        transform: Math.round
    },
    numberValueTypes = {
        borderWidth: px,
        borderTopWidth: px,
        borderRightWidth: px,
        borderBottomWidth: px,
        borderLeftWidth: px,
        borderRadius: px,
        radius: px,
        borderTopLeftRadius: px,
        borderTopRightRadius: px,
        borderBottomRightRadius: px,
        borderBottomLeftRadius: px,
        width: px,
        maxWidth: px,
        height: px,
        maxHeight: px,
        size: px,
        top: px,
        right: px,
        bottom: px,
        left: px,
        padding: px,
        paddingTop: px,
        paddingRight: px,
        paddingBottom: px,
        paddingLeft: px,
        margin: px,
        marginTop: px,
        marginRight: px,
        marginBottom: px,
        marginLeft: px,
        rotate: degrees,
        rotateX: degrees,
        rotateY: degrees,
        rotateZ: degrees,
        scale,
        scaleX: scale,
        scaleY: scale,
        scaleZ: scale,
        skew: degrees,
        skewX: degrees,
        skewY: degrees,
        distance: px,
        translateX: px,
        translateY: px,
        translateZ: px,
        x: px,
        y: px,
        z: px,
        perspective: px,
        transformPerspective: px,
        opacity: alpha,
        originX: progressPercentage,
        originY: progressPercentage,
        originZ: px,
        zIndex: int,
        backgroundPositionX: px,
        backgroundPositionY: px,
        fillOpacity: alpha,
        strokeOpacity: alpha,
        numOctaves: int
    },
    translateAlias = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    },
    numTransforms = transformPropOrder.length;

function buildTransform(s, o, a) {
    let $ = "",
        j = !0;
    for (let _e = 0; _e < numTransforms; _e++) {
        const et = transformPropOrder[_e],
            tt = s[et];
        if (tt === void 0) continue;
        let nt = !0;
        if (typeof tt == "number" ? nt = tt === (et.startsWith("scale") ? 1 : 0) : nt = parseFloat(tt) === 0, !nt || a) {
            const rt = getValueAsType(tt, numberValueTypes[et]);
            if (!nt) {
                j = !1;
                const ot = translateAlias[et] || et;
                $ += `${ot}(${rt}) `
            }
            a && (o[et] = rt)
        }
    }
    return $ = $.trim(), a ? $ = a(o, j ? "" : $) : j && ($ = "none"), $
}
const checkStringStartsWith = s => o => typeof o == "string" && o.startsWith(s),
    isCSSVariableName = checkStringStartsWith("--"),
    startsAsVariableToken = checkStringStartsWith("var(--"),
    isCSSVariableToken = s => startsAsVariableToken(s) ? singleCssVariableRegex.test(s.split("/*")[0].trim()) : !1,
    singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

function buildHTMLStyles(s, o, a) {
    const {
        style: $,
        vars: j,
        transformOrigin: _e
    } = s;
    let et = !1,
        tt = !1;
    for (const nt in o) {
        const rt = o[nt];
        if (transformProps.has(nt)) {
            et = !0;
            continue
        } else if (isCSSVariableName(nt)) {
            j[nt] = rt;
            continue
        } else {
            const ot = getValueAsType(rt, numberValueTypes[nt]);
            nt.startsWith("origin") ? (tt = !0, _e[nt] = ot) : $[nt] = ot
        }
    }
    if (o.transform || (et || a ? $.transform = buildTransform(o, s.transform, a) : $.transform && ($.transform = "none")), tt) {
        const {
            originX: nt = "50%",
            originY: rt = "50%",
            originZ: ot = 0
        } = _e;
        $.transformOrigin = `${nt} ${rt} ${ot}`
    }
}
const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});

function copyRawValuesOnly(s, o, a) {
    for (const $ in o) !isMotionValue(o[$]) && !isForcedMotionValue($, a) && (s[$] = o[$])
}

function useInitialMotionValues({
    transformTemplate: s
}, o) {
    return reactExports.useMemo(() => {
        const a = createHtmlRenderState();
        return buildHTMLStyles(a, o, s), Object.assign({}, a.vars, a.style)
    }, [o])
}

function useStyle(s, o) {
    const a = s.style || {},
        $ = {};
    return copyRawValuesOnly($, a, s), Object.assign($, useInitialMotionValues(s, o)), $
}

function useHTMLProps(s, o) {
    const a = {},
        $ = useStyle(s, o);
    return s.drag && s.dragListener !== !1 && (a.draggable = !1, $.userSelect = $.WebkitUserSelect = $.WebkitTouchCallout = "none", $.touchAction = s.drag === !0 ? "none" : `pan-${s.drag==="x"?"y":"x"}`), s.tabIndex === void 0 && (s.onTap || s.onTapStart || s.whileTap) && (a.tabIndex = 0), a.style = $, a
}
const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

function isValidMotionProp(s) {
    return s.startsWith("while") || s.startsWith("drag") && s !== "draggable" || s.startsWith("layout") || s.startsWith("onTap") || s.startsWith("onPan") || s.startsWith("onLayout") || validMotionProps.has(s)
}
let shouldForward = s => !isValidMotionProp(s);

function loadExternalIsValidProp(s) {
    s && (shouldForward = o => o.startsWith("on") ? !isValidMotionProp(o) : s(o))
}
try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
} catch (s) {}

function filterProps(s, o, a) {
    const $ = {};
    for (const j in s) j === "values" && typeof s.values == "object" || (shouldForward(j) || a === !0 && isValidMotionProp(j) || !o && !isValidMotionProp(j) || s.draggable && j.startsWith("onDrag")) && ($[j] = s[j]);
    return $
}

function calcOrigin$1(s, o, a) {
    return typeof s == "string" ? s : px.transform(o + a * s)
}

function calcSVGTransformOrigin(s, o, a) {
    const $ = calcOrigin$1(o, s.x, s.width),
        j = calcOrigin$1(a, s.y, s.height);
    return `${$} ${j}`
}
const dashKeys = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray"
    },
    camelKeys = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
    };

function buildSVGPath(s, o, a = 1, $ = 0, j = !0) {
    s.pathLength = 1;
    const _e = j ? dashKeys : camelKeys;
    s[_e.offset] = px.transform(-$);
    const et = px.transform(o),
        tt = px.transform(a);
    s[_e.array] = `${et} ${tt}`
}

function buildSVGAttrs(s, {
    attrX: o,
    attrY: a,
    attrScale: $,
    originX: j,
    originY: _e,
    pathLength: et,
    pathSpacing: tt = 1,
    pathOffset: nt = 0,
    ...rt
}, ot, st) {
    if (buildHTMLStyles(s, rt, st), ot) {
        s.style.viewBox && (s.attrs.viewBox = s.style.viewBox);
        return
    }
    s.attrs = s.style, s.style = {};
    const {
        attrs: lt,
        style: ft,
        dimensions: yt
    } = s;
    lt.transform && (yt && (ft.transform = lt.transform), delete lt.transform), yt && (j !== void 0 || _e !== void 0 || ft.transform) && (ft.transformOrigin = calcSVGTransformOrigin(yt, j !== void 0 ? j : .5, _e !== void 0 ? _e : .5)), o !== void 0 && (lt.x = o), a !== void 0 && (lt.y = a), $ !== void 0 && (lt.scale = $), et !== void 0 && buildSVGPath(lt, et, tt, nt, !1)
}
const createSvgRenderState = () => ({ ...createHtmlRenderState(),
        attrs: {}
    }),
    isSVGTag = s => typeof s == "string" && s.toLowerCase() === "svg";

function useSVGProps(s, o, a, $) {
    const j = reactExports.useMemo(() => {
        const _e = createSvgRenderState();
        return buildSVGAttrs(_e, o, isSVGTag($), s.transformTemplate), { ..._e.attrs,
            style: { ..._e.style
            }
        }
    }, [o]);
    if (s.style) {
        const _e = {};
        copyRawValuesOnly(_e, s.style, s), j.style = { ..._e,
            ...j.style
        }
    }
    return j
}

function createUseRender(s = !1) {
    return (a, $, j, {
        latestValues: _e
    }, et) => {
        const nt = (isSVGComponent(a) ? useSVGProps : useHTMLProps)($, _e, et, a),
            rt = filterProps($, typeof a == "string", s),
            ot = a !== reactExports.Fragment ? { ...rt,
                ...nt,
                ref: j
            } : {},
            {
                children: st
            } = $,
            lt = reactExports.useMemo(() => isMotionValue(st) ? st.get() : st, [st]);
        return reactExports.createElement(a, { ...ot,
            children: lt
        })
    }
}

function renderHTML(s, {
    style: o,
    vars: a
}, $, j) {
    Object.assign(s.style, o, j && j.getProjectionStyles($));
    for (const _e in a) s.style.setProperty(_e, a[_e])
}
const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function renderSVG(s, o, a, $) {
    renderHTML(s, o, void 0, $);
    for (const j in o.attrs) s.setAttribute(camelCaseAttributes.has(j) ? j : camelToDash(j), o.attrs[j])
}

function scrapeMotionValuesFromProps$1(s, o, a) {
    var $;
    const {
        style: j
    } = s, _e = {};
    for (const et in j)(isMotionValue(j[et]) || o.style && isMotionValue(o.style[et]) || isForcedMotionValue(et, s) || (($ = a == null ? void 0 : a.getValue(et)) === null || $ === void 0 ? void 0 : $.liveStyle) !== void 0) && (_e[et] = j[et]);
    return a && j && typeof j.willChange == "string" && (a.applyWillChange = !1), _e
}

function scrapeMotionValuesFromProps(s, o, a) {
    const $ = scrapeMotionValuesFromProps$1(s, o, a);
    for (const j in s)
        if (isMotionValue(s[j]) || isMotionValue(o[j])) {
            const _e = transformPropOrder.indexOf(j) !== -1 ? "attr" + j.charAt(0).toUpperCase() + j.substring(1) : j;
            $[_e] = s[j]
        }
    return $
}

function getValueState(s) {
    const o = [{}, {}];
    return s == null || s.values.forEach((a, $) => {
        o[0][$] = a.get(), o[1][$] = a.getVelocity()
    }), o
}

function resolveVariantFromProps(s, o, a, $) {
    if (typeof o == "function") {
        const [j, _e] = getValueState($);
        o = o(a !== void 0 ? a : s.custom, j, _e)
    }
    if (typeof o == "string" && (o = s.variants && s.variants[o]), typeof o == "function") {
        const [j, _e] = getValueState($);
        o = o(a !== void 0 ? a : s.custom, j, _e)
    }
    return o
}

function useConstant$1(s) {
    const o = reactExports.useRef(null);
    return o.current === null && (o.current = s()), o.current
}
const isKeyframesTarget = s => Array.isArray(s),
    isCustomValue = s => !!(s && typeof s == "object" && s.mix && s.toValue),
    resolveFinalValueInKeyframes = s => isKeyframesTarget(s) ? s[s.length - 1] || 0 : s;

function resolveMotionValue(s) {
    const o = isMotionValue(s) ? s.get() : s;
    return isCustomValue(o) ? o.toValue() : o
}
const acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"]);

function getWillChangeName(s) {
    if (transformProps.has(s)) return "transform";
    if (acceleratedValues.has(s)) return camelToDash(s)
}

function addUniqueItem(s, o) {
    s.indexOf(o) === -1 && s.push(o)
}

function removeItem(s, o) {
    const a = s.indexOf(o);
    a > -1 && s.splice(a, 1)
}

function makeState({
    applyWillChange: s = !1,
    scrapeMotionValuesFromProps: o,
    createRenderState: a,
    onMount: $
}, j, _e, et, tt) {
    const nt = {
        latestValues: makeLatestValues(j, _e, et, tt ? !1 : s, o),
        renderState: a()
    };
    return $ && (nt.mount = rt => $(j, rt, nt)), nt
}
const makeUseVisualState = s => (o, a) => {
    const $ = reactExports.useContext(MotionContext),
        j = reactExports.useContext(PresenceContext),
        _e = () => makeState(s, o, $, j, a);
    return a ? _e() : useConstant$1(_e)
};

function addWillChange(s, o) {
    const a = getWillChangeName(o);
    a && addUniqueItem(s, a)
}

function forEachDefinition(s, o, a) {
    const $ = Array.isArray(o) ? o : [o];
    for (let j = 0; j < $.length; j++) {
        const _e = resolveVariantFromProps(s, $[j]);
        if (_e) {
            const {
                transitionEnd: et,
                transition: tt,
                ...nt
            } = _e;
            a(nt, et)
        }
    }
}

function makeLatestValues(s, o, a, $, j) {
    var _e;
    const et = {},
        tt = [],
        nt = $ && ((_e = s.style) === null || _e === void 0 ? void 0 : _e.willChange) === void 0,
        rt = j(s, {});
    for (const ht in rt) et[ht] = resolveMotionValue(rt[ht]);
    let {
        initial: ot,
        animate: st
    } = s;
    const lt = isControllingVariants(s),
        ft = isVariantNode(s);
    o && ft && !lt && s.inherit !== !1 && (ot === void 0 && (ot = o.initial), st === void 0 && (st = o.animate));
    let yt = a ? a.initial === !1 : !1;
    yt = yt || ot === !1;
    const bt = yt ? st : ot;
    return bt && typeof bt != "boolean" && !isAnimationControls(bt) && forEachDefinition(s, bt, (ht, vt) => {
        for (const wt in ht) {
            let gt = ht[wt];
            if (Array.isArray(gt)) {
                const At = yt ? gt.length - 1 : 0;
                gt = gt[At]
            }
            gt !== null && (et[wt] = gt)
        }
        for (const wt in vt) et[wt] = vt[wt]
    }), nt && (st && ot !== !1 && !isAnimationControls(st) && forEachDefinition(s, st, ht => {
        for (const vt in ht) addWillChange(tt, vt)
    }), tt.length && (et.willChange = tt.join(","))), et
}
const {
    schedule: frame,
    cancel: cancelFrame,
    state: frameData,
    steps
} = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$1, !0), svgMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (s, o, {
            renderState: a,
            latestValues: $
        }) => {
            frame.read(() => {
                try {
                    a.dimensions = typeof o.getBBox == "function" ? o.getBBox() : o.getBoundingClientRect()
                } catch {
                    a.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }), frame.render(() => {
                buildSVGAttrs(a, $, isSVGTag(o.tagName), s.transformTemplate), renderSVG(o, a)
            })
        }
    })
}, htmlMotionConfig = {
    useVisualState: makeUseVisualState({
        applyWillChange: !0,
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
    })
};

function createDomMotionConfig(s, {
    forwardMotionProps: o = !1
}, a, $) {
    return { ...isSVGComponent(s) ? svgMotionConfig : htmlMotionConfig,
        preloadedFeatures: a,
        useRender: createUseRender(o),
        createVisualElement: $,
        Component: s
    }
}

function addDomEvent(s, o, a, $ = {
    passive: !0
}) {
    return s.addEventListener(o, a, $), () => s.removeEventListener(o, a)
}
const isPrimaryPointer = s => s.pointerType === "mouse" ? typeof s.button != "number" || s.button <= 0 : s.isPrimary !== !1;

function extractEventInfo(s, o = "page") {
    return {
        point: {
            x: s[`${o}X`],
            y: s[`${o}Y`]
        }
    }
}
const addPointerInfo = s => o => isPrimaryPointer(o) && s(o, extractEventInfo(o));

function addPointerEvent(s, o, a, $) {
    return addDomEvent(s, o, addPointerInfo(a), $)
}
const combineFunctions = (s, o) => a => o(s(a)),
    pipe = (...s) => s.reduce(combineFunctions);

function createLock(s) {
    let o = null;
    return () => {
        const a = () => {
            o = null
        };
        return o === null ? (o = s, a) : !1
    }
}
const globalHorizontalLock = createLock("dragHorizontal"),
    globalVerticalLock = createLock("dragVertical");

function getGlobalLock(s) {
    let o = !1;
    if (s === "y") o = globalVerticalLock();
    else if (s === "x") o = globalHorizontalLock();
    else {
        const a = globalHorizontalLock(),
            $ = globalVerticalLock();
        a && $ ? o = () => {
            a(), $()
        } : (a && a(), $ && $())
    }
    return o
}

function isDragActive() {
    const s = getGlobalLock(!0);
    return s ? (s(), !1) : !0
}
class Feature {
    constructor(o) {
        this.isMounted = !1, this.node = o
    }
    update() {}
}

function addHoverEvent(s, o) {
    const a = o ? "pointerenter" : "pointerleave",
        $ = o ? "onHoverStart" : "onHoverEnd",
        j = (_e, et) => {
            if (_e.pointerType === "touch" || isDragActive()) return;
            const tt = s.getProps();
            s.animationState && tt.whileHover && s.animationState.setActive("whileHover", o);
            const nt = tt[$];
            nt && frame.postRender(() => nt(_e, et))
        };
    return addPointerEvent(s.current, a, j, {
        passive: !s.getProps()[$]
    })
}
class HoverGesture extends Feature {
    mount() {
        this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1))
    }
    unmount() {}
}
class FocusGesture extends Feature {
    constructor() {
        super(...arguments), this.isActive = !1
    }
    onFocus() {
        let o = !1;
        try {
            o = this.node.current.matches(":focus-visible")
        } catch {
            o = !0
        }!o || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
    }
    mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
const isNodeOrChild = (s, o) => o ? s === o ? !0 : isNodeOrChild(s, o.parentElement) : !1;

function fireSyntheticPointerEvent(s, o) {
    if (!o) return;
    const a = new PointerEvent("pointer" + s);
    o(a, extractEventInfo(a))
}
class PressGesture extends Feature {
    constructor() {
        super(...arguments), this.removeStartListeners = noop$1, this.removeEndListeners = noop$1, this.removeAccessibleListeners = noop$1, this.startPointerPress = (o, a) => {
            if (this.isPressing) return;
            this.removeEndListeners();
            const $ = this.node.getProps(),
                _e = addPointerEvent(window, "pointerup", (tt, nt) => {
                    if (!this.checkPressEnd()) return;
                    const {
                        onTap: rt,
                        onTapCancel: ot,
                        globalTapTarget: st
                    } = this.node.getProps(), lt = !st && !isNodeOrChild(this.node.current, tt.target) ? ot : rt;
                    lt && frame.update(() => lt(tt, nt))
                }, {
                    passive: !($.onTap || $.onPointerUp)
                }),
                et = addPointerEvent(window, "pointercancel", (tt, nt) => this.cancelPress(tt, nt), {
                    passive: !($.onTapCancel || $.onPointerCancel)
                });
            this.removeEndListeners = pipe(_e, et), this.startPress(o, a)
        }, this.startAccessiblePress = () => {
            const o = _e => {
                    if (_e.key !== "Enter" || this.isPressing) return;
                    const et = tt => {
                        tt.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (nt, rt) => {
                            const {
                                onTap: ot
                            } = this.node.getProps();
                            ot && frame.postRender(() => ot(nt, rt))
                        })
                    };
                    this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", et), fireSyntheticPointerEvent("down", (tt, nt) => {
                        this.startPress(tt, nt)
                    })
                },
                a = addDomEvent(this.node.current, "keydown", o),
                $ = () => {
                    this.isPressing && fireSyntheticPointerEvent("cancel", (_e, et) => this.cancelPress(_e, et))
                },
                j = addDomEvent(this.node.current, "blur", $);
            this.removeAccessibleListeners = pipe(a, j)
        }
    }
    startPress(o, a) {
        this.isPressing = !0;
        const {
            onTapStart: $,
            whileTap: j
        } = this.node.getProps();
        j && this.node.animationState && this.node.animationState.setActive("whileTap", !0), $ && frame.postRender(() => $(o, a))
    }
    checkPressEnd() {
        return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive()
    }
    cancelPress(o, a) {
        if (!this.checkPressEnd()) return;
        const {
            onTapCancel: $
        } = this.node.getProps();
        $ && frame.postRender(() => $(o, a))
    }
    mount() {
        const o = this.node.getProps(),
            a = addPointerEvent(o.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
                passive: !(o.onTapStart || o.onPointerStart)
            }),
            $ = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = pipe(a, $)
    }
    unmount() {
        this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
    }
}
const observerCallbacks = new WeakMap,
    observers = new WeakMap,
    fireObserverCallback = s => {
        const o = observerCallbacks.get(s.target);
        o && o(s)
    },
    fireAllObserverCallbacks = s => {
        s.forEach(fireObserverCallback)
    };

function initIntersectionObserver({
    root: s,
    ...o
}) {
    const a = s || document;
    observers.has(a) || observers.set(a, {});
    const $ = observers.get(a),
        j = JSON.stringify(o);
    return $[j] || ($[j] = new IntersectionObserver(fireAllObserverCallbacks, {
        root: s,
        ...o
    })), $[j]
}

function observeIntersection(s, o, a) {
    const $ = initIntersectionObserver(o);
    return observerCallbacks.set(s, a), $.observe(s), () => {
        observerCallbacks.delete(s), $.unobserve(s)
    }
}
const thresholdNames = {
    some: 0,
    all: 1
};
class InViewFeature extends Feature {
    constructor() {
        super(...arguments), this.hasEnteredView = !1, this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {
            viewport: o = {}
        } = this.node.getProps(), {
            root: a,
            margin: $,
            amount: j = "some",
            once: _e
        } = o, et = {
            root: a ? a.current : void 0,
            rootMargin: $,
            threshold: typeof j == "number" ? j : thresholdNames[j]
        }, tt = nt => {
            const {
                isIntersecting: rt
            } = nt;
            if (this.isInView === rt || (this.isInView = rt, _e && !rt && this.hasEnteredView)) return;
            rt && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", rt);
            const {
                onViewportEnter: ot,
                onViewportLeave: st
            } = this.node.getProps(), lt = rt ? ot : st;
            lt && lt(nt)
        };
        return observeIntersection(this.node.current, et, tt)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u") return;
        const {
            props: o,
            prevProps: a
        } = this.node;
        ["amount", "margin", "root"].some(hasViewportOptionChanged(o, a)) && this.startObserver()
    }
    unmount() {}
}

function hasViewportOptionChanged({
    viewport: s = {}
}, {
    viewport: o = {}
} = {}) {
    return a => s[a] !== o[a]
}
const gestureAnimations = {
    inView: {
        Feature: InViewFeature
    },
    tap: {
        Feature: PressGesture
    },
    focus: {
        Feature: FocusGesture
    },
    hover: {
        Feature: HoverGesture
    }
};

function shallowCompare(s, o) {
    if (!Array.isArray(o)) return !1;
    const a = o.length;
    if (a !== s.length) return !1;
    for (let $ = 0; $ < a; $++)
        if (o[$] !== s[$]) return !1;
    return !0
}

function resolveVariant(s, o, a) {
    const $ = s.getProps();
    return resolveVariantFromProps($, o, a !== void 0 ? a : $.custom, s)
}
const secondsToMilliseconds = s => s * 1e3,
    millisecondsToSeconds = s => s / 1e3,
    underDampedSpring = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10
    },
    criticallyDampedSpring = s => ({
        type: "spring",
        stiffness: 550,
        damping: s === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
    }),
    keyframesTransition = {
        type: "keyframes",
        duration: .8
    },
    ease = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
    },
    getDefaultTransition = (s, {
        keyframes: o
    }) => o.length > 2 ? keyframesTransition : transformProps.has(s) ? s.startsWith("scale") ? criticallyDampedSpring(o[1]) : underDampedSpring : ease;

function isTransitionDefined({
    when: s,
    delay: o,
    delayChildren: a,
    staggerChildren: $,
    staggerDirection: j,
    repeat: _e,
    repeatType: et,
    repeatDelay: tt,
    from: nt,
    elapsed: rt,
    ...ot
}) {
    return !!Object.keys(ot).length
}

function getValueTransition(s, o) {
    return s[o] || s.default || s
}
const isNotNull = s => s !== null;

function getFinalKeyframe(s, {
    repeat: o,
    repeatType: a = "loop"
}, $) {
    const j = s.filter(isNotNull),
        _e = o && a !== "loop" && o % 2 === 1 ? 0 : j.length - 1;
    return !_e || $ === void 0 ? j[_e] : $
}
let now;

function clearTime() {
    now = void 0
}
const time = {
        now: () => (now === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now),
        set: s => {
            now = s, queueMicrotask(clearTime)
        }
    },
    isZeroValueString = s => /^0[^.\s]+$/u.test(s);

function isNone(s) {
    return typeof s == "number" ? s === 0 : s !== null ? s === "none" || s === "0" || isZeroValueString(s) : !0
}
const isNumericalString = s => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(s),
    splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

function parseCSSVariable(s) {
    const o = splitCSSVariableRegex.exec(s);
    if (!o) return [, ];
    const [, a, $, j] = o;
    return [`--${a??$}`, j]
}

function getVariableValue(s, o, a = 1) {
    const [$, j] = parseCSSVariable(s);
    if (!$) return;
    const _e = window.getComputedStyle(o).getPropertyValue($);
    if (_e) {
        const et = _e.trim();
        return isNumericalString(et) ? parseFloat(et) : et
    }
    return isCSSVariableToken(j) ? getVariableValue(j, o, a + 1) : j
}
const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
    isNumOrPxType = s => s === number$5 || s === px,
    getPosFromMatrix = (s, o) => parseFloat(s.split(", ")[o]),
    getTranslateFromMatrix = (s, o) => (a, {
        transform: $
    }) => {
        if ($ === "none" || !$) return 0;
        const j = $.match(/^matrix3d\((.+)\)$/u);
        if (j) return getPosFromMatrix(j[1], o); {
            const _e = $.match(/^matrix\((.+)\)$/u);
            return _e ? getPosFromMatrix(_e[1], s) : 0
        }
    },
    transformKeys = new Set(["x", "y", "z"]),
    nonTranslationalTransformKeys = transformPropOrder.filter(s => !transformKeys.has(s));

function removeNonTranslationalTransform(s) {
    const o = [];
    return nonTranslationalTransformKeys.forEach(a => {
        const $ = s.getValue(a);
        $ !== void 0 && (o.push([a, $.get()]), $.set(a.startsWith("scale") ? 1 : 0))
    }), o
}
const positionalValues = {
    width: ({
        x: s
    }, {
        paddingLeft: o = "0",
        paddingRight: a = "0"
    }) => s.max - s.min - parseFloat(o) - parseFloat(a),
    height: ({
        y: s
    }, {
        paddingTop: o = "0",
        paddingBottom: a = "0"
    }) => s.max - s.min - parseFloat(o) - parseFloat(a),
    top: (s, {
        top: o
    }) => parseFloat(o),
    left: (s, {
        left: o
    }) => parseFloat(o),
    bottom: ({
        y: s
    }, {
        top: o
    }) => parseFloat(o) + (s.max - s.min),
    right: ({
        x: s
    }, {
        left: o
    }) => parseFloat(o) + (s.max - s.min),
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const testValueType = s => o => o.test(s),
    auto = {
        test: s => s === "auto",
        parse: s => s
    },
    dimensionValueTypes = [number$5, px, percent, degrees, vw, vh, auto],
    findDimensionValueType = s => dimensionValueTypes.find(testValueType(s)),
    toResolve = new Set;
let isScheduled = !1,
    anyNeedsMeasurement = !1;

function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
        const s = Array.from(toResolve).filter($ => $.needsMeasurement),
            o = new Set(s.map($ => $.element)),
            a = new Map;
        o.forEach($ => {
            const j = removeNonTranslationalTransform($);
            j.length && (a.set($, j), $.render())
        }), s.forEach($ => $.measureInitialState()), o.forEach($ => {
            $.render();
            const j = a.get($);
            j && j.forEach(([_e, et]) => {
                var tt;
                (tt = $.getValue(_e)) === null || tt === void 0 || tt.set(et)
            })
        }), s.forEach($ => $.measureEndState()), s.forEach($ => {
            $.suspendedScrollY !== void 0 && window.scrollTo(0, $.suspendedScrollY)
        })
    }
    anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach(s => s.complete()), toResolve.clear()
}

function readAllKeyframes() {
    toResolve.forEach(s => {
        s.readKeyframes(), s.needsMeasurement && (anyNeedsMeasurement = !0)
    })
}

function flushKeyframeResolvers() {
    readAllKeyframes(), measureAllKeyframes()
}
class KeyframeResolver {
    constructor(o, a, $, j, _e, et = !1) {
        this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...o], this.onComplete = a, this.name = $, this.motionValue = j, this.element = _e, this.isAsync = et
    }
    scheduleResolve() {
        this.isScheduled = !0, this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete())
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: o,
            name: a,
            element: $,
            motionValue: j
        } = this;
        for (let _e = 0; _e < o.length; _e++)
            if (o[_e] === null)
                if (_e === 0) {
                    const et = j == null ? void 0 : j.get(),
                        tt = o[o.length - 1];
                    if (et !== void 0) o[0] = et;
                    else if ($ && a) {
                        const nt = $.readValue(a, tt);
                        nt != null && (o[0] = nt)
                    }
                    o[0] === void 0 && (o[0] = tt), j && et === void 0 && j.set(o[0])
                } else o[_e] = o[_e - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), toResolve.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1, toResolve.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const isColorString = (s, o) => a => !!(isString(a) && singleColorRegex.test(a) && a.startsWith(s) || o && !isNullish(a) && Object.prototype.hasOwnProperty.call(a, o)),
    splitColor = (s, o, a) => $ => {
        if (!isString($)) return $;
        const [j, _e, et, tt] = $.match(floatRegex);
        return {
            [s]: parseFloat(j),
            [o]: parseFloat(_e),
            [a]: parseFloat(et),
            alpha: tt !== void 0 ? parseFloat(tt) : 1
        }
    },
    clampRgbUnit = s => clamp(0, 255, s),
    rgbUnit = { ...number$5,
        transform: s => Math.round(clampRgbUnit(s))
    },
    rgba = {
        test: isColorString("rgb", "red"),
        parse: splitColor("red", "green", "blue"),
        transform: ({
            red: s,
            green: o,
            blue: a,
            alpha: $ = 1
        }) => "rgba(" + rgbUnit.transform(s) + ", " + rgbUnit.transform(o) + ", " + rgbUnit.transform(a) + ", " + sanitize(alpha.transform($)) + ")"
    };

function parseHex(s) {
    let o = "",
        a = "",
        $ = "",
        j = "";
    return s.length > 5 ? (o = s.substring(1, 3), a = s.substring(3, 5), $ = s.substring(5, 7), j = s.substring(7, 9)) : (o = s.substring(1, 2), a = s.substring(2, 3), $ = s.substring(3, 4), j = s.substring(4, 5), o += o, a += a, $ += $, j += j), {
        red: parseInt(o, 16),
        green: parseInt(a, 16),
        blue: parseInt($, 16),
        alpha: j ? parseInt(j, 16) / 255 : 1
    }
}
const hex$1 = {
        test: isColorString("#"),
        parse: parseHex,
        transform: rgba.transform
    },
    hsla = {
        test: isColorString("hsl", "hue"),
        parse: splitColor("hue", "saturation", "lightness"),
        transform: ({
            hue: s,
            saturation: o,
            lightness: a,
            alpha: $ = 1
        }) => "hsla(" + Math.round(s) + ", " + percent.transform(sanitize(o)) + ", " + percent.transform(sanitize(a)) + ", " + sanitize(alpha.transform($)) + ")"
    },
    color = {
        test: s => rgba.test(s) || hex$1.test(s) || hsla.test(s),
        parse: s => rgba.test(s) ? rgba.parse(s) : hsla.test(s) ? hsla.parse(s) : hex$1.parse(s),
        transform: s => isString(s) ? s : s.hasOwnProperty("red") ? rgba.transform(s) : hsla.transform(s)
    };

function test$1(s) {
    var o, a;
    return isNaN(s) && isString(s) && (((o = s.match(floatRegex)) === null || o === void 0 ? void 0 : o.length) || 0) + (((a = s.match(colorRegex)) === null || a === void 0 ? void 0 : a.length) || 0) > 0
}
const NUMBER_TOKEN = "number",
    COLOR_TOKEN = "color",
    VAR_TOKEN = "var",
    VAR_FUNCTION_TOKEN = "var(",
    SPLIT_TOKEN = "${}",
    complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

function analyseComplexValue(s) {
    const o = s.toString(),
        a = [],
        $ = {
            color: [],
            number: [],
            var: []
        },
        j = [];
    let _e = 0;
    const tt = o.replace(complexRegex, nt => (color.test(nt) ? ($.color.push(_e), j.push(COLOR_TOKEN), a.push(color.parse(nt))) : nt.startsWith(VAR_FUNCTION_TOKEN) ? ($.var.push(_e), j.push(VAR_TOKEN), a.push(nt)) : ($.number.push(_e), j.push(NUMBER_TOKEN), a.push(parseFloat(nt))), ++_e, SPLIT_TOKEN)).split(SPLIT_TOKEN);
    return {
        values: a,
        split: tt,
        indexes: $,
        types: j
    }
}

function parseComplexValue(s) {
    return analyseComplexValue(s).values
}

function createTransformer(s) {
    const {
        split: o,
        types: a
    } = analyseComplexValue(s), $ = o.length;
    return j => {
        let _e = "";
        for (let et = 0; et < $; et++)
            if (_e += o[et], j[et] !== void 0) {
                const tt = a[et];
                tt === NUMBER_TOKEN ? _e += sanitize(j[et]) : tt === COLOR_TOKEN ? _e += color.transform(j[et]) : _e += j[et]
            }
        return _e
    }
}
const convertNumbersToZero = s => typeof s == "number" ? 0 : s;

function getAnimatableNone$1(s) {
    const o = parseComplexValue(s);
    return createTransformer(s)(o.map(convertNumbersToZero))
}
const complex = {
        test: test$1,
        parse: parseComplexValue,
        createTransformer,
        getAnimatableNone: getAnimatableNone$1
    },
    maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);

function applyDefaultFilter(s) {
    const [o, a] = s.slice(0, -1).split("(");
    if (o === "drop-shadow") return s;
    const [$] = a.match(floatRegex) || [];
    if (!$) return s;
    const j = a.replace($, "");
    let _e = maxDefaults.has(o) ? 1 : 0;
    return $ !== a && (_e *= 100), o + "(" + _e + j + ")"
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu,
    filter = { ...complex,
        getAnimatableNone: s => {
            const o = s.match(functionRegex);
            return o ? o.map(applyDefaultFilter).join(" ") : s
        }
    },
    defaultValueTypes = { ...numberValueTypes,
        color,
        backgroundColor: color,
        outlineColor: color,
        fill: color,
        stroke: color,
        borderColor: color,
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color,
        filter,
        WebkitFilter: filter
    },
    getDefaultValueType = s => defaultValueTypes[s];

function getAnimatableNone(s, o) {
    let a = getDefaultValueType(s);
    return a !== filter && (a = complex), a.getAnimatableNone ? a.getAnimatableNone(o) : void 0
}
const invalidTemplates = new Set(["auto", "none", "0"]);

function makeNoneKeyframesAnimatable(s, o, a) {
    let $ = 0,
        j;
    for (; $ < s.length && !j;) {
        const _e = s[$];
        typeof _e == "string" && !invalidTemplates.has(_e) && analyseComplexValue(_e).values.length && (j = s[$]), $++
    }
    if (j && a)
        for (const _e of o) s[_e] = getAnimatableNone(a, j)
}
class DOMKeyframesResolver extends KeyframeResolver {
    constructor(o, a, $, j) {
        super(o, a, $, j, j == null ? void 0 : j.owner, !0)
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: o,
            element: a,
            name: $
        } = this;
        if (!a.current) return;
        super.readKeyframes();
        for (let nt = 0; nt < o.length; nt++) {
            let rt = o[nt];
            if (typeof rt == "string" && (rt = rt.trim(), isCSSVariableToken(rt))) {
                const ot = getVariableValue(rt, a.current);
                ot !== void 0 && (o[nt] = ot), nt === o.length - 1 && (this.finalKeyframe = rt)
            }
        }
        if (this.resolveNoneKeyframes(), !positionalKeys.has($) || o.length !== 2) return;
        const [j, _e] = o, et = findDimensionValueType(j), tt = findDimensionValueType(_e);
        if (et !== tt)
            if (isNumOrPxType(et) && isNumOrPxType(tt))
                for (let nt = 0; nt < o.length; nt++) {
                    const rt = o[nt];
                    typeof rt == "string" && (o[nt] = parseFloat(rt))
                } else this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {
            unresolvedKeyframes: o,
            name: a
        } = this, $ = [];
        for (let j = 0; j < o.length; j++) isNone(o[j]) && $.push(j);
        $.length && makeNoneKeyframesAnimatable(o, $, a)
    }
    measureInitialState() {
        const {
            element: o,
            unresolvedKeyframes: a,
            name: $
        } = this;
        if (!o.current) return;
        $ === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[$](o.measureViewportBox(), window.getComputedStyle(o.current)), a[0] = this.measuredOrigin;
        const j = a[a.length - 1];
        j !== void 0 && o.getValue($, j).jump(j, !1)
    }
    measureEndState() {
        var o;
        const {
            element: a,
            name: $,
            unresolvedKeyframes: j
        } = this;
        if (!a.current) return;
        const _e = a.getValue($);
        _e && _e.jump(this.measuredOrigin, !1);
        const et = j.length - 1,
            tt = j[et];
        j[et] = positionalValues[$](a.measureViewportBox(), window.getComputedStyle(a.current)), tt !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = tt), !((o = this.removedTransforms) === null || o === void 0) && o.length && this.removedTransforms.forEach(([nt, rt]) => {
            a.getValue(nt).set(rt)
        }), this.resolveNoneKeyframes()
    }
}

function memo(s) {
    let o;
    return () => (o === void 0 && (o = s()), o)
}
const isAnimatable = (s, o) => o === "zIndex" ? !1 : !!(typeof s == "number" || Array.isArray(s) || typeof s == "string" && (complex.test(s) || s === "0") && !s.startsWith("url("));

function hasKeyframesChanged(s) {
    const o = s[0];
    if (s.length === 1) return !0;
    for (let a = 0; a < s.length; a++)
        if (s[a] !== o) return !0
}

function canAnimate(s, o, a, $) {
    const j = s[0];
    if (j === null) return !1;
    if (o === "display" || o === "visibility") return !0;
    const _e = s[s.length - 1],
        et = isAnimatable(j, o),
        tt = isAnimatable(_e, o);
    return !et || !tt ? !1 : hasKeyframesChanged(s) || a === "spring" && $
}
class BaseAnimation {
    constructor({
        autoplay: o = !0,
        delay: a = 0,
        type: $ = "keyframes",
        repeat: j = 0,
        repeatDelay: _e = 0,
        repeatType: et = "loop",
        ...tt
    }) {
        this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = {
            autoplay: o,
            delay: a,
            type: $,
            repeat: j,
            repeatDelay: _e,
            repeatType: et,
            ...tt
        }, this.updateFinishedPromise()
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(), this._resolved
    }
    onKeyframesResolved(o, a) {
        this.hasAttemptedResolve = !0;
        const {
            name: $,
            type: j,
            velocity: _e,
            delay: et,
            onComplete: tt,
            onUpdate: nt,
            isGenerator: rt
        } = this.options;
        if (!rt && !canAnimate(o, $, j, _e))
            if (et) this.options.duration = 0;
            else {
                nt == null || nt(getFinalKeyframe(o, this.options, a)), tt == null || tt(), this.resolveFinishedPromise();
                return
            }
        const ot = this.initPlayback(o, a);
        ot !== !1 && (this._resolved = {
            keyframes: o,
            finalKeyframe: a,
            ...ot
        }, this.onPostResolved())
    }
    onPostResolved() {}
    then(o, a) {
        return this.currentFinishedPromise.then(o, a)
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(o => {
            this.resolveFinishedPromise = o
        })
    }
}

function velocityPerSecond(s, o) {
    return o ? s * (1e3 / o) : 0
}
const velocitySampleDuration = 5;

function calcGeneratorVelocity(s, o, a) {
    const $ = Math.max(o - velocitySampleDuration, 0);
    return velocityPerSecond(a - s($), o - $)
}
const safeMin = .001,
    minDuration = .01,
    maxDuration$1 = 10,
    minDamping = .05,
    maxDamping = 1;

function findSpring({
    duration: s = 800,
    bounce: o = .25,
    velocity: a = 0,
    mass: $ = 1
}) {
    let j, _e, et = 1 - o;
    et = clamp(minDamping, maxDamping, et), s = clamp(minDuration, maxDuration$1, millisecondsToSeconds(s)), et < 1 ? (j = rt => {
        const ot = rt * et,
            st = ot * s,
            lt = ot - a,
            ft = calcAngularFreq(rt, et),
            yt = Math.exp(-st);
        return safeMin - lt / ft * yt
    }, _e = rt => {
        const st = rt * et * s,
            lt = st * a + a,
            ft = Math.pow(et, 2) * Math.pow(rt, 2) * s,
            yt = Math.exp(-st),
            bt = calcAngularFreq(Math.pow(rt, 2), et);
        return (-j(rt) + safeMin > 0 ? -1 : 1) * ((lt - ft) * yt) / bt
    }) : (j = rt => {
        const ot = Math.exp(-rt * s),
            st = (rt - a) * s + 1;
        return -safeMin + ot * st
    }, _e = rt => {
        const ot = Math.exp(-rt * s),
            st = (a - rt) * (s * s);
        return ot * st
    });
    const tt = 5 / s,
        nt = approximateRoot(j, _e, tt);
    if (s = secondsToMilliseconds(s), isNaN(nt)) return {
        stiffness: 100,
        damping: 10,
        duration: s
    }; {
        const rt = Math.pow(nt, 2) * $;
        return {
            stiffness: rt,
            damping: et * 2 * Math.sqrt($ * rt),
            duration: s
        }
    }
}
const rootIterations = 12;

function approximateRoot(s, o, a) {
    let $ = a;
    for (let j = 1; j < rootIterations; j++) $ = $ - s($) / o($);
    return $
}

function calcAngularFreq(s, o) {
    return s * Math.sqrt(1 - o * o)
}
const durationKeys = ["duration", "bounce"],
    physicsKeys = ["stiffness", "damping", "mass"];

function isSpringType(s, o) {
    return o.some(a => s[a] !== void 0)
}

function getSpringOptions(s) {
    let o = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...s
    };
    if (!isSpringType(s, physicsKeys) && isSpringType(s, durationKeys)) {
        const a = findSpring(s);
        o = { ...o,
            ...a,
            mass: 1
        }, o.isResolvedFromDuration = !0
    }
    return o
}

function spring({
    keyframes: s,
    restDelta: o,
    restSpeed: a,
    ...$
}) {
    const j = s[0],
        _e = s[s.length - 1],
        et = {
            done: !1,
            value: j
        },
        {
            stiffness: tt,
            damping: nt,
            mass: rt,
            duration: ot,
            velocity: st,
            isResolvedFromDuration: lt
        } = getSpringOptions({ ...$,
            velocity: -millisecondsToSeconds($.velocity || 0)
        }),
        ft = st || 0,
        yt = nt / (2 * Math.sqrt(tt * rt)),
        bt = _e - j,
        ht = millisecondsToSeconds(Math.sqrt(tt / rt)),
        vt = Math.abs(bt) < 5;
    a || (a = vt ? .01 : 2), o || (o = vt ? .005 : .5);
    let wt;
    if (yt < 1) {
        const gt = calcAngularFreq(ht, yt);
        wt = At => {
            const Pt = Math.exp(-yt * ht * At);
            return _e - Pt * ((ft + yt * ht * bt) / gt * Math.sin(gt * At) + bt * Math.cos(gt * At))
        }
    } else if (yt === 1) wt = gt => _e - Math.exp(-ht * gt) * (bt + (ft + ht * bt) * gt);
    else {
        const gt = ht * Math.sqrt(yt * yt - 1);
        wt = At => {
            const Pt = Math.exp(-yt * ht * At),
                Bt = Math.min(gt * At, 300);
            return _e - Pt * ((ft + yt * ht * bt) * Math.sinh(Bt) + gt * bt * Math.cosh(Bt)) / gt
        }
    }
    return {
        calculatedDuration: lt && ot || null,
        next: gt => {
            const At = wt(gt);
            if (lt) et.done = gt >= ot;
            else {
                let Pt = ft;
                gt !== 0 && (yt < 1 ? Pt = calcGeneratorVelocity(wt, gt, At) : Pt = 0);
                const Bt = Math.abs(Pt) <= a,
                    Lt = Math.abs(_e - At) <= o;
                et.done = Bt && Lt
            }
            return et.value = et.done ? _e : At, et
        }
    }
}

function inertia({
    keyframes: s,
    velocity: o = 0,
    power: a = .8,
    timeConstant: $ = 325,
    bounceDamping: j = 10,
    bounceStiffness: _e = 500,
    modifyTarget: et,
    min: tt,
    max: nt,
    restDelta: rt = .5,
    restSpeed: ot
}) {
    const st = s[0],
        lt = {
            done: !1,
            value: st
        },
        ft = Nt => tt !== void 0 && Nt < tt || nt !== void 0 && Nt > nt,
        yt = Nt => tt === void 0 ? nt : nt === void 0 || Math.abs(tt - Nt) < Math.abs(nt - Nt) ? tt : nt;
    let bt = a * o;
    const ht = st + bt,
        vt = et === void 0 ? ht : et(ht);
    vt !== ht && (bt = vt - st);
    const wt = Nt => -bt * Math.exp(-Nt / $),
        gt = Nt => vt + wt(Nt),
        At = Nt => {
            const Ut = wt(Nt),
                Vt = gt(Nt);
            lt.done = Math.abs(Ut) <= rt, lt.value = lt.done ? vt : Vt
        };
    let Pt, Bt;
    const Lt = Nt => {
        ft(lt.value) && (Pt = Nt, Bt = spring({
            keyframes: [lt.value, yt(lt.value)],
            velocity: calcGeneratorVelocity(gt, Nt, lt.value),
            damping: j,
            stiffness: _e,
            restDelta: rt,
            restSpeed: ot
        }))
    };
    return Lt(0), {
        calculatedDuration: null,
        next: Nt => {
            let Ut = !1;
            return !Bt && Pt === void 0 && (Ut = !0, At(Nt), Lt(Nt)), Pt !== void 0 && Nt >= Pt ? Bt.next(Nt - Pt) : (!Ut && At(Nt), lt)
        }
    }
}
const calcBezier = (s, o, a) => (((1 - 3 * a + 3 * o) * s + (3 * a - 6 * o)) * s + 3 * o) * s,
    subdivisionPrecision = 1e-7,
    subdivisionMaxIterations = 12;

function binarySubdivide(s, o, a, $, j) {
    let _e, et, tt = 0;
    do et = o + (a - o) / 2, _e = calcBezier(et, $, j) - s, _e > 0 ? a = et : o = et; while (Math.abs(_e) > subdivisionPrecision && ++tt < subdivisionMaxIterations);
    return et
}

function cubicBezier(s, o, a, $) {
    if (s === o && a === $) return noop$1;
    const j = _e => binarySubdivide(_e, 0, 1, s, a);
    return _e => _e === 0 || _e === 1 ? _e : calcBezier(j(_e), o, $)
}
const easeIn = cubicBezier(.42, 0, 1, 1),
    easeOut = cubicBezier(0, 0, .58, 1),
    easeInOut = cubicBezier(.42, 0, .58, 1),
    isEasingArray = s => Array.isArray(s) && typeof s[0] != "number",
    mirrorEasing = s => o => o <= .5 ? s(2 * o) / 2 : (2 - s(2 * (1 - o))) / 2,
    reverseEasing = s => o => 1 - s(1 - o),
    circIn = s => 1 - Math.sin(Math.acos(s)),
    circOut = reverseEasing(circIn),
    circInOut = mirrorEasing(circIn),
    backOut = cubicBezier(.33, 1.53, .69, .99),
    backIn = reverseEasing(backOut),
    backInOut = mirrorEasing(backIn),
    anticipate = s => (s *= 2) < 1 ? .5 * backIn(s) : .5 * (2 - Math.pow(2, -10 * (s - 1))),
    easingLookup = {
        linear: noop$1,
        easeIn,
        easeInOut,
        easeOut,
        circIn,
        circInOut,
        circOut,
        backIn,
        backInOut,
        backOut,
        anticipate
    },
    easingDefinitionToFunction = s => {
        if (Array.isArray(s)) {
            invariant(s.length === 4);
            const [o, a, $, j] = s;
            return cubicBezier(o, a, $, j)
        } else if (typeof s == "string") return invariant(easingLookup[s] !== void 0), easingLookup[s];
        return s
    },
    progress = (s, o, a) => {
        const $ = o - s;
        return $ === 0 ? 1 : (a - s) / $
    },
    mixNumber$1 = (s, o, a) => s + (o - s) * a;

function hueToRgb(s, o, a) {
    return a < 0 && (a += 1), a > 1 && (a -= 1), a < 1 / 6 ? s + (o - s) * 6 * a : a < 1 / 2 ? o : a < 2 / 3 ? s + (o - s) * (2 / 3 - a) * 6 : s
}

function hslaToRgba({
    hue: s,
    saturation: o,
    lightness: a,
    alpha: $
}) {
    s /= 360, o /= 100, a /= 100;
    let j = 0,
        _e = 0,
        et = 0;
    if (!o) j = _e = et = a;
    else {
        const tt = a < .5 ? a * (1 + o) : a + o - a * o,
            nt = 2 * a - tt;
        j = hueToRgb(nt, tt, s + 1 / 3), _e = hueToRgb(nt, tt, s), et = hueToRgb(nt, tt, s - 1 / 3)
    }
    return {
        red: Math.round(j * 255),
        green: Math.round(_e * 255),
        blue: Math.round(et * 255),
        alpha: $
    }
}

function mixImmediate(s, o) {
    return a => a > 0 ? o : s
}
const mixLinearColor = (s, o, a) => {
        const $ = s * s,
            j = a * (o * o - $) + $;
        return j < 0 ? 0 : Math.sqrt(j)
    },
    colorTypes = [hex$1, rgba, hsla],
    getColorType = s => colorTypes.find(o => o.test(s));

function asRGBA(s) {
    const o = getColorType(s);
    if (!o) return !1;
    let a = o.parse(s);
    return o === hsla && (a = hslaToRgba(a)), a
}
const mixColor = (s, o) => {
        const a = asRGBA(s),
            $ = asRGBA(o);
        if (!a || !$) return mixImmediate(s, o);
        const j = { ...a
        };
        return _e => (j.red = mixLinearColor(a.red, $.red, _e), j.green = mixLinearColor(a.green, $.green, _e), j.blue = mixLinearColor(a.blue, $.blue, _e), j.alpha = mixNumber$1(a.alpha, $.alpha, _e), rgba.transform(j))
    },
    invisibleValues = new Set(["none", "hidden"]);

function mixVisibility(s, o) {
    return invisibleValues.has(s) ? a => a <= 0 ? s : o : a => a >= 1 ? o : s
}

function mixNumber(s, o) {
    return a => mixNumber$1(s, o, a)
}

function getMixer(s) {
    return typeof s == "number" ? mixNumber : typeof s == "string" ? isCSSVariableToken(s) ? mixImmediate : color.test(s) ? mixColor : mixComplex : Array.isArray(s) ? mixArray : typeof s == "object" ? color.test(s) ? mixColor : mixObject : mixImmediate
}

function mixArray(s, o) {
    const a = [...s],
        $ = a.length,
        j = s.map((_e, et) => getMixer(_e)(_e, o[et]));
    return _e => {
        for (let et = 0; et < $; et++) a[et] = j[et](_e);
        return a
    }
}

function mixObject(s, o) {
    const a = { ...s,
            ...o
        },
        $ = {};
    for (const j in a) s[j] !== void 0 && o[j] !== void 0 && ($[j] = getMixer(s[j])(s[j], o[j]));
    return j => {
        for (const _e in $) a[_e] = $[_e](j);
        return a
    }
}

function matchOrder(s, o) {
    var a;
    const $ = [],
        j = {
            color: 0,
            var: 0,
            number: 0
        };
    for (let _e = 0; _e < o.values.length; _e++) {
        const et = o.types[_e],
            tt = s.indexes[et][j[et]],
            nt = (a = s.values[tt]) !== null && a !== void 0 ? a : 0;
        $[_e] = nt, j[et]++
    }
    return $
}
const mixComplex = (s, o) => {
    const a = complex.createTransformer(o),
        $ = analyseComplexValue(s),
        j = analyseComplexValue(o);
    return $.indexes.var.length === j.indexes.var.length && $.indexes.color.length === j.indexes.color.length && $.indexes.number.length >= j.indexes.number.length ? invisibleValues.has(s) && !j.values.length || invisibleValues.has(o) && !$.values.length ? mixVisibility(s, o) : pipe(mixArray(matchOrder($, j), j.values), a) : mixImmediate(s, o)
};

function mix(s, o, a) {
    return typeof s == "number" && typeof o == "number" && typeof a == "number" ? mixNumber$1(s, o, a) : getMixer(s)(s, o)
}

function createMixers(s, o, a) {
    const $ = [],
        j = a || mix,
        _e = s.length - 1;
    for (let et = 0; et < _e; et++) {
        let tt = j(s[et], s[et + 1]);
        if (o) {
            const nt = Array.isArray(o) ? o[et] || noop$1 : o;
            tt = pipe(nt, tt)
        }
        $.push(tt)
    }
    return $
}

function interpolate(s, o, {
    clamp: a = !0,
    ease: $,
    mixer: j
} = {}) {
    const _e = s.length;
    if (invariant(_e === o.length), _e === 1) return () => o[0];
    if (_e === 2 && s[0] === s[1]) return () => o[1];
    s[0] > s[_e - 1] && (s = [...s].reverse(), o = [...o].reverse());
    const et = createMixers(o, $, j),
        tt = et.length,
        nt = rt => {
            let ot = 0;
            if (tt > 1)
                for (; ot < s.length - 2 && !(rt < s[ot + 1]); ot++);
            const st = progress(s[ot], s[ot + 1], rt);
            return et[ot](st)
        };
    return a ? rt => nt(clamp(s[0], s[_e - 1], rt)) : nt
}

function fillOffset(s, o) {
    const a = s[s.length - 1];
    for (let $ = 1; $ <= o; $++) {
        const j = progress(0, o, $);
        s.push(mixNumber$1(a, 1, j))
    }
}

function defaultOffset(s) {
    const o = [0];
    return fillOffset(o, s.length - 1), o
}

function convertOffsetToTimes(s, o) {
    return s.map(a => a * o)
}

function defaultEasing(s, o) {
    return s.map(() => o || easeInOut).splice(0, s.length - 1)
}

function keyframes({
    duration: s = 300,
    keyframes: o,
    times: a,
    ease: $ = "easeInOut"
}) {
    const j = isEasingArray($) ? $.map(easingDefinitionToFunction) : easingDefinitionToFunction($),
        _e = {
            done: !1,
            value: o[0]
        },
        et = convertOffsetToTimes(a && a.length === o.length ? a : defaultOffset(o), s),
        tt = interpolate(et, o, {
            ease: Array.isArray(j) ? j : defaultEasing(o, j)
        });
    return {
        calculatedDuration: s,
        next: nt => (_e.value = tt(nt), _e.done = nt >= s, _e)
    }
}
const maxGeneratorDuration = 2e4;

function calcGeneratorDuration(s) {
    let o = 0;
    const a = 50;
    let $ = s.next(o);
    for (; !$.done && o < maxGeneratorDuration;) o += a, $ = s.next(o);
    return o >= maxGeneratorDuration ? 1 / 0 : o
}
const frameloopDriver = s => {
        const o = ({
            timestamp: a
        }) => s(a);
        return {
            start: () => frame.update(o, !0),
            stop: () => cancelFrame(o),
            now: () => frameData.isProcessing ? frameData.timestamp : time.now()
        }
    },
    generators = {
        decay: inertia,
        inertia,
        tween: keyframes,
        keyframes,
        spring
    },
    percentToProgress = s => s / 100;
class MainThreadAnimation extends BaseAnimation {
    constructor({
        KeyframeResolver: o = KeyframeResolver,
        ...a
    }) {
        super(a), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle", this.stop = () => {
            if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
            this.teardown();
            const {
                onStop: tt
            } = this.options;
            tt && tt()
        };
        const {
            name: $,
            motionValue: j,
            keyframes: _e
        } = this.options, et = (tt, nt) => this.onKeyframesResolved(tt, nt);
        $ && j && j.owner ? this.resolver = j.owner.resolveKeyframes(_e, et, $, j) : this.resolver = new o(_e, et, $, j), this.resolver.scheduleResolve()
    }
    initPlayback(o) {
        const {
            type: a = "keyframes",
            repeat: $ = 0,
            repeatDelay: j = 0,
            repeatType: _e,
            velocity: et = 0
        } = this.options, tt = generators[a] || keyframes;
        let nt, rt;
        tt !== keyframes && typeof o[0] != "number" && (nt = pipe(percentToProgress, mix(o[0], o[1])), o = [0, 100]);
        const ot = tt({ ...this.options,
            keyframes: o
        });
        _e === "mirror" && (rt = tt({ ...this.options,
            keyframes: [...o].reverse(),
            velocity: -et
        })), ot.calculatedDuration === null && (ot.calculatedDuration = calcGeneratorDuration(ot));
        const {
            calculatedDuration: st
        } = ot, lt = st + j, ft = lt * ($ + 1) - j;
        return {
            generator: ot,
            mirroredGenerator: rt,
            mapPercentToKeyframes: nt,
            calculatedDuration: st,
            resolvedDuration: lt,
            totalDuration: ft
        }
    }
    onPostResolved() {
        const {
            autoplay: o = !0
        } = this.options;
        this.play(), this.pendingPlayState === "paused" || !o ? this.pause() : this.state = this.pendingPlayState
    }
    tick(o, a = !1) {
        const {
            resolved: $
        } = this;
        if (!$) {
            const {
                keyframes: Nt
            } = this.options;
            return {
                done: !0,
                value: Nt[Nt.length - 1]
            }
        }
        const {
            finalKeyframe: j,
            generator: _e,
            mirroredGenerator: et,
            mapPercentToKeyframes: tt,
            keyframes: nt,
            calculatedDuration: rt,
            totalDuration: ot,
            resolvedDuration: st
        } = $;
        if (this.startTime === null) return _e.next(0);
        const {
            delay: lt,
            repeat: ft,
            repeatType: yt,
            repeatDelay: bt,
            onUpdate: ht
        } = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, o) : this.speed < 0 && (this.startTime = Math.min(o - ot / this.speed, this.startTime)), a ? this.currentTime = o : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(o - this.startTime) * this.speed;
        const vt = this.currentTime - lt * (this.speed >= 0 ? 1 : -1),
            wt = this.speed >= 0 ? vt < 0 : vt > ot;
        this.currentTime = Math.max(vt, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = ot);
        let gt = this.currentTime,
            At = _e;
        if (ft) {
            const Nt = Math.min(this.currentTime, ot) / st;
            let Ut = Math.floor(Nt),
                Vt = Nt % 1;
            !Vt && Nt >= 1 && (Vt = 1), Vt === 1 && Ut--, Ut = Math.min(Ut, ft + 1), !!(Ut % 2) && (yt === "reverse" ? (Vt = 1 - Vt, bt && (Vt -= bt / st)) : yt === "mirror" && (At = et)), gt = clamp(0, 1, Vt) * st
        }
        const Pt = wt ? {
            done: !1,
            value: nt[0]
        } : At.next(gt);
        tt && (Pt.value = tt(Pt.value));
        let {
            done: Bt
        } = Pt;
        !wt && rt !== null && (Bt = this.speed >= 0 ? this.currentTime >= ot : this.currentTime <= 0);
        const Lt = this.holdTime === null && (this.state === "finished" || this.state === "running" && Bt);
        return Lt && j !== void 0 && (Pt.value = getFinalKeyframe(nt, this.options, j)), ht && ht(Pt.value), Lt && this.finish(), Pt
    }
    get duration() {
        const {
            resolved: o
        } = this;
        return o ? millisecondsToSeconds(o.calculatedDuration) : 0
    }
    get time() {
        return millisecondsToSeconds(this.currentTime)
    }
    set time(o) {
        o = secondsToMilliseconds(o), this.currentTime = o, this.holdTime !== null || this.speed === 0 ? this.holdTime = o : this.driver && (this.startTime = this.driver.now() - o / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(o) {
        const a = this.playbackSpeed !== o;
        this.playbackSpeed = o, a && (this.time = millisecondsToSeconds(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped) return;
        const {
            driver: o = frameloopDriver,
            onPlay: a
        } = this.options;
        this.driver || (this.driver = o(j => this.tick(j))), a && a();
        const $ = this.driver.now();
        this.holdTime !== null ? this.startTime = $ - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = $), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start()
    }
    pause() {
        var o;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused", this.holdTime = (o = this.currentTime) !== null && o !== void 0 ? o : 0
    }
    complete() {
        this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null
    }
    finish() {
        this.teardown(), this.state = "finished";
        const {
            onComplete: o
        } = this.options;
        o && o()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(), this.driver = void 0)
    }
    sample(o) {
        return this.startTime = 0, this.tick(o, !0)
    }
}
const isBezierDefinition = s => Array.isArray(s) && typeof s[0] == "number";

function isWaapiSupportedEasing(s) {
    return !!(!s || typeof s == "string" && s in supportedWaapiEasing || isBezierDefinition(s) || Array.isArray(s) && s.every(isWaapiSupportedEasing))
}
const cubicBezierAsString = ([s, o, a, $]) => `cubic-bezier(${s}, ${o}, ${a}, ${$})`,
    supportedWaapiEasing = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: cubicBezierAsString([0, .65, .55, 1]),
        circOut: cubicBezierAsString([.55, 0, 1, .45]),
        backIn: cubicBezierAsString([.31, .01, .66, -.59]),
        backOut: cubicBezierAsString([.33, 1.53, .69, .99])
    };

function mapEasingToNativeEasingWithDefault(s) {
    return mapEasingToNativeEasing(s) || supportedWaapiEasing.easeOut
}

function mapEasingToNativeEasing(s) {
    if (s) return isBezierDefinition(s) ? cubicBezierAsString(s) : Array.isArray(s) ? s.map(mapEasingToNativeEasingWithDefault) : supportedWaapiEasing[s]
}

function animateStyle(s, o, a, {
    delay: $ = 0,
    duration: j = 300,
    repeat: _e = 0,
    repeatType: et = "loop",
    ease: tt,
    times: nt
} = {}) {
    const rt = {
        [o]: a
    };
    nt && (rt.offset = nt);
    const ot = mapEasingToNativeEasing(tt);
    return Array.isArray(ot) && (rt.easing = ot), s.animate(rt, {
        delay: $,
        duration: j,
        easing: Array.isArray(ot) ? "linear" : ot,
        fill: "both",
        iterations: _e + 1,
        direction: et === "reverse" ? "alternate" : "normal"
    })
}
const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
    sampleDelta = 10,
    maxDuration = 2e4;

function requiresPregeneratedKeyframes(s) {
    return s.type === "spring" || !isWaapiSupportedEasing(s.ease)
}

function pregenerateKeyframes(s, o) {
    const a = new MainThreadAnimation({ ...o,
        keyframes: s,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let $ = {
        done: !1,
        value: s[0]
    };
    const j = [];
    let _e = 0;
    for (; !$.done && _e < maxDuration;) $ = a.sample(_e), j.push($.value), _e += sampleDelta;
    return {
        times: void 0,
        keyframes: j,
        duration: _e - sampleDelta,
        ease: "linear"
    }
}
class AcceleratedAnimation extends BaseAnimation {
    constructor(o) {
        super(o);
        const {
            name: a,
            motionValue: $,
            keyframes: j
        } = this.options;
        this.resolver = new DOMKeyframesResolver(j, (_e, et) => this.onKeyframesResolved(_e, et), a, $), this.resolver.scheduleResolve()
    }
    initPlayback(o, a) {
        var $;
        let {
            duration: j = 300,
            times: _e,
            ease: et,
            type: tt,
            motionValue: nt,
            name: rt
        } = this.options;
        if (!(!(($ = nt.owner) === null || $ === void 0) && $.current)) return !1;
        if (requiresPregeneratedKeyframes(this.options)) {
            const {
                onComplete: st,
                onUpdate: lt,
                motionValue: ft,
                ...yt
            } = this.options, bt = pregenerateKeyframes(o, yt);
            o = bt.keyframes, o.length === 1 && (o[1] = o[0]), j = bt.duration, _e = bt.times, et = bt.ease, tt = "keyframes"
        }
        const ot = animateStyle(nt.owner.current, rt, o, { ...this.options,
            duration: j,
            times: _e,
            ease: et
        });
        return ot.startTime = time.now(), this.pendingTimeline ? (ot.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : ot.onfinish = () => {
            const {
                onComplete: st
            } = this.options;
            nt.set(getFinalKeyframe(o, this.options, a)), st && st(), this.cancel(), this.resolveFinishedPromise()
        }, {
            animation: ot,
            duration: j,
            times: _e,
            type: tt,
            ease: et,
            keyframes: o
        }
    }
    get duration() {
        const {
            resolved: o
        } = this;
        if (!o) return 0;
        const {
            duration: a
        } = o;
        return millisecondsToSeconds(a)
    }
    get time() {
        const {
            resolved: o
        } = this;
        if (!o) return 0;
        const {
            animation: a
        } = o;
        return millisecondsToSeconds(a.currentTime || 0)
    }
    set time(o) {
        const {
            resolved: a
        } = this;
        if (!a) return;
        const {
            animation: $
        } = a;
        $.currentTime = secondsToMilliseconds(o)
    }
    get speed() {
        const {
            resolved: o
        } = this;
        if (!o) return 1;
        const {
            animation: a
        } = o;
        return a.playbackRate
    }
    set speed(o) {
        const {
            resolved: a
        } = this;
        if (!a) return;
        const {
            animation: $
        } = a;
        $.playbackRate = o
    }
    get state() {
        const {
            resolved: o
        } = this;
        if (!o) return "idle";
        const {
            animation: a
        } = o;
        return a.playState
    }
    attachTimeline(o) {
        if (!this._resolved) this.pendingTimeline = o;
        else {
            const {
                resolved: a
            } = this;
            if (!a) return noop$1;
            const {
                animation: $
            } = a;
            $.timeline = o, $.onfinish = null
        }
        return noop$1
    }
    play() {
        if (this.isStopped) return;
        const {
            resolved: o
        } = this;
        if (!o) return;
        const {
            animation: a
        } = o;
        a.playState === "finished" && this.updateFinishedPromise(), a.play()
    }
    pause() {
        const {
            resolved: o
        } = this;
        if (!o) return;
        const {
            animation: a
        } = o;
        a.pause()
    }
    stop() {
        if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
        this.resolveFinishedPromise(), this.updateFinishedPromise();
        const {
            resolved: o
        } = this;
        if (!o) return;
        const {
            animation: a,
            keyframes: $,
            duration: j,
            type: _e,
            ease: et,
            times: tt
        } = o;
        if (a.playState === "idle" || a.playState === "finished") return;
        if (this.time) {
            const {
                motionValue: rt,
                onUpdate: ot,
                onComplete: st,
                ...lt
            } = this.options, ft = new MainThreadAnimation({ ...lt,
                keyframes: $,
                duration: j,
                type: _e,
                ease: et,
                times: tt,
                isGenerator: !0
            }), yt = secondsToMilliseconds(this.time);
            rt.setWithVelocity(ft.sample(yt - sampleDelta).value, ft.sample(yt).value, sampleDelta)
        }
        const {
            onStop: nt
        } = this.options;
        nt && nt(), this.cancel()
    }
    complete() {
        const {
            resolved: o
        } = this;
        o && o.animation.finish()
    }
    cancel() {
        const {
            resolved: o
        } = this;
        o && o.animation.cancel()
    }
    static supports(o) {
        const {
            motionValue: a,
            name: $,
            repeatDelay: j,
            repeatType: _e,
            damping: et,
            type: tt
        } = o;
        return supportsWaapi() && $ && acceleratedValues.has($) && a && a.owner && a.owner.current instanceof HTMLElement && !a.owner.getProps().onUpdate && !j && _e !== "mirror" && et !== 0 && tt !== "inertia"
    }
}

function observeTimeline(s, o) {
    let a;
    const $ = () => {
        const {
            currentTime: j
        } = o, et = (j === null ? 0 : j.value) / 100;
        a !== et && s(et), a = et
    };
    return frame.update($, !0), () => cancelFrame($)
}
const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
class GroupPlaybackControls {
    constructor(o) {
        this.stop = () => this.runAll("stop"), this.animations = o.filter(Boolean)
    }
    then(o, a) {
        return Promise.all(this.animations).then(o).catch(a)
    }
    getAll(o) {
        return this.animations[0][o]
    }
    setAll(o, a) {
        for (let $ = 0; $ < this.animations.length; $++) this.animations[$][o] = a
    }
    attachTimeline(o) {
        const a = this.animations.map($ => {
            if (supportsScrollTimeline() && $.attachTimeline) $.attachTimeline(o);
            else return $.pause(), observeTimeline(j => {
                $.time = $.duration * j
            }, o)
        });
        return () => {
            a.forEach(($, j) => {
                $ && $(), this.animations[j].stop()
            })
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(o) {
        this.setAll("time", o)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(o) {
        this.setAll("speed", o)
    }
    get duration() {
        let o = 0;
        for (let a = 0; a < this.animations.length; a++) o = Math.max(o, this.animations[a].duration);
        return o
    }
    runAll(o) {
        this.animations.forEach(a => a[o]())
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
const animateMotionValue = (s, o, a, $ = {}, j, _e, et) => tt => {
    const nt = getValueTransition($, s) || {},
        rt = nt.delay || $.delay || 0;
    let {
        elapsed: ot = 0
    } = $;
    ot = ot - secondsToMilliseconds(rt);
    let st = {
        keyframes: Array.isArray(a) ? a : [null, a],
        ease: "easeOut",
        velocity: o.getVelocity(),
        ...nt,
        delay: -ot,
        onUpdate: ft => {
            o.set(ft), nt.onUpdate && nt.onUpdate(ft)
        },
        onComplete: () => {
            tt(), nt.onComplete && nt.onComplete(), et && et()
        },
        onStop: et,
        name: s,
        motionValue: o,
        element: _e ? void 0 : j
    };
    isTransitionDefined(nt) || (st = { ...st,
        ...getDefaultTransition(s, st)
    }), st.duration && (st.duration = secondsToMilliseconds(st.duration)), st.repeatDelay && (st.repeatDelay = secondsToMilliseconds(st.repeatDelay)), st.from !== void 0 && (st.keyframes[0] = st.from);
    let lt = !1;
    if ((st.type === !1 || st.duration === 0 && !st.repeatDelay) && (st.duration = 0, st.delay === 0 && (lt = !0)), lt && !_e && o.get() !== void 0) {
        const ft = getFinalKeyframe(st.keyframes, nt);
        if (ft !== void 0) return frame.update(() => {
            st.onUpdate(ft), st.onComplete()
        }), new GroupPlaybackControls([])
    }
    return !_e && AcceleratedAnimation.supports(st) ? new AcceleratedAnimation(st) : new MainThreadAnimation(st)
};
class SubscriptionManager {
    constructor() {
        this.subscriptions = []
    }
    add(o) {
        return addUniqueItem(this.subscriptions, o), () => removeItem(this.subscriptions, o)
    }
    notify(o, a, $) {
        const j = this.subscriptions.length;
        if (j)
            if (j === 1) this.subscriptions[0](o, a, $);
            else
                for (let _e = 0; _e < j; _e++) {
                    const et = this.subscriptions[_e];
                    et && et(o, a, $)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const MAX_VELOCITY_DELTA = 30,
    isFloat = s => !isNaN(parseFloat(s));
class MotionValue {
    constructor(o, a = {}) {
        this.version = "11.3.21", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = ($, j = !0) => {
            const _e = time.now();
            this.updatedAt !== _e && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent($), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), j && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }, this.hasAnimated = !1, this.setCurrent(o), this.owner = a.owner
    }
    setCurrent(o) {
        this.current = o, this.updatedAt = time.now(), this.canTrackVelocity === null && o !== void 0 && (this.canTrackVelocity = isFloat(this.current))
    }
    setPrevFrameValue(o = this.current) {
        this.prevFrameValue = o, this.prevUpdatedAt = this.updatedAt
    }
    onChange(o) {
        return this.on("change", o)
    }
    on(o, a) {
        this.events[o] || (this.events[o] = new SubscriptionManager);
        const $ = this.events[o].add(a);
        return o === "change" ? () => {
            $(), frame.read(() => {
                this.events.change.getSize() || this.stop()
            })
        } : $
    }
    clearListeners() {
        for (const o in this.events) this.events[o].clear()
    }
    attach(o, a) {
        this.passiveEffect = o, this.stopPassiveEffect = a
    }
    set(o, a = !0) {
        !a || !this.passiveEffect ? this.updateAndNotify(o, a) : this.passiveEffect(o, this.updateAndNotify)
    }
    setWithVelocity(o, a, $) {
        this.set(a), this.prev = void 0, this.prevFrameValue = o, this.prevUpdatedAt = this.updatedAt - $
    }
    jump(o, a = !0) {
        this.updateAndNotify(o), this.prev = o, this.prevUpdatedAt = this.prevFrameValue = void 0, a && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const o = time.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || o - this.updatedAt > MAX_VELOCITY_DELTA) return 0;
        const a = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
        return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), a)
    }
    start(o) {
        return this.stop(), new Promise(a => {
            this.hasAnimated = !0, this.animation = o(a), this.events.animationStart && this.events.animationStart.notify()
        }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
        })
    }
    stop() {
        this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
}

function motionValue(s, o) {
    return new MotionValue(s, o)
}

function setMotionValue(s, o, a) {
    s.hasValue(o) ? s.getValue(o).set(a) : s.addValue(o, motionValue(a))
}

function setTarget(s, o) {
    const a = resolveVariant(s, o);
    let {
        transitionEnd: $ = {},
        transition: j = {},
        ..._e
    } = a || {};
    _e = { ..._e,
        ...$
    };
    for (const et in _e) {
        const tt = resolveFinalValueInKeyframes(_e[et]);
        setMotionValue(s, et, tt)
    }
}

function getOptimisedAppearId(s) {
    return s.getProps()[optimizedAppearDataAttribute]
}
class WillChangeMotionValue extends MotionValue {
    constructor() {
        super(...arguments), this.output = [], this.counts = new Map
    }
    add(o) {
        const a = getWillChangeName(o);
        if (!a) return;
        const $ = this.counts.get(a) || 0;
        this.counts.set(a, $ + 1), $ === 0 && (this.output.push(a), this.update());
        let j = !1;
        return () => {
            if (j) return;
            j = !0;
            const _e = this.counts.get(a) - 1;
            this.counts.set(a, _e), _e === 0 && (removeItem(this.output, a), this.update())
        }
    }
    update() {
        this.set(this.output.length ? this.output.join(", ") : "auto")
    }
}

function isWillChangeMotionValue(s) {
    return !!(isMotionValue(s) && s.add)
}

function addValueToWillChange(s, o) {
    var a;
    if (!s.applyWillChange) return;
    let $ = s.getValue("willChange");
    if (!$ && !(!((a = s.props.style) === null || a === void 0) && a.willChange) && ($ = new WillChangeMotionValue("auto"), s.addValue("willChange", $)), isWillChangeMotionValue($)) return $.add(o)
}

function shouldBlockAnimation({
    protectedKeys: s,
    needsAnimating: o
}, a) {
    const $ = s.hasOwnProperty(a) && o[a] !== !0;
    return o[a] = !1, $
}

function animateTarget(s, o, {
    delay: a = 0,
    transitionOverride: $,
    type: j
} = {}) {
    var _e;
    let {
        transition: et = s.getDefaultTransition(),
        transitionEnd: tt,
        ...nt
    } = o;
    $ && (et = $);
    const rt = [],
        ot = j && s.animationState && s.animationState.getState()[j];
    for (const st in nt) {
        const lt = s.getValue(st, (_e = s.latestValues[st]) !== null && _e !== void 0 ? _e : null),
            ft = nt[st];
        if (ft === void 0 || ot && shouldBlockAnimation(ot, st)) continue;
        const yt = {
            delay: a,
            elapsed: 0,
            ...getValueTransition(et || {}, st)
        };
        let bt = !1;
        if (window.HandoffAppearAnimations) {
            const vt = getOptimisedAppearId(s);
            if (vt) {
                const wt = window.HandoffAppearAnimations(vt, st, lt, frame);
                wt !== null && (yt.elapsed = wt, bt = !0)
            }
        }
        lt.start(animateMotionValue(st, lt, ft, s.shouldReduceMotion && transformProps.has(st) ? {
            type: !1
        } : yt, s, bt, addValueToWillChange(s, st)));
        const ht = lt.animation;
        ht && rt.push(ht)
    }
    return tt && Promise.all(rt).then(() => {
        frame.update(() => {
            tt && setTarget(s, tt)
        })
    }), rt
}

function animateVariant(s, o, a = {}) {
    var $;
    const j = resolveVariant(s, o, a.type === "exit" ? ($ = s.presenceContext) === null || $ === void 0 ? void 0 : $.custom : void 0);
    let {
        transition: _e = s.getDefaultTransition() || {}
    } = j || {};
    a.transitionOverride && (_e = a.transitionOverride);
    const et = j ? () => Promise.all(animateTarget(s, j, a)) : () => Promise.resolve(),
        tt = s.variantChildren && s.variantChildren.size ? (rt = 0) => {
            const {
                delayChildren: ot = 0,
                staggerChildren: st,
                staggerDirection: lt
            } = _e;
            return animateChildren(s, o, ot + rt, st, lt, a)
        } : () => Promise.resolve(),
        {
            when: nt
        } = _e;
    if (nt) {
        const [rt, ot] = nt === "beforeChildren" ? [et, tt] : [tt, et];
        return rt().then(() => ot())
    } else return Promise.all([et(), tt(a.delay)])
}

function animateChildren(s, o, a = 0, $ = 0, j = 1, _e) {
    const et = [],
        tt = (s.variantChildren.size - 1) * $,
        nt = j === 1 ? (rt = 0) => rt * $ : (rt = 0) => tt - rt * $;
    return Array.from(s.variantChildren).sort(sortByTreeOrder).forEach((rt, ot) => {
        rt.notify("AnimationStart", o), et.push(animateVariant(rt, o, { ..._e,
            delay: a + nt(ot)
        }).then(() => rt.notify("AnimationComplete", o)))
    }), Promise.all(et)
}

function sortByTreeOrder(s, o) {
    return s.sortNodePosition(o)
}

function animateVisualElement(s, o, a = {}) {
    s.notify("AnimationStart", o);
    let $;
    if (Array.isArray(o)) {
        const j = o.map(_e => animateVariant(s, _e, a));
        $ = Promise.all(j)
    } else if (typeof o == "string") $ = animateVariant(s, o, a);
    else {
        const j = typeof o == "function" ? resolveVariant(s, o, a.custom) : o;
        $ = Promise.all(animateTarget(s, j, a))
    }
    return $.then(() => {
        s.notify("AnimationComplete", o)
    })
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(),
    numAnimationTypes = variantPriorityOrder.length;

function animateList(s) {
    return o => Promise.all(o.map(({
        animation: a,
        options: $
    }) => animateVisualElement(s, a, $)))
}

function createAnimationState(s) {
    let o = animateList(s),
        a = createState(),
        $ = !0;
    const j = nt => (rt, ot) => {
        var st;
        const lt = resolveVariant(s, ot, nt === "exit" ? (st = s.presenceContext) === null || st === void 0 ? void 0 : st.custom : void 0);
        if (lt) {
            const {
                transition: ft,
                transitionEnd: yt,
                ...bt
            } = lt;
            rt = { ...rt,
                ...bt,
                ...yt
            }
        }
        return rt
    };

    function _e(nt) {
        o = nt(s)
    }

    function et(nt) {
        const rt = s.getProps(),
            ot = s.getVariantContext(!0) || {},
            st = [],
            lt = new Set;
        let ft = {},
            yt = 1 / 0;
        for (let ht = 0; ht < numAnimationTypes; ht++) {
            const vt = reversePriorityOrder[ht],
                wt = a[vt],
                gt = rt[vt] !== void 0 ? rt[vt] : ot[vt],
                At = isVariantLabel(gt),
                Pt = vt === nt ? wt.isActive : null;
            Pt === !1 && (yt = ht);
            let Bt = gt === ot[vt] && gt !== rt[vt] && At;
            if (Bt && $ && s.manuallyAnimateOnMount && (Bt = !1), wt.protectedKeys = { ...ft
                }, !wt.isActive && Pt === null || !gt && !wt.prevProp || isAnimationControls(gt) || typeof gt == "boolean") continue;
            let Nt = checkVariantsDidChange(wt.prevProp, gt) || vt === nt && wt.isActive && !Bt && At || ht > yt && At,
                Ut = !1;
            const Vt = Array.isArray(gt) ? gt : [gt];
            let Ft = Vt.reduce(j(vt), {});
            Pt === !1 && (Ft = {});
            const {
                prevResolvedValues: Wt = {}
            } = wt, Ct = { ...Wt,
                ...Ft
            }, it = at => {
                Nt = !0, lt.has(at) && (Ut = !0, lt.delete(at)), wt.needsAnimating[at] = !0;
                const mt = s.getValue(at);
                mt && (mt.liveStyle = !1)
            };
            for (const at in Ct) {
                const mt = Ft[at],
                    xt = Wt[at];
                if (ft.hasOwnProperty(at)) continue;
                let $t = !1;
                isKeyframesTarget(mt) && isKeyframesTarget(xt) ? $t = !shallowCompare(mt, xt) : $t = mt !== xt, $t ? mt != null ? it(at) : lt.add(at) : mt !== void 0 && lt.has(at) ? it(at) : wt.protectedKeys[at] = !0
            }
            wt.prevProp = gt, wt.prevResolvedValues = Ft, wt.isActive && (ft = { ...ft,
                ...Ft
            }), $ && s.blockInitialAnimation && (Nt = !1), Nt && (!Bt || Ut) && st.push(...Vt.map(at => ({
                animation: at,
                options: {
                    type: vt
                }
            })))
        }
        if (lt.size) {
            const ht = {};
            lt.forEach(vt => {
                const wt = s.getBaseTarget(vt),
                    gt = s.getValue(vt);
                gt && (gt.liveStyle = !0), ht[vt] = wt ? ? null
            }), st.push({
                animation: ht
            })
        }
        let bt = !!st.length;
        return $ && (rt.initial === !1 || rt.initial === rt.animate) && !s.manuallyAnimateOnMount && (bt = !1), $ = !1, bt ? o(st) : Promise.resolve()
    }

    function tt(nt, rt) {
        var ot;
        if (a[nt].isActive === rt) return Promise.resolve();
        (ot = s.variantChildren) === null || ot === void 0 || ot.forEach(lt => {
            var ft;
            return (ft = lt.animationState) === null || ft === void 0 ? void 0 : ft.setActive(nt, rt)
        }), a[nt].isActive = rt;
        const st = et(nt);
        for (const lt in a) a[lt].protectedKeys = {};
        return st
    }
    return {
        animateChanges: et,
        setActive: tt,
        setAnimateFunction: _e,
        getState: () => a,
        reset: () => {
            a = createState(), $ = !0
        }
    }
}

function checkVariantsDidChange(s, o) {
    return typeof o == "string" ? o !== s : Array.isArray(o) ? !shallowCompare(o, s) : !1
}

function createTypeState(s = !1) {
    return {
        isActive: s,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}

function createState() {
    return {
        animate: createTypeState(!0),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
    }
}
class AnimationFeature extends Feature {
    constructor(o) {
        super(o), o.animationState || (o.animationState = createAnimationState(o))
    }
    updateAnimationControlsSubscription() {
        const {
            animate: o
        } = this.node.getProps();
        isAnimationControls(o) && (this.unmountControls = o.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {
            animate: o
        } = this.node.getProps(), {
            animate: a
        } = this.node.prevProps || {};
        o !== a && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var o;
        this.node.animationState.reset(), (o = this.unmountControls) === null || o === void 0 || o.call(this)
    }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
    constructor() {
        super(...arguments), this.id = id$1++
    }
    update() {
        if (!this.node.presenceContext) return;
        const {
            isPresent: o,
            onExitComplete: a
        } = this.node.presenceContext, {
            isPresent: $
        } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || o === $) return;
        const j = this.node.animationState.setActive("exit", !o);
        a && !o && j.then(() => a(this.id))
    }
    mount() {
        const {
            register: o
        } = this.node.presenceContext || {};
        o && (this.unmount = o(this.id))
    }
    unmount() {}
}
const animations = {
        animation: {
            Feature: AnimationFeature
        },
        exit: {
            Feature: ExitAnimationFeature
        }
    },
    distance = (s, o) => Math.abs(s - o);

function distance2D(s, o) {
    const a = distance(s.x, o.x),
        $ = distance(s.y, o.y);
    return Math.sqrt(a ** 2 + $ ** 2)
}
class PanSession {
    constructor(o, a, {
        transformPagePoint: $,
        contextWindow: j,
        dragSnapToOrigin: _e = !1
    } = {}) {
        if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const st = getPanInfo(this.lastMoveEventInfo, this.history),
                    lt = this.startEvent !== null,
                    ft = distance2D(st.offset, {
                        x: 0,
                        y: 0
                    }) >= 3;
                if (!lt && !ft) return;
                const {
                    point: yt
                } = st, {
                    timestamp: bt
                } = frameData;
                this.history.push({ ...yt,
                    timestamp: bt
                });
                const {
                    onStart: ht,
                    onMove: vt
                } = this.handlers;
                lt || (ht && ht(this.lastMoveEvent, st), this.startEvent = this.lastMoveEvent), vt && vt(this.lastMoveEvent, st)
            }, this.handlePointerMove = (st, lt) => {
                this.lastMoveEvent = st, this.lastMoveEventInfo = transformPoint(lt, this.transformPagePoint), frame.update(this.updatePoint, !0)
            }, this.handlePointerUp = (st, lt) => {
                this.end();
                const {
                    onEnd: ft,
                    onSessionEnd: yt,
                    resumeAnimation: bt
                } = this.handlers;
                if (this.dragSnapToOrigin && bt && bt(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const ht = getPanInfo(st.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(lt, this.transformPagePoint), this.history);
                this.startEvent && ft && ft(st, ht), yt && yt(st, ht)
            }, !isPrimaryPointer(o)) return;
        this.dragSnapToOrigin = _e, this.handlers = a, this.transformPagePoint = $, this.contextWindow = j || window;
        const et = extractEventInfo(o),
            tt = transformPoint(et, this.transformPagePoint),
            {
                point: nt
            } = tt,
            {
                timestamp: rt
            } = frameData;
        this.history = [{ ...nt,
            timestamp: rt
        }];
        const {
            onSessionStart: ot
        } = a;
        ot && ot(o, getPanInfo(tt, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(o) {
        this.handlers = o
    }
    end() {
        this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint)
    }
}

function transformPoint(s, o) {
    return o ? {
        point: o(s.point)
    } : s
}

function subtractPoint(s, o) {
    return {
        x: s.x - o.x,
        y: s.y - o.y
    }
}

function getPanInfo({
    point: s
}, o) {
    return {
        point: s,
        delta: subtractPoint(s, lastDevicePoint(o)),
        offset: subtractPoint(s, startDevicePoint(o)),
        velocity: getVelocity(o, .1)
    }
}

function startDevicePoint(s) {
    return s[0]
}

function lastDevicePoint(s) {
    return s[s.length - 1]
}

function getVelocity(s, o) {
    if (s.length < 2) return {
        x: 0,
        y: 0
    };
    let a = s.length - 1,
        $ = null;
    const j = lastDevicePoint(s);
    for (; a >= 0 && ($ = s[a], !(j.timestamp - $.timestamp > secondsToMilliseconds(o)));) a--;
    if (!$) return {
        x: 0,
        y: 0
    };
    const _e = millisecondsToSeconds(j.timestamp - $.timestamp);
    if (_e === 0) return {
        x: 0,
        y: 0
    };
    const et = {
        x: (j.x - $.x) / _e,
        y: (j.y - $.y) / _e
    };
    return et.x === 1 / 0 && (et.x = 0), et.y === 1 / 0 && (et.y = 0), et
}
const SCALE_PRECISION = 1e-4,
    SCALE_MIN = 1 - SCALE_PRECISION,
    SCALE_MAX = 1 + SCALE_PRECISION,
    TRANSLATE_PRECISION = .01,
    TRANSLATE_MIN = 0 - TRANSLATE_PRECISION,
    TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;

function calcLength(s) {
    return s.max - s.min
}

function isNear(s, o, a) {
    return Math.abs(s - o) <= a
}

function calcAxisDelta(s, o, a, $ = .5) {
    s.origin = $, s.originPoint = mixNumber$1(o.min, o.max, s.origin), s.scale = calcLength(a) / calcLength(o), s.translate = mixNumber$1(a.min, a.max, s.origin) - s.originPoint, (s.scale >= SCALE_MIN && s.scale <= SCALE_MAX || isNaN(s.scale)) && (s.scale = 1), (s.translate >= TRANSLATE_MIN && s.translate <= TRANSLATE_MAX || isNaN(s.translate)) && (s.translate = 0)
}

function calcBoxDelta(s, o, a, $) {
    calcAxisDelta(s.x, o.x, a.x, $ ? $.originX : void 0), calcAxisDelta(s.y, o.y, a.y, $ ? $.originY : void 0)
}

function calcRelativeAxis(s, o, a) {
    s.min = a.min + o.min, s.max = s.min + calcLength(o)
}

function calcRelativeBox(s, o, a) {
    calcRelativeAxis(s.x, o.x, a.x), calcRelativeAxis(s.y, o.y, a.y)
}

function calcRelativeAxisPosition(s, o, a) {
    s.min = o.min - a.min, s.max = s.min + calcLength(o)
}

function calcRelativePosition(s, o, a) {
    calcRelativeAxisPosition(s.x, o.x, a.x), calcRelativeAxisPosition(s.y, o.y, a.y)
}

function applyConstraints(s, {
    min: o,
    max: a
}, $) {
    return o !== void 0 && s < o ? s = $ ? mixNumber$1(o, s, $.min) : Math.max(s, o) : a !== void 0 && s > a && (s = $ ? mixNumber$1(a, s, $.max) : Math.min(s, a)), s
}

function calcRelativeAxisConstraints(s, o, a) {
    return {
        min: o !== void 0 ? s.min + o : void 0,
        max: a !== void 0 ? s.max + a - (s.max - s.min) : void 0
    }
}

function calcRelativeConstraints(s, {
    top: o,
    left: a,
    bottom: $,
    right: j
}) {
    return {
        x: calcRelativeAxisConstraints(s.x, a, j),
        y: calcRelativeAxisConstraints(s.y, o, $)
    }
}

function calcViewportAxisConstraints(s, o) {
    let a = o.min - s.min,
        $ = o.max - s.max;
    return o.max - o.min < s.max - s.min && ([a, $] = [$, a]), {
        min: a,
        max: $
    }
}

function calcViewportConstraints(s, o) {
    return {
        x: calcViewportAxisConstraints(s.x, o.x),
        y: calcViewportAxisConstraints(s.y, o.y)
    }
}

function calcOrigin(s, o) {
    let a = .5;
    const $ = calcLength(s),
        j = calcLength(o);
    return j > $ ? a = progress(o.min, o.max - $, s.min) : $ > j && (a = progress(s.min, s.max - j, o.min)), clamp(0, 1, a)
}

function rebaseAxisConstraints(s, o) {
    const a = {};
    return o.min !== void 0 && (a.min = o.min - s.min), o.max !== void 0 && (a.max = o.max - s.min), a
}
const defaultElastic = .35;

function resolveDragElastic(s = defaultElastic) {
    return s === !1 ? s = 0 : s === !0 && (s = defaultElastic), {
        x: resolveAxisElastic(s, "left", "right"),
        y: resolveAxisElastic(s, "top", "bottom")
    }
}

function resolveAxisElastic(s, o, a) {
    return {
        min: resolvePointElastic(s, o),
        max: resolvePointElastic(s, a)
    }
}

function resolvePointElastic(s, o) {
    return typeof s == "number" ? s : s[o] || 0
}
const createAxisDelta = () => ({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0
    }),
    createDelta = () => ({
        x: createAxisDelta(),
        y: createAxisDelta()
    }),
    createAxis = () => ({
        min: 0,
        max: 0
    }),
    createBox = () => ({
        x: createAxis(),
        y: createAxis()
    });

function eachAxis(s) {
    return [s("x"), s("y")]
}

function convertBoundingBoxToBox({
    top: s,
    left: o,
    right: a,
    bottom: $
}) {
    return {
        x: {
            min: o,
            max: a
        },
        y: {
            min: s,
            max: $
        }
    }
}

function convertBoxToBoundingBox({
    x: s,
    y: o
}) {
    return {
        top: o.min,
        right: s.max,
        bottom: o.max,
        left: s.min
    }
}

function transformBoxPoints(s, o) {
    if (!o) return s;
    const a = o({
            x: s.left,
            y: s.top
        }),
        $ = o({
            x: s.right,
            y: s.bottom
        });
    return {
        top: a.y,
        left: a.x,
        bottom: $.y,
        right: $.x
    }
}

function isIdentityScale(s) {
    return s === void 0 || s === 1
}

function hasScale({
    scale: s,
    scaleX: o,
    scaleY: a
}) {
    return !isIdentityScale(s) || !isIdentityScale(o) || !isIdentityScale(a)
}

function hasTransform(s) {
    return hasScale(s) || has2DTranslate(s) || s.z || s.rotate || s.rotateX || s.rotateY || s.skewX || s.skewY
}

function has2DTranslate(s) {
    return is2DTranslate(s.x) || is2DTranslate(s.y)
}

function is2DTranslate(s) {
    return s && s !== "0%"
}

function scalePoint(s, o, a) {
    const $ = s - a,
        j = o * $;
    return a + j
}

function applyPointDelta(s, o, a, $, j) {
    return j !== void 0 && (s = scalePoint(s, j, $)), scalePoint(s, a, $) + o
}

function applyAxisDelta(s, o = 0, a = 1, $, j) {
    s.min = applyPointDelta(s.min, o, a, $, j), s.max = applyPointDelta(s.max, o, a, $, j)
}

function applyBoxDelta(s, {
    x: o,
    y: a
}) {
    applyAxisDelta(s.x, o.translate, o.scale, o.originPoint), applyAxisDelta(s.y, a.translate, a.scale, a.originPoint)
}
const TREE_SCALE_SNAP_MIN = .999999999999,
    TREE_SCALE_SNAP_MAX = 1.0000000000001;

function applyTreeDeltas(s, o, a, $ = !1) {
    const j = a.length;
    if (!j) return;
    o.x = o.y = 1;
    let _e, et;
    for (let tt = 0; tt < j; tt++) {
        _e = a[tt], et = _e.projectionDelta;
        const {
            visualElement: nt
        } = _e.options;
        nt && nt.props.style && nt.props.style.display === "contents" || ($ && _e.options.layoutScroll && _e.scroll && _e !== _e.root && transformBox(s, {
            x: -_e.scroll.offset.x,
            y: -_e.scroll.offset.y
        }), et && (o.x *= et.x.scale, o.y *= et.y.scale, applyBoxDelta(s, et)), $ && hasTransform(_e.latestValues) && transformBox(s, _e.latestValues))
    }
    o.x < TREE_SCALE_SNAP_MAX && o.x > TREE_SCALE_SNAP_MIN && (o.x = 1), o.y < TREE_SCALE_SNAP_MAX && o.y > TREE_SCALE_SNAP_MIN && (o.y = 1)
}

function translateAxis(s, o) {
    s.min = s.min + o, s.max = s.max + o
}

function transformAxis(s, o, a, $, j = .5) {
    const _e = mixNumber$1(s.min, s.max, j);
    applyAxisDelta(s, o, a, _e, $)
}

function transformBox(s, o) {
    transformAxis(s.x, o.x, o.scaleX, o.scale, o.originX), transformAxis(s.y, o.y, o.scaleY, o.scale, o.originY)
}

function measureViewportBox(s, o) {
    return convertBoundingBoxToBox(transformBoxPoints(s.getBoundingClientRect(), o))
}

function measurePageBox(s, o, a) {
    const $ = measureViewportBox(s, a),
        {
            scroll: j
        } = o;
    return j && (translateAxis($.x, j.offset.x), translateAxis($.y, j.offset.y)), $
}
const getContextWindow = ({
        current: s
    }) => s ? s.ownerDocument.defaultView : null,
    elementDragControls = new WeakMap;
class VisualElementDragControls {
    constructor(o) {
        this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
        }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = o
    }
    start(o, {
        snapToCursor: a = !1
    } = {}) {
        const {
            presenceContext: $
        } = this.visualElement;
        if ($ && $.isPresent === !1) return;
        const j = ot => {
                const {
                    dragSnapToOrigin: st
                } = this.getProps();
                st ? this.pauseAnimation() : this.stopAnimation(), a && this.snapToCursor(extractEventInfo(ot, "page").point)
            },
            _e = (ot, st) => {
                var lt;
                const {
                    drag: ft,
                    dragPropagation: yt,
                    onDragStart: bt
                } = this.getProps();
                if (ft && !yt && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(ft), !this.openGlobalLock)) return;
                this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis(vt => {
                    let wt = this.getAxisMotionValue(vt).get() || 0;
                    if (percent.test(wt)) {
                        const {
                            projection: gt
                        } = this.visualElement;
                        if (gt && gt.layout) {
                            const At = gt.layout.layoutBox[vt];
                            At && (wt = calcLength(At) * (parseFloat(wt) / 100))
                        }
                    }
                    this.originPoint[vt] = wt
                }), bt && frame.postRender(() => bt(ot, st)), (lt = this.removeWillChange) === null || lt === void 0 || lt.call(this), this.removeWillChange = addValueToWillChange(this.visualElement, "transform");
                const {
                    animationState: ht
                } = this.visualElement;
                ht && ht.setActive("whileDrag", !0)
            },
            et = (ot, st) => {
                const {
                    dragPropagation: lt,
                    dragDirectionLock: ft,
                    onDirectionLock: yt,
                    onDrag: bt
                } = this.getProps();
                if (!lt && !this.openGlobalLock) return;
                const {
                    offset: ht
                } = st;
                if (ft && this.currentDirection === null) {
                    this.currentDirection = getCurrentDirection(ht), this.currentDirection !== null && yt && yt(this.currentDirection);
                    return
                }
                this.updateAxis("x", st.point, ht), this.updateAxis("y", st.point, ht), this.visualElement.render(), bt && bt(ot, st)
            },
            tt = (ot, st) => this.stop(ot, st),
            nt = () => eachAxis(ot => {
                var st;
                return this.getAnimationState(ot) === "paused" && ((st = this.getAxisMotionValue(ot).animation) === null || st === void 0 ? void 0 : st.play())
            }),
            {
                dragSnapToOrigin: rt
            } = this.getProps();
        this.panSession = new PanSession(o, {
            onSessionStart: j,
            onStart: _e,
            onMove: et,
            onSessionEnd: tt,
            resumeAnimation: nt
        }, {
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: rt,
            contextWindow: getContextWindow(this.visualElement)
        })
    }
    stop(o, a) {
        var $;
        ($ = this.removeWillChange) === null || $ === void 0 || $.call(this);
        const j = this.isDragging;
        if (this.cancel(), !j) return;
        const {
            velocity: _e
        } = a;
        this.startAnimation(_e);
        const {
            onDragEnd: et
        } = this.getProps();
        et && frame.postRender(() => et(o, a))
    }
    cancel() {
        this.isDragging = !1;
        const {
            projection: o,
            animationState: a
        } = this.visualElement;
        o && (o.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
        const {
            dragPropagation: $
        } = this.getProps();
        !$ && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), a && a.setActive("whileDrag", !1)
    }
    updateAxis(o, a, $) {
        const {
            drag: j
        } = this.getProps();
        if (!$ || !shouldDrag(o, j, this.currentDirection)) return;
        const _e = this.getAxisMotionValue(o);
        let et = this.originPoint[o] + $[o];
        this.constraints && this.constraints[o] && (et = applyConstraints(et, this.constraints[o], this.elastic[o])), _e.set(et)
    }
    resolveConstraints() {
        var o;
        const {
            dragConstraints: a,
            dragElastic: $
        } = this.getProps(), j = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (o = this.visualElement.projection) === null || o === void 0 ? void 0 : o.layout, _e = this.constraints;
        a && isRefObject(a) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : a && j ? this.constraints = calcRelativeConstraints(j.layoutBox, a) : this.constraints = !1, this.elastic = resolveDragElastic($), _e !== this.constraints && j && this.constraints && !this.hasMutatedConstraints && eachAxis(et => {
            this.constraints !== !1 && this.getAxisMotionValue(et) && (this.constraints[et] = rebaseAxisConstraints(j.layoutBox[et], this.constraints[et]))
        })
    }
    resolveRefConstraints() {
        const {
            dragConstraints: o,
            onMeasureDragConstraints: a
        } = this.getProps();
        if (!o || !isRefObject(o)) return !1;
        const $ = o.current,
            {
                projection: j
            } = this.visualElement;
        if (!j || !j.layout) return !1;
        const _e = measurePageBox($, j.root, this.visualElement.getTransformPagePoint());
        let et = calcViewportConstraints(j.layout.layoutBox, _e);
        if (a) {
            const tt = a(convertBoxToBoundingBox(et));
            this.hasMutatedConstraints = !!tt, tt && (et = convertBoundingBoxToBox(tt))
        }
        return et
    }
    startAnimation(o) {
        const {
            drag: a,
            dragMomentum: $,
            dragElastic: j,
            dragTransition: _e,
            dragSnapToOrigin: et,
            onDragTransitionEnd: tt
        } = this.getProps(), nt = this.constraints || {}, rt = eachAxis(ot => {
            if (!shouldDrag(ot, a, this.currentDirection)) return;
            let st = nt && nt[ot] || {};
            et && (st = {
                min: 0,
                max: 0
            });
            const lt = j ? 200 : 1e6,
                ft = j ? 40 : 1e7,
                yt = {
                    type: "inertia",
                    velocity: $ ? o[ot] : 0,
                    bounceStiffness: lt,
                    bounceDamping: ft,
                    timeConstant: 750,
                    restDelta: 1,
                    restSpeed: 10,
                    ..._e,
                    ...st
                };
            return this.startAxisValueAnimation(ot, yt)
        });
        return Promise.all(rt).then(tt)
    }
    startAxisValueAnimation(o, a) {
        const $ = this.getAxisMotionValue(o);
        return $.start(animateMotionValue(o, $, 0, a, this.visualElement, !1, addValueToWillChange(this.visualElement, o)))
    }
    stopAnimation() {
        eachAxis(o => this.getAxisMotionValue(o).stop())
    }
    pauseAnimation() {
        eachAxis(o => {
            var a;
            return (a = this.getAxisMotionValue(o).animation) === null || a === void 0 ? void 0 : a.pause()
        })
    }
    getAnimationState(o) {
        var a;
        return (a = this.getAxisMotionValue(o).animation) === null || a === void 0 ? void 0 : a.state
    }
    getAxisMotionValue(o) {
        const a = `_drag${o.toUpperCase()}`,
            $ = this.visualElement.getProps(),
            j = $[a];
        return j || this.visualElement.getValue(o, ($.initial ? $.initial[o] : void 0) || 0)
    }
    snapToCursor(o) {
        eachAxis(a => {
            const {
                drag: $
            } = this.getProps();
            if (!shouldDrag(a, $, this.currentDirection)) return;
            const {
                projection: j
            } = this.visualElement, _e = this.getAxisMotionValue(a);
            if (j && j.layout) {
                const {
                    min: et,
                    max: tt
                } = j.layout.layoutBox[a];
                _e.set(o[a] - mixNumber$1(et, tt, .5))
            }
        })
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current) return;
        const {
            drag: o,
            dragConstraints: a
        } = this.getProps(), {
            projection: $
        } = this.visualElement;
        if (!isRefObject(a) || !$ || !this.constraints) return;
        this.stopAnimation();
        const j = {
            x: 0,
            y: 0
        };
        eachAxis(et => {
            const tt = this.getAxisMotionValue(et);
            if (tt && this.constraints !== !1) {
                const nt = tt.get();
                j[et] = calcOrigin({
                    min: nt,
                    max: nt
                }, this.constraints[et])
            }
        });
        const {
            transformTemplate: _e
        } = this.visualElement.getProps();
        this.visualElement.current.style.transform = _e ? _e({}, "") : "none", $.root && $.root.updateScroll(), $.updateLayout(), this.resolveConstraints(), eachAxis(et => {
            if (!shouldDrag(et, o, null)) return;
            const tt = this.getAxisMotionValue(et),
                {
                    min: nt,
                    max: rt
                } = this.constraints[et];
            tt.set(mixNumber$1(nt, rt, j[et]))
        })
    }
    addListeners() {
        if (!this.visualElement.current) return;
        elementDragControls.set(this.visualElement, this);
        const o = this.visualElement.current,
            a = addPointerEvent(o, "pointerdown", nt => {
                const {
                    drag: rt,
                    dragListener: ot = !0
                } = this.getProps();
                rt && ot && this.start(nt)
            }),
            $ = () => {
                const {
                    dragConstraints: nt
                } = this.getProps();
                isRefObject(nt) && nt.current && (this.constraints = this.resolveRefConstraints())
            },
            {
                projection: j
            } = this.visualElement,
            _e = j.addEventListener("measure", $);
        j && !j.layout && (j.root && j.root.updateScroll(), j.updateLayout()), frame.read($);
        const et = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()),
            tt = j.addEventListener("didUpdate", ({
                delta: nt,
                hasLayoutChanged: rt
            }) => {
                this.isDragging && rt && (eachAxis(ot => {
                    const st = this.getAxisMotionValue(ot);
                    st && (this.originPoint[ot] += nt[ot].translate, st.set(st.get() + nt[ot].translate))
                }), this.visualElement.render())
            });
        return () => {
            et(), a(), _e(), tt && tt()
        }
    }
    getProps() {
        const o = this.visualElement.getProps(),
            {
                drag: a = !1,
                dragDirectionLock: $ = !1,
                dragPropagation: j = !1,
                dragConstraints: _e = !1,
                dragElastic: et = defaultElastic,
                dragMomentum: tt = !0
            } = o;
        return { ...o,
            drag: a,
            dragDirectionLock: $,
            dragPropagation: j,
            dragConstraints: _e,
            dragElastic: et,
            dragMomentum: tt
        }
    }
}

function shouldDrag(s, o, a) {
    return (o === !0 || o === s) && (a === null || a === s)
}

function getCurrentDirection(s, o = 10) {
    let a = null;
    return Math.abs(s.y) > o ? a = "y" : Math.abs(s.x) > o && (a = "x"), a
}
class DragGesture extends Feature {
    constructor(o) {
        super(o), this.removeGroupControls = noop$1, this.removeListeners = noop$1, this.controls = new VisualElementDragControls(o)
    }
    mount() {
        const {
            dragControls: o
        } = this.node.getProps();
        o && (this.removeGroupControls = o.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop$1
    }
    unmount() {
        this.removeGroupControls(), this.removeListeners()
    }
}
const asyncHandler = s => (o, a) => {
    s && frame.postRender(() => s(o, a))
};
class PanGesture extends Feature {
    constructor() {
        super(...arguments), this.removePointerDownListener = noop$1
    }
    onPointerDown(o) {
        this.session = new PanSession(o, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: getContextWindow(this.node)
        })
    }
    createPanHandlers() {
        const {
            onPanSessionStart: o,
            onPanStart: a,
            onPan: $,
            onPanEnd: j
        } = this.node.getProps();
        return {
            onSessionStart: asyncHandler(o),
            onStart: asyncHandler(a),
            onMove: $,
            onEnd: (_e, et) => {
                delete this.session, j && frame.postRender(() => j(_e, et))
            }
        }
    }
    mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", o => this.onPointerDown(o))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(), this.session && this.session.end()
    }
}

function usePresence() {
    const s = reactExports.useContext(PresenceContext);
    if (s === null) return [!0, null];
    const {
        isPresent: o,
        onExitComplete: a,
        register: $
    } = s, j = reactExports.useId();
    reactExports.useEffect(() => $(j), []);
    const _e = reactExports.useCallback(() => a && a(j), [j, a]);
    return !o && a ? [!1, _e] : [!0]
}
const globalProjectionState = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};

function pixelsToPercent(s, o) {
    return o.max === o.min ? 0 : s / (o.max - o.min) * 100
}
const correctBorderRadius = {
        correct: (s, o) => {
            if (!o.target) return s;
            if (typeof s == "string")
                if (px.test(s)) s = parseFloat(s);
                else return s;
            const a = pixelsToPercent(s, o.target.x),
                $ = pixelsToPercent(s, o.target.y);
            return `${a}% ${$}%`
        }
    },
    correctBoxShadow = {
        correct: (s, {
            treeScale: o,
            projectionDelta: a
        }) => {
            const $ = s,
                j = complex.parse(s);
            if (j.length > 5) return $;
            const _e = complex.createTransformer(s),
                et = typeof j[0] != "number" ? 1 : 0,
                tt = a.x.scale * o.x,
                nt = a.y.scale * o.y;
            j[0 + et] /= tt, j[1 + et] /= nt;
            const rt = mixNumber$1(tt, nt, .5);
            return typeof j[2 + et] == "number" && (j[2 + et] /= rt), typeof j[3 + et] == "number" && (j[3 + et] /= rt), _e(j)
        }
    };
class MeasureLayoutWithContext extends reactExports.Component {
    componentDidMount() {
        const {
            visualElement: o,
            layoutGroup: a,
            switchLayoutGroup: $,
            layoutId: j
        } = this.props, {
            projection: _e
        } = o;
        addScaleCorrector(defaultScaleCorrectors), _e && (a.group && a.group.add(_e), $ && $.register && j && $.register(_e), _e.root.didUpdate(), _e.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }), _e.setOptions({ ..._e.options,
            onExitComplete: () => this.safeToRemove()
        })), globalProjectionState.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(o) {
        const {
            layoutDependency: a,
            visualElement: $,
            drag: j,
            isPresent: _e
        } = this.props, et = $.projection;
        return et && (et.isPresent = _e, j || o.layoutDependency !== a || a === void 0 ? et.willUpdate() : this.safeToRemove(), o.isPresent !== _e && (_e ? et.promote() : et.relegate() || frame.postRender(() => {
            const tt = et.getStack();
            (!tt || !tt.members.length) && this.safeToRemove()
        }))), null
    }
    componentDidUpdate() {
        const {
            projection: o
        } = this.props.visualElement;
        o && (o.root.didUpdate(), microtask.postRender(() => {
            !o.currentAnimation && o.isLead() && this.safeToRemove()
        }))
    }
    componentWillUnmount() {
        const {
            visualElement: o,
            layoutGroup: a,
            switchLayoutGroup: $
        } = this.props, {
            projection: j
        } = o;
        j && (j.scheduleCheckAfterUnmount(), a && a.group && a.group.remove(j), $ && $.deregister && $.deregister(j))
    }
    safeToRemove() {
        const {
            safeToRemove: o
        } = this.props;
        o && o()
    }
    render() {
        return null
    }
}

function MeasureLayout(s) {
    const [o, a] = usePresence(), $ = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...s,
        layoutGroup: $,
        switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
        isPresent: o,
        safeToRemove: a
    })
}
const defaultScaleCorrectors = {
        borderRadius: { ...correctBorderRadius,
            applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
        },
        borderTopLeftRadius: correctBorderRadius,
        borderTopRightRadius: correctBorderRadius,
        borderBottomLeftRadius: correctBorderRadius,
        borderBottomRightRadius: correctBorderRadius,
        boxShadow: correctBoxShadow
    },
    borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
    numBorders = borders.length,
    asNumber = s => typeof s == "string" ? parseFloat(s) : s,
    isPx = s => typeof s == "number" || px.test(s);

function mixValues(s, o, a, $, j, _e) {
    j ? (s.opacity = mixNumber$1(0, a.opacity !== void 0 ? a.opacity : 1, easeCrossfadeIn($)), s.opacityExit = mixNumber$1(o.opacity !== void 0 ? o.opacity : 1, 0, easeCrossfadeOut($))) : _e && (s.opacity = mixNumber$1(o.opacity !== void 0 ? o.opacity : 1, a.opacity !== void 0 ? a.opacity : 1, $));
    for (let et = 0; et < numBorders; et++) {
        const tt = `border${borders[et]}Radius`;
        let nt = getRadius(o, tt),
            rt = getRadius(a, tt);
        if (nt === void 0 && rt === void 0) continue;
        nt || (nt = 0), rt || (rt = 0), nt === 0 || rt === 0 || isPx(nt) === isPx(rt) ? (s[tt] = Math.max(mixNumber$1(asNumber(nt), asNumber(rt), $), 0), (percent.test(rt) || percent.test(nt)) && (s[tt] += "%")) : s[tt] = rt
    }(o.rotate || a.rotate) && (s.rotate = mixNumber$1(o.rotate || 0, a.rotate || 0, $))
}

function getRadius(s, o) {
    return s[o] !== void 0 ? s[o] : s.borderRadius
}
const easeCrossfadeIn = compress(0, .5, circOut),
    easeCrossfadeOut = compress(.5, .95, noop$1);

function compress(s, o, a) {
    return $ => $ < s ? 0 : $ > o ? 1 : a(progress(s, o, $))
}

function copyAxisInto(s, o) {
    s.min = o.min, s.max = o.max
}

function copyBoxInto(s, o) {
    copyAxisInto(s.x, o.x), copyAxisInto(s.y, o.y)
}

function copyAxisDeltaInto(s, o) {
    s.translate = o.translate, s.scale = o.scale, s.originPoint = o.originPoint, s.origin = o.origin
}

function removePointDelta(s, o, a, $, j) {
    return s -= o, s = scalePoint(s, 1 / a, $), j !== void 0 && (s = scalePoint(s, 1 / j, $)), s
}

function removeAxisDelta(s, o = 0, a = 1, $ = .5, j, _e = s, et = s) {
    if (percent.test(o) && (o = parseFloat(o), o = mixNumber$1(et.min, et.max, o / 100) - et.min), typeof o != "number") return;
    let tt = mixNumber$1(_e.min, _e.max, $);
    s === _e && (tt -= o), s.min = removePointDelta(s.min, o, a, tt, j), s.max = removePointDelta(s.max, o, a, tt, j)
}

function removeAxisTransforms(s, o, [a, $, j], _e, et) {
    removeAxisDelta(s, o[a], o[$], o[j], o.scale, _e, et)
}
const xKeys = ["x", "scaleX", "originX"],
    yKeys = ["y", "scaleY", "originY"];

function removeBoxTransforms(s, o, a, $) {
    removeAxisTransforms(s.x, o, xKeys, a ? a.x : void 0, $ ? $.x : void 0), removeAxisTransforms(s.y, o, yKeys, a ? a.y : void 0, $ ? $.y : void 0)
}

function isAxisDeltaZero(s) {
    return s.translate === 0 && s.scale === 1
}

function isDeltaZero(s) {
    return isAxisDeltaZero(s.x) && isAxisDeltaZero(s.y)
}

function axisEquals(s, o) {
    return s.min === o.min && s.max === o.max
}

function boxEquals(s, o) {
    return axisEquals(s.x, o.x) && axisEquals(s.y, o.y)
}

function axisEqualsRounded(s, o) {
    return Math.round(s.min) === Math.round(o.min) && Math.round(s.max) === Math.round(o.max)
}

function boxEqualsRounded(s, o) {
    return axisEqualsRounded(s.x, o.x) && axisEqualsRounded(s.y, o.y)
}

function aspectRatio(s) {
    return calcLength(s.x) / calcLength(s.y)
}

function axisDeltaEquals(s, o) {
    return s.translate === o.translate && s.scale === o.scale && s.originPoint === o.originPoint
}
class NodeStack {
    constructor() {
        this.members = []
    }
    add(o) {
        addUniqueItem(this.members, o), o.scheduleRender()
    }
    remove(o) {
        if (removeItem(this.members, o), o === this.prevLead && (this.prevLead = void 0), o === this.lead) {
            const a = this.members[this.members.length - 1];
            a && this.promote(a)
        }
    }
    relegate(o) {
        const a = this.members.findIndex(j => o === j);
        if (a === 0) return !1;
        let $;
        for (let j = a; j >= 0; j--) {
            const _e = this.members[j];
            if (_e.isPresent !== !1) {
                $ = _e;
                break
            }
        }
        return $ ? (this.promote($), !0) : !1
    }
    promote(o, a) {
        const $ = this.lead;
        if (o !== $ && (this.prevLead = $, this.lead = o, o.show(), $)) {
            $.instance && $.scheduleRender(), o.scheduleRender(), o.resumeFrom = $, a && (o.resumeFrom.preserveOpacity = !0), $.snapshot && (o.snapshot = $.snapshot, o.snapshot.latestValues = $.animationValues || $.latestValues), o.root && o.root.isUpdating && (o.isLayoutDirty = !0);
            const {
                crossfade: j
            } = o.options;
            j === !1 && $.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(o => {
            const {
                options: a,
                resumingFrom: $
            } = o;
            a.onExitComplete && a.onExitComplete(), $ && $.options.onExitComplete && $.options.onExitComplete()
        })
    }
    scheduleRender() {
        this.members.forEach(o => {
            o.instance && o.scheduleRender(!1)
        })
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}

function buildProjectionTransform(s, o, a) {
    let $ = "";
    const j = s.x.translate / o.x,
        _e = s.y.translate / o.y,
        et = (a == null ? void 0 : a.z) || 0;
    if ((j || _e || et) && ($ = `translate3d(${j}px, ${_e}px, ${et}px) `), (o.x !== 1 || o.y !== 1) && ($ += `scale(${1/o.x}, ${1/o.y}) `), a) {
        const {
            transformPerspective: rt,
            rotate: ot,
            rotateX: st,
            rotateY: lt,
            skewX: ft,
            skewY: yt
        } = a;
        rt && ($ = `perspective(${rt}px) ${$}`), ot && ($ += `rotate(${ot}deg) `), st && ($ += `rotateX(${st}deg) `), lt && ($ += `rotateY(${lt}deg) `), ft && ($ += `skewX(${ft}deg) `), yt && ($ += `skewY(${yt}deg) `)
    }
    const tt = s.x.scale * o.x,
        nt = s.y.scale * o.y;
    return (tt !== 1 || nt !== 1) && ($ += `scale(${tt}, ${nt})`), $ || "none"
}
const compareByDepth = (s, o) => s.depth - o.depth;
class FlatTree {
    constructor() {
        this.children = [], this.isDirty = !1
    }
    add(o) {
        addUniqueItem(this.children, o), this.isDirty = !0
    }
    remove(o) {
        removeItem(this.children, o), this.isDirty = !0
    }
    forEach(o) {
        this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(o)
    }
}

function delay(s, o) {
    const a = time.now(),
        $ = ({
            timestamp: j
        }) => {
            const _e = j - a;
            _e >= o && (cancelFrame($), s(_e - o))
        };
    return frame.read($, !0), () => cancelFrame($)
}

function isSVGElement(s) {
    return s instanceof SVGElement && s.tagName !== "svg"
}

function animateSingleValue(s, o, a) {
    const $ = isMotionValue(s) ? s : motionValue(s);
    return $.start(animateMotionValue("", $, o, a)), $.animation
}
const metrics = {
        type: "projectionFrame",
        totalNodes: 0,
        resolvedTargetDeltas: 0,
        recalculatedProjection: 0
    },
    isDebug = typeof window < "u" && window.MotionDebug !== void 0,
    transformAxes = ["", "X", "Y", "Z"],
    hiddenVisibility = {
        visibility: "hidden"
    },
    animationTarget = 1e3;
let id = 0;

function resetDistortingTransform(s, o, a, $) {
    const {
        latestValues: j
    } = o;
    j[s] && (a[s] = j[s], o.setStaticValue(s, 0), $ && ($[s] = 0))
}

function isOptimisedAppearTree(s) {
    if (s.hasCheckedOptimisedAppear = !0, s.root === s) return !1;
    const {
        visualElement: o
    } = s.options;
    return o ? getOptimisedAppearId(o) ? !0 : s.parent && !s.parent.hasCheckedOptimisedAppear ? isOptimisedAppearTree(s.parent) : !1 : !1
}

function createProjectionNode({
    attachResizeListener: s,
    defaultParent: o,
    measureScroll: a,
    checkIsScrollRoot: $,
    resetTransform: j
}) {
    return class {
        constructor(et = {}, tt = o == null ? void 0 : o()) {
            this.id = id++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
                x: 1,
                y: 1
            }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
            }, this.updateProjection = () => {
                this.projectionUpdateScheduled = !1, isDebug && (metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0), this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), isDebug && window.MotionDebug.record(metrics)
            }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = et, this.root = tt ? tt.root || tt : this, this.path = tt ? [...tt.path, tt] : [], this.parent = tt, this.depth = tt ? tt.depth + 1 : 0;
            for (let nt = 0; nt < this.path.length; nt++) this.path[nt].shouldResetTransform = !0;
            this.root === this && (this.nodes = new FlatTree)
        }
        addEventListener(et, tt) {
            return this.eventHandlers.has(et) || this.eventHandlers.set(et, new SubscriptionManager), this.eventHandlers.get(et).add(tt)
        }
        notifyListeners(et, ...tt) {
            const nt = this.eventHandlers.get(et);
            nt && nt.notify(...tt)
        }
        hasListeners(et) {
            return this.eventHandlers.has(et)
        }
        mount(et, tt = this.root.hasTreeAnimated) {
            if (this.instance) return;
            this.isSVG = isSVGElement(et), this.instance = et;
            const {
                layoutId: nt,
                layout: rt,
                visualElement: ot
            } = this.options;
            if (ot && !ot.current && ot.mount(et), this.root.nodes.add(this), this.parent && this.parent.children.add(this), tt && (rt || nt) && (this.isLayoutDirty = !0), s) {
                let st;
                const lt = () => this.root.updateBlockedByResize = !1;
                s(et, () => {
                    this.root.updateBlockedByResize = !0, st && st(), st = delay(lt, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation))
                })
            }
            nt && this.root.registerSharedNode(nt, this), this.options.animate !== !1 && ot && (nt || rt) && this.addEventListener("didUpdate", ({
                delta: st,
                hasLayoutChanged: lt,
                hasRelativeTargetChanged: ft,
                layout: yt
            }) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0, this.relativeTarget = void 0;
                    return
                }
                const bt = this.options.transition || ot.getDefaultTransition() || defaultLayoutTransition,
                    {
                        onLayoutAnimationStart: ht,
                        onLayoutAnimationComplete: vt
                    } = ot.getProps(),
                    wt = !this.targetLayout || !boxEqualsRounded(this.targetLayout, yt) || ft,
                    gt = !lt && ft;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || gt || lt && (wt || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(st, gt);
                    const At = { ...getValueTransition(bt, "layout"),
                        onPlay: ht,
                        onComplete: vt
                    };
                    (ot.shouldReduceMotion || this.options.layoutRoot) && (At.delay = 0, At.type = !1), this.startAnimation(At)
                } else lt || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = yt
            })
        }
        unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            const et = this.getStack();
            et && et.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++)
        }
        getTransformTemplate() {
            const {
                visualElement: et
            } = this.options;
            return et && et.getProps().transformTemplate
        }
        willUpdate(et = !0) {
            if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.HandoffCancelAllAnimations && isOptimisedAppearTree(this) && window.HandoffCancelAllAnimations(), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
            this.isLayoutDirty = !0;
            for (let ot = 0; ot < this.path.length; ot++) {
                const st = this.path[ot];
                st.shouldResetTransform = !0, st.updateScroll("snapshot"), st.options.layoutRoot && st.willUpdate(!1)
            }
            const {
                layoutId: tt,
                layout: nt
            } = this.options;
            if (tt === void 0 && !nt) return;
            const rt = this.getTransformTemplate();
            this.prevTransformTemplateValue = rt ? rt(this.latestValues, "") : void 0, this.updateSnapshot(), et && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
                return
            }
            this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots();
            const tt = time.now();
            frameData.delta = clamp(0, 1e3 / 60, tt - frameData.timestamp), frameData.timestamp = tt, frameData.isProcessing = !0, steps.update.process(frameData), steps.preRender.process(frameData), steps.render.process(frameData), frameData.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            frame.postRender(() => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            })
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let nt = 0; nt < this.path.length; nt++) this.path[nt].updateScroll();
            const et = this.layout;
            this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            const {
                visualElement: tt
            } = this.options;
            tt && tt.notify("LayoutMeasure", this.layout.layoutBox, et ? et.layoutBox : void 0)
        }
        updateScroll(et = "measure") {
            let tt = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === et && (tt = !1), tt) {
                const nt = $(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: et,
                    isRoot: nt,
                    offset: a(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : nt
                }
            }
        }
        resetTransform() {
            if (!j) return;
            const et = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
                tt = this.projectionDelta && !isDeltaZero(this.projectionDelta),
                nt = this.getTransformTemplate(),
                rt = nt ? nt(this.latestValues, "") : void 0,
                ot = rt !== this.prevTransformTemplateValue;
            et && (tt || hasTransform(this.latestValues) || ot) && (j(this.instance, rt), this.shouldResetTransform = !1, this.scheduleRender())
        }
        measure(et = !0) {
            const tt = this.measurePageBox();
            let nt = this.removeElementScroll(tt);
            return et && (nt = this.removeTransform(nt)), roundBox(nt), {
                animationId: this.root.animationId,
                measuredBox: tt,
                layoutBox: nt,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var et;
            const {
                visualElement: tt
            } = this.options;
            if (!tt) return createBox();
            const nt = tt.measureViewportBox();
            if (!(((et = this.scroll) === null || et === void 0 ? void 0 : et.wasRoot) || this.path.some(checkNodeWasScrollRoot))) {
                const {
                    scroll: ot
                } = this.root;
                ot && (translateAxis(nt.x, ot.offset.x), translateAxis(nt.y, ot.offset.y))
            }
            return nt
        }
        removeElementScroll(et) {
            var tt;
            const nt = createBox();
            if (copyBoxInto(nt, et), !((tt = this.scroll) === null || tt === void 0) && tt.wasRoot) return nt;
            for (let rt = 0; rt < this.path.length; rt++) {
                const ot = this.path[rt],
                    {
                        scroll: st,
                        options: lt
                    } = ot;
                ot !== this.root && st && lt.layoutScroll && (st.wasRoot && copyBoxInto(nt, et), translateAxis(nt.x, st.offset.x), translateAxis(nt.y, st.offset.y))
            }
            return nt
        }
        applyTransform(et, tt = !1) {
            const nt = createBox();
            copyBoxInto(nt, et);
            for (let rt = 0; rt < this.path.length; rt++) {
                const ot = this.path[rt];
                !tt && ot.options.layoutScroll && ot.scroll && ot !== ot.root && transformBox(nt, {
                    x: -ot.scroll.offset.x,
                    y: -ot.scroll.offset.y
                }), hasTransform(ot.latestValues) && transformBox(nt, ot.latestValues)
            }
            return hasTransform(this.latestValues) && transformBox(nt, this.latestValues), nt
        }
        removeTransform(et) {
            const tt = createBox();
            copyBoxInto(tt, et);
            for (let nt = 0; nt < this.path.length; nt++) {
                const rt = this.path[nt];
                if (!rt.instance || !hasTransform(rt.latestValues)) continue;
                hasScale(rt.latestValues) && rt.updateSnapshot();
                const ot = createBox(),
                    st = rt.measurePageBox();
                copyBoxInto(ot, st), removeBoxTransforms(tt, rt.latestValues, rt.snapshot ? rt.snapshot.layoutBox : void 0, ot)
            }
            return hasTransform(this.latestValues) && removeBoxTransforms(tt, this.latestValues), tt
        }
        setTargetDelta(et) {
            this.targetDelta = et, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
        }
        setOptions(et) {
            this.options = { ...this.options,
                ...et,
                crossfade: et.crossfade !== void 0 ? et.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(et = !1) {
            var tt;
            const nt = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = nt.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = nt.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = nt.isSharedProjectionDirty);
            const rt = !!this.resumingFrom || this !== nt;
            if (!(et || rt && this.isSharedProjectionDirty || this.isProjectionDirty || !((tt = this.parent) === null || tt === void 0) && tt.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
            const {
                layout: st,
                layoutId: lt
            } = this.options;
            if (!(!this.layout || !(st || lt))) {
                if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
                    const ft = this.getClosestProjectingParent();
                    ft && ft.layout && this.animationProgress !== 1 ? (this.relativeParent = ft, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, ft.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const ft = this.getClosestProjectingParent();
                        ft && !!ft.resumingFrom == !!this.resumingFrom && !ft.options.layoutScroll && ft.target && this.animationProgress !== 1 ? (this.relativeParent = ft, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, ft.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    isDebug && metrics.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var et;
            const tt = this.getLead(),
                nt = !!this.resumingFrom || this !== tt;
            let rt = !0;
            if ((this.isProjectionDirty || !((et = this.parent) === null || et === void 0) && et.isProjectionDirty) && (rt = !1), nt && (this.isSharedProjectionDirty || this.isTransformDirty) && (rt = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (rt = !1), rt) return;
            const {
                layout: ot,
                layoutId: st
            } = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(ot || st)) return;
            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
            const lt = this.treeScale.x,
                ft = this.treeScale.y;
            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, nt), tt.layout && !tt.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (tt.target = tt.layout.layoutBox, tt.targetWithTransforms = createBox());
            const {
                target: yt
            } = tt;
            if (!yt) {
                this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
                return
            }!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, yt, this.latestValues), (this.treeScale.x !== lt || this.treeScale.y !== ft || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", yt)), isDebug && metrics.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(et = !0) {
            var tt;
            if ((tt = this.options.visualElement) === null || tt === void 0 || tt.scheduleRender(), et) {
                const nt = this.getStack();
                nt && nt.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta()
        }
        setAnimationOrigin(et, tt = !1) {
            const nt = this.snapshot,
                rt = nt ? nt.latestValues : {},
                ot = { ...this.latestValues
                },
                st = createDelta();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !tt;
            const lt = createBox(),
                ft = nt ? nt.source : void 0,
                yt = this.layout ? this.layout.source : void 0,
                bt = ft !== yt,
                ht = this.getStack(),
                vt = !ht || ht.members.length <= 1,
                wt = !!(bt && !vt && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
            this.animationProgress = 0;
            let gt;
            this.mixTargetDelta = At => {
                const Pt = At / 1e3;
                mixAxisDelta(st.x, et.x, Pt), mixAxisDelta(st.y, et.y, Pt), this.setTargetDelta(st), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(lt, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, lt, Pt), gt && boxEquals(this.relativeTarget, gt) && (this.isProjectionDirty = !1), gt || (gt = createBox()), copyBoxInto(gt, this.relativeTarget)), bt && (this.animationValues = ot, mixValues(ot, rt, this.latestValues, Pt, wt, vt)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = Pt
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(et) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
                globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, { ...et,
                    onUpdate: tt => {
                        this.mixTargetDelta(tt), et.onUpdate && et.onUpdate(tt)
                    },
                    onComplete: () => {
                        et.onComplete && et.onComplete(), this.completeAnimation()
                    }
                }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
            })
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            const et = this.getStack();
            et && et.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation()
        }
        applyTransformsToTarget() {
            const et = this.getLead();
            let {
                targetWithTransforms: tt,
                target: nt,
                layout: rt,
                latestValues: ot
            } = et;
            if (!(!tt || !nt || !rt)) {
                if (this !== et && this.layout && rt && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, rt.layoutBox)) {
                    nt = this.target || createBox();
                    const st = calcLength(this.layout.layoutBox.x);
                    nt.x.min = et.target.x.min, nt.x.max = nt.x.min + st;
                    const lt = calcLength(this.layout.layoutBox.y);
                    nt.y.min = et.target.y.min, nt.y.max = nt.y.min + lt
                }
                copyBoxInto(tt, nt), transformBox(tt, ot), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, tt, ot)
            }
        }
        registerSharedNode(et, tt) {
            this.sharedNodes.has(et) || this.sharedNodes.set(et, new NodeStack), this.sharedNodes.get(et).add(tt);
            const rt = tt.options.initialPromotionConfig;
            tt.promote({
                transition: rt ? rt.transition : void 0,
                preserveFollowOpacity: rt && rt.shouldPreserveFollowOpacity ? rt.shouldPreserveFollowOpacity(tt) : void 0
            })
        }
        isLead() {
            const et = this.getStack();
            return et ? et.lead === this : !0
        }
        getLead() {
            var et;
            const {
                layoutId: tt
            } = this.options;
            return tt ? ((et = this.getStack()) === null || et === void 0 ? void 0 : et.lead) || this : this
        }
        getPrevLead() {
            var et;
            const {
                layoutId: tt
            } = this.options;
            return tt ? (et = this.getStack()) === null || et === void 0 ? void 0 : et.prevLead : void 0
        }
        getStack() {
            const {
                layoutId: et
            } = this.options;
            if (et) return this.root.sharedNodes.get(et)
        }
        promote({
            needsReset: et,
            transition: tt,
            preserveFollowOpacity: nt
        } = {}) {
            const rt = this.getStack();
            rt && rt.promote(this, nt), et && (this.projectionDelta = void 0, this.needsReset = !0), tt && this.setOptions({
                transition: tt
            })
        }
        relegate() {
            const et = this.getStack();
            return et ? et.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {
                visualElement: et
            } = this.options;
            if (!et) return;
            let tt = !1;
            const {
                latestValues: nt
            } = et;
            if ((nt.z || nt.rotate || nt.rotateX || nt.rotateY || nt.rotateZ || nt.skewX || nt.skewY) && (tt = !0), !tt) return;
            const rt = {};
            nt.z && resetDistortingTransform("z", et, rt, this.animationValues);
            for (let ot = 0; ot < transformAxes.length; ot++) resetDistortingTransform(`rotate${transformAxes[ot]}`, et, rt, this.animationValues), resetDistortingTransform(`skew${transformAxes[ot]}`, et, rt, this.animationValues);
            et.render();
            for (const ot in rt) et.setStaticValue(ot, rt[ot]), this.animationValues && (this.animationValues[ot] = rt[ot]);
            et.scheduleRender()
        }
        getProjectionStyles(et) {
            var tt, nt;
            if (!this.instance || this.isSVG) return;
            if (!this.isVisible) return hiddenVisibility;
            const rt = {
                    visibility: ""
                },
                ot = this.getTransformTemplate();
            if (this.needsReset) return this.needsReset = !1, rt.opacity = "", rt.pointerEvents = resolveMotionValue(et == null ? void 0 : et.pointerEvents) || "", rt.transform = ot ? ot(this.latestValues, "") : "none", rt;
            const st = this.getLead();
            if (!this.projectionDelta || !this.layout || !st.target) {
                const bt = {};
                return this.options.layoutId && (bt.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, bt.pointerEvents = resolveMotionValue(et == null ? void 0 : et.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (bt.transform = ot ? ot({}, "") : "none", this.hasProjected = !1), bt
            }
            const lt = st.animationValues || st.latestValues;
            this.applyTransformsToTarget(), rt.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, lt), ot && (rt.transform = ot(lt, rt.transform));
            const {
                x: ft,
                y: yt
            } = this.projectionDelta;
            rt.transformOrigin = `${ft.origin*100}% ${yt.origin*100}% 0`, st.animationValues ? rt.opacity = st === this ? (nt = (tt = lt.opacity) !== null && tt !== void 0 ? tt : this.latestValues.opacity) !== null && nt !== void 0 ? nt : 1 : this.preserveOpacity ? this.latestValues.opacity : lt.opacityExit : rt.opacity = st === this ? lt.opacity !== void 0 ? lt.opacity : "" : lt.opacityExit !== void 0 ? lt.opacityExit : 0;
            for (const bt in scaleCorrectors) {
                if (lt[bt] === void 0) continue;
                const {
                    correct: ht,
                    applyTo: vt
                } = scaleCorrectors[bt], wt = rt.transform === "none" ? lt[bt] : ht(lt[bt], st);
                if (vt) {
                    const gt = vt.length;
                    for (let At = 0; At < gt; At++) rt[vt[At]] = wt
                } else rt[bt] = wt
            }
            return this.options.layoutId && (rt.pointerEvents = st === this ? resolveMotionValue(et == null ? void 0 : et.pointerEvents) || "" : "none"), rt
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(et => {
                var tt;
                return (tt = et.currentAnimation) === null || tt === void 0 ? void 0 : tt.stop()
            }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear()
        }
    }
}

function updateLayout(s) {
    s.updateLayout()
}

function notifyLayoutUpdate(s) {
    var o;
    const a = ((o = s.resumeFrom) === null || o === void 0 ? void 0 : o.snapshot) || s.snapshot;
    if (s.isLead() && s.layout && a && s.hasListeners("didUpdate")) {
        const {
            layoutBox: $,
            measuredBox: j
        } = s.layout, {
            animationType: _e
        } = s.options, et = a.source !== s.layout.source;
        _e === "size" ? eachAxis(st => {
            const lt = et ? a.measuredBox[st] : a.layoutBox[st],
                ft = calcLength(lt);
            lt.min = $[st].min, lt.max = lt.min + ft
        }) : shouldAnimatePositionOnly(_e, a.layoutBox, $) && eachAxis(st => {
            const lt = et ? a.measuredBox[st] : a.layoutBox[st],
                ft = calcLength($[st]);
            lt.max = lt.min + ft, s.relativeTarget && !s.currentAnimation && (s.isProjectionDirty = !0, s.relativeTarget[st].max = s.relativeTarget[st].min + ft)
        });
        const tt = createDelta();
        calcBoxDelta(tt, $, a.layoutBox);
        const nt = createDelta();
        et ? calcBoxDelta(nt, s.applyTransform(j, !0), a.measuredBox) : calcBoxDelta(nt, $, a.layoutBox);
        const rt = !isDeltaZero(tt);
        let ot = !1;
        if (!s.resumeFrom) {
            const st = s.getClosestProjectingParent();
            if (st && !st.resumeFrom) {
                const {
                    snapshot: lt,
                    layout: ft
                } = st;
                if (lt && ft) {
                    const yt = createBox();
                    calcRelativePosition(yt, a.layoutBox, lt.layoutBox);
                    const bt = createBox();
                    calcRelativePosition(bt, $, ft.layoutBox), boxEqualsRounded(yt, bt) || (ot = !0), st.options.layoutRoot && (s.relativeTarget = bt, s.relativeTargetOrigin = yt, s.relativeParent = st)
                }
            }
        }
        s.notifyListeners("didUpdate", {
            layout: $,
            snapshot: a,
            delta: nt,
            layoutDelta: tt,
            hasLayoutChanged: rt,
            hasRelativeTargetChanged: ot
        })
    } else if (s.isLead()) {
        const {
            onExitComplete: $
        } = s.options;
        $ && $()
    }
    s.options.transition = void 0
}

function propagateDirtyNodes(s) {
    isDebug && metrics.totalNodes++, s.parent && (s.isProjecting() || (s.isProjectionDirty = s.parent.isProjectionDirty), s.isSharedProjectionDirty || (s.isSharedProjectionDirty = !!(s.isProjectionDirty || s.parent.isProjectionDirty || s.parent.isSharedProjectionDirty)), s.isTransformDirty || (s.isTransformDirty = s.parent.isTransformDirty))
}

function cleanDirtyNodes(s) {
    s.isProjectionDirty = s.isSharedProjectionDirty = s.isTransformDirty = !1
}

function clearSnapshot(s) {
    s.clearSnapshot()
}

function clearMeasurements(s) {
    s.clearMeasurements()
}

function clearIsLayoutDirty(s) {
    s.isLayoutDirty = !1
}

function resetTransformStyle(s) {
    const {
        visualElement: o
    } = s.options;
    o && o.getProps().onBeforeLayoutMeasure && o.notify("BeforeLayoutMeasure"), s.resetTransform()
}

function finishAnimation(s) {
    s.finishAnimation(), s.targetDelta = s.relativeTarget = s.target = void 0, s.isProjectionDirty = !0
}

function resolveTargetDelta(s) {
    s.resolveTargetDelta()
}

function calcProjection(s) {
    s.calcProjection()
}

function resetSkewAndRotation(s) {
    s.resetSkewAndRotation()
}

function removeLeadSnapshots(s) {
    s.removeLeadSnapshot()
}

function mixAxisDelta(s, o, a) {
    s.translate = mixNumber$1(o.translate, 0, a), s.scale = mixNumber$1(o.scale, 1, a), s.origin = o.origin, s.originPoint = o.originPoint
}

function mixAxis(s, o, a, $) {
    s.min = mixNumber$1(o.min, a.min, $), s.max = mixNumber$1(o.max, a.max, $)
}

function mixBox(s, o, a, $) {
    mixAxis(s.x, o.x, a.x, $), mixAxis(s.y, o.y, a.y, $)
}

function hasOpacityCrossfade(s) {
    return s.animationValues && s.animationValues.opacityExit !== void 0
}
const defaultLayoutTransition = {
        duration: .45,
        ease: [.4, 0, .1, 1]
    },
    userAgentContains = s => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(s),
    roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$1;

function roundAxis(s) {
    s.min = roundPoint(s.min), s.max = roundPoint(s.max)
}

function roundBox(s) {
    roundAxis(s.x), roundAxis(s.y)
}

function shouldAnimatePositionOnly(s, o, a) {
    return s === "position" || s === "preserve-aspect" && !isNear(aspectRatio(o), aspectRatio(a), .2)
}

function checkNodeWasScrollRoot(s) {
    var o;
    return s !== s.root && ((o = s.scroll) === null || o === void 0 ? void 0 : o.wasRoot)
}
const DocumentProjectionNode = createProjectionNode({
        attachResizeListener: (s, o) => addDomEvent(s, "resize", o),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: () => !0
    }),
    rootProjectionNode = {
        current: void 0
    },
    HTMLProjectionNode = createProjectionNode({
        measureScroll: s => ({
            x: s.scrollLeft,
            y: s.scrollTop
        }),
        defaultParent: () => {
            if (!rootProjectionNode.current) {
                const s = new DocumentProjectionNode({});
                s.mount(window), s.setOptions({
                    layoutScroll: !0
                }), rootProjectionNode.current = s
            }
            return rootProjectionNode.current
        },
        resetTransform: (s, o) => {
            s.style.transform = o !== void 0 ? o : "none"
        },
        checkIsScrollRoot: s => window.getComputedStyle(s).position === "fixed"
    }),
    drag = {
        pan: {
            Feature: PanGesture
        },
        drag: {
            Feature: DragGesture,
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout
        }
    },
    prefersReducedMotion = {
        current: null
    },
    hasReducedMotionListener = {
        current: !1
    };

function initPrefersReducedMotion() {
    if (hasReducedMotionListener.current = !0, !!isBrowser)
        if (window.matchMedia) {
            const s = window.matchMedia("(prefers-reduced-motion)"),
                o = () => prefersReducedMotion.current = s.matches;
            s.addListener(o), o()
        } else prefersReducedMotion.current = !1
}

function updateMotionValuesFromProps(s, o, a) {
    for (const $ in o) {
        const j = o[$],
            _e = a[$];
        if (isMotionValue(j)) s.addValue($, j);
        else if (isMotionValue(_e)) s.addValue($, motionValue(j, {
            owner: s
        }));
        else if (_e !== j)
            if (s.hasValue($)) {
                const et = s.getValue($);
                et.liveStyle === !0 ? et.jump(j) : et.hasAnimated || et.set(j)
            } else {
                const et = s.getStaticValue($);
                s.addValue($, motionValue(et !== void 0 ? et : j, {
                    owner: s
                }))
            }
    }
    for (const $ in a) o[$] === void 0 && s.removeValue($);
    return o
}
const visualElementStore = new WeakMap,
    valueTypes = [...dimensionValueTypes, color, complex],
    findValueType = s => valueTypes.find(testValueType(s)),
    propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"],
    numVariantProps = variantProps.length;
class VisualElement {
    scrapeMotionValuesFromProps(o, a, $) {
        return {}
    }
    constructor({
        parent: o,
        props: a,
        presenceContext: $,
        reducedMotionConfig: j,
        blockInitialAnimation: _e,
        visualState: et
    }, tt = {}) {
        this.applyWillChange = !1, this.resolveKeyframes = (lt, ft, yt, bt) => new this.KeyframeResolver(lt, ft, yt, bt, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }, this.isRenderScheduled = !1, this.scheduleRender = () => {
            this.isRenderScheduled || (this.isRenderScheduled = !0, frame.render(this.render, !1, !0))
        };
        const {
            latestValues: nt,
            renderState: rt
        } = et;
        this.latestValues = nt, this.baseTarget = { ...nt
        }, this.initialValues = a.initial ? { ...nt
        } : {}, this.renderState = rt, this.parent = o, this.props = a, this.presenceContext = $, this.depth = o ? o.depth + 1 : 0, this.reducedMotionConfig = j, this.options = tt, this.blockInitialAnimation = !!_e, this.isControllingVariants = isControllingVariants(a), this.isVariantNode = isVariantNode(a), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(o && o.current);
        const {
            willChange: ot,
            ...st
        } = this.scrapeMotionValuesFromProps(a, {}, this);
        for (const lt in st) {
            const ft = st[lt];
            nt[lt] !== void 0 && isMotionValue(ft) && ft.set(nt[lt], !1)
        }
    }
    mount(o) {
        this.current = o, visualElementStore.set(o, this), this.projection && !this.projection.instance && this.projection.mount(o), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((a, $) => this.bindToMotionValue($, a)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
    }
    unmount() {
        visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach(o => o()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
        for (const o in this.events) this.events[o].clear();
        for (const o in this.features) {
            const a = this.features[o];
            a && (a.unmount(), a.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(o, a) {
        const $ = transformProps.has(o),
            j = a.on("change", et => {
                this.latestValues[o] = et, this.props.onUpdate && frame.preRender(this.notifyUpdate), $ && this.projection && (this.projection.isTransformDirty = !0)
            }),
            _e = a.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(o, () => {
            j(), _e(), a.owner && a.stop()
        })
    }
    sortNodePosition(o) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== o.type ? 0 : this.sortInstanceNodePosition(this.current, o.current)
    }
    updateFeatures() {
        let o = "animation";
        for (o in featureDefinitions) {
            const a = featureDefinitions[o];
            if (!a) continue;
            const {
                isEnabled: $,
                Feature: j
            } = a;
            if (!this.features[o] && j && $(this.props) && (this.features[o] = new j(this)), this.features[o]) {
                const _e = this.features[o];
                _e.isMounted ? _e.update() : (_e.mount(), _e.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
    }
    getStaticValue(o) {
        return this.latestValues[o]
    }
    setStaticValue(o, a) {
        this.latestValues[o] = a
    }
    update(o, a) {
        (o.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = o, this.prevPresenceContext = this.presenceContext, this.presenceContext = a;
        for (let $ = 0; $ < propEventHandlers.length; $++) {
            const j = propEventHandlers[$];
            this.propEventSubscriptions[j] && (this.propEventSubscriptions[j](), delete this.propEventSubscriptions[j]);
            const _e = "on" + j,
                et = o[_e];
            et && (this.propEventSubscriptions[j] = this.on(j, et))
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(o, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(o) {
        return this.props.variants ? this.props.variants[o] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(o = !1) {
        if (o) return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const $ = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && ($.initial = this.props.initial), $
        }
        const a = {};
        for (let $ = 0; $ < numVariantProps; $++) {
            const j = variantProps[$],
                _e = this.props[j];
            (isVariantLabel(_e) || _e === !1) && (a[j] = _e)
        }
        return a
    }
    addVariantChild(o) {
        const a = this.getClosestVariantNode();
        if (a) return a.variantChildren && a.variantChildren.add(o), () => a.variantChildren.delete(o)
    }
    addValue(o, a) {
        const $ = this.values.get(o);
        a !== $ && ($ && this.removeValue(o), this.bindToMotionValue(o, a), this.values.set(o, a), this.latestValues[o] = a.get())
    }
    removeValue(o) {
        this.values.delete(o);
        const a = this.valueSubscriptions.get(o);
        a && (a(), this.valueSubscriptions.delete(o)), delete this.latestValues[o], this.removeValueFromRenderState(o, this.renderState)
    }
    hasValue(o) {
        return this.values.has(o)
    }
    getValue(o, a) {
        if (this.props.values && this.props.values[o]) return this.props.values[o];
        let $ = this.values.get(o);
        return $ === void 0 && a !== void 0 && ($ = motionValue(a === null ? void 0 : a, {
            owner: this
        }), this.addValue(o, $)), $
    }
    readValue(o, a) {
        var $;
        let j = this.latestValues[o] !== void 0 || !this.current ? this.latestValues[o] : ($ = this.getBaseTargetFromProps(this.props, o)) !== null && $ !== void 0 ? $ : this.readValueFromInstance(this.current, o, this.options);
        return j != null && (typeof j == "string" && (isNumericalString(j) || isZeroValueString(j)) ? j = parseFloat(j) : !findValueType(j) && complex.test(a) && (j = getAnimatableNone(o, a)), this.setBaseTarget(o, isMotionValue(j) ? j.get() : j)), isMotionValue(j) ? j.get() : j
    }
    setBaseTarget(o, a) {
        this.baseTarget[o] = a
    }
    getBaseTarget(o) {
        var a;
        const {
            initial: $
        } = this.props;
        let j;
        if (typeof $ == "string" || typeof $ == "object") {
            const et = resolveVariantFromProps(this.props, $, (a = this.presenceContext) === null || a === void 0 ? void 0 : a.custom);
            et && (j = et[o])
        }
        if ($ && j !== void 0) return j;
        const _e = this.getBaseTargetFromProps(this.props, o);
        return _e !== void 0 && !isMotionValue(_e) ? _e : this.initialValues[o] !== void 0 && j === void 0 ? void 0 : this.baseTarget[o]
    }
    on(o, a) {
        return this.events[o] || (this.events[o] = new SubscriptionManager), this.events[o].add(a)
    }
    notify(o, ...a) {
        this.events[o] && this.events[o].notify(...a)
    }
}
class DOMVisualElement extends VisualElement {
    constructor() {
        super(...arguments), this.KeyframeResolver = DOMKeyframesResolver
    }
    sortInstanceNodePosition(o, a) {
        return o.compareDocumentPosition(a) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(o, a) {
        return o.style ? o.style[a] : void 0
    }
    removeValueFromRenderState(o, {
        vars: a,
        style: $
    }) {
        delete a[o], delete $[o]
    }
}

function getComputedStyle(s) {
    return window.getComputedStyle(s)
}
class HTMLVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = renderHTML
    }
    readValueFromInstance(o, a) {
        if (transformProps.has(a)) {
            const $ = getDefaultValueType(a);
            return $ && $.default || 0
        } else {
            const $ = getComputedStyle(o),
                j = (isCSSVariableName(a) ? $.getPropertyValue(a) : $[a]) || 0;
            return typeof j == "string" ? j.trim() : j
        }
    }
    measureInstanceViewportBox(o, {
        transformPagePoint: a
    }) {
        return measureViewportBox(o, a)
    }
    build(o, a, $) {
        buildHTMLStyles(o, a, $.transformTemplate)
    }
    scrapeMotionValuesFromProps(o, a, $) {
        return scrapeMotionValuesFromProps$1(o, a, $)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(), delete this.childSubscription);
        const {
            children: o
        } = this.props;
        isMotionValue(o) && (this.childSubscription = o.on("change", a => {
            this.current && (this.current.textContent = `${a}`)
        }))
    }
}
class SVGVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox
    }
    getBaseTargetFromProps(o, a) {
        return o[a]
    }
    readValueFromInstance(o, a) {
        if (transformProps.has(a)) {
            const $ = getDefaultValueType(a);
            return $ && $.default || 0
        }
        return a = camelCaseAttributes.has(a) ? a : camelToDash(a), o.getAttribute(a)
    }
    scrapeMotionValuesFromProps(o, a, $) {
        return scrapeMotionValuesFromProps(o, a, $)
    }
    build(o, a, $) {
        buildSVGAttrs(o, a, this.isSVGTag, $.transformTemplate)
    }
    renderInstance(o, a, $, j) {
        renderSVG(o, a, $, j)
    }
    mount(o) {
        this.isSVGTag = isSVGTag(o.tagName), super.mount(o)
    }
}
const createDomVisualElement = (s, o) => isSVGComponent(s) ? new SVGVisualElement(o) : new HTMLVisualElement(o, {
        allowProjection: s !== reactExports.Fragment
    }),
    layout = {
        layout: {
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout
        }
    },
    preloadedFeatures = { ...animations,
        ...gestureAnimations,
        ...drag,
        ...layout
    },
    motion = createMotionProxy((s, o) => createDomMotionConfig(s, o, preloadedFeatures, createDomVisualElement)),
    Index = {
        Box,
        FormHelperText,
        TextField,
        Typography,
        FormControlLabel,
        Checkbox,
        Button: Button$1,
        IconButton,
        InputAdornment,
        OutlinedInput,
        VisibilityOff: default_1$2,
        Visibility: default_1$3,
        Link,
        List,
        ListItem,
        Table,
        TableBody,
        TableCell,
        TableContainer,
        TableHead,
        TableRow,
        Paper,
        TextareaAutosize,
        Select,
        MenuItem,
        FormControl,
        RadioGroup,
        Radio,
        Tabs,
        Tab,
        Switch,
        styled,
        Modal,
        Menu,
        ExpandLess: default_1$1,
        ExpandMore: default_1,
        Collapse: Collapse$1,
        Stack,
        TablePagination,
        SwipeableDrawer,
        Accordion,
        AccordionActions,
        AccordionDetails,
        AccordionSummary,
        ExpandMoreIcon: default_1,
        OwlCarousel,
        motion,
        Tooltip
    },
    DEFAULT_CONTEXT$1 = {
        setVisible(s) {
            console.error(constructMissingProviderErrorMessage("call", "setVisible"))
        },
        visible: !1
    };
Object.defineProperty(DEFAULT_CONTEXT$1, "visible", {
    get() {
        return console.error(constructMissingProviderErrorMessage("read", "visible")), !1
    }
});

function constructMissingProviderErrorMessage(s, o) {
    return `You have tried to  ${s} "${o}" on a WalletModalContext without providing one. Make sure to render a WalletModalProvider as an ancestor of the component that uses WalletModalContext`
}
const WalletModalContext = reactExports.createContext(DEFAULT_CONTEXT$1);

function useWalletModal() {
    return reactExports.useContext(WalletModalContext)
}
var buffer$1 = {},
    base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [],
    revLookup$1 = [],
    Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array,
    code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$3 = 0, len$1 = code$1.length; i$3 < len$1; ++i$3) lookup$1[i$3] = code$1[i$3], revLookup$1[code$1.charCodeAt(i$3)] = i$3;
revLookup$1[45] = 62;
revLookup$1[95] = 63;

function getLens$1(s) {
    var o = s.length;
    if (o % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var a = s.indexOf("=");
    a === -1 && (a = o);
    var $ = a === o ? 0 : 4 - a % 4;
    return [a, $]
}

function byteLength$1(s) {
    var o = getLens$1(s),
        a = o[0],
        $ = o[1];
    return (a + $) * 3 / 4 - $
}

function _byteLength$1(s, o, a) {
    return (o + a) * 3 / 4 - a
}

function toByteArray$1(s) {
    var o, a = getLens$1(s),
        $ = a[0],
        j = a[1],
        _e = new Arr$1(_byteLength$1(s, $, j)),
        et = 0,
        tt = j > 0 ? $ - 4 : $,
        nt;
    for (nt = 0; nt < tt; nt += 4) o = revLookup$1[s.charCodeAt(nt)] << 18 | revLookup$1[s.charCodeAt(nt + 1)] << 12 | revLookup$1[s.charCodeAt(nt + 2)] << 6 | revLookup$1[s.charCodeAt(nt + 3)], _e[et++] = o >> 16 & 255, _e[et++] = o >> 8 & 255, _e[et++] = o & 255;
    return j === 2 && (o = revLookup$1[s.charCodeAt(nt)] << 2 | revLookup$1[s.charCodeAt(nt + 1)] >> 4, _e[et++] = o & 255), j === 1 && (o = revLookup$1[s.charCodeAt(nt)] << 10 | revLookup$1[s.charCodeAt(nt + 1)] << 4 | revLookup$1[s.charCodeAt(nt + 2)] >> 2, _e[et++] = o >> 8 & 255, _e[et++] = o & 255), _e
}

function tripletToBase64$1(s) {
    return lookup$1[s >> 18 & 63] + lookup$1[s >> 12 & 63] + lookup$1[s >> 6 & 63] + lookup$1[s & 63]
}

function encodeChunk$1(s, o, a) {
    for (var $, j = [], _e = o; _e < a; _e += 3) $ = (s[_e] << 16 & 16711680) + (s[_e + 1] << 8 & 65280) + (s[_e + 2] & 255), j.push(tripletToBase64$1($));
    return j.join("")
}

function fromByteArray$1(s) {
    for (var o, a = s.length, $ = a % 3, j = [], _e = 16383, et = 0, tt = a - $; et < tt; et += _e) j.push(encodeChunk$1(s, et, et + _e > tt ? tt : et + _e));
    return $ === 1 ? (o = s[a - 1], j.push(lookup$1[o >> 2] + lookup$1[o << 4 & 63] + "==")) : $ === 2 && (o = (s[a - 2] << 8) + s[a - 1], j.push(lookup$1[o >> 10] + lookup$1[o >> 4 & 63] + lookup$1[o << 2 & 63] + "=")), j.join("")
}
var ieee754$1 = {}; /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(s, o, a, $, j) {
    var _e, et, tt = j * 8 - $ - 1,
        nt = (1 << tt) - 1,
        rt = nt >> 1,
        ot = -7,
        st = a ? j - 1 : 0,
        lt = a ? -1 : 1,
        ft = s[o + st];
    for (st += lt, _e = ft & (1 << -ot) - 1, ft >>= -ot, ot += tt; ot > 0; _e = _e * 256 + s[o + st], st += lt, ot -= 8);
    for (et = _e & (1 << -ot) - 1, _e >>= -ot, ot += $; ot > 0; et = et * 256 + s[o + st], st += lt, ot -= 8);
    if (_e === 0) _e = 1 - rt;
    else {
        if (_e === nt) return et ? NaN : (ft ? -1 : 1) * (1 / 0);
        et = et + Math.pow(2, $), _e = _e - rt
    }
    return (ft ? -1 : 1) * et * Math.pow(2, _e - $)
};
ieee754$1.write = function(s, o, a, $, j, _e) {
    var et, tt, nt, rt = _e * 8 - j - 1,
        ot = (1 << rt) - 1,
        st = ot >> 1,
        lt = j === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        ft = $ ? 0 : _e - 1,
        yt = $ ? 1 : -1,
        bt = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
    for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (tt = isNaN(o) ? 1 : 0, et = ot) : (et = Math.floor(Math.log(o) / Math.LN2), o * (nt = Math.pow(2, -et)) < 1 && (et--, nt *= 2), et + st >= 1 ? o += lt / nt : o += lt * Math.pow(2, 1 - st), o * nt >= 2 && (et++, nt /= 2), et + st >= ot ? (tt = 0, et = ot) : et + st >= 1 ? (tt = (o * nt - 1) * Math.pow(2, j), et = et + st) : (tt = o * Math.pow(2, st - 1) * Math.pow(2, j), et = 0)); j >= 8; s[a + ft] = tt & 255, ft += yt, tt /= 256, j -= 8);
    for (et = et << j | tt, rt += j; rt > 0; s[a + ft] = et & 255, ft += yt, et /= 256, rt -= 8);
    s[a + ft - yt] |= bt * 128
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(s) {
    const o = base64Js$1,
        a = ieee754$1,
        $ = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    s.Buffer = tt, s.SlowBuffer = wt, s.INSPECT_MAX_BYTES = 50;
    const j = 2147483647;
    s.kMaxLength = j, tt.TYPED_ARRAY_SUPPORT = _e(), !tt.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

    function _e() {
        try {
            const St = new Uint8Array(1),
                ct = {
                    foo: function() {
                        return 42
                    }
                };
            return Object.setPrototypeOf(ct, Uint8Array.prototype), Object.setPrototypeOf(St, ct), St.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(tt.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (tt.isBuffer(this)) return this.buffer
        }
    }), Object.defineProperty(tt.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (tt.isBuffer(this)) return this.byteOffset
        }
    });

    function et(St) {
        if (St > j) throw new RangeError('The value "' + St + '" is invalid for option "size"');
        const ct = new Uint8Array(St);
        return Object.setPrototypeOf(ct, tt.prototype), ct
    }

    function tt(St, ct, pt) {
        if (typeof St == "number") {
            if (typeof ct == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return st(St)
        }
        return nt(St, ct, pt)
    }
    tt.poolSize = 8192;

    function nt(St, ct, pt) {
        if (typeof St == "string") return lt(St, ct);
        if (ArrayBuffer.isView(St)) return yt(St);
        if (St == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof St);
        if (vn(St, ArrayBuffer) || St && vn(St.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (vn(St, SharedArrayBuffer) || St && vn(St.buffer, SharedArrayBuffer))) return bt(St, ct, pt);
        if (typeof St == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const kt = St.valueOf && St.valueOf();
        if (kt != null && kt !== St) return tt.from(kt, ct, pt);
        const Dt = ht(St);
        if (Dt) return Dt;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof St[Symbol.toPrimitive] == "function") return tt.from(St[Symbol.toPrimitive]("string"), ct, pt);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof St)
    }
    tt.from = function(St, ct, pt) {
        return nt(St, ct, pt)
    }, Object.setPrototypeOf(tt.prototype, Uint8Array.prototype), Object.setPrototypeOf(tt, Uint8Array);

    function rt(St) {
        if (typeof St != "number") throw new TypeError('"size" argument must be of type number');
        if (St < 0) throw new RangeError('The value "' + St + '" is invalid for option "size"')
    }

    function ot(St, ct, pt) {
        return rt(St), St <= 0 ? et(St) : ct !== void 0 ? typeof pt == "string" ? et(St).fill(ct, pt) : et(St).fill(ct) : et(St)
    }
    tt.alloc = function(St, ct, pt) {
        return ot(St, ct, pt)
    };

    function st(St) {
        return rt(St), et(St < 0 ? 0 : vt(St) | 0)
    }
    tt.allocUnsafe = function(St) {
        return st(St)
    }, tt.allocUnsafeSlow = function(St) {
        return st(St)
    };

    function lt(St, ct) {
        if ((typeof ct != "string" || ct === "") && (ct = "utf8"), !tt.isEncoding(ct)) throw new TypeError("Unknown encoding: " + ct);
        const pt = gt(St, ct) | 0;
        let kt = et(pt);
        const Dt = kt.write(St, ct);
        return Dt !== pt && (kt = kt.slice(0, Dt)), kt
    }

    function ft(St) {
        const ct = St.length < 0 ? 0 : vt(St.length) | 0,
            pt = et(ct);
        for (let kt = 0; kt < ct; kt += 1) pt[kt] = St[kt] & 255;
        return pt
    }

    function yt(St) {
        if (vn(St, Uint8Array)) {
            const ct = new Uint8Array(St);
            return bt(ct.buffer, ct.byteOffset, ct.byteLength)
        }
        return ft(St)
    }

    function bt(St, ct, pt) {
        if (ct < 0 || St.byteLength < ct) throw new RangeError('"offset" is outside of buffer bounds');
        if (St.byteLength < ct + (pt || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let kt;
        return ct === void 0 && pt === void 0 ? kt = new Uint8Array(St) : pt === void 0 ? kt = new Uint8Array(St, ct) : kt = new Uint8Array(St, ct, pt), Object.setPrototypeOf(kt, tt.prototype), kt
    }

    function ht(St) {
        if (tt.isBuffer(St)) {
            const ct = vt(St.length) | 0,
                pt = et(ct);
            return pt.length === 0 || St.copy(pt, 0, 0, ct), pt
        }
        if (St.length !== void 0) return typeof St.length != "number" || gn(St.length) ? et(0) : ft(St);
        if (St.type === "Buffer" && Array.isArray(St.data)) return ft(St.data)
    }

    function vt(St) {
        if (St >= j) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + j.toString(16) + " bytes");
        return St | 0
    }

    function wt(St) {
        return +St != St && (St = 0), tt.alloc(+St)
    }
    tt.isBuffer = function(ct) {
        return ct != null && ct._isBuffer === !0 && ct !== tt.prototype
    }, tt.compare = function(ct, pt) {
        if (vn(ct, Uint8Array) && (ct = tt.from(ct, ct.offset, ct.byteLength)), vn(pt, Uint8Array) && (pt = tt.from(pt, pt.offset, pt.byteLength)), !tt.isBuffer(ct) || !tt.isBuffer(pt)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (ct === pt) return 0;
        let kt = ct.length,
            Dt = pt.length;
        for (let zt = 0, Ht = Math.min(kt, Dt); zt < Ht; ++zt)
            if (ct[zt] !== pt[zt]) {
                kt = ct[zt], Dt = pt[zt];
                break
            }
        return kt < Dt ? -1 : Dt < kt ? 1 : 0
    }, tt.isEncoding = function(ct) {
        switch (String(ct).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, tt.concat = function(ct, pt) {
        if (!Array.isArray(ct)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (ct.length === 0) return tt.alloc(0);
        let kt;
        if (pt === void 0)
            for (pt = 0, kt = 0; kt < ct.length; ++kt) pt += ct[kt].length;
        const Dt = tt.allocUnsafe(pt);
        let zt = 0;
        for (kt = 0; kt < ct.length; ++kt) {
            let Ht = ct[kt];
            if (vn(Ht, Uint8Array)) zt + Ht.length > Dt.length ? (tt.isBuffer(Ht) || (Ht = tt.from(Ht)), Ht.copy(Dt, zt)) : Uint8Array.prototype.set.call(Dt, Ht, zt);
            else if (tt.isBuffer(Ht)) Ht.copy(Dt, zt);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            zt += Ht.length
        }
        return Dt
    };

    function gt(St, ct) {
        if (tt.isBuffer(St)) return St.length;
        if (ArrayBuffer.isView(St) || vn(St, ArrayBuffer)) return St.byteLength;
        if (typeof St != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof St);
        const pt = St.length,
            kt = arguments.length > 2 && arguments[2] === !0;
        if (!kt && pt === 0) return 0;
        let Dt = !1;
        for (;;) switch (ct) {
            case "ascii":
            case "latin1":
            case "binary":
                return pt;
            case "utf8":
            case "utf-8":
                return hn(St).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return pt * 2;
            case "hex":
                return pt >>> 1;
            case "base64":
                return mn(St).length;
            default:
                if (Dt) return kt ? -1 : hn(St).length;
                ct = ("" + ct).toLowerCase(), Dt = !0
        }
    }
    tt.byteLength = gt;

    function At(St, ct, pt) {
        let kt = !1;
        if ((ct === void 0 || ct < 0) && (ct = 0), ct > this.length || ((pt === void 0 || pt > this.length) && (pt = this.length), pt <= 0) || (pt >>>= 0, ct >>>= 0, pt <= ct)) return "";
        for (St || (St = "utf8");;) switch (St) {
            case "hex":
                return Rt(this, ct, pt);
            case "utf8":
            case "utf-8":
                return it(this, ct, pt);
            case "ascii":
                return xt(this, ct, pt);
            case "latin1":
            case "binary":
                return $t(this, ct, pt);
            case "base64":
                return Ct(this, ct, pt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return It(this, ct, pt);
            default:
                if (kt) throw new TypeError("Unknown encoding: " + St);
                St = (St + "").toLowerCase(), kt = !0
        }
    }
    tt.prototype._isBuffer = !0;

    function Pt(St, ct, pt) {
        const kt = St[ct];
        St[ct] = St[pt], St[pt] = kt
    }
    tt.prototype.swap16 = function() {
        const ct = this.length;
        if (ct % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let pt = 0; pt < ct; pt += 2) Pt(this, pt, pt + 1);
        return this
    }, tt.prototype.swap32 = function() {
        const ct = this.length;
        if (ct % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let pt = 0; pt < ct; pt += 4) Pt(this, pt, pt + 3), Pt(this, pt + 1, pt + 2);
        return this
    }, tt.prototype.swap64 = function() {
        const ct = this.length;
        if (ct % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let pt = 0; pt < ct; pt += 8) Pt(this, pt, pt + 7), Pt(this, pt + 1, pt + 6), Pt(this, pt + 2, pt + 5), Pt(this, pt + 3, pt + 4);
        return this
    }, tt.prototype.toString = function() {
        const ct = this.length;
        return ct === 0 ? "" : arguments.length === 0 ? it(this, 0, ct) : At.apply(this, arguments)
    }, tt.prototype.toLocaleString = tt.prototype.toString, tt.prototype.equals = function(ct) {
        if (!tt.isBuffer(ct)) throw new TypeError("Argument must be a Buffer");
        return this === ct ? !0 : tt.compare(this, ct) === 0
    }, tt.prototype.inspect = function() {
        let ct = "";
        const pt = s.INSPECT_MAX_BYTES;
        return ct = this.toString("hex", 0, pt).replace(/(.{2})/g, "$1 ").trim(), this.length > pt && (ct += " ... "), "<Buffer " + ct + ">"
    }, $ && (tt.prototype[$] = tt.prototype.inspect), tt.prototype.compare = function(ct, pt, kt, Dt, zt) {
        if (vn(ct, Uint8Array) && (ct = tt.from(ct, ct.offset, ct.byteLength)), !tt.isBuffer(ct)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ct);
        if (pt === void 0 && (pt = 0), kt === void 0 && (kt = ct ? ct.length : 0), Dt === void 0 && (Dt = 0), zt === void 0 && (zt = this.length), pt < 0 || kt > ct.length || Dt < 0 || zt > this.length) throw new RangeError("out of range index");
        if (Dt >= zt && pt >= kt) return 0;
        if (Dt >= zt) return -1;
        if (pt >= kt) return 1;
        if (pt >>>= 0, kt >>>= 0, Dt >>>= 0, zt >>>= 0, this === ct) return 0;
        let Ht = zt - Dt,
            an = kt - pt;
        const Xt = Math.min(Ht, an),
            tn = this.slice(Dt, zt),
            pn = ct.slice(pt, kt);
        for (let sn = 0; sn < Xt; ++sn)
            if (tn[sn] !== pn[sn]) {
                Ht = tn[sn], an = pn[sn];
                break
            }
        return Ht < an ? -1 : an < Ht ? 1 : 0
    };

    function Bt(St, ct, pt, kt, Dt) {
        if (St.length === 0) return -1;
        if (typeof pt == "string" ? (kt = pt, pt = 0) : pt > 2147483647 ? pt = 2147483647 : pt < -2147483648 && (pt = -2147483648), pt = +pt, gn(pt) && (pt = Dt ? 0 : St.length - 1), pt < 0 && (pt = St.length + pt), pt >= St.length) {
            if (Dt) return -1;
            pt = St.length - 1
        } else if (pt < 0)
            if (Dt) pt = 0;
            else return -1;
        if (typeof ct == "string" && (ct = tt.from(ct, kt)), tt.isBuffer(ct)) return ct.length === 0 ? -1 : Lt(St, ct, pt, kt, Dt);
        if (typeof ct == "number") return ct = ct & 255, typeof Uint8Array.prototype.indexOf == "function" ? Dt ? Uint8Array.prototype.indexOf.call(St, ct, pt) : Uint8Array.prototype.lastIndexOf.call(St, ct, pt) : Lt(St, [ct], pt, kt, Dt);
        throw new TypeError("val must be string, number or Buffer")
    }

    function Lt(St, ct, pt, kt, Dt) {
        let zt = 1,
            Ht = St.length,
            an = ct.length;
        if (kt !== void 0 && (kt = String(kt).toLowerCase(), kt === "ucs2" || kt === "ucs-2" || kt === "utf16le" || kt === "utf-16le")) {
            if (St.length < 2 || ct.length < 2) return -1;
            zt = 2, Ht /= 2, an /= 2, pt /= 2
        }

        function Xt(pn, sn) {
            return zt === 1 ? pn[sn] : pn.readUInt16BE(sn * zt)
        }
        let tn;
        if (Dt) {
            let pn = -1;
            for (tn = pt; tn < Ht; tn++)
                if (Xt(St, tn) === Xt(ct, pn === -1 ? 0 : tn - pn)) {
                    if (pn === -1 && (pn = tn), tn - pn + 1 === an) return pn * zt
                } else pn !== -1 && (tn -= tn - pn), pn = -1
        } else
            for (pt + an > Ht && (pt = Ht - an), tn = pt; tn >= 0; tn--) {
                let pn = !0;
                for (let sn = 0; sn < an; sn++)
                    if (Xt(St, tn + sn) !== Xt(ct, sn)) {
                        pn = !1;
                        break
                    }
                if (pn) return tn
            }
        return -1
    }
    tt.prototype.includes = function(ct, pt, kt) {
        return this.indexOf(ct, pt, kt) !== -1
    }, tt.prototype.indexOf = function(ct, pt, kt) {
        return Bt(this, ct, pt, kt, !0)
    }, tt.prototype.lastIndexOf = function(ct, pt, kt) {
        return Bt(this, ct, pt, kt, !1)
    };

    function Nt(St, ct, pt, kt) {
        pt = Number(pt) || 0;
        const Dt = St.length - pt;
        kt ? (kt = Number(kt), kt > Dt && (kt = Dt)) : kt = Dt;
        const zt = ct.length;
        kt > zt / 2 && (kt = zt / 2);
        let Ht;
        for (Ht = 0; Ht < kt; ++Ht) {
            const an = parseInt(ct.substr(Ht * 2, 2), 16);
            if (gn(an)) return Ht;
            St[pt + Ht] = an
        }
        return Ht
    }

    function Ut(St, ct, pt, kt) {
        return dn(hn(ct, St.length - pt), St, pt, kt)
    }

    function Vt(St, ct, pt, kt) {
        return dn(fn(ct), St, pt, kt)
    }

    function Ft(St, ct, pt, kt) {
        return dn(mn(ct), St, pt, kt)
    }

    function Wt(St, ct, pt, kt) {
        return dn(rn(ct, St.length - pt), St, pt, kt)
    }
    tt.prototype.write = function(ct, pt, kt, Dt) {
        if (pt === void 0) Dt = "utf8", kt = this.length, pt = 0;
        else if (kt === void 0 && typeof pt == "string") Dt = pt, kt = this.length, pt = 0;
        else if (isFinite(pt)) pt = pt >>> 0, isFinite(kt) ? (kt = kt >>> 0, Dt === void 0 && (Dt = "utf8")) : (Dt = kt, kt = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const zt = this.length - pt;
        if ((kt === void 0 || kt > zt) && (kt = zt), ct.length > 0 && (kt < 0 || pt < 0) || pt > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        Dt || (Dt = "utf8");
        let Ht = !1;
        for (;;) switch (Dt) {
            case "hex":
                return Nt(this, ct, pt, kt);
            case "utf8":
            case "utf-8":
                return Ut(this, ct, pt, kt);
            case "ascii":
            case "latin1":
            case "binary":
                return Vt(this, ct, pt, kt);
            case "base64":
                return Ft(this, ct, pt, kt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Wt(this, ct, pt, kt);
            default:
                if (Ht) throw new TypeError("Unknown encoding: " + Dt);
                Dt = ("" + Dt).toLowerCase(), Ht = !0
        }
    }, tt.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    };

    function Ct(St, ct, pt) {
        return ct === 0 && pt === St.length ? o.fromByteArray(St) : o.fromByteArray(St.slice(ct, pt))
    }

    function it(St, ct, pt) {
        pt = Math.min(St.length, pt);
        const kt = [];
        let Dt = ct;
        for (; Dt < pt;) {
            const zt = St[Dt];
            let Ht = null,
                an = zt > 239 ? 4 : zt > 223 ? 3 : zt > 191 ? 2 : 1;
            if (Dt + an <= pt) {
                let Xt, tn, pn, sn;
                switch (an) {
                    case 1:
                        zt < 128 && (Ht = zt);
                        break;
                    case 2:
                        Xt = St[Dt + 1], (Xt & 192) === 128 && (sn = (zt & 31) << 6 | Xt & 63, sn > 127 && (Ht = sn));
                        break;
                    case 3:
                        Xt = St[Dt + 1], tn = St[Dt + 2], (Xt & 192) === 128 && (tn & 192) === 128 && (sn = (zt & 15) << 12 | (Xt & 63) << 6 | tn & 63, sn > 2047 && (sn < 55296 || sn > 57343) && (Ht = sn));
                        break;
                    case 4:
                        Xt = St[Dt + 1], tn = St[Dt + 2], pn = St[Dt + 3], (Xt & 192) === 128 && (tn & 192) === 128 && (pn & 192) === 128 && (sn = (zt & 15) << 18 | (Xt & 63) << 12 | (tn & 63) << 6 | pn & 63, sn > 65535 && sn < 1114112 && (Ht = sn))
                }
            }
            Ht === null ? (Ht = 65533, an = 1) : Ht > 65535 && (Ht -= 65536, kt.push(Ht >>> 10 & 1023 | 55296), Ht = 56320 | Ht & 1023), kt.push(Ht), Dt += an
        }
        return mt(kt)
    }
    const at = 4096;

    function mt(St) {
        const ct = St.length;
        if (ct <= at) return String.fromCharCode.apply(String, St);
        let pt = "",
            kt = 0;
        for (; kt < ct;) pt += String.fromCharCode.apply(String, St.slice(kt, kt += at));
        return pt
    }

    function xt(St, ct, pt) {
        let kt = "";
        pt = Math.min(St.length, pt);
        for (let Dt = ct; Dt < pt; ++Dt) kt += String.fromCharCode(St[Dt] & 127);
        return kt
    }

    function $t(St, ct, pt) {
        let kt = "";
        pt = Math.min(St.length, pt);
        for (let Dt = ct; Dt < pt; ++Dt) kt += String.fromCharCode(St[Dt]);
        return kt
    }

    function Rt(St, ct, pt) {
        const kt = St.length;
        (!ct || ct < 0) && (ct = 0), (!pt || pt < 0 || pt > kt) && (pt = kt);
        let Dt = "";
        for (let zt = ct; zt < pt; ++zt) Dt += Gt[St[zt]];
        return Dt
    }

    function It(St, ct, pt) {
        const kt = St.slice(ct, pt);
        let Dt = "";
        for (let zt = 0; zt < kt.length - 1; zt += 2) Dt += String.fromCharCode(kt[zt] + kt[zt + 1] * 256);
        return Dt
    }
    tt.prototype.slice = function(ct, pt) {
        const kt = this.length;
        ct = ~~ct, pt = pt === void 0 ? kt : ~~pt, ct < 0 ? (ct += kt, ct < 0 && (ct = 0)) : ct > kt && (ct = kt), pt < 0 ? (pt += kt, pt < 0 && (pt = 0)) : pt > kt && (pt = kt), pt < ct && (pt = ct);
        const Dt = this.subarray(ct, pt);
        return Object.setPrototypeOf(Dt, tt.prototype), Dt
    };

    function Tt(St, ct, pt) {
        if (St % 1 !== 0 || St < 0) throw new RangeError("offset is not uint");
        if (St + ct > pt) throw new RangeError("Trying to access beyond buffer length")
    }
    tt.prototype.readUintLE = tt.prototype.readUIntLE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = this[ct],
            zt = 1,
            Ht = 0;
        for (; ++Ht < pt && (zt *= 256);) Dt += this[ct + Ht] * zt;
        return Dt
    }, tt.prototype.readUintBE = tt.prototype.readUIntBE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = this[ct + --pt],
            zt = 1;
        for (; pt > 0 && (zt *= 256);) Dt += this[ct + --pt] * zt;
        return Dt
    }, tt.prototype.readUint8 = tt.prototype.readUInt8 = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 1, this.length), this[ct]
    }, tt.prototype.readUint16LE = tt.prototype.readUInt16LE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 2, this.length), this[ct] | this[ct + 1] << 8
    }, tt.prototype.readUint16BE = tt.prototype.readUInt16BE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 2, this.length), this[ct] << 8 | this[ct + 1]
    }, tt.prototype.readUint32LE = tt.prototype.readUInt32LE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), (this[ct] | this[ct + 1] << 8 | this[ct + 2] << 16) + this[ct + 3] * 16777216
    }, tt.prototype.readUint32BE = tt.prototype.readUInt32BE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), this[ct] * 16777216 + (this[ct + 1] << 16 | this[ct + 2] << 8 | this[ct + 3])
    }, tt.prototype.readBigUInt64LE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = pt + this[++ct] * 2 ** 8 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 24,
            zt = this[++ct] + this[++ct] * 2 ** 8 + this[++ct] * 2 ** 16 + kt * 2 ** 24;
        return BigInt(Dt) + (BigInt(zt) << BigInt(32))
    }), tt.prototype.readBigUInt64BE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = pt * 2 ** 24 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + this[++ct],
            zt = this[++ct] * 2 ** 24 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + kt;
        return (BigInt(Dt) << BigInt(32)) + BigInt(zt)
    }), tt.prototype.readIntLE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = this[ct],
            zt = 1,
            Ht = 0;
        for (; ++Ht < pt && (zt *= 256);) Dt += this[ct + Ht] * zt;
        return zt *= 128, Dt >= zt && (Dt -= Math.pow(2, 8 * pt)), Dt
    }, tt.prototype.readIntBE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = pt,
            zt = 1,
            Ht = this[ct + --Dt];
        for (; Dt > 0 && (zt *= 256);) Ht += this[ct + --Dt] * zt;
        return zt *= 128, Ht >= zt && (Ht -= Math.pow(2, 8 * pt)), Ht
    }, tt.prototype.readInt8 = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 1, this.length), this[ct] & 128 ? (255 - this[ct] + 1) * -1 : this[ct]
    }, tt.prototype.readInt16LE = function(ct, pt) {
        ct = ct >>> 0, pt || Tt(ct, 2, this.length);
        const kt = this[ct] | this[ct + 1] << 8;
        return kt & 32768 ? kt | 4294901760 : kt
    }, tt.prototype.readInt16BE = function(ct, pt) {
        ct = ct >>> 0, pt || Tt(ct, 2, this.length);
        const kt = this[ct + 1] | this[ct] << 8;
        return kt & 32768 ? kt | 4294901760 : kt
    }, tt.prototype.readInt32LE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), this[ct] | this[ct + 1] << 8 | this[ct + 2] << 16 | this[ct + 3] << 24
    }, tt.prototype.readInt32BE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), this[ct] << 24 | this[ct + 1] << 16 | this[ct + 2] << 8 | this[ct + 3]
    }, tt.prototype.readBigInt64LE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = this[ct + 4] + this[ct + 5] * 2 ** 8 + this[ct + 6] * 2 ** 16 + (kt << 24);
        return (BigInt(Dt) << BigInt(32)) + BigInt(pt + this[++ct] * 2 ** 8 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 24)
    }), tt.prototype.readBigInt64BE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = (pt << 24) + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + this[++ct];
        return (BigInt(Dt) << BigInt(32)) + BigInt(this[++ct] * 2 ** 24 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + kt)
    }), tt.prototype.readFloatLE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), a.read(this, ct, !0, 23, 4)
    }, tt.prototype.readFloatBE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), a.read(this, ct, !1, 23, 4)
    }, tt.prototype.readDoubleLE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 8, this.length), a.read(this, ct, !0, 52, 8)
    }, tt.prototype.readDoubleBE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 8, this.length), a.read(this, ct, !1, 52, 8)
    };

    function dt(St, ct, pt, kt, Dt, zt) {
        if (!tt.isBuffer(St)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (ct > Dt || ct < zt) throw new RangeError('"value" argument is out of bounds');
        if (pt + kt > St.length) throw new RangeError("Index out of range")
    }
    tt.prototype.writeUintLE = tt.prototype.writeUIntLE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, kt = kt >>> 0, !Dt) {
            const an = Math.pow(2, 8 * kt) - 1;
            dt(this, ct, pt, kt, an, 0)
        }
        let zt = 1,
            Ht = 0;
        for (this[pt] = ct & 255; ++Ht < kt && (zt *= 256);) this[pt + Ht] = ct / zt & 255;
        return pt + kt
    }, tt.prototype.writeUintBE = tt.prototype.writeUIntBE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, kt = kt >>> 0, !Dt) {
            const an = Math.pow(2, 8 * kt) - 1;
            dt(this, ct, pt, kt, an, 0)
        }
        let zt = kt - 1,
            Ht = 1;
        for (this[pt + zt] = ct & 255; --zt >= 0 && (Ht *= 256);) this[pt + zt] = ct / Ht & 255;
        return pt + kt
    }, tt.prototype.writeUint8 = tt.prototype.writeUInt8 = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 1, 255, 0), this[pt] = ct & 255, pt + 1
    }, tt.prototype.writeUint16LE = tt.prototype.writeUInt16LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 65535, 0), this[pt] = ct & 255, this[pt + 1] = ct >>> 8, pt + 2
    }, tt.prototype.writeUint16BE = tt.prototype.writeUInt16BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 65535, 0), this[pt] = ct >>> 8, this[pt + 1] = ct & 255, pt + 2
    }, tt.prototype.writeUint32LE = tt.prototype.writeUInt32LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 4294967295, 0), this[pt + 3] = ct >>> 24, this[pt + 2] = ct >>> 16, this[pt + 1] = ct >>> 8, this[pt] = ct & 255, pt + 4
    }, tt.prototype.writeUint32BE = tt.prototype.writeUInt32BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 4294967295, 0), this[pt] = ct >>> 24, this[pt + 1] = ct >>> 16, this[pt + 2] = ct >>> 8, this[pt + 3] = ct & 255, pt + 4
    };

    function Et(St, ct, pt, kt, Dt) {
        en(ct, kt, Dt, St, pt, 7);
        let zt = Number(ct & BigInt(4294967295));
        St[pt++] = zt, zt = zt >> 8, St[pt++] = zt, zt = zt >> 8, St[pt++] = zt, zt = zt >> 8, St[pt++] = zt;
        let Ht = Number(ct >> BigInt(32) & BigInt(4294967295));
        return St[pt++] = Ht, Ht = Ht >> 8, St[pt++] = Ht, Ht = Ht >> 8, St[pt++] = Ht, Ht = Ht >> 8, St[pt++] = Ht, pt
    }

    function Ot(St, ct, pt, kt, Dt) {
        en(ct, kt, Dt, St, pt, 7);
        let zt = Number(ct & BigInt(4294967295));
        St[pt + 7] = zt, zt = zt >> 8, St[pt + 6] = zt, zt = zt >> 8, St[pt + 5] = zt, zt = zt >> 8, St[pt + 4] = zt;
        let Ht = Number(ct >> BigInt(32) & BigInt(4294967295));
        return St[pt + 3] = Ht, Ht = Ht >> 8, St[pt + 2] = Ht, Ht = Ht >> 8, St[pt + 1] = Ht, Ht = Ht >> 8, St[pt] = Ht, pt + 8
    }
    tt.prototype.writeBigUInt64LE = Yt(function(ct, pt = 0) {
        return Et(this, ct, pt, BigInt(0), BigInt("0xffffffffffffffff"))
    }), tt.prototype.writeBigUInt64BE = Yt(function(ct, pt = 0) {
        return Ot(this, ct, pt, BigInt(0), BigInt("0xffffffffffffffff"))
    }), tt.prototype.writeIntLE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, !Dt) {
            const Xt = Math.pow(2, 8 * kt - 1);
            dt(this, ct, pt, kt, Xt - 1, -Xt)
        }
        let zt = 0,
            Ht = 1,
            an = 0;
        for (this[pt] = ct & 255; ++zt < kt && (Ht *= 256);) ct < 0 && an === 0 && this[pt + zt - 1] !== 0 && (an = 1), this[pt + zt] = (ct / Ht >> 0) - an & 255;
        return pt + kt
    }, tt.prototype.writeIntBE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, !Dt) {
            const Xt = Math.pow(2, 8 * kt - 1);
            dt(this, ct, pt, kt, Xt - 1, -Xt)
        }
        let zt = kt - 1,
            Ht = 1,
            an = 0;
        for (this[pt + zt] = ct & 255; --zt >= 0 && (Ht *= 256);) ct < 0 && an === 0 && this[pt + zt + 1] !== 0 && (an = 1), this[pt + zt] = (ct / Ht >> 0) - an & 255;
        return pt + kt
    }, tt.prototype.writeInt8 = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 1, 127, -128), ct < 0 && (ct = 255 + ct + 1), this[pt] = ct & 255, pt + 1
    }, tt.prototype.writeInt16LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 32767, -32768), this[pt] = ct & 255, this[pt + 1] = ct >>> 8, pt + 2
    }, tt.prototype.writeInt16BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 32767, -32768), this[pt] = ct >>> 8, this[pt + 1] = ct & 255, pt + 2
    }, tt.prototype.writeInt32LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 2147483647, -2147483648), this[pt] = ct & 255, this[pt + 1] = ct >>> 8, this[pt + 2] = ct >>> 16, this[pt + 3] = ct >>> 24, pt + 4
    }, tt.prototype.writeInt32BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 2147483647, -2147483648), ct < 0 && (ct = 4294967295 + ct + 1), this[pt] = ct >>> 24, this[pt + 1] = ct >>> 16, this[pt + 2] = ct >>> 8, this[pt + 3] = ct & 255, pt + 4
    }, tt.prototype.writeBigInt64LE = Yt(function(ct, pt = 0) {
        return Et(this, ct, pt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }), tt.prototype.writeBigInt64BE = Yt(function(ct, pt = 0) {
        return Ot(this, ct, pt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });

    function Mt(St, ct, pt, kt, Dt, zt) {
        if (pt + kt > St.length) throw new RangeError("Index out of range");
        if (pt < 0) throw new RangeError("Index out of range")
    }

    function jt(St, ct, pt, kt, Dt) {
        return ct = +ct, pt = pt >>> 0, Dt || Mt(St, ct, pt, 4), a.write(St, ct, pt, kt, 23, 4), pt + 4
    }
    tt.prototype.writeFloatLE = function(ct, pt, kt) {
        return jt(this, ct, pt, !0, kt)
    }, tt.prototype.writeFloatBE = function(ct, pt, kt) {
        return jt(this, ct, pt, !1, kt)
    };

    function Qt(St, ct, pt, kt, Dt) {
        return ct = +ct, pt = pt >>> 0, Dt || Mt(St, ct, pt, 8), a.write(St, ct, pt, kt, 52, 8), pt + 8
    }
    tt.prototype.writeDoubleLE = function(ct, pt, kt) {
        return Qt(this, ct, pt, !0, kt)
    }, tt.prototype.writeDoubleBE = function(ct, pt, kt) {
        return Qt(this, ct, pt, !1, kt)
    }, tt.prototype.copy = function(ct, pt, kt, Dt) {
        if (!tt.isBuffer(ct)) throw new TypeError("argument should be a Buffer");
        if (kt || (kt = 0), !Dt && Dt !== 0 && (Dt = this.length), pt >= ct.length && (pt = ct.length), pt || (pt = 0), Dt > 0 && Dt < kt && (Dt = kt), Dt === kt || ct.length === 0 || this.length === 0) return 0;
        if (pt < 0) throw new RangeError("targetStart out of bounds");
        if (kt < 0 || kt >= this.length) throw new RangeError("Index out of range");
        if (Dt < 0) throw new RangeError("sourceEnd out of bounds");
        Dt > this.length && (Dt = this.length), ct.length - pt < Dt - kt && (Dt = ct.length - pt + kt);
        const zt = Dt - kt;
        return this === ct && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(pt, kt, Dt) : Uint8Array.prototype.set.call(ct, this.subarray(kt, Dt), pt), zt
    }, tt.prototype.fill = function(ct, pt, kt, Dt) {
        if (typeof ct == "string") {
            if (typeof pt == "string" ? (Dt = pt, pt = 0, kt = this.length) : typeof kt == "string" && (Dt = kt, kt = this.length), Dt !== void 0 && typeof Dt != "string") throw new TypeError("encoding must be a string");
            if (typeof Dt == "string" && !tt.isEncoding(Dt)) throw new TypeError("Unknown encoding: " + Dt);
            if (ct.length === 1) {
                const Ht = ct.charCodeAt(0);
                (Dt === "utf8" && Ht < 128 || Dt === "latin1") && (ct = Ht)
            }
        } else typeof ct == "number" ? ct = ct & 255 : typeof ct == "boolean" && (ct = Number(ct));
        if (pt < 0 || this.length < pt || this.length < kt) throw new RangeError("Out of range index");
        if (kt <= pt) return this;
        pt = pt >>> 0, kt = kt === void 0 ? this.length : kt >>> 0, ct || (ct = 0);
        let zt;
        if (typeof ct == "number")
            for (zt = pt; zt < kt; ++zt) this[zt] = ct;
        else {
            const Ht = tt.isBuffer(ct) ? ct : tt.from(ct, Dt),
                an = Ht.length;
            if (an === 0) throw new TypeError('The value "' + ct + '" is invalid for argument "value"');
            for (zt = 0; zt < kt - pt; ++zt) this[zt + pt] = Ht[zt % an]
        }
        return this
    };
    const Kt = {};

    function qt(St, ct, pt) {
        Kt[St] = class extends pt {
            constructor() {
                super(), Object.defineProperty(this, "message", {
                    value: ct.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${St}]`, this.stack, delete this.name
            }
            get code() {
                return St
            }
            set code(Dt) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: Dt,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${St}]: ${this.message}`
            }
        }
    }
    qt("ERR_BUFFER_OUT_OF_BOUNDS", function(St) {
        return St ? `${St} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError), qt("ERR_INVALID_ARG_TYPE", function(St, ct) {
        return `The "${St}" argument must be of type number. Received type ${typeof ct}`
    }, TypeError), qt("ERR_OUT_OF_RANGE", function(St, ct, pt) {
        let kt = `The value of "${St}" is out of range.`,
            Dt = pt;
        return Number.isInteger(pt) && Math.abs(pt) > 2 ** 32 ? Dt = Jt(String(pt)) : typeof pt == "bigint" && (Dt = String(pt), (pt > BigInt(2) ** BigInt(32) || pt < -(BigInt(2) ** BigInt(32))) && (Dt = Jt(Dt)), Dt += "n"), kt += ` It must be ${ct}. Received ${Dt}`, kt
    }, RangeError);

    function Jt(St) {
        let ct = "",
            pt = St.length;
        const kt = St[0] === "-" ? 1 : 0;
        for (; pt >= kt + 4; pt -= 3) ct = `_${St.slice(pt-3,pt)}${ct}`;
        return `${St.slice(0,pt)}${ct}`
    }

    function Zt(St, ct, pt) {
        ln(ct, "offset"), (St[ct] === void 0 || St[ct + pt] === void 0) && cn(ct, St.length - (pt + 1))
    }

    function en(St, ct, pt, kt, Dt, zt) {
        if (St > pt || St < ct) {
            const Ht = typeof ct == "bigint" ? "n" : "";
            let an;
            throw ct === 0 || ct === BigInt(0) ? an = `>= 0${Ht} and < 2${Ht} ** ${(zt+1)*8}${Ht}` : an = `>= -(2${Ht} ** ${(zt+1)*8-1}${Ht}) and < 2 ** ${(zt+1)*8-1}${Ht}`, new Kt.ERR_OUT_OF_RANGE("value", an, St)
        }
        Zt(kt, Dt, zt)
    }

    function ln(St, ct) {
        if (typeof St != "number") throw new Kt.ERR_INVALID_ARG_TYPE(ct, "number", St)
    }

    function cn(St, ct, pt) {
        throw Math.floor(St) !== St ? (ln(St, pt), new Kt.ERR_OUT_OF_RANGE("offset", "an integer", St)) : ct < 0 ? new Kt.ERR_BUFFER_OUT_OF_BOUNDS : new Kt.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${ct}`, St)
    }
    const un = /[^+/0-9A-Za-z-_]/g;

    function Nn(St) {
        if (St = St.split("=")[0], St = St.trim().replace(un, ""), St.length < 2) return "";
        for (; St.length % 4 !== 0;) St = St + "=";
        return St
    }

    function hn(St, ct) {
        ct = ct || 1 / 0;
        let pt;
        const kt = St.length;
        let Dt = null;
        const zt = [];
        for (let Ht = 0; Ht < kt; ++Ht) {
            if (pt = St.charCodeAt(Ht), pt > 55295 && pt < 57344) {
                if (!Dt) {
                    if (pt > 56319) {
                        (ct -= 3) > -1 && zt.push(239, 191, 189);
                        continue
                    } else if (Ht + 1 === kt) {
                        (ct -= 3) > -1 && zt.push(239, 191, 189);
                        continue
                    }
                    Dt = pt;
                    continue
                }
                if (pt < 56320) {
                    (ct -= 3) > -1 && zt.push(239, 191, 189), Dt = pt;
                    continue
                }
                pt = (Dt - 55296 << 10 | pt - 56320) + 65536
            } else Dt && (ct -= 3) > -1 && zt.push(239, 191, 189);
            if (Dt = null, pt < 128) {
                if ((ct -= 1) < 0) break;
                zt.push(pt)
            } else if (pt < 2048) {
                if ((ct -= 2) < 0) break;
                zt.push(pt >> 6 | 192, pt & 63 | 128)
            } else if (pt < 65536) {
                if ((ct -= 3) < 0) break;
                zt.push(pt >> 12 | 224, pt >> 6 & 63 | 128, pt & 63 | 128)
            } else if (pt < 1114112) {
                if ((ct -= 4) < 0) break;
                zt.push(pt >> 18 | 240, pt >> 12 & 63 | 128, pt >> 6 & 63 | 128, pt & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return zt
    }

    function fn(St) {
        const ct = [];
        for (let pt = 0; pt < St.length; ++pt) ct.push(St.charCodeAt(pt) & 255);
        return ct
    }

    function rn(St, ct) {
        let pt, kt, Dt;
        const zt = [];
        for (let Ht = 0; Ht < St.length && !((ct -= 2) < 0); ++Ht) pt = St.charCodeAt(Ht), kt = pt >> 8, Dt = pt % 256, zt.push(Dt), zt.push(kt);
        return zt
    }

    function mn(St) {
        return o.toByteArray(Nn(St))
    }

    function dn(St, ct, pt, kt) {
        let Dt;
        for (Dt = 0; Dt < kt && !(Dt + pt >= ct.length || Dt >= St.length); ++Dt) ct[Dt + pt] = St[Dt];
        return Dt
    }

    function vn(St, ct) {
        return St instanceof ct || St != null && St.constructor != null && St.constructor.name != null && St.constructor.name === ct.name
    }

    function gn(St) {
        return St !== St
    }
    const Gt = function() {
        const St = "0123456789abcdef",
            ct = new Array(256);
        for (let pt = 0; pt < 16; ++pt) {
            const kt = pt * 16;
            for (let Dt = 0; Dt < 16; ++Dt) ct[kt + Dt] = St[pt] + St[Dt]
        }
        return ct
    }();

    function Yt(St) {
        return typeof BigInt > "u" ? nn : St
    }

    function nn() {
        throw new Error("BigInt not supported")
    }
})(buffer$1);

function number$4(s) {
    if (!Number.isSafeInteger(s) || s < 0) throw new Error(`positive integer expected, not ${s}`)
}

function isBytes$3(s) {
    return s instanceof Uint8Array || s != null && typeof s == "object" && s.constructor.name === "Uint8Array"
}

function bytes$1(s, ...o) {
    if (!isBytes$3(s)) throw new Error("Uint8Array expected");
    if (o.length > 0 && !o.includes(s.length)) throw new Error(`Uint8Array expected of length ${o}, not of length=${s.length}`)
}

function hash$2(s) {
    if (typeof s != "function" || typeof s.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number$4(s.outputLen), number$4(s.blockLen)
}

function exists$1(s, o = !0) {
    if (s.destroyed) throw new Error("Hash instance has been destroyed");
    if (o && s.finished) throw new Error("Hash#digest() has already been called")
}

function output$1(s, o) {
    bytes$1(s);
    const a = o.outputLen;
    if (s.length < a) throw new Error(`digestInto() expects output buffer of length at least ${a}`)
}
const crypto$2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const createView$1 = s => new DataView(s.buffer, s.byteOffset, s.byteLength),
    rotr$1 = (s, o) => s << 32 - o | s >>> o;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];

function utf8ToBytes$3(s) {
    if (typeof s != "string") throw new Error(`utf8ToBytes expected string, got ${typeof s}`);
    return new Uint8Array(new TextEncoder().encode(s))
}

function toBytes$1(s) {
    return typeof s == "string" && (s = utf8ToBytes$3(s)), bytes$1(s), s
}

function concatBytes$3(...s) {
    let o = 0;
    for (let $ = 0; $ < s.length; $++) {
        const j = s[$];
        bytes$1(j), o += j.length
    }
    const a = new Uint8Array(o);
    for (let $ = 0, j = 0; $ < s.length; $++) {
        const _e = s[$];
        a.set(_e, j), j += _e.length
    }
    return a
}
let Hash$1 = class {
    clone() {
        return this._cloneInto()
    }
};

function wrapConstructor$1(s) {
    const o = $ => s().update(toBytes$1($)).digest(),
        a = s();
    return o.outputLen = a.outputLen, o.blockLen = a.blockLen, o.create = () => s(), o
}

function randomBytes$1(s = 32) {
    if (crypto$2 && typeof crypto$2.getRandomValues == "function") return crypto$2.getRandomValues(new Uint8Array(s));
    if (crypto$2 && typeof crypto$2.randomBytes == "function") return crypto$2.randomBytes(s);
    throw new Error("crypto.getRandomValues must be defined")
}

function setBigUint64$1(s, o, a, $) {
    if (typeof s.setBigUint64 == "function") return s.setBigUint64(o, a, $);
    const j = BigInt(32),
        _e = BigInt(4294967295),
        et = Number(a >> j & _e),
        tt = Number(a & _e),
        nt = $ ? 4 : 0,
        rt = $ ? 0 : 4;
    s.setUint32(o + nt, et, $), s.setUint32(o + rt, tt, $)
}
const Chi$1 = (s, o, a) => s & o ^ ~s & a,
    Maj$1 = (s, o, a) => s & o ^ s & a ^ o & a;
let HashMD$1 = class extends Hash$1 {
    constructor(o, a, $, j) {
        super(), this.blockLen = o, this.outputLen = a, this.padOffset = $, this.isLE = j, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(o), this.view = createView$1(this.buffer)
    }
    update(o) {
        exists$1(this);
        const {
            view: a,
            buffer: $,
            blockLen: j
        } = this;
        o = toBytes$1(o);
        const _e = o.length;
        for (let et = 0; et < _e;) {
            const tt = Math.min(j - this.pos, _e - et);
            if (tt === j) {
                const nt = createView$1(o);
                for (; j <= _e - et; et += j) this.process(nt, et);
                continue
            }
            $.set(o.subarray(et, et + tt), this.pos), this.pos += tt, et += tt, this.pos === j && (this.process(a, 0), this.pos = 0)
        }
        return this.length += o.length, this.roundClean(), this
    }
    digestInto(o) {
        exists$1(this), output$1(o, this), this.finished = !0;
        const {
            buffer: a,
            view: $,
            blockLen: j,
            isLE: _e
        } = this;
        let {
            pos: et
        } = this;
        a[et++] = 128, this.buffer.subarray(et).fill(0), this.padOffset > j - et && (this.process($, 0), et = 0);
        for (let st = et; st < j; st++) a[st] = 0;
        setBigUint64$1($, j - 8, BigInt(this.length * 8), _e), this.process($, 0);
        const tt = createView$1(o),
            nt = this.outputLen;
        if (nt % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const rt = nt / 4,
            ot = this.get();
        if (rt > ot.length) throw new Error("_sha2: outputLen bigger than state");
        for (let st = 0; st < rt; st++) tt.setUint32(4 * st, ot[st], _e)
    }
    digest() {
        const {
            buffer: o,
            outputLen: a
        } = this;
        this.digestInto(o);
        const $ = o.slice(0, a);
        return this.destroy(), $
    }
    _cloneInto(o) {
        o || (o = new this.constructor), o.set(...this.get());
        const {
            blockLen: a,
            buffer: $,
            length: j,
            finished: _e,
            destroyed: et,
            pos: tt
        } = this;
        return o.length = j, o.pos = tt, o.finished = _e, o.destroyed = et, j % a && o.buffer.set($), o
    }
};
const U32_MASK64$1 = BigInt(2 ** 32 - 1),
    _32n$1 = BigInt(32);

function fromBig$1(s, o = !1) {
    return o ? {
        h: Number(s & U32_MASK64$1),
        l: Number(s >> _32n$1 & U32_MASK64$1)
    } : {
        h: Number(s >> _32n$1 & U32_MASK64$1) | 0,
        l: Number(s & U32_MASK64$1) | 0
    }
}

function split$1(s, o = !1) {
    let a = new Uint32Array(s.length),
        $ = new Uint32Array(s.length);
    for (let j = 0; j < s.length; j++) {
        const {
            h: _e,
            l: et
        } = fromBig$1(s[j], o);
        [a[j], $[j]] = [_e, et]
    }
    return [a, $]
}
const toBig$1 = (s, o) => BigInt(s >>> 0) << _32n$1 | BigInt(o >>> 0),
    shrSH$1 = (s, o, a) => s >>> a,
    shrSL$1 = (s, o, a) => s << 32 - a | o >>> a,
    rotrSH$1 = (s, o, a) => s >>> a | o << 32 - a,
    rotrSL$1 = (s, o, a) => s << 32 - a | o >>> a,
    rotrBH$1 = (s, o, a) => s << 64 - a | o >>> a - 32,
    rotrBL$1 = (s, o, a) => s >>> a - 32 | o << 64 - a,
    rotr32H$1 = (s, o) => o,
    rotr32L$1 = (s, o) => s,
    rotlSH$1 = (s, o, a) => s << a | o >>> 32 - a,
    rotlSL$1 = (s, o, a) => o << a | s >>> 32 - a,
    rotlBH$1 = (s, o, a) => o << a - 32 | s >>> 64 - a,
    rotlBL$1 = (s, o, a) => s << a - 32 | o >>> 64 - a;

function add$1(s, o, a, $) {
    const j = (o >>> 0) + ($ >>> 0);
    return {
        h: s + a + (j / 2 ** 32 | 0) | 0,
        l: j | 0
    }
}
const add3L$1 = (s, o, a) => (s >>> 0) + (o >>> 0) + (a >>> 0),
    add3H$1 = (s, o, a, $) => o + a + $ + (s / 2 ** 32 | 0) | 0,
    add4L$1 = (s, o, a, $) => (s >>> 0) + (o >>> 0) + (a >>> 0) + ($ >>> 0),
    add4H$1 = (s, o, a, $, j) => o + a + $ + j + (s / 2 ** 32 | 0) | 0,
    add5L$1 = (s, o, a, $, j) => (s >>> 0) + (o >>> 0) + (a >>> 0) + ($ >>> 0) + (j >>> 0),
    add5H$1 = (s, o, a, $, j, _e) => o + a + $ + j + _e + (s / 2 ** 32 | 0) | 0,
    u64$4 = {
        fromBig: fromBig$1,
        split: split$1,
        toBig: toBig$1,
        shrSH: shrSH$1,
        shrSL: shrSL$1,
        rotrSH: rotrSH$1,
        rotrSL: rotrSL$1,
        rotrBH: rotrBH$1,
        rotrBL: rotrBL$1,
        rotr32H: rotr32H$1,
        rotr32L: rotr32L$1,
        rotlSH: rotlSH$1,
        rotlSL: rotlSL$1,
        rotlBH: rotlBH$1,
        rotlBL: rotlBL$1,
        add: add$1,
        add3L: add3L$1,
        add3H: add3H$1,
        add4L: add4L$1,
        add4H: add4H$1,
        add5H: add5H$1,
        add5L: add5L$1
    },
    [SHA512_Kh$1, SHA512_Kl$1] = u64$4.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(s => BigInt(s))),
    SHA512_W_H$1 = new Uint32Array(80),
    SHA512_W_L$1 = new Uint32Array(80);
let SHA512$1 = class extends HashMD$1 {
    constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
    }
    get() {
        const {
            Ah: o,
            Al: a,
            Bh: $,
            Bl: j,
            Ch: _e,
            Cl: et,
            Dh: tt,
            Dl: nt,
            Eh: rt,
            El: ot,
            Fh: st,
            Fl: lt,
            Gh: ft,
            Gl: yt,
            Hh: bt,
            Hl: ht
        } = this;
        return [o, a, $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht]
    }
    set(o, a, $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht) {
        this.Ah = o | 0, this.Al = a | 0, this.Bh = $ | 0, this.Bl = j | 0, this.Ch = _e | 0, this.Cl = et | 0, this.Dh = tt | 0, this.Dl = nt | 0, this.Eh = rt | 0, this.El = ot | 0, this.Fh = st | 0, this.Fl = lt | 0, this.Gh = ft | 0, this.Gl = yt | 0, this.Hh = bt | 0, this.Hl = ht | 0
    }
    process(o, a) {
        for (let gt = 0; gt < 16; gt++, a += 4) SHA512_W_H$1[gt] = o.getUint32(a), SHA512_W_L$1[gt] = o.getUint32(a += 4);
        for (let gt = 16; gt < 80; gt++) {
            const At = SHA512_W_H$1[gt - 15] | 0,
                Pt = SHA512_W_L$1[gt - 15] | 0,
                Bt = u64$4.rotrSH(At, Pt, 1) ^ u64$4.rotrSH(At, Pt, 8) ^ u64$4.shrSH(At, Pt, 7),
                Lt = u64$4.rotrSL(At, Pt, 1) ^ u64$4.rotrSL(At, Pt, 8) ^ u64$4.shrSL(At, Pt, 7),
                Nt = SHA512_W_H$1[gt - 2] | 0,
                Ut = SHA512_W_L$1[gt - 2] | 0,
                Vt = u64$4.rotrSH(Nt, Ut, 19) ^ u64$4.rotrBH(Nt, Ut, 61) ^ u64$4.shrSH(Nt, Ut, 6),
                Ft = u64$4.rotrSL(Nt, Ut, 19) ^ u64$4.rotrBL(Nt, Ut, 61) ^ u64$4.shrSL(Nt, Ut, 6),
                Wt = u64$4.add4L(Lt, Ft, SHA512_W_L$1[gt - 7], SHA512_W_L$1[gt - 16]),
                Ct = u64$4.add4H(Wt, Bt, Vt, SHA512_W_H$1[gt - 7], SHA512_W_H$1[gt - 16]);
            SHA512_W_H$1[gt] = Ct | 0, SHA512_W_L$1[gt] = Wt | 0
        }
        let {
            Ah: $,
            Al: j,
            Bh: _e,
            Bl: et,
            Ch: tt,
            Cl: nt,
            Dh: rt,
            Dl: ot,
            Eh: st,
            El: lt,
            Fh: ft,
            Fl: yt,
            Gh: bt,
            Gl: ht,
            Hh: vt,
            Hl: wt
        } = this;
        for (let gt = 0; gt < 80; gt++) {
            const At = u64$4.rotrSH(st, lt, 14) ^ u64$4.rotrSH(st, lt, 18) ^ u64$4.rotrBH(st, lt, 41),
                Pt = u64$4.rotrSL(st, lt, 14) ^ u64$4.rotrSL(st, lt, 18) ^ u64$4.rotrBL(st, lt, 41),
                Bt = st & ft ^ ~st & bt,
                Lt = lt & yt ^ ~lt & ht,
                Nt = u64$4.add5L(wt, Pt, Lt, SHA512_Kl$1[gt], SHA512_W_L$1[gt]),
                Ut = u64$4.add5H(Nt, vt, At, Bt, SHA512_Kh$1[gt], SHA512_W_H$1[gt]),
                Vt = Nt | 0,
                Ft = u64$4.rotrSH($, j, 28) ^ u64$4.rotrBH($, j, 34) ^ u64$4.rotrBH($, j, 39),
                Wt = u64$4.rotrSL($, j, 28) ^ u64$4.rotrBL($, j, 34) ^ u64$4.rotrBL($, j, 39),
                Ct = $ & _e ^ $ & tt ^ _e & tt,
                it = j & et ^ j & nt ^ et & nt;
            vt = bt | 0, wt = ht | 0, bt = ft | 0, ht = yt | 0, ft = st | 0, yt = lt | 0, {
                h: st,
                l: lt
            } = u64$4.add(rt | 0, ot | 0, Ut | 0, Vt | 0), rt = tt | 0, ot = nt | 0, tt = _e | 0, nt = et | 0, _e = $ | 0, et = j | 0;
            const at = u64$4.add3L(Vt, Wt, it);
            $ = u64$4.add3H(at, Ut, Ft, Ct), j = at | 0
        }({
            h: $,
            l: j
        } = u64$4.add(this.Ah | 0, this.Al | 0, $ | 0, j | 0)), {
            h: _e,
            l: et
        } = u64$4.add(this.Bh | 0, this.Bl | 0, _e | 0, et | 0), {
            h: tt,
            l: nt
        } = u64$4.add(this.Ch | 0, this.Cl | 0, tt | 0, nt | 0), {
            h: rt,
            l: ot
        } = u64$4.add(this.Dh | 0, this.Dl | 0, rt | 0, ot | 0), {
            h: st,
            l: lt
        } = u64$4.add(this.Eh | 0, this.El | 0, st | 0, lt | 0), {
            h: ft,
            l: yt
        } = u64$4.add(this.Fh | 0, this.Fl | 0, ft | 0, yt | 0), {
            h: bt,
            l: ht
        } = u64$4.add(this.Gh | 0, this.Gl | 0, bt | 0, ht | 0), {
            h: vt,
            l: wt
        } = u64$4.add(this.Hh | 0, this.Hl | 0, vt | 0, wt | 0), this.set($, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht, vt, wt)
    }
    roundClean() {
        SHA512_W_H$1.fill(0), SHA512_W_L$1.fill(0)
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
};
const sha512$1 = wrapConstructor$1(() => new SHA512$1); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$a = BigInt(0),
    _1n$e = BigInt(1),
    _2n$a = BigInt(2);

function isBytes$2(s) {
    return s instanceof Uint8Array || s != null && typeof s == "object" && s.constructor.name === "Uint8Array"
}

function abytes$1(s) {
    if (!isBytes$2(s)) throw new Error("Uint8Array expected")
}

function abool$1(s, o) {
    if (typeof o != "boolean") throw new Error(`${s} must be valid boolean, got "${o}".`)
}
const hexes$1 = Array.from({
    length: 256
}, (s, o) => o.toString(16).padStart(2, "0"));

function bytesToHex$1(s) {
    abytes$1(s);
    let o = "";
    for (let a = 0; a < s.length; a++) o += hexes$1[s[a]];
    return o
}

function numberToHexUnpadded$1(s) {
    const o = s.toString(16);
    return o.length & 1 ? `0${o}` : o
}

function hexToNumber$1(s) {
    if (typeof s != "string") throw new Error("hex string expected, got " + typeof s);
    return BigInt(s === "" ? "0" : `0x${s}`)
}
const asciis$1 = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};

function asciiToBase16$1(s) {
    if (s >= asciis$1._0 && s <= asciis$1._9) return s - asciis$1._0;
    if (s >= asciis$1._A && s <= asciis$1._F) return s - (asciis$1._A - 10);
    if (s >= asciis$1._a && s <= asciis$1._f) return s - (asciis$1._a - 10)
}

function hexToBytes$1(s) {
    if (typeof s != "string") throw new Error("hex string expected, got " + typeof s);
    const o = s.length,
        a = o / 2;
    if (o % 2) throw new Error("padded hex string expected, got unpadded hex of length " + o);
    const $ = new Uint8Array(a);
    for (let j = 0, _e = 0; j < a; j++, _e += 2) {
        const et = asciiToBase16$1(s.charCodeAt(_e)),
            tt = asciiToBase16$1(s.charCodeAt(_e + 1));
        if (et === void 0 || tt === void 0) {
            const nt = s[_e] + s[_e + 1];
            throw new Error('hex string expected, got non-hex character "' + nt + '" at index ' + _e)
        }
        $[j] = et * 16 + tt
    }
    return $
}

function bytesToNumberBE$1(s) {
    return hexToNumber$1(bytesToHex$1(s))
}

function bytesToNumberLE$1(s) {
    return abytes$1(s), hexToNumber$1(bytesToHex$1(Uint8Array.from(s).reverse()))
}

function numberToBytesBE$1(s, o) {
    return hexToBytes$1(s.toString(16).padStart(o * 2, "0"))
}

function numberToBytesLE$1(s, o) {
    return numberToBytesBE$1(s, o).reverse()
}

function numberToVarBytesBE$1(s) {
    return hexToBytes$1(numberToHexUnpadded$1(s))
}

function ensureBytes$1(s, o, a) {
    let $;
    if (typeof o == "string") try {
            $ = hexToBytes$1(o)
        } catch (_e) {
            throw new Error(`${s} must be valid hex string, got "${o}". Cause: ${_e}`)
        } else if (isBytes$2(o)) $ = Uint8Array.from(o);
        else throw new Error(`${s} must be hex string or Uint8Array`);
    const j = $.length;
    if (typeof a == "number" && j !== a) throw new Error(`${s} expected ${a} bytes, got ${j}`);
    return $
}

function concatBytes$2(...s) {
    let o = 0;
    for (let $ = 0; $ < s.length; $++) {
        const j = s[$];
        abytes$1(j), o += j.length
    }
    const a = new Uint8Array(o);
    for (let $ = 0, j = 0; $ < s.length; $++) {
        const _e = s[$];
        a.set(_e, j), j += _e.length
    }
    return a
}

function equalBytes$1(s, o) {
    if (s.length !== o.length) return !1;
    let a = 0;
    for (let $ = 0; $ < s.length; $++) a |= s[$] ^ o[$];
    return a === 0
}

function utf8ToBytes$2(s) {
    if (typeof s != "string") throw new Error(`utf8ToBytes expected string, got ${typeof s}`);
    return new Uint8Array(new TextEncoder().encode(s))
}
const isPosBig$1 = s => typeof s == "bigint" && _0n$a <= s;

function inRange$3(s, o, a) {
    return isPosBig$1(s) && isPosBig$1(o) && isPosBig$1(a) && o <= s && s < a
}

function aInRange$1(s, o, a, $) {
    if (!inRange$3(o, a, $)) throw new Error(`expected valid ${s}: ${a} <= n < ${$}, got ${typeof o} ${o}`)
}

function bitLen$1(s) {
    let o;
    for (o = 0; s > _0n$a; s >>= _1n$e, o += 1);
    return o
}

function bitGet$1(s, o) {
    return s >> BigInt(o) & _1n$e
}

function bitSet$1(s, o, a) {
    return s | (a ? _1n$e : _0n$a) << BigInt(o)
}
const bitMask$1 = s => (_2n$a << BigInt(s - 1)) - _1n$e,
    u8n$1 = s => new Uint8Array(s),
    u8fr$1 = s => Uint8Array.from(s);

function createHmacDrbg$1(s, o, a) {
    if (typeof s != "number" || s < 2) throw new Error("hashLen must be a number");
    if (typeof o != "number" || o < 2) throw new Error("qByteLen must be a number");
    if (typeof a != "function") throw new Error("hmacFn must be a function");
    let $ = u8n$1(s),
        j = u8n$1(s),
        _e = 0;
    const et = () => {
            $.fill(1), j.fill(0), _e = 0
        },
        tt = (...st) => a(j, $, ...st),
        nt = (st = u8n$1()) => {
            j = tt(u8fr$1([0]), st), $ = tt(), st.length !== 0 && (j = tt(u8fr$1([1]), st), $ = tt())
        },
        rt = () => {
            if (_e++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let st = 0;
            const lt = [];
            for (; st < o;) {
                $ = tt();
                const ft = $.slice();
                lt.push(ft), st += $.length
            }
            return concatBytes$2(...lt)
        };
    return (st, lt) => {
        et(), nt(st);
        let ft;
        for (; !(ft = lt(rt()));) nt();
        return et(), ft
    }
}
const validatorFns$1 = {
    bigint: s => typeof s == "bigint",
    function: s => typeof s == "function",
    boolean: s => typeof s == "boolean",
    string: s => typeof s == "string",
    stringOrUint8Array: s => typeof s == "string" || isBytes$2(s),
    isSafeInteger: s => Number.isSafeInteger(s),
    array: s => Array.isArray(s),
    field: (s, o) => o.Fp.isValid(s),
    hash: s => typeof s == "function" && Number.isSafeInteger(s.outputLen)
};

function validateObject$1(s, o, a = {}) {
    const $ = (j, _e, et) => {
        const tt = validatorFns$1[_e];
        if (typeof tt != "function") throw new Error(`Invalid validator "${_e}", expected function`);
        const nt = s[j];
        if (!(et && nt === void 0) && !tt(nt, s)) throw new Error(`Invalid param ${String(j)}=${nt} (${typeof nt}), expected ${_e}`)
    };
    for (const [j, _e] of Object.entries(o)) $(j, _e, !1);
    for (const [j, _e] of Object.entries(a)) $(j, _e, !0);
    return s
}
const notImplemented$1 = () => {
    throw new Error("not implemented")
};

function memoized$1(s) {
    const o = new WeakMap;
    return (a, ...$) => {
        const j = o.get(a);
        if (j !== void 0) return j;
        const _e = s(a, ...$);
        return o.set(a, _e), _e
    }
}
const ut$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    aInRange: aInRange$1,
    abool: abool$1,
    abytes: abytes$1,
    bitGet: bitGet$1,
    bitLen: bitLen$1,
    bitMask: bitMask$1,
    bitSet: bitSet$1,
    bytesToHex: bytesToHex$1,
    bytesToNumberBE: bytesToNumberBE$1,
    bytesToNumberLE: bytesToNumberLE$1,
    concatBytes: concatBytes$2,
    createHmacDrbg: createHmacDrbg$1,
    ensureBytes: ensureBytes$1,
    equalBytes: equalBytes$1,
    hexToBytes: hexToBytes$1,
    hexToNumber: hexToNumber$1,
    inRange: inRange$3,
    isBytes: isBytes$2,
    memoized: memoized$1,
    notImplemented: notImplemented$1,
    numberToBytesBE: numberToBytesBE$1,
    numberToBytesLE: numberToBytesLE$1,
    numberToHexUnpadded: numberToHexUnpadded$1,
    numberToVarBytesBE: numberToVarBytesBE$1,
    utf8ToBytes: utf8ToBytes$2,
    validateObject: validateObject$1
}, Symbol.toStringTag, {
    value: "Module"
})); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$9 = BigInt(0),
    _1n$d = BigInt(1),
    _2n$9 = BigInt(2),
    _3n$3 = BigInt(3),
    _4n$1 = BigInt(4),
    _5n$3 = BigInt(5),
    _8n$5 = BigInt(8);
BigInt(9);
BigInt(16);

function mod$1(s, o) {
    const a = s % o;
    return a >= _0n$9 ? a : o + a
}

function pow$1(s, o, a) {
    if (a <= _0n$9 || o < _0n$9) throw new Error("Expected power/modulo > 0");
    if (a === _1n$d) return _0n$9;
    let $ = _1n$d;
    for (; o > _0n$9;) o & _1n$d && ($ = $ * s % a), s = s * s % a, o >>= _1n$d;
    return $
}

function pow2$1(s, o, a) {
    let $ = s;
    for (; o-- > _0n$9;) $ *= $, $ %= a;
    return $
}

function invert$1(s, o) {
    if (s === _0n$9 || o <= _0n$9) throw new Error(`invert: expected positive integers, got n=${s} mod=${o}`);
    let a = mod$1(s, o),
        $ = o,
        j = _0n$9,
        _e = _1n$d;
    for (; a !== _0n$9;) {
        const tt = $ / a,
            nt = $ % a,
            rt = j - _e * tt;
        $ = a, a = nt, j = _e, _e = rt
    }
    if ($ !== _1n$d) throw new Error("invert: does not exist");
    return mod$1(j, o)
}

function tonelliShanks$1(s) {
    const o = (s - _1n$d) / _2n$9;
    let a, $, j;
    for (a = s - _1n$d, $ = 0; a % _2n$9 === _0n$9; a /= _2n$9, $++);
    for (j = _2n$9; j < s && pow$1(j, o, s) !== s - _1n$d; j++);
    if ($ === 1) {
        const et = (s + _1n$d) / _4n$1;
        return function(nt, rt) {
            const ot = nt.pow(rt, et);
            if (!nt.eql(nt.sqr(ot), rt)) throw new Error("Cannot find square root");
            return ot
        }
    }
    const _e = (a + _1n$d) / _2n$9;
    return function(tt, nt) {
        if (tt.pow(nt, o) === tt.neg(tt.ONE)) throw new Error("Cannot find square root");
        let rt = $,
            ot = tt.pow(tt.mul(tt.ONE, j), a),
            st = tt.pow(nt, _e),
            lt = tt.pow(nt, a);
        for (; !tt.eql(lt, tt.ONE);) {
            if (tt.eql(lt, tt.ZERO)) return tt.ZERO;
            let ft = 1;
            for (let bt = tt.sqr(lt); ft < rt && !tt.eql(bt, tt.ONE); ft++) bt = tt.sqr(bt);
            const yt = tt.pow(ot, _1n$d << BigInt(rt - ft - 1));
            ot = tt.sqr(yt), st = tt.mul(st, yt), lt = tt.mul(lt, ot), rt = ft
        }
        return st
    }
}

function FpSqrt$1(s) {
    if (s % _4n$1 === _3n$3) {
        const o = (s + _1n$d) / _4n$1;
        return function($, j) {
            const _e = $.pow(j, o);
            if (!$.eql($.sqr(_e), j)) throw new Error("Cannot find square root");
            return _e
        }
    }
    if (s % _8n$5 === _5n$3) {
        const o = (s - _5n$3) / _8n$5;
        return function($, j) {
            const _e = $.mul(j, _2n$9),
                et = $.pow(_e, o),
                tt = $.mul(j, et),
                nt = $.mul($.mul(tt, _2n$9), et),
                rt = $.mul(tt, $.sub(nt, $.ONE));
            if (!$.eql($.sqr(rt), j)) throw new Error("Cannot find square root");
            return rt
        }
    }
    return tonelliShanks$1(s)
}
const isNegativeLE$1 = (s, o) => (mod$1(s, o) & _1n$d) === _1n$d,
    FIELD_FIELDS$1 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function validateField$1(s) {
    const o = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        },
        a = FIELD_FIELDS$1.reduce(($, j) => ($[j] = "function", $), o);
    return validateObject$1(s, a)
}

function FpPow$1(s, o, a) {
    if (a < _0n$9) throw new Error("Expected power > 0");
    if (a === _0n$9) return s.ONE;
    if (a === _1n$d) return o;
    let $ = s.ONE,
        j = o;
    for (; a > _0n$9;) a & _1n$d && ($ = s.mul($, j)), j = s.sqr(j), a >>= _1n$d;
    return $
}

function FpInvertBatch$1(s, o) {
    const a = new Array(o.length),
        $ = o.reduce((_e, et, tt) => s.is0(et) ? _e : (a[tt] = _e, s.mul(_e, et)), s.ONE),
        j = s.inv($);
    return o.reduceRight((_e, et, tt) => s.is0(et) ? _e : (a[tt] = s.mul(_e, a[tt]), s.mul(_e, et)), j), a
}

function nLength$1(s, o) {
    const a = o !== void 0 ? o : s.toString(2).length,
        $ = Math.ceil(a / 8);
    return {
        nBitLength: a,
        nByteLength: $
    }
}

function Field$1(s, o, a = !1, $ = {}) {
    if (s <= _0n$9) throw new Error(`Expected Field ORDER > 0, got ${s}`);
    const {
        nBitLength: j,
        nByteLength: _e
    } = nLength$1(s, o);
    if (_e > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const et = FpSqrt$1(s),
        tt = Object.freeze({
            ORDER: s,
            BITS: j,
            BYTES: _e,
            MASK: bitMask$1(j),
            ZERO: _0n$9,
            ONE: _1n$d,
            create: nt => mod$1(nt, s),
            isValid: nt => {
                if (typeof nt != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof nt}`);
                return _0n$9 <= nt && nt < s
            },
            is0: nt => nt === _0n$9,
            isOdd: nt => (nt & _1n$d) === _1n$d,
            neg: nt => mod$1(-nt, s),
            eql: (nt, rt) => nt === rt,
            sqr: nt => mod$1(nt * nt, s),
            add: (nt, rt) => mod$1(nt + rt, s),
            sub: (nt, rt) => mod$1(nt - rt, s),
            mul: (nt, rt) => mod$1(nt * rt, s),
            pow: (nt, rt) => FpPow$1(tt, nt, rt),
            div: (nt, rt) => mod$1(nt * invert$1(rt, s), s),
            sqrN: nt => nt * nt,
            addN: (nt, rt) => nt + rt,
            subN: (nt, rt) => nt - rt,
            mulN: (nt, rt) => nt * rt,
            inv: nt => invert$1(nt, s),
            sqrt: $.sqrt || (nt => et(tt, nt)),
            invertBatch: nt => FpInvertBatch$1(tt, nt),
            cmov: (nt, rt, ot) => ot ? rt : nt,
            toBytes: nt => a ? numberToBytesLE$1(nt, _e) : numberToBytesBE$1(nt, _e),
            fromBytes: nt => {
                if (nt.length !== _e) throw new Error(`Fp.fromBytes: expected ${_e}, got ${nt.length}`);
                return a ? bytesToNumberLE$1(nt) : bytesToNumberBE$1(nt)
            }
        });
    return Object.freeze(tt)
}

function getFieldBytesLength$1(s) {
    if (typeof s != "bigint") throw new Error("field order must be bigint");
    const o = s.toString(2).length;
    return Math.ceil(o / 8)
}

function getMinHashLength$1(s) {
    const o = getFieldBytesLength$1(s);
    return o + Math.ceil(o / 2)
}

function mapHashToField$1(s, o, a = !1) {
    const $ = s.length,
        j = getFieldBytesLength$1(o),
        _e = getMinHashLength$1(o);
    if ($ < 16 || $ < _e || $ > 1024) throw new Error(`expected ${_e}-1024 bytes of input, got ${$}`);
    const et = a ? bytesToNumberBE$1(s) : bytesToNumberLE$1(s),
        tt = mod$1(et, o - _1n$d) + _1n$d;
    return a ? numberToBytesLE$1(tt, j) : numberToBytesBE$1(tt, j)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$8 = BigInt(0),
    _1n$c = BigInt(1),
    pointPrecomputes$1 = new WeakMap,
    pointWindowSizes$1 = new WeakMap;

function wNAF$1(s, o) {
    const a = (_e, et) => {
            const tt = et.negate();
            return _e ? tt : et
        },
        $ = _e => {
            if (!Number.isSafeInteger(_e) || _e <= 0 || _e > o) throw new Error(`Wrong window size=${_e}, should be [1..${o}]`)
        },
        j = _e => {
            $(_e);
            const et = Math.ceil(o / _e) + 1,
                tt = 2 ** (_e - 1);
            return {
                windows: et,
                windowSize: tt
            }
        };
    return {
        constTimeNegate: a,
        unsafeLadder(_e, et) {
            let tt = s.ZERO,
                nt = _e;
            for (; et > _0n$8;) et & _1n$c && (tt = tt.add(nt)), nt = nt.double(), et >>= _1n$c;
            return tt
        },
        precomputeWindow(_e, et) {
            const {
                windows: tt,
                windowSize: nt
            } = j(et), rt = [];
            let ot = _e,
                st = ot;
            for (let lt = 0; lt < tt; lt++) {
                st = ot, rt.push(st);
                for (let ft = 1; ft < nt; ft++) st = st.add(ot), rt.push(st);
                ot = st.double()
            }
            return rt
        },
        wNAF(_e, et, tt) {
            const {
                windows: nt,
                windowSize: rt
            } = j(_e);
            let ot = s.ZERO,
                st = s.BASE;
            const lt = BigInt(2 ** _e - 1),
                ft = 2 ** _e,
                yt = BigInt(_e);
            for (let bt = 0; bt < nt; bt++) {
                const ht = bt * rt;
                let vt = Number(tt & lt);
                tt >>= yt, vt > rt && (vt -= ft, tt += _1n$c);
                const wt = ht,
                    gt = ht + Math.abs(vt) - 1,
                    At = bt % 2 !== 0,
                    Pt = vt < 0;
                vt === 0 ? st = st.add(a(At, et[wt])) : ot = ot.add(a(Pt, et[gt]))
            }
            return {
                p: ot,
                f: st
            }
        },
        wNAFCached(_e, et, tt) {
            const nt = pointWindowSizes$1.get(_e) || 1;
            let rt = pointPrecomputes$1.get(_e);
            return rt || (rt = this.precomputeWindow(_e, nt), nt !== 1 && pointPrecomputes$1.set(_e, tt(rt))), this.wNAF(nt, rt, et)
        },
        setWindowSize(_e, et) {
            $(et), pointWindowSizes$1.set(_e, et), pointPrecomputes$1.delete(_e)
        }
    }
}

function pippenger$1(s, o, a, $) {
    if (!Array.isArray(a) || !Array.isArray($) || $.length !== a.length) throw new Error("arrays of points and scalars must have equal length");
    $.forEach((ot, st) => {
        if (!o.isValid(ot)) throw new Error(`wrong scalar at index ${st}`)
    }), a.forEach((ot, st) => {
        if (!(ot instanceof s)) throw new Error(`wrong point at index ${st}`)
    });
    const j = bitLen$1(BigInt(a.length)),
        _e = j > 12 ? j - 3 : j > 4 ? j - 2 : j ? 2 : 1,
        et = (1 << _e) - 1,
        tt = new Array(et + 1).fill(s.ZERO),
        nt = Math.floor((o.BITS - 1) / _e) * _e;
    let rt = s.ZERO;
    for (let ot = nt; ot >= 0; ot -= _e) {
        tt.fill(s.ZERO);
        for (let lt = 0; lt < $.length; lt++) {
            const ft = $[lt],
                yt = Number(ft >> BigInt(ot) & BigInt(et));
            tt[yt] = tt[yt].add(a[lt])
        }
        let st = s.ZERO;
        for (let lt = tt.length - 1, ft = s.ZERO; lt > 0; lt--) ft = ft.add(tt[lt]), st = st.add(ft);
        if (rt = rt.add(st), ot !== 0)
            for (let lt = 0; lt < _e; lt++) rt = rt.double()
    }
    return rt
}

function validateBasic$1(s) {
    return validateField$1(s.Fp), validateObject$1(s, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({ ...nLength$1(s.n, s.nBitLength),
        ...s,
        p: s.Fp.ORDER
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0),
    _1n$b = BigInt(1),
    _2n$8 = BigInt(2),
    _8n$4 = BigInt(8),
    VERIFY_DEFAULT$1 = {
        zip215: !0
    };

function validateOpts$3(s) {
    const o = validateBasic$1(s);
    return validateObject$1(s, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }), Object.freeze({ ...o
    })
}

function twistedEdwards$1(s) {
    const o = validateOpts$3(s),
        {
            Fp: a,
            n: $,
            prehash: j,
            hash: _e,
            randomBytes: et,
            nByteLength: tt,
            h: nt
        } = o,
        rt = _2n$8 << BigInt(tt * 8) - _1n$b,
        ot = a.create,
        st = Field$1(o.n, o.nBitLength),
        lt = o.uvRatio || ((mt, xt) => {
            try {
                return {
                    isValid: !0,
                    value: a.sqrt(mt * a.inv(xt))
                }
            } catch {
                return {
                    isValid: !1,
                    value: _0n$7
                }
            }
        }),
        ft = o.adjustScalarBytes || (mt => mt),
        yt = o.domain || ((mt, xt, $t) => {
            if (abool$1("phflag", $t), xt.length || $t) throw new Error("Contexts/pre-hash are not supported");
            return mt
        });

    function bt(mt, xt) {
        aInRange$1("coordinate " + mt, xt, _0n$7, rt)
    }

    function ht(mt) {
        if (!(mt instanceof gt)) throw new Error("ExtendedPoint expected")
    }
    const vt = memoized$1((mt, xt) => {
            const {
                ex: $t,
                ey: Rt,
                ez: It
            } = mt, Tt = mt.is0();
            xt == null && (xt = Tt ? _8n$4 : a.inv(It));
            const dt = ot($t * xt),
                Et = ot(Rt * xt),
                Ot = ot(It * xt);
            if (Tt) return {
                x: _0n$7,
                y: _1n$b
            };
            if (Ot !== _1n$b) throw new Error("invZ was invalid");
            return {
                x: dt,
                y: Et
            }
        }),
        wt = memoized$1(mt => {
            const {
                a: xt,
                d: $t
            } = o;
            if (mt.is0()) throw new Error("bad point: ZERO");
            const {
                ex: Rt,
                ey: It,
                ez: Tt,
                et: dt
            } = mt, Et = ot(Rt * Rt), Ot = ot(It * It), Mt = ot(Tt * Tt), jt = ot(Mt * Mt), Qt = ot(Et * xt), Kt = ot(Mt * ot(Qt + Ot)), qt = ot(jt + ot($t * ot(Et * Ot)));
            if (Kt !== qt) throw new Error("bad point: equation left != right (1)");
            const Jt = ot(Rt * It),
                Zt = ot(Tt * dt);
            if (Jt !== Zt) throw new Error("bad point: equation left != right (2)");
            return !0
        });
    class gt {
        constructor(xt, $t, Rt, It) {
            this.ex = xt, this.ey = $t, this.ez = Rt, this.et = It, bt("x", xt), bt("y", $t), bt("z", Rt), bt("t", It), Object.freeze(this)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(xt) {
            if (xt instanceof gt) throw new Error("extended point not allowed");
            const {
                x: $t,
                y: Rt
            } = xt || {};
            return bt("x", $t), bt("y", Rt), new gt($t, Rt, _1n$b, ot($t * Rt))
        }
        static normalizeZ(xt) {
            const $t = a.invertBatch(xt.map(Rt => Rt.ez));
            return xt.map((Rt, It) => Rt.toAffine($t[It])).map(gt.fromAffine)
        }
        static msm(xt, $t) {
            return pippenger$1(gt, st, xt, $t)
        }
        _setWindowSize(xt) {
            Bt.setWindowSize(this, xt)
        }
        assertValidity() {
            wt(this)
        }
        equals(xt) {
            ht(xt);
            const {
                ex: $t,
                ey: Rt,
                ez: It
            } = this, {
                ex: Tt,
                ey: dt,
                ez: Et
            } = xt, Ot = ot($t * Et), Mt = ot(Tt * It), jt = ot(Rt * Et), Qt = ot(dt * It);
            return Ot === Mt && jt === Qt
        }
        is0() {
            return this.equals(gt.ZERO)
        }
        negate() {
            return new gt(ot(-this.ex), this.ey, this.ez, ot(-this.et))
        }
        double() {
            const {
                a: xt
            } = o, {
                ex: $t,
                ey: Rt,
                ez: It
            } = this, Tt = ot($t * $t), dt = ot(Rt * Rt), Et = ot(_2n$8 * ot(It * It)), Ot = ot(xt * Tt), Mt = $t + Rt, jt = ot(ot(Mt * Mt) - Tt - dt), Qt = Ot + dt, Kt = Qt - Et, qt = Ot - dt, Jt = ot(jt * Kt), Zt = ot(Qt * qt), en = ot(jt * qt), ln = ot(Kt * Qt);
            return new gt(Jt, Zt, ln, en)
        }
        add(xt) {
            ht(xt);
            const {
                a: $t,
                d: Rt
            } = o, {
                ex: It,
                ey: Tt,
                ez: dt,
                et: Et
            } = this, {
                ex: Ot,
                ey: Mt,
                ez: jt,
                et: Qt
            } = xt;
            if ($t === BigInt(-1)) {
                const mn = ot((Tt - It) * (Mt + Ot)),
                    dn = ot((Tt + It) * (Mt - Ot)),
                    vn = ot(dn - mn);
                if (vn === _0n$7) return this.double();
                const gn = ot(dt * _2n$8 * Qt),
                    Gt = ot(Et * _2n$8 * jt),
                    Yt = Gt + gn,
                    nn = dn + mn,
                    St = Gt - gn,
                    ct = ot(Yt * vn),
                    pt = ot(nn * St),
                    kt = ot(Yt * St),
                    Dt = ot(vn * nn);
                return new gt(ct, pt, Dt, kt)
            }
            const Kt = ot(It * Ot),
                qt = ot(Tt * Mt),
                Jt = ot(Et * Rt * Qt),
                Zt = ot(dt * jt),
                en = ot((It + Tt) * (Ot + Mt) - Kt - qt),
                ln = Zt - Jt,
                cn = Zt + Jt,
                un = ot(qt - $t * Kt),
                Nn = ot(en * ln),
                hn = ot(cn * un),
                fn = ot(en * un),
                rn = ot(ln * cn);
            return new gt(Nn, hn, rn, fn)
        }
        subtract(xt) {
            return this.add(xt.negate())
        }
        wNAF(xt) {
            return Bt.wNAFCached(this, xt, gt.normalizeZ)
        }
        multiply(xt) {
            const $t = xt;
            aInRange$1("scalar", $t, _1n$b, $);
            const {
                p: Rt,
                f: It
            } = this.wNAF($t);
            return gt.normalizeZ([Rt, It])[0]
        }
        multiplyUnsafe(xt) {
            const $t = xt;
            return aInRange$1("scalar", $t, _0n$7, $), $t === _0n$7 ? Pt : this.equals(Pt) || $t === _1n$b ? this : this.equals(At) ? this.wNAF($t).p : Bt.unsafeLadder(this, $t)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(nt).is0()
        }
        isTorsionFree() {
            return Bt.unsafeLadder(this, $).is0()
        }
        toAffine(xt) {
            return vt(this, xt)
        }
        clearCofactor() {
            const {
                h: xt
            } = o;
            return xt === _1n$b ? this : this.multiplyUnsafe(xt)
        }
        static fromHex(xt, $t = !1) {
            const {
                d: Rt,
                a: It
            } = o, Tt = a.BYTES;
            xt = ensureBytes$1("pointHex", xt, Tt), abool$1("zip215", $t);
            const dt = xt.slice(),
                Et = xt[Tt - 1];
            dt[Tt - 1] = Et & -129;
            const Ot = bytesToNumberLE$1(dt),
                Mt = $t ? rt : a.ORDER;
            aInRange$1("pointHex.y", Ot, _0n$7, Mt);
            const jt = ot(Ot * Ot),
                Qt = ot(jt - _1n$b),
                Kt = ot(Rt * jt - It);
            let {
                isValid: qt,
                value: Jt
            } = lt(Qt, Kt);
            if (!qt) throw new Error("Point.fromHex: invalid y coordinate");
            const Zt = (Jt & _1n$b) === _1n$b,
                en = (Et & 128) !== 0;
            if (!$t && Jt === _0n$7 && en) throw new Error("Point.fromHex: x=0 and x_0=1");
            return en !== Zt && (Jt = ot(-Jt)), gt.fromAffine({
                x: Jt,
                y: Ot
            })
        }
        static fromPrivateKey(xt) {
            return Ut(xt).point
        }
        toRawBytes() {
            const {
                x: xt,
                y: $t
            } = this.toAffine(), Rt = numberToBytesLE$1($t, a.BYTES);
            return Rt[Rt.length - 1] |= xt & _1n$b ? 128 : 0, Rt
        }
        toHex() {
            return bytesToHex$1(this.toRawBytes())
        }
    }
    gt.BASE = new gt(o.Gx, o.Gy, _1n$b, ot(o.Gx * o.Gy)), gt.ZERO = new gt(_0n$7, _1n$b, _1n$b, _0n$7);
    const {
        BASE: At,
        ZERO: Pt
    } = gt, Bt = wNAF$1(gt, tt * 8);

    function Lt(mt) {
        return mod$1(mt, $)
    }

    function Nt(mt) {
        return Lt(bytesToNumberLE$1(mt))
    }

    function Ut(mt) {
        const xt = tt;
        mt = ensureBytes$1("private key", mt, xt);
        const $t = ensureBytes$1("hashed private key", _e(mt), 2 * xt),
            Rt = ft($t.slice(0, xt)),
            It = $t.slice(xt, 2 * xt),
            Tt = Nt(Rt),
            dt = At.multiply(Tt),
            Et = dt.toRawBytes();
        return {
            head: Rt,
            prefix: It,
            scalar: Tt,
            point: dt,
            pointBytes: Et
        }
    }

    function Vt(mt) {
        return Ut(mt).pointBytes
    }

    function Ft(mt = new Uint8Array, ...xt) {
        const $t = concatBytes$2(...xt);
        return Nt(_e(yt($t, ensureBytes$1("context", mt), !!j)))
    }

    function Wt(mt, xt, $t = {}) {
        mt = ensureBytes$1("message", mt), j && (mt = j(mt));
        const {
            prefix: Rt,
            scalar: It,
            pointBytes: Tt
        } = Ut(xt), dt = Ft($t.context, Rt, mt), Et = At.multiply(dt).toRawBytes(), Ot = Ft($t.context, Et, Tt, mt), Mt = Lt(dt + Ot * It);
        aInRange$1("signature.s", Mt, _0n$7, $);
        const jt = concatBytes$2(Et, numberToBytesLE$1(Mt, a.BYTES));
        return ensureBytes$1("result", jt, tt * 2)
    }
    const Ct = VERIFY_DEFAULT$1;

    function it(mt, xt, $t, Rt = Ct) {
        const {
            context: It,
            zip215: Tt
        } = Rt, dt = a.BYTES;
        mt = ensureBytes$1("signature", mt, 2 * dt), xt = ensureBytes$1("message", xt), Tt !== void 0 && abool$1("zip215", Tt), j && (xt = j(xt));
        const Et = bytesToNumberLE$1(mt.slice(dt, 2 * dt));
        let Ot, Mt, jt;
        try {
            Ot = gt.fromHex($t, Tt), Mt = gt.fromHex(mt.slice(0, dt), Tt), jt = At.multiplyUnsafe(Et)
        } catch {
            return !1
        }
        if (!Tt && Ot.isSmallOrder()) return !1;
        const Qt = Ft(It, Mt.toRawBytes(), Ot.toRawBytes(), xt);
        return Mt.add(Ot.multiplyUnsafe(Qt)).subtract(jt).clearCofactor().equals(gt.ZERO)
    }
    return At._setWindowSize(8), {
        CURVE: o,
        getPublicKey: Vt,
        sign: Wt,
        verify: it,
        ExtendedPoint: gt,
        utils: {
            getExtendedPublicKey: Ut,
            randomPrivateKey: () => et(a.BYTES),
            precompute(mt = 8, xt = gt.BASE) {
                return xt._setWindowSize(mt), xt.multiply(BigInt(3)), xt
            }
        }
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P$1 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
    ED25519_SQRT_M1$1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$a = BigInt(1),
    _2n$7 = BigInt(2);
BigInt(3);
const _5n$2 = BigInt(5),
    _8n$3 = BigInt(8);

function ed25519_pow_2_252_3$1(s) {
    const o = BigInt(10),
        a = BigInt(20),
        $ = BigInt(40),
        j = BigInt(80),
        _e = ED25519_P$1,
        tt = s * s % _e * s % _e,
        nt = pow2$1(tt, _2n$7, _e) * tt % _e,
        rt = pow2$1(nt, _1n$a, _e) * s % _e,
        ot = pow2$1(rt, _5n$2, _e) * rt % _e,
        st = pow2$1(ot, o, _e) * ot % _e,
        lt = pow2$1(st, a, _e) * st % _e,
        ft = pow2$1(lt, $, _e) * lt % _e,
        yt = pow2$1(ft, j, _e) * ft % _e,
        bt = pow2$1(yt, j, _e) * ft % _e,
        ht = pow2$1(bt, o, _e) * ot % _e;
    return {
        pow_p_5_8: pow2$1(ht, _2n$7, _e) * s % _e,
        b2: tt
    }
}

function adjustScalarBytes$1(s) {
    return s[0] &= 248, s[31] &= 127, s[31] |= 64, s
}

function uvRatio$1(s, o) {
    const a = ED25519_P$1,
        $ = mod$1(o * o * o, a),
        j = mod$1($ * $ * o, a),
        _e = ed25519_pow_2_252_3$1(s * j).pow_p_5_8;
    let et = mod$1(s * $ * _e, a);
    const tt = mod$1(o * et * et, a),
        nt = et,
        rt = mod$1(et * ED25519_SQRT_M1$1, a),
        ot = tt === s,
        st = tt === mod$1(-s, a),
        lt = tt === mod$1(-s * ED25519_SQRT_M1$1, a);
    return ot && (et = nt), (st || lt) && (et = rt), isNegativeLE$1(et, a) && (et = mod$1(-et, a)), {
        isValid: ot || st,
        value: et
    }
}
const Fp$3 = Field$1(ED25519_P$1, void 0, !0),
    ed25519Defaults$1 = {
        a: BigInt(-1),
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        Fp: Fp$3,
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        h: _8n$3,
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512$1,
        randomBytes: randomBytes$1,
        adjustScalarBytes: adjustScalarBytes$1,
        uvRatio: uvRatio$1
    },
    ed25519$1 = twistedEdwards$1(ed25519Defaults$1);
var bn$1 = {
    exports: {}
};
const __viteBrowserExternal = {},
    __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    require$$1$1 = getAugmentedNamespace(__viteBrowserExternal$1);
bn$1.exports;
(function(s) {
    (function(o, a) {
        function $(Ct, it) {
            if (!Ct) throw new Error(it || "Assertion failed")
        }

        function j(Ct, it) {
            Ct.super_ = it;
            var at = function() {};
            at.prototype = it.prototype, Ct.prototype = new at, Ct.prototype.constructor = Ct
        }

        function _e(Ct, it, at) {
            if (_e.isBN(Ct)) return Ct;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, Ct !== null && ((it === "le" || it === "be") && (at = it, it = 10), this._init(Ct || 0, it || 10, at || "be"))
        }
        typeof o == "object" ? o.exports = _e : a.BN = _e, _e.BN = _e, _e.wordSize = 26;
        var et;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? et = window.Buffer : et = require$$1$1.Buffer
        } catch {}
        _e.isBN = function(it) {
            return it instanceof _e ? !0 : it !== null && typeof it == "object" && it.constructor.wordSize === _e.wordSize && Array.isArray(it.words)
        }, _e.max = function(it, at) {
            return it.cmp(at) > 0 ? it : at
        }, _e.min = function(it, at) {
            return it.cmp(at) < 0 ? it : at
        }, _e.prototype._init = function(it, at, mt) {
            if (typeof it == "number") return this._initNumber(it, at, mt);
            if (typeof it == "object") return this._initArray(it, at, mt);
            at === "hex" && (at = 16), $(at === (at | 0) && at >= 2 && at <= 36), it = it.toString().replace(/\s+/g, "");
            var xt = 0;
            it[0] === "-" && (xt++, this.negative = 1), xt < it.length && (at === 16 ? this._parseHex(it, xt, mt) : (this._parseBase(it, at, xt), mt === "le" && this._initArray(this.toArray(), at, mt)))
        }, _e.prototype._initNumber = function(it, at, mt) {
            it < 0 && (this.negative = 1, it = -it), it < 67108864 ? (this.words = [it & 67108863], this.length = 1) : it < 4503599627370496 ? (this.words = [it & 67108863, it / 67108864 & 67108863], this.length = 2) : ($(it < 9007199254740992), this.words = [it & 67108863, it / 67108864 & 67108863, 1], this.length = 3), mt === "le" && this._initArray(this.toArray(), at, mt)
        }, _e.prototype._initArray = function(it, at, mt) {
            if ($(typeof it.length == "number"), it.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(it.length / 3), this.words = new Array(this.length);
            for (var xt = 0; xt < this.length; xt++) this.words[xt] = 0;
            var $t, Rt, It = 0;
            if (mt === "be")
                for (xt = it.length - 1, $t = 0; xt >= 0; xt -= 3) Rt = it[xt] | it[xt - 1] << 8 | it[xt - 2] << 16, this.words[$t] |= Rt << It & 67108863, this.words[$t + 1] = Rt >>> 26 - It & 67108863, It += 24, It >= 26 && (It -= 26, $t++);
            else if (mt === "le")
                for (xt = 0, $t = 0; xt < it.length; xt += 3) Rt = it[xt] | it[xt + 1] << 8 | it[xt + 2] << 16, this.words[$t] |= Rt << It & 67108863, this.words[$t + 1] = Rt >>> 26 - It & 67108863, It += 24, It >= 26 && (It -= 26, $t++);
            return this._strip()
        };

        function tt(Ct, it) {
            var at = Ct.charCodeAt(it);
            if (at >= 48 && at <= 57) return at - 48;
            if (at >= 65 && at <= 70) return at - 55;
            if (at >= 97 && at <= 102) return at - 87;
            $(!1, "Invalid character in " + Ct)
        }

        function nt(Ct, it, at) {
            var mt = tt(Ct, at);
            return at - 1 >= it && (mt |= tt(Ct, at - 1) << 4), mt
        }
        _e.prototype._parseHex = function(it, at, mt) {
            this.length = Math.ceil((it.length - at) / 6), this.words = new Array(this.length);
            for (var xt = 0; xt < this.length; xt++) this.words[xt] = 0;
            var $t = 0,
                Rt = 0,
                It;
            if (mt === "be")
                for (xt = it.length - 1; xt >= at; xt -= 2) It = nt(it, at, xt) << $t, this.words[Rt] |= It & 67108863, $t >= 18 ? ($t -= 18, Rt += 1, this.words[Rt] |= It >>> 26) : $t += 8;
            else {
                var Tt = it.length - at;
                for (xt = Tt % 2 === 0 ? at + 1 : at; xt < it.length; xt += 2) It = nt(it, at, xt) << $t, this.words[Rt] |= It & 67108863, $t >= 18 ? ($t -= 18, Rt += 1, this.words[Rt] |= It >>> 26) : $t += 8
            }
            this._strip()
        };

        function rt(Ct, it, at, mt) {
            for (var xt = 0, $t = 0, Rt = Math.min(Ct.length, at), It = it; It < Rt; It++) {
                var Tt = Ct.charCodeAt(It) - 48;
                xt *= mt, Tt >= 49 ? $t = Tt - 49 + 10 : Tt >= 17 ? $t = Tt - 17 + 10 : $t = Tt, $(Tt >= 0 && $t < mt, "Invalid character"), xt += $t
            }
            return xt
        }
        _e.prototype._parseBase = function(it, at, mt) {
            this.words = [0], this.length = 1;
            for (var xt = 0, $t = 1; $t <= 67108863; $t *= at) xt++;
            xt--, $t = $t / at | 0;
            for (var Rt = it.length - mt, It = Rt % xt, Tt = Math.min(Rt, Rt - It) + mt, dt = 0, Et = mt; Et < Tt; Et += xt) dt = rt(it, Et, Et + xt, at), this.imuln($t), this.words[0] + dt < 67108864 ? this.words[0] += dt : this._iaddn(dt);
            if (It !== 0) {
                var Ot = 1;
                for (dt = rt(it, Et, it.length, at), Et = 0; Et < It; Et++) Ot *= at;
                this.imuln(Ot), this.words[0] + dt < 67108864 ? this.words[0] += dt : this._iaddn(dt)
            }
            this._strip()
        }, _e.prototype.copy = function(it) {
            it.words = new Array(this.length);
            for (var at = 0; at < this.length; at++) it.words[at] = this.words[at];
            it.length = this.length, it.negative = this.negative, it.red = this.red
        };

        function ot(Ct, it) {
            Ct.words = it.words, Ct.length = it.length, Ct.negative = it.negative, Ct.red = it.red
        }
        if (_e.prototype._move = function(it) {
                ot(it, this)
            }, _e.prototype.clone = function() {
                var it = new _e(null);
                return this.copy(it), it
            }, _e.prototype._expand = function(it) {
                for (; this.length < it;) this.words[this.length++] = 0;
                return this
            }, _e.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                return this._normSign()
            }, _e.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
            _e.prototype[Symbol.for("nodejs.util.inspect.custom")] = st
        } catch {
            _e.prototype.inspect = st
        } else _e.prototype.inspect = st;

        function st() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            ft = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            yt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        _e.prototype.toString = function(it, at) {
            it = it || 10, at = at | 0 || 1;
            var mt;
            if (it === 16 || it === "hex") {
                mt = "";
                for (var xt = 0, $t = 0, Rt = 0; Rt < this.length; Rt++) {
                    var It = this.words[Rt],
                        Tt = ((It << xt | $t) & 16777215).toString(16);
                    $t = It >>> 24 - xt & 16777215, xt += 2, xt >= 26 && (xt -= 26, Rt--), $t !== 0 || Rt !== this.length - 1 ? mt = lt[6 - Tt.length] + Tt + mt : mt = Tt + mt
                }
                for ($t !== 0 && (mt = $t.toString(16) + mt); mt.length % at !== 0;) mt = "0" + mt;
                return this.negative !== 0 && (mt = "-" + mt), mt
            }
            if (it === (it | 0) && it >= 2 && it <= 36) {
                var dt = ft[it],
                    Et = yt[it];
                mt = "";
                var Ot = this.clone();
                for (Ot.negative = 0; !Ot.isZero();) {
                    var Mt = Ot.modrn(Et).toString(it);
                    Ot = Ot.idivn(Et), Ot.isZero() ? mt = Mt + mt : mt = lt[dt - Mt.length] + Mt + mt
                }
                for (this.isZero() && (mt = "0" + mt); mt.length % at !== 0;) mt = "0" + mt;
                return this.negative !== 0 && (mt = "-" + mt), mt
            }
            $(!1, "Base should be between 2 and 36")
        }, _e.prototype.toNumber = function() {
            var it = this.words[0];
            return this.length === 2 ? it += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? it += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -it : it
        }, _e.prototype.toJSON = function() {
            return this.toString(16, 2)
        }, et && (_e.prototype.toBuffer = function(it, at) {
            return this.toArrayLike(et, it, at)
        }), _e.prototype.toArray = function(it, at) {
            return this.toArrayLike(Array, it, at)
        };
        var bt = function(it, at) {
            return it.allocUnsafe ? it.allocUnsafe(at) : new it(at)
        };
        _e.prototype.toArrayLike = function(it, at, mt) {
            this._strip();
            var xt = this.byteLength(),
                $t = mt || Math.max(1, xt);
            $(xt <= $t, "byte array longer than desired length"), $($t > 0, "Requested array length <= 0");
            var Rt = bt(it, $t),
                It = at === "le" ? "LE" : "BE";
            return this["_toArrayLike" + It](Rt, xt), Rt
        }, _e.prototype._toArrayLikeLE = function(it, at) {
            for (var mt = 0, xt = 0, $t = 0, Rt = 0; $t < this.length; $t++) {
                var It = this.words[$t] << Rt | xt;
                it[mt++] = It & 255, mt < it.length && (it[mt++] = It >> 8 & 255), mt < it.length && (it[mt++] = It >> 16 & 255), Rt === 6 ? (mt < it.length && (it[mt++] = It >> 24 & 255), xt = 0, Rt = 0) : (xt = It >>> 24, Rt += 2)
            }
            if (mt < it.length)
                for (it[mt++] = xt; mt < it.length;) it[mt++] = 0
        }, _e.prototype._toArrayLikeBE = function(it, at) {
            for (var mt = it.length - 1, xt = 0, $t = 0, Rt = 0; $t < this.length; $t++) {
                var It = this.words[$t] << Rt | xt;
                it[mt--] = It & 255, mt >= 0 && (it[mt--] = It >> 8 & 255), mt >= 0 && (it[mt--] = It >> 16 & 255), Rt === 6 ? (mt >= 0 && (it[mt--] = It >> 24 & 255), xt = 0, Rt = 0) : (xt = It >>> 24, Rt += 2)
            }
            if (mt >= 0)
                for (it[mt--] = xt; mt >= 0;) it[mt--] = 0
        }, Math.clz32 ? _e.prototype._countBits = function(it) {
            return 32 - Math.clz32(it)
        } : _e.prototype._countBits = function(it) {
            var at = it,
                mt = 0;
            return at >= 4096 && (mt += 13, at >>>= 13), at >= 64 && (mt += 7, at >>>= 7), at >= 8 && (mt += 4, at >>>= 4), at >= 2 && (mt += 2, at >>>= 2), mt + at
        }, _e.prototype._zeroBits = function(it) {
            if (it === 0) return 26;
            var at = it,
                mt = 0;
            return at & 8191 || (mt += 13, at >>>= 13), at & 127 || (mt += 7, at >>>= 7), at & 15 || (mt += 4, at >>>= 4), at & 3 || (mt += 2, at >>>= 2), at & 1 || mt++, mt
        }, _e.prototype.bitLength = function() {
            var it = this.words[this.length - 1],
                at = this._countBits(it);
            return (this.length - 1) * 26 + at
        };

        function ht(Ct) {
            for (var it = new Array(Ct.bitLength()), at = 0; at < it.length; at++) {
                var mt = at / 26 | 0,
                    xt = at % 26;
                it[at] = Ct.words[mt] >>> xt & 1
            }
            return it
        }
        _e.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var it = 0, at = 0; at < this.length; at++) {
                var mt = this._zeroBits(this.words[at]);
                if (it += mt, mt !== 26) break
            }
            return it
        }, _e.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, _e.prototype.toTwos = function(it) {
            return this.negative !== 0 ? this.abs().inotn(it).iaddn(1) : this.clone()
        }, _e.prototype.fromTwos = function(it) {
            return this.testn(it - 1) ? this.notn(it).iaddn(1).ineg() : this.clone()
        }, _e.prototype.isNeg = function() {
            return this.negative !== 0
        }, _e.prototype.neg = function() {
            return this.clone().ineg()
        }, _e.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, _e.prototype.iuor = function(it) {
            for (; this.length < it.length;) this.words[this.length++] = 0;
            for (var at = 0; at < it.length; at++) this.words[at] = this.words[at] | it.words[at];
            return this._strip()
        }, _e.prototype.ior = function(it) {
            return $((this.negative | it.negative) === 0), this.iuor(it)
        }, _e.prototype.or = function(it) {
            return this.length > it.length ? this.clone().ior(it) : it.clone().ior(this)
        }, _e.prototype.uor = function(it) {
            return this.length > it.length ? this.clone().iuor(it) : it.clone().iuor(this)
        }, _e.prototype.iuand = function(it) {
            var at;
            this.length > it.length ? at = it : at = this;
            for (var mt = 0; mt < at.length; mt++) this.words[mt] = this.words[mt] & it.words[mt];
            return this.length = at.length, this._strip()
        }, _e.prototype.iand = function(it) {
            return $((this.negative | it.negative) === 0), this.iuand(it)
        }, _e.prototype.and = function(it) {
            return this.length > it.length ? this.clone().iand(it) : it.clone().iand(this)
        }, _e.prototype.uand = function(it) {
            return this.length > it.length ? this.clone().iuand(it) : it.clone().iuand(this)
        }, _e.prototype.iuxor = function(it) {
            var at, mt;
            this.length > it.length ? (at = this, mt = it) : (at = it, mt = this);
            for (var xt = 0; xt < mt.length; xt++) this.words[xt] = at.words[xt] ^ mt.words[xt];
            if (this !== at)
                for (; xt < at.length; xt++) this.words[xt] = at.words[xt];
            return this.length = at.length, this._strip()
        }, _e.prototype.ixor = function(it) {
            return $((this.negative | it.negative) === 0), this.iuxor(it)
        }, _e.prototype.xor = function(it) {
            return this.length > it.length ? this.clone().ixor(it) : it.clone().ixor(this)
        }, _e.prototype.uxor = function(it) {
            return this.length > it.length ? this.clone().iuxor(it) : it.clone().iuxor(this)
        }, _e.prototype.inotn = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = Math.ceil(it / 26) | 0,
                mt = it % 26;
            this._expand(at), mt > 0 && at--;
            for (var xt = 0; xt < at; xt++) this.words[xt] = ~this.words[xt] & 67108863;
            return mt > 0 && (this.words[xt] = ~this.words[xt] & 67108863 >> 26 - mt), this._strip()
        }, _e.prototype.notn = function(it) {
            return this.clone().inotn(it)
        }, _e.prototype.setn = function(it, at) {
            $(typeof it == "number" && it >= 0);
            var mt = it / 26 | 0,
                xt = it % 26;
            return this._expand(mt + 1), at ? this.words[mt] = this.words[mt] | 1 << xt : this.words[mt] = this.words[mt] & ~(1 << xt), this._strip()
        }, _e.prototype.iadd = function(it) {
            var at;
            if (this.negative !== 0 && it.negative === 0) return this.negative = 0, at = this.isub(it), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && it.negative !== 0) return it.negative = 0, at = this.isub(it), it.negative = 1, at._normSign();
            var mt, xt;
            this.length > it.length ? (mt = this, xt = it) : (mt = it, xt = this);
            for (var $t = 0, Rt = 0; Rt < xt.length; Rt++) at = (mt.words[Rt] | 0) + (xt.words[Rt] | 0) + $t, this.words[Rt] = at & 67108863, $t = at >>> 26;
            for (; $t !== 0 && Rt < mt.length; Rt++) at = (mt.words[Rt] | 0) + $t, this.words[Rt] = at & 67108863, $t = at >>> 26;
            if (this.length = mt.length, $t !== 0) this.words[this.length] = $t, this.length++;
            else if (mt !== this)
                for (; Rt < mt.length; Rt++) this.words[Rt] = mt.words[Rt];
            return this
        }, _e.prototype.add = function(it) {
            var at;
            return it.negative !== 0 && this.negative === 0 ? (it.negative = 0, at = this.sub(it), it.negative ^= 1, at) : it.negative === 0 && this.negative !== 0 ? (this.negative = 0, at = it.sub(this), this.negative = 1, at) : this.length > it.length ? this.clone().iadd(it) : it.clone().iadd(this)
        }, _e.prototype.isub = function(it) {
            if (it.negative !== 0) {
                it.negative = 0;
                var at = this.iadd(it);
                return it.negative = 1, at._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(it), this.negative = 1, this._normSign();
            var mt = this.cmp(it);
            if (mt === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var xt, $t;
            mt > 0 ? (xt = this, $t = it) : (xt = it, $t = this);
            for (var Rt = 0, It = 0; It < $t.length; It++) at = (xt.words[It] | 0) - ($t.words[It] | 0) + Rt, Rt = at >> 26, this.words[It] = at & 67108863;
            for (; Rt !== 0 && It < xt.length; It++) at = (xt.words[It] | 0) + Rt, Rt = at >> 26, this.words[It] = at & 67108863;
            if (Rt === 0 && It < xt.length && xt !== this)
                for (; It < xt.length; It++) this.words[It] = xt.words[It];
            return this.length = Math.max(this.length, It), xt !== this && (this.negative = 1), this._strip()
        }, _e.prototype.sub = function(it) {
            return this.clone().isub(it)
        };

        function vt(Ct, it, at) {
            at.negative = it.negative ^ Ct.negative;
            var mt = Ct.length + it.length | 0;
            at.length = mt, mt = mt - 1 | 0;
            var xt = Ct.words[0] | 0,
                $t = it.words[0] | 0,
                Rt = xt * $t,
                It = Rt & 67108863,
                Tt = Rt / 67108864 | 0;
            at.words[0] = It;
            for (var dt = 1; dt < mt; dt++) {
                for (var Et = Tt >>> 26, Ot = Tt & 67108863, Mt = Math.min(dt, it.length - 1), jt = Math.max(0, dt - Ct.length + 1); jt <= Mt; jt++) {
                    var Qt = dt - jt | 0;
                    xt = Ct.words[Qt] | 0, $t = it.words[jt] | 0, Rt = xt * $t + Ot, Et += Rt / 67108864 | 0, Ot = Rt & 67108863
                }
                at.words[dt] = Ot | 0, Tt = Et | 0
            }
            return Tt !== 0 ? at.words[dt] = Tt | 0 : at.length--, at._strip()
        }
        var wt = function(it, at, mt) {
            var xt = it.words,
                $t = at.words,
                Rt = mt.words,
                It = 0,
                Tt, dt, Et, Ot = xt[0] | 0,
                Mt = Ot & 8191,
                jt = Ot >>> 13,
                Qt = xt[1] | 0,
                Kt = Qt & 8191,
                qt = Qt >>> 13,
                Jt = xt[2] | 0,
                Zt = Jt & 8191,
                en = Jt >>> 13,
                ln = xt[3] | 0,
                cn = ln & 8191,
                un = ln >>> 13,
                Nn = xt[4] | 0,
                hn = Nn & 8191,
                fn = Nn >>> 13,
                rn = xt[5] | 0,
                mn = rn & 8191,
                dn = rn >>> 13,
                vn = xt[6] | 0,
                gn = vn & 8191,
                Gt = vn >>> 13,
                Yt = xt[7] | 0,
                nn = Yt & 8191,
                St = Yt >>> 13,
                ct = xt[8] | 0,
                pt = ct & 8191,
                kt = ct >>> 13,
                Dt = xt[9] | 0,
                zt = Dt & 8191,
                Ht = Dt >>> 13,
                an = $t[0] | 0,
                Xt = an & 8191,
                tn = an >>> 13,
                pn = $t[1] | 0,
                sn = pn & 8191,
                yn = pn >>> 13,
                Dn = $t[2] | 0,
                wn = Dn & 8191,
                _n = Dn >>> 13,
                Un = $t[3] | 0,
                $n = Un & 8191,
                An = Un >>> 13,
                Gn = $t[4] | 0,
                Pn = Gn & 8191,
                Bn = Gn >>> 13,
                zn = $t[5] | 0,
                Ln = zn & 8191,
                En = zn >>> 13,
                Wn = $t[6] | 0,
                xn = Wn & 8191,
                Sn = Wn >>> 13,
                Qn = $t[7] | 0,
                Tn = Qn & 8191,
                Rn = Qn >>> 13,
                Kn = $t[8] | 0,
                Cn = Kn & 8191,
                kn = Kn >>> 13,
                qn = $t[9] | 0,
                On = qn & 8191,
                Mn = qn >>> 13;
            mt.negative = it.negative ^ at.negative, mt.length = 19, Tt = Math.imul(Mt, Xt), dt = Math.imul(Mt, tn), dt = dt + Math.imul(jt, Xt) | 0, Et = Math.imul(jt, tn);
            var Hn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Hn >>> 26) | 0, Hn &= 67108863, Tt = Math.imul(Kt, Xt), dt = Math.imul(Kt, tn), dt = dt + Math.imul(qt, Xt) | 0, Et = Math.imul(qt, tn), Tt = Tt + Math.imul(Mt, sn) | 0, dt = dt + Math.imul(Mt, yn) | 0, dt = dt + Math.imul(jt, sn) | 0, Et = Et + Math.imul(jt, yn) | 0;
            var Vn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Vn >>> 26) | 0, Vn &= 67108863, Tt = Math.imul(Zt, Xt), dt = Math.imul(Zt, tn), dt = dt + Math.imul(en, Xt) | 0, Et = Math.imul(en, tn), Tt = Tt + Math.imul(Kt, sn) | 0, dt = dt + Math.imul(Kt, yn) | 0, dt = dt + Math.imul(qt, sn) | 0, Et = Et + Math.imul(qt, yn) | 0, Tt = Tt + Math.imul(Mt, wn) | 0, dt = dt + Math.imul(Mt, _n) | 0, dt = dt + Math.imul(jt, wn) | 0, Et = Et + Math.imul(jt, _n) | 0;
            var In = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, Tt = Math.imul(cn, Xt), dt = Math.imul(cn, tn), dt = dt + Math.imul(un, Xt) | 0, Et = Math.imul(un, tn), Tt = Tt + Math.imul(Zt, sn) | 0, dt = dt + Math.imul(Zt, yn) | 0, dt = dt + Math.imul(en, sn) | 0, Et = Et + Math.imul(en, yn) | 0, Tt = Tt + Math.imul(Kt, wn) | 0, dt = dt + Math.imul(Kt, _n) | 0, dt = dt + Math.imul(qt, wn) | 0, Et = Et + Math.imul(qt, _n) | 0, Tt = Tt + Math.imul(Mt, $n) | 0, dt = dt + Math.imul(Mt, An) | 0, dt = dt + Math.imul(jt, $n) | 0, Et = Et + Math.imul(jt, An) | 0;
            var Fn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Fn >>> 26) | 0, Fn &= 67108863, Tt = Math.imul(hn, Xt), dt = Math.imul(hn, tn), dt = dt + Math.imul(fn, Xt) | 0, Et = Math.imul(fn, tn), Tt = Tt + Math.imul(cn, sn) | 0, dt = dt + Math.imul(cn, yn) | 0, dt = dt + Math.imul(un, sn) | 0, Et = Et + Math.imul(un, yn) | 0, Tt = Tt + Math.imul(Zt, wn) | 0, dt = dt + Math.imul(Zt, _n) | 0, dt = dt + Math.imul(en, wn) | 0, Et = Et + Math.imul(en, _n) | 0, Tt = Tt + Math.imul(Kt, $n) | 0, dt = dt + Math.imul(Kt, An) | 0, dt = dt + Math.imul(qt, $n) | 0, Et = Et + Math.imul(qt, An) | 0, Tt = Tt + Math.imul(Mt, Pn) | 0, dt = dt + Math.imul(Mt, Bn) | 0, dt = dt + Math.imul(jt, Pn) | 0, Et = Et + Math.imul(jt, Bn) | 0;
            var Yn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Yn >>> 26) | 0, Yn &= 67108863, Tt = Math.imul(mn, Xt), dt = Math.imul(mn, tn), dt = dt + Math.imul(dn, Xt) | 0, Et = Math.imul(dn, tn), Tt = Tt + Math.imul(hn, sn) | 0, dt = dt + Math.imul(hn, yn) | 0, dt = dt + Math.imul(fn, sn) | 0, Et = Et + Math.imul(fn, yn) | 0, Tt = Tt + Math.imul(cn, wn) | 0, dt = dt + Math.imul(cn, _n) | 0, dt = dt + Math.imul(un, wn) | 0, Et = Et + Math.imul(un, _n) | 0, Tt = Tt + Math.imul(Zt, $n) | 0, dt = dt + Math.imul(Zt, An) | 0, dt = dt + Math.imul(en, $n) | 0, Et = Et + Math.imul(en, An) | 0, Tt = Tt + Math.imul(Kt, Pn) | 0, dt = dt + Math.imul(Kt, Bn) | 0, dt = dt + Math.imul(qt, Pn) | 0, Et = Et + Math.imul(qt, Bn) | 0, Tt = Tt + Math.imul(Mt, Ln) | 0, dt = dt + Math.imul(Mt, En) | 0, dt = dt + Math.imul(jt, Ln) | 0, Et = Et + Math.imul(jt, En) | 0;
            var Zn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Zn >>> 26) | 0, Zn &= 67108863, Tt = Math.imul(gn, Xt), dt = Math.imul(gn, tn), dt = dt + Math.imul(Gt, Xt) | 0, Et = Math.imul(Gt, tn), Tt = Tt + Math.imul(mn, sn) | 0, dt = dt + Math.imul(mn, yn) | 0, dt = dt + Math.imul(dn, sn) | 0, Et = Et + Math.imul(dn, yn) | 0, Tt = Tt + Math.imul(hn, wn) | 0, dt = dt + Math.imul(hn, _n) | 0, dt = dt + Math.imul(fn, wn) | 0, Et = Et + Math.imul(fn, _n) | 0, Tt = Tt + Math.imul(cn, $n) | 0, dt = dt + Math.imul(cn, An) | 0, dt = dt + Math.imul(un, $n) | 0, Et = Et + Math.imul(un, An) | 0, Tt = Tt + Math.imul(Zt, Pn) | 0, dt = dt + Math.imul(Zt, Bn) | 0, dt = dt + Math.imul(en, Pn) | 0, Et = Et + Math.imul(en, Bn) | 0, Tt = Tt + Math.imul(Kt, Ln) | 0, dt = dt + Math.imul(Kt, En) | 0, dt = dt + Math.imul(qt, Ln) | 0, Et = Et + Math.imul(qt, En) | 0, Tt = Tt + Math.imul(Mt, xn) | 0, dt = dt + Math.imul(Mt, Sn) | 0, dt = dt + Math.imul(jt, xn) | 0, Et = Et + Math.imul(jt, Sn) | 0;
            var Xn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Xn >>> 26) | 0, Xn &= 67108863, Tt = Math.imul(nn, Xt), dt = Math.imul(nn, tn), dt = dt + Math.imul(St, Xt) | 0, Et = Math.imul(St, tn), Tt = Tt + Math.imul(gn, sn) | 0, dt = dt + Math.imul(gn, yn) | 0, dt = dt + Math.imul(Gt, sn) | 0, Et = Et + Math.imul(Gt, yn) | 0, Tt = Tt + Math.imul(mn, wn) | 0, dt = dt + Math.imul(mn, _n) | 0, dt = dt + Math.imul(dn, wn) | 0, Et = Et + Math.imul(dn, _n) | 0, Tt = Tt + Math.imul(hn, $n) | 0, dt = dt + Math.imul(hn, An) | 0, dt = dt + Math.imul(fn, $n) | 0, Et = Et + Math.imul(fn, An) | 0, Tt = Tt + Math.imul(cn, Pn) | 0, dt = dt + Math.imul(cn, Bn) | 0, dt = dt + Math.imul(un, Pn) | 0, Et = Et + Math.imul(un, Bn) | 0, Tt = Tt + Math.imul(Zt, Ln) | 0, dt = dt + Math.imul(Zt, En) | 0, dt = dt + Math.imul(en, Ln) | 0, Et = Et + Math.imul(en, En) | 0, Tt = Tt + Math.imul(Kt, xn) | 0, dt = dt + Math.imul(Kt, Sn) | 0, dt = dt + Math.imul(qt, xn) | 0, Et = Et + Math.imul(qt, Sn) | 0, Tt = Tt + Math.imul(Mt, Tn) | 0, dt = dt + Math.imul(Mt, Rn) | 0, dt = dt + Math.imul(jt, Tn) | 0, Et = Et + Math.imul(jt, Rn) | 0;
            var Jn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Jn >>> 26) | 0, Jn &= 67108863, Tt = Math.imul(pt, Xt), dt = Math.imul(pt, tn), dt = dt + Math.imul(kt, Xt) | 0, Et = Math.imul(kt, tn), Tt = Tt + Math.imul(nn, sn) | 0, dt = dt + Math.imul(nn, yn) | 0, dt = dt + Math.imul(St, sn) | 0, Et = Et + Math.imul(St, yn) | 0, Tt = Tt + Math.imul(gn, wn) | 0, dt = dt + Math.imul(gn, _n) | 0, dt = dt + Math.imul(Gt, wn) | 0, Et = Et + Math.imul(Gt, _n) | 0, Tt = Tt + Math.imul(mn, $n) | 0, dt = dt + Math.imul(mn, An) | 0, dt = dt + Math.imul(dn, $n) | 0, Et = Et + Math.imul(dn, An) | 0, Tt = Tt + Math.imul(hn, Pn) | 0, dt = dt + Math.imul(hn, Bn) | 0, dt = dt + Math.imul(fn, Pn) | 0, Et = Et + Math.imul(fn, Bn) | 0, Tt = Tt + Math.imul(cn, Ln) | 0, dt = dt + Math.imul(cn, En) | 0, dt = dt + Math.imul(un, Ln) | 0, Et = Et + Math.imul(un, En) | 0, Tt = Tt + Math.imul(Zt, xn) | 0, dt = dt + Math.imul(Zt, Sn) | 0, dt = dt + Math.imul(en, xn) | 0, Et = Et + Math.imul(en, Sn) | 0, Tt = Tt + Math.imul(Kt, Tn) | 0, dt = dt + Math.imul(Kt, Rn) | 0, dt = dt + Math.imul(qt, Tn) | 0, Et = Et + Math.imul(qt, Rn) | 0, Tt = Tt + Math.imul(Mt, Cn) | 0, dt = dt + Math.imul(Mt, kn) | 0, dt = dt + Math.imul(jt, Cn) | 0, Et = Et + Math.imul(jt, kn) | 0;
            var er = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, Tt = Math.imul(zt, Xt), dt = Math.imul(zt, tn), dt = dt + Math.imul(Ht, Xt) | 0, Et = Math.imul(Ht, tn), Tt = Tt + Math.imul(pt, sn) | 0, dt = dt + Math.imul(pt, yn) | 0, dt = dt + Math.imul(kt, sn) | 0, Et = Et + Math.imul(kt, yn) | 0, Tt = Tt + Math.imul(nn, wn) | 0, dt = dt + Math.imul(nn, _n) | 0, dt = dt + Math.imul(St, wn) | 0, Et = Et + Math.imul(St, _n) | 0, Tt = Tt + Math.imul(gn, $n) | 0, dt = dt + Math.imul(gn, An) | 0, dt = dt + Math.imul(Gt, $n) | 0, Et = Et + Math.imul(Gt, An) | 0, Tt = Tt + Math.imul(mn, Pn) | 0, dt = dt + Math.imul(mn, Bn) | 0, dt = dt + Math.imul(dn, Pn) | 0, Et = Et + Math.imul(dn, Bn) | 0, Tt = Tt + Math.imul(hn, Ln) | 0, dt = dt + Math.imul(hn, En) | 0, dt = dt + Math.imul(fn, Ln) | 0, Et = Et + Math.imul(fn, En) | 0, Tt = Tt + Math.imul(cn, xn) | 0, dt = dt + Math.imul(cn, Sn) | 0, dt = dt + Math.imul(un, xn) | 0, Et = Et + Math.imul(un, Sn) | 0, Tt = Tt + Math.imul(Zt, Tn) | 0, dt = dt + Math.imul(Zt, Rn) | 0, dt = dt + Math.imul(en, Tn) | 0, Et = Et + Math.imul(en, Rn) | 0, Tt = Tt + Math.imul(Kt, Cn) | 0, dt = dt + Math.imul(Kt, kn) | 0, dt = dt + Math.imul(qt, Cn) | 0, Et = Et + Math.imul(qt, kn) | 0, Tt = Tt + Math.imul(Mt, On) | 0, dt = dt + Math.imul(Mt, Mn) | 0, dt = dt + Math.imul(jt, On) | 0, Et = Et + Math.imul(jt, Mn) | 0;
            var tr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, Tt = Math.imul(zt, sn), dt = Math.imul(zt, yn), dt = dt + Math.imul(Ht, sn) | 0, Et = Math.imul(Ht, yn), Tt = Tt + Math.imul(pt, wn) | 0, dt = dt + Math.imul(pt, _n) | 0, dt = dt + Math.imul(kt, wn) | 0, Et = Et + Math.imul(kt, _n) | 0, Tt = Tt + Math.imul(nn, $n) | 0, dt = dt + Math.imul(nn, An) | 0, dt = dt + Math.imul(St, $n) | 0, Et = Et + Math.imul(St, An) | 0, Tt = Tt + Math.imul(gn, Pn) | 0, dt = dt + Math.imul(gn, Bn) | 0, dt = dt + Math.imul(Gt, Pn) | 0, Et = Et + Math.imul(Gt, Bn) | 0, Tt = Tt + Math.imul(mn, Ln) | 0, dt = dt + Math.imul(mn, En) | 0, dt = dt + Math.imul(dn, Ln) | 0, Et = Et + Math.imul(dn, En) | 0, Tt = Tt + Math.imul(hn, xn) | 0, dt = dt + Math.imul(hn, Sn) | 0, dt = dt + Math.imul(fn, xn) | 0, Et = Et + Math.imul(fn, Sn) | 0, Tt = Tt + Math.imul(cn, Tn) | 0, dt = dt + Math.imul(cn, Rn) | 0, dt = dt + Math.imul(un, Tn) | 0, Et = Et + Math.imul(un, Rn) | 0, Tt = Tt + Math.imul(Zt, Cn) | 0, dt = dt + Math.imul(Zt, kn) | 0, dt = dt + Math.imul(en, Cn) | 0, Et = Et + Math.imul(en, kn) | 0, Tt = Tt + Math.imul(Kt, On) | 0, dt = dt + Math.imul(Kt, Mn) | 0, dt = dt + Math.imul(qt, On) | 0, Et = Et + Math.imul(qt, Mn) | 0;
            var nr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, Tt = Math.imul(zt, wn), dt = Math.imul(zt, _n), dt = dt + Math.imul(Ht, wn) | 0, Et = Math.imul(Ht, _n), Tt = Tt + Math.imul(pt, $n) | 0, dt = dt + Math.imul(pt, An) | 0, dt = dt + Math.imul(kt, $n) | 0, Et = Et + Math.imul(kt, An) | 0, Tt = Tt + Math.imul(nn, Pn) | 0, dt = dt + Math.imul(nn, Bn) | 0, dt = dt + Math.imul(St, Pn) | 0, Et = Et + Math.imul(St, Bn) | 0, Tt = Tt + Math.imul(gn, Ln) | 0, dt = dt + Math.imul(gn, En) | 0, dt = dt + Math.imul(Gt, Ln) | 0, Et = Et + Math.imul(Gt, En) | 0, Tt = Tt + Math.imul(mn, xn) | 0, dt = dt + Math.imul(mn, Sn) | 0, dt = dt + Math.imul(dn, xn) | 0, Et = Et + Math.imul(dn, Sn) | 0, Tt = Tt + Math.imul(hn, Tn) | 0, dt = dt + Math.imul(hn, Rn) | 0, dt = dt + Math.imul(fn, Tn) | 0, Et = Et + Math.imul(fn, Rn) | 0, Tt = Tt + Math.imul(cn, Cn) | 0, dt = dt + Math.imul(cn, kn) | 0, dt = dt + Math.imul(un, Cn) | 0, Et = Et + Math.imul(un, kn) | 0, Tt = Tt + Math.imul(Zt, On) | 0, dt = dt + Math.imul(Zt, Mn) | 0, dt = dt + Math.imul(en, On) | 0, Et = Et + Math.imul(en, Mn) | 0;
            var rr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, Tt = Math.imul(zt, $n), dt = Math.imul(zt, An), dt = dt + Math.imul(Ht, $n) | 0, Et = Math.imul(Ht, An), Tt = Tt + Math.imul(pt, Pn) | 0, dt = dt + Math.imul(pt, Bn) | 0, dt = dt + Math.imul(kt, Pn) | 0, Et = Et + Math.imul(kt, Bn) | 0, Tt = Tt + Math.imul(nn, Ln) | 0, dt = dt + Math.imul(nn, En) | 0, dt = dt + Math.imul(St, Ln) | 0, Et = Et + Math.imul(St, En) | 0, Tt = Tt + Math.imul(gn, xn) | 0, dt = dt + Math.imul(gn, Sn) | 0, dt = dt + Math.imul(Gt, xn) | 0, Et = Et + Math.imul(Gt, Sn) | 0, Tt = Tt + Math.imul(mn, Tn) | 0, dt = dt + Math.imul(mn, Rn) | 0, dt = dt + Math.imul(dn, Tn) | 0, Et = Et + Math.imul(dn, Rn) | 0, Tt = Tt + Math.imul(hn, Cn) | 0, dt = dt + Math.imul(hn, kn) | 0, dt = dt + Math.imul(fn, Cn) | 0, Et = Et + Math.imul(fn, kn) | 0, Tt = Tt + Math.imul(cn, On) | 0, dt = dt + Math.imul(cn, Mn) | 0, dt = dt + Math.imul(un, On) | 0, Et = Et + Math.imul(un, Mn) | 0;
            var or = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, Tt = Math.imul(zt, Pn), dt = Math.imul(zt, Bn), dt = dt + Math.imul(Ht, Pn) | 0, Et = Math.imul(Ht, Bn), Tt = Tt + Math.imul(pt, Ln) | 0, dt = dt + Math.imul(pt, En) | 0, dt = dt + Math.imul(kt, Ln) | 0, Et = Et + Math.imul(kt, En) | 0, Tt = Tt + Math.imul(nn, xn) | 0, dt = dt + Math.imul(nn, Sn) | 0, dt = dt + Math.imul(St, xn) | 0, Et = Et + Math.imul(St, Sn) | 0, Tt = Tt + Math.imul(gn, Tn) | 0, dt = dt + Math.imul(gn, Rn) | 0, dt = dt + Math.imul(Gt, Tn) | 0, Et = Et + Math.imul(Gt, Rn) | 0, Tt = Tt + Math.imul(mn, Cn) | 0, dt = dt + Math.imul(mn, kn) | 0, dt = dt + Math.imul(dn, Cn) | 0, Et = Et + Math.imul(dn, kn) | 0, Tt = Tt + Math.imul(hn, On) | 0, dt = dt + Math.imul(hn, Mn) | 0, dt = dt + Math.imul(fn, On) | 0, Et = Et + Math.imul(fn, Mn) | 0;
            var ir = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, Tt = Math.imul(zt, Ln), dt = Math.imul(zt, En), dt = dt + Math.imul(Ht, Ln) | 0, Et = Math.imul(Ht, En), Tt = Tt + Math.imul(pt, xn) | 0, dt = dt + Math.imul(pt, Sn) | 0, dt = dt + Math.imul(kt, xn) | 0, Et = Et + Math.imul(kt, Sn) | 0, Tt = Tt + Math.imul(nn, Tn) | 0, dt = dt + Math.imul(nn, Rn) | 0, dt = dt + Math.imul(St, Tn) | 0, Et = Et + Math.imul(St, Rn) | 0, Tt = Tt + Math.imul(gn, Cn) | 0, dt = dt + Math.imul(gn, kn) | 0, dt = dt + Math.imul(Gt, Cn) | 0, Et = Et + Math.imul(Gt, kn) | 0, Tt = Tt + Math.imul(mn, On) | 0, dt = dt + Math.imul(mn, Mn) | 0, dt = dt + Math.imul(dn, On) | 0, Et = Et + Math.imul(dn, Mn) | 0;
            var sr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, Tt = Math.imul(zt, xn), dt = Math.imul(zt, Sn), dt = dt + Math.imul(Ht, xn) | 0, Et = Math.imul(Ht, Sn), Tt = Tt + Math.imul(pt, Tn) | 0, dt = dt + Math.imul(pt, Rn) | 0, dt = dt + Math.imul(kt, Tn) | 0, Et = Et + Math.imul(kt, Rn) | 0, Tt = Tt + Math.imul(nn, Cn) | 0, dt = dt + Math.imul(nn, kn) | 0, dt = dt + Math.imul(St, Cn) | 0, Et = Et + Math.imul(St, kn) | 0, Tt = Tt + Math.imul(gn, On) | 0, dt = dt + Math.imul(gn, Mn) | 0, dt = dt + Math.imul(Gt, On) | 0, Et = Et + Math.imul(Gt, Mn) | 0;
            var ar = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, Tt = Math.imul(zt, Tn), dt = Math.imul(zt, Rn), dt = dt + Math.imul(Ht, Tn) | 0, Et = Math.imul(Ht, Rn), Tt = Tt + Math.imul(pt, Cn) | 0, dt = dt + Math.imul(pt, kn) | 0, dt = dt + Math.imul(kt, Cn) | 0, Et = Et + Math.imul(kt, kn) | 0, Tt = Tt + Math.imul(nn, On) | 0, dt = dt + Math.imul(nn, Mn) | 0, dt = dt + Math.imul(St, On) | 0, Et = Et + Math.imul(St, Mn) | 0;
            var lr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, Tt = Math.imul(zt, Cn), dt = Math.imul(zt, kn), dt = dt + Math.imul(Ht, Cn) | 0, Et = Math.imul(Ht, kn), Tt = Tt + Math.imul(pt, On) | 0, dt = dt + Math.imul(pt, Mn) | 0, dt = dt + Math.imul(kt, On) | 0, Et = Et + Math.imul(kt, Mn) | 0;
            var cr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, Tt = Math.imul(zt, On), dt = Math.imul(zt, Mn), dt = dt + Math.imul(Ht, On) | 0, Et = Math.imul(Ht, Mn);
            var ur = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            return It = (Et + (dt >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, Rt[0] = Hn, Rt[1] = Vn, Rt[2] = In, Rt[3] = Fn, Rt[4] = Yn, Rt[5] = Zn, Rt[6] = Xn, Rt[7] = Jn, Rt[8] = er, Rt[9] = tr, Rt[10] = nr, Rt[11] = rr, Rt[12] = or, Rt[13] = ir, Rt[14] = sr, Rt[15] = ar, Rt[16] = lr, Rt[17] = cr, Rt[18] = ur, It !== 0 && (Rt[19] = It, mt.length++), mt
        };
        Math.imul || (wt = vt);

        function gt(Ct, it, at) {
            at.negative = it.negative ^ Ct.negative, at.length = Ct.length + it.length;
            for (var mt = 0, xt = 0, $t = 0; $t < at.length - 1; $t++) {
                var Rt = xt;
                xt = 0;
                for (var It = mt & 67108863, Tt = Math.min($t, it.length - 1), dt = Math.max(0, $t - Ct.length + 1); dt <= Tt; dt++) {
                    var Et = $t - dt,
                        Ot = Ct.words[Et] | 0,
                        Mt = it.words[dt] | 0,
                        jt = Ot * Mt,
                        Qt = jt & 67108863;
                    Rt = Rt + (jt / 67108864 | 0) | 0, Qt = Qt + It | 0, It = Qt & 67108863, Rt = Rt + (Qt >>> 26) | 0, xt += Rt >>> 26, Rt &= 67108863
                }
                at.words[$t] = It, mt = Rt, Rt = xt
            }
            return mt !== 0 ? at.words[$t] = mt : at.length--, at._strip()
        }

        function At(Ct, it, at) {
            return gt(Ct, it, at)
        }
        _e.prototype.mulTo = function(it, at) {
            var mt, xt = this.length + it.length;
            return this.length === 10 && it.length === 10 ? mt = wt(this, it, at) : xt < 63 ? mt = vt(this, it, at) : xt < 1024 ? mt = gt(this, it, at) : mt = At(this, it, at), mt
        }, _e.prototype.mul = function(it) {
            var at = new _e(null);
            return at.words = new Array(this.length + it.length), this.mulTo(it, at)
        }, _e.prototype.mulf = function(it) {
            var at = new _e(null);
            return at.words = new Array(this.length + it.length), At(this, it, at)
        }, _e.prototype.imul = function(it) {
            return this.clone().mulTo(it, this)
        }, _e.prototype.imuln = function(it) {
            var at = it < 0;
            at && (it = -it), $(typeof it == "number"), $(it < 67108864);
            for (var mt = 0, xt = 0; xt < this.length; xt++) {
                var $t = (this.words[xt] | 0) * it,
                    Rt = ($t & 67108863) + (mt & 67108863);
                mt >>= 26, mt += $t / 67108864 | 0, mt += Rt >>> 26, this.words[xt] = Rt & 67108863
            }
            return mt !== 0 && (this.words[xt] = mt, this.length++), at ? this.ineg() : this
        }, _e.prototype.muln = function(it) {
            return this.clone().imuln(it)
        }, _e.prototype.sqr = function() {
            return this.mul(this)
        }, _e.prototype.isqr = function() {
            return this.imul(this.clone())
        }, _e.prototype.pow = function(it) {
            var at = ht(it);
            if (at.length === 0) return new _e(1);
            for (var mt = this, xt = 0; xt < at.length && at[xt] === 0; xt++, mt = mt.sqr());
            if (++xt < at.length)
                for (var $t = mt.sqr(); xt < at.length; xt++, $t = $t.sqr()) at[xt] !== 0 && (mt = mt.mul($t));
            return mt
        }, _e.prototype.iushln = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = it % 26,
                mt = (it - at) / 26,
                xt = 67108863 >>> 26 - at << 26 - at,
                $t;
            if (at !== 0) {
                var Rt = 0;
                for ($t = 0; $t < this.length; $t++) {
                    var It = this.words[$t] & xt,
                        Tt = (this.words[$t] | 0) - It << at;
                    this.words[$t] = Tt | Rt, Rt = It >>> 26 - at
                }
                Rt && (this.words[$t] = Rt, this.length++)
            }
            if (mt !== 0) {
                for ($t = this.length - 1; $t >= 0; $t--) this.words[$t + mt] = this.words[$t];
                for ($t = 0; $t < mt; $t++) this.words[$t] = 0;
                this.length += mt
            }
            return this._strip()
        }, _e.prototype.ishln = function(it) {
            return $(this.negative === 0), this.iushln(it)
        }, _e.prototype.iushrn = function(it, at, mt) {
            $(typeof it == "number" && it >= 0);
            var xt;
            at ? xt = (at - at % 26) / 26 : xt = 0;
            var $t = it % 26,
                Rt = Math.min((it - $t) / 26, this.length),
                It = 67108863 ^ 67108863 >>> $t << $t,
                Tt = mt;
            if (xt -= Rt, xt = Math.max(0, xt), Tt) {
                for (var dt = 0; dt < Rt; dt++) Tt.words[dt] = this.words[dt];
                Tt.length = Rt
            }
            if (Rt !== 0)
                if (this.length > Rt)
                    for (this.length -= Rt, dt = 0; dt < this.length; dt++) this.words[dt] = this.words[dt + Rt];
                else this.words[0] = 0, this.length = 1;
            var Et = 0;
            for (dt = this.length - 1; dt >= 0 && (Et !== 0 || dt >= xt); dt--) {
                var Ot = this.words[dt] | 0;
                this.words[dt] = Et << 26 - $t | Ot >>> $t, Et = Ot & It
            }
            return Tt && Et !== 0 && (Tt.words[Tt.length++] = Et), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
        }, _e.prototype.ishrn = function(it, at, mt) {
            return $(this.negative === 0), this.iushrn(it, at, mt)
        }, _e.prototype.shln = function(it) {
            return this.clone().ishln(it)
        }, _e.prototype.ushln = function(it) {
            return this.clone().iushln(it)
        }, _e.prototype.shrn = function(it) {
            return this.clone().ishrn(it)
        }, _e.prototype.ushrn = function(it) {
            return this.clone().iushrn(it)
        }, _e.prototype.testn = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = it % 26,
                mt = (it - at) / 26,
                xt = 1 << at;
            if (this.length <= mt) return !1;
            var $t = this.words[mt];
            return !!($t & xt)
        }, _e.prototype.imaskn = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = it % 26,
                mt = (it - at) / 26;
            if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= mt) return this;
            if (at !== 0 && mt++, this.length = Math.min(mt, this.length), at !== 0) {
                var xt = 67108863 ^ 67108863 >>> at << at;
                this.words[this.length - 1] &= xt
            }
            return this._strip()
        }, _e.prototype.maskn = function(it) {
            return this.clone().imaskn(it)
        }, _e.prototype.iaddn = function(it) {
            return $(typeof it == "number"), $(it < 67108864), it < 0 ? this.isubn(-it) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= it ? (this.words[0] = it - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(it), this.negative = 1, this) : this._iaddn(it)
        }, _e.prototype._iaddn = function(it) {
            this.words[0] += it;
            for (var at = 0; at < this.length && this.words[at] >= 67108864; at++) this.words[at] -= 67108864, at === this.length - 1 ? this.words[at + 1] = 1 : this.words[at + 1]++;
            return this.length = Math.max(this.length, at + 1), this
        }, _e.prototype.isubn = function(it) {
            if ($(typeof it == "number"), $(it < 67108864), it < 0) return this.iaddn(-it);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(it), this.negative = 1, this;
            if (this.words[0] -= it, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var at = 0; at < this.length && this.words[at] < 0; at++) this.words[at] += 67108864, this.words[at + 1] -= 1;
            return this._strip()
        }, _e.prototype.addn = function(it) {
            return this.clone().iaddn(it)
        }, _e.prototype.subn = function(it) {
            return this.clone().isubn(it)
        }, _e.prototype.iabs = function() {
            return this.negative = 0, this
        }, _e.prototype.abs = function() {
            return this.clone().iabs()
        }, _e.prototype._ishlnsubmul = function(it, at, mt) {
            var xt = it.length + mt,
                $t;
            this._expand(xt);
            var Rt, It = 0;
            for ($t = 0; $t < it.length; $t++) {
                Rt = (this.words[$t + mt] | 0) + It;
                var Tt = (it.words[$t] | 0) * at;
                Rt -= Tt & 67108863, It = (Rt >> 26) - (Tt / 67108864 | 0), this.words[$t + mt] = Rt & 67108863
            }
            for (; $t < this.length - mt; $t++) Rt = (this.words[$t + mt] | 0) + It, It = Rt >> 26, this.words[$t + mt] = Rt & 67108863;
            if (It === 0) return this._strip();
            for ($(It === -1), It = 0, $t = 0; $t < this.length; $t++) Rt = -(this.words[$t] | 0) + It, It = Rt >> 26, this.words[$t] = Rt & 67108863;
            return this.negative = 1, this._strip()
        }, _e.prototype._wordDiv = function(it, at) {
            var mt = this.length - it.length,
                xt = this.clone(),
                $t = it,
                Rt = $t.words[$t.length - 1] | 0,
                It = this._countBits(Rt);
            mt = 26 - It, mt !== 0 && ($t = $t.ushln(mt), xt.iushln(mt), Rt = $t.words[$t.length - 1] | 0);
            var Tt = xt.length - $t.length,
                dt;
            if (at !== "mod") {
                dt = new _e(null), dt.length = Tt + 1, dt.words = new Array(dt.length);
                for (var Et = 0; Et < dt.length; Et++) dt.words[Et] = 0
            }
            var Ot = xt.clone()._ishlnsubmul($t, 1, Tt);
            Ot.negative === 0 && (xt = Ot, dt && (dt.words[Tt] = 1));
            for (var Mt = Tt - 1; Mt >= 0; Mt--) {
                var jt = (xt.words[$t.length + Mt] | 0) * 67108864 + (xt.words[$t.length + Mt - 1] | 0);
                for (jt = Math.min(jt / Rt | 0, 67108863), xt._ishlnsubmul($t, jt, Mt); xt.negative !== 0;) jt--, xt.negative = 0, xt._ishlnsubmul($t, 1, Mt), xt.isZero() || (xt.negative ^= 1);
                dt && (dt.words[Mt] = jt)
            }
            return dt && dt._strip(), xt._strip(), at !== "div" && mt !== 0 && xt.iushrn(mt), {
                div: dt || null,
                mod: xt
            }
        }, _e.prototype.divmod = function(it, at, mt) {
            if ($(!it.isZero()), this.isZero()) return {
                div: new _e(0),
                mod: new _e(0)
            };
            var xt, $t, Rt;
            return this.negative !== 0 && it.negative === 0 ? (Rt = this.neg().divmod(it, at), at !== "mod" && (xt = Rt.div.neg()), at !== "div" && ($t = Rt.mod.neg(), mt && $t.negative !== 0 && $t.iadd(it)), {
                div: xt,
                mod: $t
            }) : this.negative === 0 && it.negative !== 0 ? (Rt = this.divmod(it.neg(), at), at !== "mod" && (xt = Rt.div.neg()), {
                div: xt,
                mod: Rt.mod
            }) : this.negative & it.negative ? (Rt = this.neg().divmod(it.neg(), at), at !== "div" && ($t = Rt.mod.neg(), mt && $t.negative !== 0 && $t.isub(it)), {
                div: Rt.div,
                mod: $t
            }) : it.length > this.length || this.cmp(it) < 0 ? {
                div: new _e(0),
                mod: this
            } : it.length === 1 ? at === "div" ? {
                div: this.divn(it.words[0]),
                mod: null
            } : at === "mod" ? {
                div: null,
                mod: new _e(this.modrn(it.words[0]))
            } : {
                div: this.divn(it.words[0]),
                mod: new _e(this.modrn(it.words[0]))
            } : this._wordDiv(it, at)
        }, _e.prototype.div = function(it) {
            return this.divmod(it, "div", !1).div
        }, _e.prototype.mod = function(it) {
            return this.divmod(it, "mod", !1).mod
        }, _e.prototype.umod = function(it) {
            return this.divmod(it, "mod", !0).mod
        }, _e.prototype.divRound = function(it) {
            var at = this.divmod(it);
            if (at.mod.isZero()) return at.div;
            var mt = at.div.negative !== 0 ? at.mod.isub(it) : at.mod,
                xt = it.ushrn(1),
                $t = it.andln(1),
                Rt = mt.cmp(xt);
            return Rt < 0 || $t === 1 && Rt === 0 ? at.div : at.div.negative !== 0 ? at.div.isubn(1) : at.div.iaddn(1)
        }, _e.prototype.modrn = function(it) {
            var at = it < 0;
            at && (it = -it), $(it <= 67108863);
            for (var mt = (1 << 26) % it, xt = 0, $t = this.length - 1; $t >= 0; $t--) xt = (mt * xt + (this.words[$t] | 0)) % it;
            return at ? -xt : xt
        }, _e.prototype.modn = function(it) {
            return this.modrn(it)
        }, _e.prototype.idivn = function(it) {
            var at = it < 0;
            at && (it = -it), $(it <= 67108863);
            for (var mt = 0, xt = this.length - 1; xt >= 0; xt--) {
                var $t = (this.words[xt] | 0) + mt * 67108864;
                this.words[xt] = $t / it | 0, mt = $t % it
            }
            return this._strip(), at ? this.ineg() : this
        }, _e.prototype.divn = function(it) {
            return this.clone().idivn(it)
        }, _e.prototype.egcd = function(it) {
            $(it.negative === 0), $(!it.isZero());
            var at = this,
                mt = it.clone();
            at.negative !== 0 ? at = at.umod(it) : at = at.clone();
            for (var xt = new _e(1), $t = new _e(0), Rt = new _e(0), It = new _e(1), Tt = 0; at.isEven() && mt.isEven();) at.iushrn(1), mt.iushrn(1), ++Tt;
            for (var dt = mt.clone(), Et = at.clone(); !at.isZero();) {
                for (var Ot = 0, Mt = 1; !(at.words[0] & Mt) && Ot < 26; ++Ot, Mt <<= 1);
                if (Ot > 0)
                    for (at.iushrn(Ot); Ot-- > 0;)(xt.isOdd() || $t.isOdd()) && (xt.iadd(dt), $t.isub(Et)), xt.iushrn(1), $t.iushrn(1);
                for (var jt = 0, Qt = 1; !(mt.words[0] & Qt) && jt < 26; ++jt, Qt <<= 1);
                if (jt > 0)
                    for (mt.iushrn(jt); jt-- > 0;)(Rt.isOdd() || It.isOdd()) && (Rt.iadd(dt), It.isub(Et)), Rt.iushrn(1), It.iushrn(1);
                at.cmp(mt) >= 0 ? (at.isub(mt), xt.isub(Rt), $t.isub(It)) : (mt.isub(at), Rt.isub(xt), It.isub($t))
            }
            return {
                a: Rt,
                b: It,
                gcd: mt.iushln(Tt)
            }
        }, _e.prototype._invmp = function(it) {
            $(it.negative === 0), $(!it.isZero());
            var at = this,
                mt = it.clone();
            at.negative !== 0 ? at = at.umod(it) : at = at.clone();
            for (var xt = new _e(1), $t = new _e(0), Rt = mt.clone(); at.cmpn(1) > 0 && mt.cmpn(1) > 0;) {
                for (var It = 0, Tt = 1; !(at.words[0] & Tt) && It < 26; ++It, Tt <<= 1);
                if (It > 0)
                    for (at.iushrn(It); It-- > 0;) xt.isOdd() && xt.iadd(Rt), xt.iushrn(1);
                for (var dt = 0, Et = 1; !(mt.words[0] & Et) && dt < 26; ++dt, Et <<= 1);
                if (dt > 0)
                    for (mt.iushrn(dt); dt-- > 0;) $t.isOdd() && $t.iadd(Rt), $t.iushrn(1);
                at.cmp(mt) >= 0 ? (at.isub(mt), xt.isub($t)) : (mt.isub(at), $t.isub(xt))
            }
            var Ot;
            return at.cmpn(1) === 0 ? Ot = xt : Ot = $t, Ot.cmpn(0) < 0 && Ot.iadd(it), Ot
        }, _e.prototype.gcd = function(it) {
            if (this.isZero()) return it.abs();
            if (it.isZero()) return this.abs();
            var at = this.clone(),
                mt = it.clone();
            at.negative = 0, mt.negative = 0;
            for (var xt = 0; at.isEven() && mt.isEven(); xt++) at.iushrn(1), mt.iushrn(1);
            do {
                for (; at.isEven();) at.iushrn(1);
                for (; mt.isEven();) mt.iushrn(1);
                var $t = at.cmp(mt);
                if ($t < 0) {
                    var Rt = at;
                    at = mt, mt = Rt
                } else if ($t === 0 || mt.cmpn(1) === 0) break;
                at.isub(mt)
            } while (!0);
            return mt.iushln(xt)
        }, _e.prototype.invm = function(it) {
            return this.egcd(it).a.umod(it)
        }, _e.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }, _e.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }, _e.prototype.andln = function(it) {
            return this.words[0] & it
        }, _e.prototype.bincn = function(it) {
            $(typeof it == "number");
            var at = it % 26,
                mt = (it - at) / 26,
                xt = 1 << at;
            if (this.length <= mt) return this._expand(mt + 1), this.words[mt] |= xt, this;
            for (var $t = xt, Rt = mt; $t !== 0 && Rt < this.length; Rt++) {
                var It = this.words[Rt] | 0;
                It += $t, $t = It >>> 26, It &= 67108863, this.words[Rt] = It
            }
            return $t !== 0 && (this.words[Rt] = $t, this.length++), this
        }, _e.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, _e.prototype.cmpn = function(it) {
            var at = it < 0;
            if (this.negative !== 0 && !at) return -1;
            if (this.negative === 0 && at) return 1;
            this._strip();
            var mt;
            if (this.length > 1) mt = 1;
            else {
                at && (it = -it), $(it <= 67108863, "Number is too big");
                var xt = this.words[0] | 0;
                mt = xt === it ? 0 : xt < it ? -1 : 1
            }
            return this.negative !== 0 ? -mt | 0 : mt
        }, _e.prototype.cmp = function(it) {
            if (this.negative !== 0 && it.negative === 0) return -1;
            if (this.negative === 0 && it.negative !== 0) return 1;
            var at = this.ucmp(it);
            return this.negative !== 0 ? -at | 0 : at
        }, _e.prototype.ucmp = function(it) {
            if (this.length > it.length) return 1;
            if (this.length < it.length) return -1;
            for (var at = 0, mt = this.length - 1; mt >= 0; mt--) {
                var xt = this.words[mt] | 0,
                    $t = it.words[mt] | 0;
                if (xt !== $t) {
                    xt < $t ? at = -1 : xt > $t && (at = 1);
                    break
                }
            }
            return at
        }, _e.prototype.gtn = function(it) {
            return this.cmpn(it) === 1
        }, _e.prototype.gt = function(it) {
            return this.cmp(it) === 1
        }, _e.prototype.gten = function(it) {
            return this.cmpn(it) >= 0
        }, _e.prototype.gte = function(it) {
            return this.cmp(it) >= 0
        }, _e.prototype.ltn = function(it) {
            return this.cmpn(it) === -1
        }, _e.prototype.lt = function(it) {
            return this.cmp(it) === -1
        }, _e.prototype.lten = function(it) {
            return this.cmpn(it) <= 0
        }, _e.prototype.lte = function(it) {
            return this.cmp(it) <= 0
        }, _e.prototype.eqn = function(it) {
            return this.cmpn(it) === 0
        }, _e.prototype.eq = function(it) {
            return this.cmp(it) === 0
        }, _e.red = function(it) {
            return new Ft(it)
        }, _e.prototype.toRed = function(it) {
            return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), it.convertTo(this)._forceRed(it)
        }, _e.prototype.fromRed = function() {
            return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, _e.prototype._forceRed = function(it) {
            return this.red = it, this
        }, _e.prototype.forceRed = function(it) {
            return $(!this.red, "Already a number in reduction context"), this._forceRed(it)
        }, _e.prototype.redAdd = function(it) {
            return $(this.red, "redAdd works only with red numbers"), this.red.add(this, it)
        }, _e.prototype.redIAdd = function(it) {
            return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, it)
        }, _e.prototype.redSub = function(it) {
            return $(this.red, "redSub works only with red numbers"), this.red.sub(this, it)
        }, _e.prototype.redISub = function(it) {
            return $(this.red, "redISub works only with red numbers"), this.red.isub(this, it)
        }, _e.prototype.redShl = function(it) {
            return $(this.red, "redShl works only with red numbers"), this.red.shl(this, it)
        }, _e.prototype.redMul = function(it) {
            return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, it), this.red.mul(this, it)
        }, _e.prototype.redIMul = function(it) {
            return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, it), this.red.imul(this, it)
        }, _e.prototype.redSqr = function() {
            return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, _e.prototype.redISqr = function() {
            return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, _e.prototype.redSqrt = function() {
            return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, _e.prototype.redInvm = function() {
            return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, _e.prototype.redNeg = function() {
            return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, _e.prototype.redPow = function(it) {
            return $(this.red && !it.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, it)
        };
        var Pt = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function Bt(Ct, it) {
            this.name = Ct, this.p = new _e(it, 16), this.n = this.p.bitLength(), this.k = new _e(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        Bt.prototype._tmp = function() {
            var it = new _e(null);
            return it.words = new Array(Math.ceil(this.n / 13)), it
        }, Bt.prototype.ireduce = function(it) {
            var at = it,
                mt;
            do this.split(at, this.tmp), at = this.imulK(at), at = at.iadd(this.tmp), mt = at.bitLength(); while (mt > this.n);
            var xt = mt < this.n ? -1 : at.ucmp(this.p);
            return xt === 0 ? (at.words[0] = 0, at.length = 1) : xt > 0 ? at.isub(this.p) : at.strip !== void 0 ? at.strip() : at._strip(), at
        }, Bt.prototype.split = function(it, at) {
            it.iushrn(this.n, 0, at)
        }, Bt.prototype.imulK = function(it) {
            return it.imul(this.k)
        };

        function Lt() {
            Bt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        j(Lt, Bt), Lt.prototype.split = function(it, at) {
            for (var mt = 4194303, xt = Math.min(it.length, 9), $t = 0; $t < xt; $t++) at.words[$t] = it.words[$t];
            if (at.length = xt, it.length <= 9) {
                it.words[0] = 0, it.length = 1;
                return
            }
            var Rt = it.words[9];
            for (at.words[at.length++] = Rt & mt, $t = 10; $t < it.length; $t++) {
                var It = it.words[$t] | 0;
                it.words[$t - 10] = (It & mt) << 4 | Rt >>> 22, Rt = It
            }
            Rt >>>= 22, it.words[$t - 10] = Rt, Rt === 0 && it.length > 10 ? it.length -= 10 : it.length -= 9
        }, Lt.prototype.imulK = function(it) {
            it.words[it.length] = 0, it.words[it.length + 1] = 0, it.length += 2;
            for (var at = 0, mt = 0; mt < it.length; mt++) {
                var xt = it.words[mt] | 0;
                at += xt * 977, it.words[mt] = at & 67108863, at = xt * 64 + (at / 67108864 | 0)
            }
            return it.words[it.length - 1] === 0 && (it.length--, it.words[it.length - 1] === 0 && it.length--), it
        };

        function Nt() {
            Bt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        j(Nt, Bt);

        function Ut() {
            Bt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        j(Ut, Bt);

        function Vt() {
            Bt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        j(Vt, Bt), Vt.prototype.imulK = function(it) {
            for (var at = 0, mt = 0; mt < it.length; mt++) {
                var xt = (it.words[mt] | 0) * 19 + at,
                    $t = xt & 67108863;
                xt >>>= 26, it.words[mt] = $t, at = xt
            }
            return at !== 0 && (it.words[it.length++] = at), it
        }, _e._prime = function(it) {
            if (Pt[it]) return Pt[it];
            var at;
            if (it === "k256") at = new Lt;
            else if (it === "p224") at = new Nt;
            else if (it === "p192") at = new Ut;
            else if (it === "p25519") at = new Vt;
            else throw new Error("Unknown prime " + it);
            return Pt[it] = at, at
        };

        function Ft(Ct) {
            if (typeof Ct == "string") {
                var it = _e._prime(Ct);
                this.m = it.p, this.prime = it
            } else $(Ct.gtn(1), "modulus must be greater than 1"), this.m = Ct, this.prime = null
        }
        Ft.prototype._verify1 = function(it) {
            $(it.negative === 0, "red works only with positives"), $(it.red, "red works only with red numbers")
        }, Ft.prototype._verify2 = function(it, at) {
            $((it.negative | at.negative) === 0, "red works only with positives"), $(it.red && it.red === at.red, "red works only with red numbers")
        }, Ft.prototype.imod = function(it) {
            return this.prime ? this.prime.ireduce(it)._forceRed(this) : (ot(it, it.umod(this.m)._forceRed(this)), it)
        }, Ft.prototype.neg = function(it) {
            return it.isZero() ? it.clone() : this.m.sub(it)._forceRed(this)
        }, Ft.prototype.add = function(it, at) {
            this._verify2(it, at);
            var mt = it.add(at);
            return mt.cmp(this.m) >= 0 && mt.isub(this.m), mt._forceRed(this)
        }, Ft.prototype.iadd = function(it, at) {
            this._verify2(it, at);
            var mt = it.iadd(at);
            return mt.cmp(this.m) >= 0 && mt.isub(this.m), mt
        }, Ft.prototype.sub = function(it, at) {
            this._verify2(it, at);
            var mt = it.sub(at);
            return mt.cmpn(0) < 0 && mt.iadd(this.m), mt._forceRed(this)
        }, Ft.prototype.isub = function(it, at) {
            this._verify2(it, at);
            var mt = it.isub(at);
            return mt.cmpn(0) < 0 && mt.iadd(this.m), mt
        }, Ft.prototype.shl = function(it, at) {
            return this._verify1(it), this.imod(it.ushln(at))
        }, Ft.prototype.imul = function(it, at) {
            return this._verify2(it, at), this.imod(it.imul(at))
        }, Ft.prototype.mul = function(it, at) {
            return this._verify2(it, at), this.imod(it.mul(at))
        }, Ft.prototype.isqr = function(it) {
            return this.imul(it, it.clone())
        }, Ft.prototype.sqr = function(it) {
            return this.mul(it, it)
        }, Ft.prototype.sqrt = function(it) {
            if (it.isZero()) return it.clone();
            var at = this.m.andln(3);
            if ($(at % 2 === 1), at === 3) {
                var mt = this.m.add(new _e(1)).iushrn(2);
                return this.pow(it, mt)
            }
            for (var xt = this.m.subn(1), $t = 0; !xt.isZero() && xt.andln(1) === 0;) $t++, xt.iushrn(1);
            $(!xt.isZero());
            var Rt = new _e(1).toRed(this),
                It = Rt.redNeg(),
                Tt = this.m.subn(1).iushrn(1),
                dt = this.m.bitLength();
            for (dt = new _e(2 * dt * dt).toRed(this); this.pow(dt, Tt).cmp(It) !== 0;) dt.redIAdd(It);
            for (var Et = this.pow(dt, xt), Ot = this.pow(it, xt.addn(1).iushrn(1)), Mt = this.pow(it, xt), jt = $t; Mt.cmp(Rt) !== 0;) {
                for (var Qt = Mt, Kt = 0; Qt.cmp(Rt) !== 0; Kt++) Qt = Qt.redSqr();
                $(Kt < jt);
                var qt = this.pow(Et, new _e(1).iushln(jt - Kt - 1));
                Ot = Ot.redMul(qt), Et = qt.redSqr(), Mt = Mt.redMul(Et), jt = Kt
            }
            return Ot
        }, Ft.prototype.invm = function(it) {
            var at = it._invmp(this.m);
            return at.negative !== 0 ? (at.negative = 0, this.imod(at).redNeg()) : this.imod(at)
        }, Ft.prototype.pow = function(it, at) {
            if (at.isZero()) return new _e(1).toRed(this);
            if (at.cmpn(1) === 0) return it.clone();
            var mt = 4,
                xt = new Array(1 << mt);
            xt[0] = new _e(1).toRed(this), xt[1] = it;
            for (var $t = 2; $t < xt.length; $t++) xt[$t] = this.mul(xt[$t - 1], it);
            var Rt = xt[0],
                It = 0,
                Tt = 0,
                dt = at.bitLength() % 26;
            for (dt === 0 && (dt = 26), $t = at.length - 1; $t >= 0; $t--) {
                for (var Et = at.words[$t], Ot = dt - 1; Ot >= 0; Ot--) {
                    var Mt = Et >> Ot & 1;
                    if (Rt !== xt[0] && (Rt = this.sqr(Rt)), Mt === 0 && It === 0) {
                        Tt = 0;
                        continue
                    }
                    It <<= 1, It |= Mt, Tt++, !(Tt !== mt && ($t !== 0 || Ot !== 0)) && (Rt = this.mul(Rt, xt[It]), Tt = 0, It = 0)
                }
                dt = 26
            }
            return Rt
        }, Ft.prototype.convertTo = function(it) {
            var at = it.umod(this.m);
            return at === it ? at.clone() : at
        }, Ft.prototype.convertFrom = function(it) {
            var at = it.clone();
            return at.red = null, at
        }, _e.mont = function(it) {
            return new Wt(it)
        };

        function Wt(Ct) {
            Ft.call(this, Ct), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new _e(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        j(Wt, Ft), Wt.prototype.convertTo = function(it) {
            return this.imod(it.ushln(this.shift))
        }, Wt.prototype.convertFrom = function(it) {
            var at = this.imod(it.mul(this.rinv));
            return at.red = null, at
        }, Wt.prototype.imul = function(it, at) {
            if (it.isZero() || at.isZero()) return it.words[0] = 0, it.length = 1, it;
            var mt = it.imul(at),
                xt = mt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                $t = mt.isub(xt).iushrn(this.shift),
                Rt = $t;
            return $t.cmp(this.m) >= 0 ? Rt = $t.isub(this.m) : $t.cmpn(0) < 0 && (Rt = $t.iadd(this.m)), Rt._forceRed(this)
        }, Wt.prototype.mul = function(it, at) {
            if (it.isZero() || at.isZero()) return new _e(0)._forceRed(this);
            var mt = it.mul(at),
                xt = mt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                $t = mt.isub(xt).iushrn(this.shift),
                Rt = $t;
            return $t.cmp(this.m) >= 0 ? Rt = $t.isub(this.m) : $t.cmpn(0) < 0 && (Rt = $t.iadd(this.m)), Rt._forceRed(this)
        }, Wt.prototype.invm = function(it) {
            var at = this.imod(it._invmp(this.m).mul(this.r2));
            return at._forceRed(this)
        }
    })(s, commonjsGlobal$1)
})(bn$1);
var bnExports$1 = bn$1.exports;
const BN$1 = getDefaultExportFromCjs$3(bnExports$1);
var safeBuffer$1 = {
    exports: {}
}; /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(s, o) {
    var a = buffer$1,
        $ = a.Buffer;

    function j(et, tt) {
        for (var nt in et) tt[nt] = et[nt]
    }
    $.from && $.alloc && $.allocUnsafe && $.allocUnsafeSlow ? s.exports = a : (j(a, o), o.Buffer = _e);

    function _e(et, tt, nt) {
        return $(et, tt, nt)
    }
    _e.prototype = Object.create($.prototype), j($, _e), _e.from = function(et, tt, nt) {
        if (typeof et == "number") throw new TypeError("Argument must not be a number");
        return $(et, tt, nt)
    }, _e.alloc = function(et, tt, nt) {
        if (typeof et != "number") throw new TypeError("Argument must be a number");
        var rt = $(et);
        return tt !== void 0 ? typeof nt == "string" ? rt.fill(tt, nt) : rt.fill(tt) : rt.fill(0), rt
    }, _e.allocUnsafe = function(et) {
        if (typeof et != "number") throw new TypeError("Argument must be a number");
        return $(et)
    }, _e.allocUnsafeSlow = function(et) {
        if (typeof et != "number") throw new TypeError("Argument must be a number");
        return a.SlowBuffer(et)
    }
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports$1 = safeBuffer$1.exports,
    _Buffer$2 = safeBufferExports$1.Buffer;

function base$3(s) {
    if (s.length >= 255) throw new TypeError("Alphabet too long");
    for (var o = new Uint8Array(256), a = 0; a < o.length; a++) o[a] = 255;
    for (var $ = 0; $ < s.length; $++) {
        var j = s.charAt($),
            _e = j.charCodeAt(0);
        if (o[_e] !== 255) throw new TypeError(j + " is ambiguous");
        o[_e] = $
    }
    var et = s.length,
        tt = s.charAt(0),
        nt = Math.log(et) / Math.log(256),
        rt = Math.log(256) / Math.log(et);

    function ot(ft) {
        if ((Array.isArray(ft) || ft instanceof Uint8Array) && (ft = _Buffer$2.from(ft)), !_Buffer$2.isBuffer(ft)) throw new TypeError("Expected Buffer");
        if (ft.length === 0) return "";
        for (var yt = 0, bt = 0, ht = 0, vt = ft.length; ht !== vt && ft[ht] === 0;) ht++, yt++;
        for (var wt = (vt - ht) * rt + 1 >>> 0, gt = new Uint8Array(wt); ht !== vt;) {
            for (var At = ft[ht], Pt = 0, Bt = wt - 1;
                (At !== 0 || Pt < bt) && Bt !== -1; Bt--, Pt++) At += 256 * gt[Bt] >>> 0, gt[Bt] = At % et >>> 0, At = At / et >>> 0;
            if (At !== 0) throw new Error("Non-zero carry");
            bt = Pt, ht++
        }
        for (var Lt = wt - bt; Lt !== wt && gt[Lt] === 0;) Lt++;
        for (var Nt = tt.repeat(yt); Lt < wt; ++Lt) Nt += s.charAt(gt[Lt]);
        return Nt
    }

    function st(ft) {
        if (typeof ft != "string") throw new TypeError("Expected String");
        if (ft.length === 0) return _Buffer$2.alloc(0);
        for (var yt = 0, bt = 0, ht = 0; ft[yt] === tt;) bt++, yt++;
        for (var vt = (ft.length - yt) * nt + 1 >>> 0, wt = new Uint8Array(vt); yt < ft.length;) {
            var gt = o[ft.charCodeAt(yt)];
            if (gt === 255) return;
            for (var At = 0, Pt = vt - 1;
                (gt !== 0 || At < ht) && Pt !== -1; Pt--, At++) gt += et * wt[Pt] >>> 0, wt[Pt] = gt % 256 >>> 0, gt = gt / 256 >>> 0;
            if (gt !== 0) throw new Error("Non-zero carry");
            ht = At, yt++
        }
        for (var Bt = vt - ht; Bt !== vt && wt[Bt] === 0;) Bt++;
        var Lt = _Buffer$2.allocUnsafe(bt + (vt - Bt));
        Lt.fill(0, 0, bt);
        for (var Nt = bt; Bt !== vt;) Lt[Nt++] = wt[Bt++];
        return Lt
    }

    function lt(ft) {
        var yt = st(ft);
        if (yt) return yt;
        throw new Error("Non-base" + et + " character")
    }
    return {
        encode: ot,
        decodeUnsafe: st,
        decode: lt
    }
}
var src$3 = base$3,
    basex$3 = src$3,
    ALPHABET$3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    bs58$4 = basex$3(ALPHABET$3);
const bs58$5 = getDefaultExportFromCjs$3(bs58$4),
    SHA256_K$1 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    SHA256_IV$1 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    SHA256_W$1 = new Uint32Array(64);
let SHA256$1 = class extends HashMD$1 {
    constructor() {
        super(64, 32, 8, !1), this.A = SHA256_IV$1[0] | 0, this.B = SHA256_IV$1[1] | 0, this.C = SHA256_IV$1[2] | 0, this.D = SHA256_IV$1[3] | 0, this.E = SHA256_IV$1[4] | 0, this.F = SHA256_IV$1[5] | 0, this.G = SHA256_IV$1[6] | 0, this.H = SHA256_IV$1[7] | 0
    }
    get() {
        const {
            A: o,
            B: a,
            C: $,
            D: j,
            E: _e,
            F: et,
            G: tt,
            H: nt
        } = this;
        return [o, a, $, j, _e, et, tt, nt]
    }
    set(o, a, $, j, _e, et, tt, nt) {
        this.A = o | 0, this.B = a | 0, this.C = $ | 0, this.D = j | 0, this.E = _e | 0, this.F = et | 0, this.G = tt | 0, this.H = nt | 0
    }
    process(o, a) {
        for (let st = 0; st < 16; st++, a += 4) SHA256_W$1[st] = o.getUint32(a, !1);
        for (let st = 16; st < 64; st++) {
            const lt = SHA256_W$1[st - 15],
                ft = SHA256_W$1[st - 2],
                yt = rotr$1(lt, 7) ^ rotr$1(lt, 18) ^ lt >>> 3,
                bt = rotr$1(ft, 17) ^ rotr$1(ft, 19) ^ ft >>> 10;
            SHA256_W$1[st] = bt + SHA256_W$1[st - 7] + yt + SHA256_W$1[st - 16] | 0
        }
        let {
            A: $,
            B: j,
            C: _e,
            D: et,
            E: tt,
            F: nt,
            G: rt,
            H: ot
        } = this;
        for (let st = 0; st < 64; st++) {
            const lt = rotr$1(tt, 6) ^ rotr$1(tt, 11) ^ rotr$1(tt, 25),
                ft = ot + lt + Chi$1(tt, nt, rt) + SHA256_K$1[st] + SHA256_W$1[st] | 0,
                bt = (rotr$1($, 2) ^ rotr$1($, 13) ^ rotr$1($, 22)) + Maj$1($, j, _e) | 0;
            ot = rt, rt = nt, nt = tt, tt = et + ft | 0, et = _e, _e = j, j = $, $ = ft + bt | 0
        }
        $ = $ + this.A | 0, j = j + this.B | 0, _e = _e + this.C | 0, et = et + this.D | 0, tt = tt + this.E | 0, nt = nt + this.F | 0, rt = rt + this.G | 0, ot = ot + this.H | 0, this.set($, j, _e, et, tt, nt, rt, ot)
    }
    roundClean() {
        SHA256_W$1.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
    }
};
const sha256$3 = wrapConstructor$1(() => new SHA256$1);
var lib$1 = {},
    _Buffer$1 = safeBufferExports$1.Buffer;

function base$2(s) {
    if (s.length >= 255) throw new TypeError("Alphabet too long");
    for (var o = new Uint8Array(256), a = 0; a < o.length; a++) o[a] = 255;
    for (var $ = 0; $ < s.length; $++) {
        var j = s.charAt($),
            _e = j.charCodeAt(0);
        if (o[_e] !== 255) throw new TypeError(j + " is ambiguous");
        o[_e] = $
    }
    var et = s.length,
        tt = s.charAt(0),
        nt = Math.log(et) / Math.log(256),
        rt = Math.log(256) / Math.log(et);

    function ot(ft) {
        if ((Array.isArray(ft) || ft instanceof Uint8Array) && (ft = _Buffer$1.from(ft)), !_Buffer$1.isBuffer(ft)) throw new TypeError("Expected Buffer");
        if (ft.length === 0) return "";
        for (var yt = 0, bt = 0, ht = 0, vt = ft.length; ht !== vt && ft[ht] === 0;) ht++, yt++;
        for (var wt = (vt - ht) * rt + 1 >>> 0, gt = new Uint8Array(wt); ht !== vt;) {
            for (var At = ft[ht], Pt = 0, Bt = wt - 1;
                (At !== 0 || Pt < bt) && Bt !== -1; Bt--, Pt++) At += 256 * gt[Bt] >>> 0, gt[Bt] = At % et >>> 0, At = At / et >>> 0;
            if (At !== 0) throw new Error("Non-zero carry");
            bt = Pt, ht++
        }
        for (var Lt = wt - bt; Lt !== wt && gt[Lt] === 0;) Lt++;
        for (var Nt = tt.repeat(yt); Lt < wt; ++Lt) Nt += s.charAt(gt[Lt]);
        return Nt
    }

    function st(ft) {
        if (typeof ft != "string") throw new TypeError("Expected String");
        if (ft.length === 0) return _Buffer$1.alloc(0);
        for (var yt = 0, bt = 0, ht = 0; ft[yt] === tt;) bt++, yt++;
        for (var vt = (ft.length - yt) * nt + 1 >>> 0, wt = new Uint8Array(vt); yt < ft.length;) {
            var gt = o[ft.charCodeAt(yt)];
            if (gt === 255) return;
            for (var At = 0, Pt = vt - 1;
                (gt !== 0 || At < ht) && Pt !== -1; Pt--, At++) gt += et * wt[Pt] >>> 0, wt[Pt] = gt % 256 >>> 0, gt = gt / 256 >>> 0;
            if (gt !== 0) throw new Error("Non-zero carry");
            ht = At, yt++
        }
        for (var Bt = vt - ht; Bt !== vt && wt[Bt] === 0;) Bt++;
        var Lt = _Buffer$1.allocUnsafe(bt + (vt - Bt));
        Lt.fill(0, 0, bt);
        for (var Nt = bt; Bt !== vt;) Lt[Nt++] = wt[Bt++];
        return Lt
    }

    function lt(ft) {
        var yt = st(ft);
        if (yt) return yt;
        throw new Error("Non-base" + et + " character")
    }
    return {
        encode: ot,
        decodeUnsafe: st,
        decode: lt
    }
}
var src$2 = base$2,
    basex$2 = src$2,
    ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    bs58$3 = basex$2(ALPHABET$2);

function inRange$2(s, o, a) {
    return o <= s && s <= a
}

function ToDictionary$1(s) {
    if (s === void 0) return {};
    if (s === Object(s)) return s;
    throw TypeError("Could not convert argument to dictionary")
}

function stringToCodePoints$1(s) {
    for (var o = String(s), a = o.length, $ = 0, j = []; $ < a;) {
        var _e = o.charCodeAt($);
        if (_e < 55296 || _e > 57343) j.push(_e);
        else if (56320 <= _e && _e <= 57343) j.push(65533);
        else if (55296 <= _e && _e <= 56319)
            if ($ === a - 1) j.push(65533);
            else {
                var et = s.charCodeAt($ + 1);
                if (56320 <= et && et <= 57343) {
                    var tt = _e & 1023,
                        nt = et & 1023;
                    j.push(65536 + (tt << 10) + nt), $ += 1
                } else j.push(65533)
            }
        $ += 1
    }
    return j
}

function codePointsToString$1(s) {
    for (var o = "", a = 0; a < s.length; ++a) {
        var $ = s[a];
        $ <= 65535 ? o += String.fromCharCode($) : ($ -= 65536, o += String.fromCharCode(($ >> 10) + 55296, ($ & 1023) + 56320))
    }
    return o
}
var end_of_stream$1 = -1;

function Stream$1(s) {
    this.tokens = [].slice.call(s)
}
Stream$1.prototype = {
    endOfStream: function() {
        return !this.tokens.length
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : end_of_stream$1
    },
    prepend: function(s) {
        if (Array.isArray(s))
            for (var o = s; o.length;) this.tokens.unshift(o.pop());
        else this.tokens.unshift(s)
    },
    push: function(s) {
        if (Array.isArray(s))
            for (var o = s; o.length;) this.tokens.push(o.shift());
        else this.tokens.push(s)
    }
};
var finished$1 = -1;

function decoderError$1(s, o) {
    if (s) throw TypeError("Decoder error");
    return o || 65533
}
var DEFAULT_ENCODING$1 = "utf-8";

function TextDecoder$2(s, o) {
    if (!(this instanceof TextDecoder$2)) return new TextDecoder$2(s, o);
    if (s = s !== void 0 ? String(s).toLowerCase() : DEFAULT_ENCODING$1, s !== DEFAULT_ENCODING$1) throw new Error("Encoding not supported. Only utf-8 is supported");
    o = ToDictionary$1(o), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!o.fatal, this._ignoreBOM = !!o.ignoreBOM, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }), Object.defineProperty(this, "fatal", {
        value: this._fatal
    }), Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
TextDecoder$2.prototype = {
    decode: function s(o, a) {
        var $;
        typeof o == "object" && o instanceof ArrayBuffer ? $ = new Uint8Array(o) : typeof o == "object" && "buffer" in o && o.buffer instanceof ArrayBuffer ? $ = new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : $ = new Uint8Array(0), a = ToDictionary$1(a), this._streaming || (this._decoder = new UTF8Decoder$1({
            fatal: this._fatal
        }), this._BOMseen = !1), this._streaming = !!a.stream;
        for (var j = new Stream$1($), _e = [], et; !j.endOfStream() && (et = this._decoder.handler(j, j.read()), et !== finished$1);) et !== null && (Array.isArray(et) ? _e.push.apply(_e, et) : _e.push(et));
        if (!this._streaming) {
            do {
                if (et = this._decoder.handler(j, j.read()), et === finished$1) break;
                et !== null && (Array.isArray(et) ? _e.push.apply(_e, et) : _e.push(et))
            } while (!j.endOfStream());
            this._decoder = null
        }
        return _e.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (_e[0] === 65279 ? (this._BOMseen = !0, _e.shift()) : this._BOMseen = !0), codePointsToString$1(_e)
    }
};

function TextEncoder$2(s, o) {
    if (!(this instanceof TextEncoder$2)) return new TextEncoder$2(s, o);
    if (s = s !== void 0 ? String(s).toLowerCase() : DEFAULT_ENCODING$1, s !== DEFAULT_ENCODING$1) throw new Error("Encoding not supported. Only utf-8 is supported");
    o = ToDictionary$1(o), this._streaming = !1, this._encoder = null, this._options = {
        fatal: !!o.fatal
    }, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
TextEncoder$2.prototype = {
    encode: function s(o, a) {
        o = o ? String(o) : "", a = ToDictionary$1(a), this._streaming || (this._encoder = new UTF8Encoder$1(this._options)), this._streaming = !!a.stream;
        for (var $ = [], j = new Stream$1(stringToCodePoints$1(o)), _e; !j.endOfStream() && (_e = this._encoder.handler(j, j.read()), _e !== finished$1);) Array.isArray(_e) ? $.push.apply($, _e) : $.push(_e);
        if (!this._streaming) {
            for (; _e = this._encoder.handler(j, j.read()), _e !== finished$1;) Array.isArray(_e) ? $.push.apply($, _e) : $.push(_e);
            this._encoder = null
        }
        return new Uint8Array($)
    }
};

function UTF8Decoder$1(s) {
    var o = s.fatal,
        a = 0,
        $ = 0,
        j = 0,
        _e = 128,
        et = 191;
    this.handler = function(tt, nt) {
        if (nt === end_of_stream$1 && j !== 0) return j = 0, decoderError$1(o);
        if (nt === end_of_stream$1) return finished$1;
        if (j === 0) {
            if (inRange$2(nt, 0, 127)) return nt;
            if (inRange$2(nt, 194, 223)) j = 1, a = nt - 192;
            else if (inRange$2(nt, 224, 239)) nt === 224 && (_e = 160), nt === 237 && (et = 159), j = 2, a = nt - 224;
            else if (inRange$2(nt, 240, 244)) nt === 240 && (_e = 144), nt === 244 && (et = 143), j = 3, a = nt - 240;
            else return decoderError$1(o);
            return a = a << 6 * j, null
        }
        if (!inRange$2(nt, _e, et)) return a = j = $ = 0, _e = 128, et = 191, tt.prepend(nt), decoderError$1(o);
        if (_e = 128, et = 191, $ += 1, a += nt - 128 << 6 * (j - $), $ !== j) return null;
        var rt = a;
        return a = j = $ = 0, rt
    }
}

function UTF8Encoder$1(s) {
    s.fatal, this.handler = function(o, a) {
        if (a === end_of_stream$1) return finished$1;
        if (inRange$2(a, 0, 127)) return a;
        var $, j;
        inRange$2(a, 128, 2047) ? ($ = 1, j = 192) : inRange$2(a, 2048, 65535) ? ($ = 2, j = 224) : inRange$2(a, 65536, 1114111) && ($ = 3, j = 240);
        for (var _e = [(a >> 6 * $) + j]; $ > 0;) {
            var et = a >> 6 * ($ - 1);
            _e.push(128 | et & 63), $ -= 1
        }
        return _e
    }
}
const encoding$3 = Object.freeze(Object.defineProperty({
        __proto__: null,
        TextDecoder: TextDecoder$2,
        TextEncoder: TextEncoder$2
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    require$$2$1 = getAugmentedNamespace(encoding$3);
var __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(s, o, a, $) {
        $ === void 0 && ($ = a), Object.defineProperty(s, $, {
            enumerable: !0,
            get: function() {
                return o[a]
            }
        })
    } : function(s, o, a, $) {
        $ === void 0 && ($ = a), s[$] = o[a]
    }),
    __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(s, o) {
        Object.defineProperty(s, "default", {
            enumerable: !0,
            value: o
        })
    } : function(s, o) {
        s.default = o
    }),
    __decorate$1 = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(s, o, a, $) {
        var j = arguments.length,
            _e = j < 3 ? o : $ === null ? $ = Object.getOwnPropertyDescriptor(o, a) : $,
            et;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") _e = Reflect.decorate(s, o, a, $);
        else
            for (var tt = s.length - 1; tt >= 0; tt--)(et = s[tt]) && (_e = (j < 3 ? et(_e) : j > 3 ? et(o, a, _e) : et(o, a)) || _e);
        return j > 3 && _e && Object.defineProperty(o, a, _e), _e
    },
    __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(s) {
        if (s && s.__esModule) return s;
        var o = {};
        if (s != null)
            for (var a in s) a !== "default" && Object.hasOwnProperty.call(s, a) && __createBinding$1(o, s, a);
        return __setModuleDefault$1(o, s), o
    },
    __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(s) {
        return s && s.__esModule ? s : {
            default: s
        }
    };
Object.defineProperty(lib$1, "__esModule", {
    value: !0
});
var deserializeUnchecked_1$1 = lib$1.deserializeUnchecked = deserialize_1$1 = lib$1.deserialize = serialize_1$1 = lib$1.serialize = lib$1.BinaryReader = lib$1.BinaryWriter = lib$1.BorshError = lib$1.baseDecode = lib$1.baseEncode = void 0;
const bn_js_1$1 = __importDefault$1(bnExports$1),
    bs58_1$1 = __importDefault$1(bs58$3),
    encoding$2 = __importStar$1(require$$2$1),
    ResolvedTextDecoder$1 = typeof TextDecoder != "function" ? encoding$2.TextDecoder : TextDecoder,
    textDecoder$1 = new ResolvedTextDecoder$1("utf-8", {
        fatal: !0
    });

function baseEncode$1(s) {
    return typeof s == "string" && (s = Buffer.from(s, "utf8")), bs58_1$1.default.encode(Buffer.from(s))
}
lib$1.baseEncode = baseEncode$1;

function baseDecode$1(s) {
    return Buffer.from(bs58_1$1.default.decode(s))
}
lib$1.baseDecode = baseDecode$1;
const INITIAL_LENGTH$1 = 1024;
let BorshError$1 = class extends Error {
    constructor(o) {
        super(o), this.fieldPath = [], this.originalMessage = o
    }
    addToFieldPath(o) {
        this.fieldPath.splice(0, 0, o), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
    }
};
lib$1.BorshError = BorshError$1;
let BinaryWriter$1 = class {
    constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH$1), this.length = 0
    }
    maybeResize() {
        this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH$1)]))
    }
    writeU8(o) {
        this.maybeResize(), this.buf.writeUInt8(o, this.length), this.length += 1
    }
    writeU16(o) {
        this.maybeResize(), this.buf.writeUInt16LE(o, this.length), this.length += 2
    }
    writeU32(o) {
        this.maybeResize(), this.buf.writeUInt32LE(o, this.length), this.length += 4
    }
    writeU64(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$1.default(o).toArray("le", 8)))
    }
    writeU128(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$1.default(o).toArray("le", 16)))
    }
    writeU256(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$1.default(o).toArray("le", 32)))
    }
    writeU512(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$1.default(o).toArray("le", 64)))
    }
    writeBuffer(o) {
        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), o, Buffer.alloc(INITIAL_LENGTH$1)]), this.length += o.length
    }
    writeString(o) {
        this.maybeResize();
        const a = Buffer.from(o, "utf8");
        this.writeU32(a.length), this.writeBuffer(a)
    }
    writeFixedArray(o) {
        this.writeBuffer(Buffer.from(o))
    }
    writeArray(o, a) {
        this.maybeResize(), this.writeU32(o.length);
        for (const $ of o) this.maybeResize(), a($)
    }
    toArray() {
        return this.buf.subarray(0, this.length)
    }
};
lib$1.BinaryWriter = BinaryWriter$1;

function handlingRangeError$1(s, o, a) {
    const $ = a.value;
    a.value = function(...j) {
        try {
            return $.apply(this, j)
        } catch (_e) {
            if (_e instanceof RangeError) {
                const et = _e.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(et) >= 0) throw new BorshError$1("Reached the end of buffer when deserializing")
            }
            throw _e
        }
    }
}
let BinaryReader$1 = class {
    constructor(o) {
        this.buf = o, this.offset = 0
    }
    readU8() {
        const o = this.buf.readUInt8(this.offset);
        return this.offset += 1, o
    }
    readU16() {
        const o = this.buf.readUInt16LE(this.offset);
        return this.offset += 2, o
    }
    readU32() {
        const o = this.buf.readUInt32LE(this.offset);
        return this.offset += 4, o
    }
    readU64() {
        const o = this.readBuffer(8);
        return new bn_js_1$1.default(o, "le")
    }
    readU128() {
        const o = this.readBuffer(16);
        return new bn_js_1$1.default(o, "le")
    }
    readU256() {
        const o = this.readBuffer(32);
        return new bn_js_1$1.default(o, "le")
    }
    readU512() {
        const o = this.readBuffer(64);
        return new bn_js_1$1.default(o, "le")
    }
    readBuffer(o) {
        if (this.offset + o > this.buf.length) throw new BorshError$1(`Expected buffer length ${o} isn't within bounds`);
        const a = this.buf.slice(this.offset, this.offset + o);
        return this.offset += o, a
    }
    readString() {
        const o = this.readU32(),
            a = this.readBuffer(o);
        try {
            return textDecoder$1.decode(a)
        } catch ($) {
            throw new BorshError$1(`Error decoding UTF-8 string: ${$}`)
        }
    }
    readFixedArray(o) {
        return new Uint8Array(this.readBuffer(o))
    }
    readArray(o) {
        const a = this.readU32(),
            $ = Array();
        for (let j = 0; j < a; ++j) $.push(o());
        return $
    }
};
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readU8", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readU16", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readU32", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readU64", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readU128", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readU256", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readU512", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readString", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readFixedArray", null);
__decorate$1([handlingRangeError$1], BinaryReader$1.prototype, "readArray", null);
lib$1.BinaryReader = BinaryReader$1;

function capitalizeFirstLetter$1(s) {
    return s.charAt(0).toUpperCase() + s.slice(1)
}

function serializeField$1(s, o, a, $, j) {
    try {
        if (typeof $ == "string") j[`write${capitalizeFirstLetter$1($)}`](a);
        else if ($ instanceof Array)
            if (typeof $[0] == "number") {
                if (a.length !== $[0]) throw new BorshError$1(`Expecting byte array of length ${$[0]}, but got ${a.length} bytes`);
                j.writeFixedArray(a)
            } else if ($.length === 2 && typeof $[1] == "number") {
            if (a.length !== $[1]) throw new BorshError$1(`Expecting byte array of length ${$[1]}, but got ${a.length} bytes`);
            for (let _e = 0; _e < $[1]; _e++) serializeField$1(s, null, a[_e], $[0], j)
        } else j.writeArray(a, _e => {
            serializeField$1(s, o, _e, $[0], j)
        });
        else if ($.kind !== void 0) switch ($.kind) {
            case "option":
                {
                    a == null ? j.writeU8(0) : (j.writeU8(1), serializeField$1(s, o, a, $.type, j));
                    break
                }
            case "map":
                {
                    j.writeU32(a.size),
                    a.forEach((_e, et) => {
                        serializeField$1(s, o, et, $.key, j), serializeField$1(s, o, _e, $.value, j)
                    });
                    break
                }
            default:
                throw new BorshError$1(`FieldType ${$} unrecognized`)
        } else serializeStruct$1(s, a, j)
    } catch (_e) {
        throw _e instanceof BorshError$1 && _e.addToFieldPath(o), _e
    }
}

function serializeStruct$1(s, o, a) {
    if (typeof o.borshSerialize == "function") {
        o.borshSerialize(a);
        return
    }
    const $ = s.get(o.constructor);
    if (!$) throw new BorshError$1(`Class ${o.constructor.name} is missing in schema`);
    if ($.kind === "struct") $.fields.map(([j, _e]) => {
        serializeField$1(s, j, o[j], _e, a)
    });
    else if ($.kind === "enum") {
        const j = o[$.field];
        for (let _e = 0; _e < $.values.length; ++_e) {
            const [et, tt] = $.values[_e];
            if (et === j) {
                a.writeU8(_e), serializeField$1(s, et, o[et], tt, a);
                break
            }
        }
    } else throw new BorshError$1(`Unexpected schema kind: ${$.kind} for ${o.constructor.name}`)
}

function serialize$1(s, o, a = BinaryWriter$1) {
    const $ = new a;
    return serializeStruct$1(s, o, $), $.toArray()
}
var serialize_1$1 = lib$1.serialize = serialize$1;

function deserializeField$1(s, o, a, $) {
    try {
        if (typeof a == "string") return $[`read${capitalizeFirstLetter$1(a)}`]();
        if (a instanceof Array) {
            if (typeof a[0] == "number") return $.readFixedArray(a[0]);
            if (typeof a[1] == "number") {
                const j = [];
                for (let _e = 0; _e < a[1]; _e++) j.push(deserializeField$1(s, null, a[0], $));
                return j
            } else return $.readArray(() => deserializeField$1(s, o, a[0], $))
        }
        if (a.kind === "option") return $.readU8() ? deserializeField$1(s, o, a.type, $) : void 0;
        if (a.kind === "map") {
            let j = new Map;
            const _e = $.readU32();
            for (let et = 0; et < _e; et++) {
                const tt = deserializeField$1(s, o, a.key, $),
                    nt = deserializeField$1(s, o, a.value, $);
                j.set(tt, nt)
            }
            return j
        }
        return deserializeStruct$1(s, a, $)
    } catch (j) {
        throw j instanceof BorshError$1 && j.addToFieldPath(o), j
    }
}

function deserializeStruct$1(s, o, a) {
    if (typeof o.borshDeserialize == "function") return o.borshDeserialize(a);
    const $ = s.get(o);
    if (!$) throw new BorshError$1(`Class ${o.name} is missing in schema`);
    if ($.kind === "struct") {
        const j = {};
        for (const [_e, et] of s.get(o).fields) j[_e] = deserializeField$1(s, _e, et, a);
        return new o(j)
    }
    if ($.kind === "enum") {
        const j = a.readU8();
        if (j >= $.values.length) throw new BorshError$1(`Enum index: ${j} is out of range`);
        const [_e, et] = $.values[j], tt = deserializeField$1(s, _e, et, a);
        return new o({
            [_e]: tt
        })
    }
    throw new BorshError$1(`Unexpected schema kind: ${$.kind} for ${o.constructor.name}`)
}

function deserialize$1(s, o, a, $ = BinaryReader$1) {
    const j = new $(a),
        _e = deserializeStruct$1(s, o, j);
    if (j.offset < a.length) throw new BorshError$1(`Unexpected ${a.length-j.offset} bytes after deserialized data`);
    return _e
}
var deserialize_1$1 = lib$1.deserialize = deserialize$1;

function deserializeUnchecked$1(s, o, a, $ = BinaryReader$1) {
    const j = new $(a);
    return deserializeStruct$1(s, o, j)
}
deserializeUnchecked_1$1 = lib$1.deserializeUnchecked = deserializeUnchecked$1;
var Layout$7 = {};
Object.defineProperty(Layout$7, "__esModule", {
    value: !0
});
Layout$7.s16 = Layout$7.s8 = Layout$7.nu64be = Layout$7.u48be = Layout$7.u40be = Layout$7.u32be = Layout$7.u24be = Layout$7.u16be = nu64$2 = Layout$7.nu64 = Layout$7.u48 = Layout$7.u40 = u32$3 = Layout$7.u32 = Layout$7.u24 = u16$1 = Layout$7.u16 = u8$2 = Layout$7.u8 = offset$2 = Layout$7.offset = Layout$7.greedy = Layout$7.Constant = Layout$7.UTF8 = Layout$7.CString = Layout$7.Blob = Layout$7.Boolean = Layout$7.BitField = Layout$7.BitStructure = Layout$7.VariantLayout = Layout$7.Union = Layout$7.UnionLayoutDiscriminator = Layout$7.UnionDiscriminator = Layout$7.Structure = Layout$7.Sequence = Layout$7.DoubleBE = Layout$7.Double = Layout$7.FloatBE = Layout$7.Float = Layout$7.NearInt64BE = Layout$7.NearInt64 = Layout$7.NearUInt64BE = Layout$7.NearUInt64 = Layout$7.IntBE = Layout$7.Int = Layout$7.UIntBE = Layout$7.UInt = Layout$7.OffsetLayout = Layout$7.GreedyCount = Layout$7.ExternalLayout = Layout$7.bindConstructorLayout = Layout$7.nameWithProperty = Layout$7.Layout = Layout$7.uint8ArrayToBuffer = Layout$7.checkUint8Array = void 0;
Layout$7.constant = Layout$7.utf8 = Layout$7.cstr = blob$2 = Layout$7.blob = Layout$7.unionLayoutDiscriminator = Layout$7.union = seq$1 = Layout$7.seq = Layout$7.bits = struct$2 = Layout$7.struct = Layout$7.f64be = Layout$7.f64 = Layout$7.f32be = Layout$7.f32 = Layout$7.ns64be = Layout$7.s48be = Layout$7.s40be = Layout$7.s32be = Layout$7.s24be = Layout$7.s16be = ns64$2 = Layout$7.ns64 = Layout$7.s48 = Layout$7.s40 = Layout$7.s32 = Layout$7.s24 = void 0;
const buffer_1$1 = buffer$1;

function checkUint8Array$1(s) {
    if (!(s instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
}
Layout$7.checkUint8Array = checkUint8Array$1;

function uint8ArrayToBuffer$1(s) {
    return checkUint8Array$1(s), buffer_1$1.Buffer.from(s.buffer, s.byteOffset, s.length)
}
Layout$7.uint8ArrayToBuffer = uint8ArrayToBuffer$1;
let Layout$6 = class {
    constructor(o, a) {
        if (!Number.isInteger(o)) throw new TypeError("span must be an integer");
        this.span = o, this.property = a
    }
    makeDestinationObject() {
        return {}
    }
    getSpan(o, a) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(o) {
        const a = Object.create(this.constructor.prototype);
        return Object.assign(a, this), a.property = o, a
    }
    fromArray(o) {}
};
Layout$7.Layout = Layout$6;

function nameWithProperty$3(s, o) {
    return o.property ? s + "[" + o.property + "]" : s
}
Layout$7.nameWithProperty = nameWithProperty$3;

function bindConstructorLayout$2(s, o) {
    if (typeof s != "function") throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(s, "layout_")) throw new Error("Class is already bound to a layout");
    if (!(o && o instanceof Layout$6)) throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(o, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
    s.layout_ = o, o.boundConstructor_ = s, o.makeDestinationObject = () => new s, Object.defineProperty(s.prototype, "encode", {
        value(a, $) {
            return o.encode(this, a, $)
        },
        writable: !0
    }), Object.defineProperty(s, "decode", {
        value(a, $) {
            return o.decode(a, $)
        },
        writable: !0
    })
}
Layout$7.bindConstructorLayout = bindConstructorLayout$2;
let ExternalLayout$3 = class extends Layout$6 {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
};
Layout$7.ExternalLayout = ExternalLayout$3;
let GreedyCount$2 = class extends ExternalLayout$3 {
    constructor(o = 1, a) {
        if (!Number.isInteger(o) || 0 >= o) throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, a), this.elementSpan = o
    }
    isCount() {
        return !0
    }
    decode(o, a = 0) {
        checkUint8Array$1(o);
        const $ = o.length - a;
        return Math.floor($ / this.elementSpan)
    }
    encode(o, a, $) {
        return 0
    }
};
Layout$7.GreedyCount = GreedyCount$2;
let OffsetLayout$3 = class extends ExternalLayout$3 {
    constructor(o, a = 0, $) {
        if (!(o instanceof Layout$6)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(a)) throw new TypeError("offset must be integer or undefined");
        super(o.span, $ || o.property), this.layout = o, this.offset = a
    }
    isCount() {
        return this.layout instanceof UInt$3 || this.layout instanceof UIntBE$3
    }
    decode(o, a = 0) {
        return this.layout.decode(o, a + this.offset)
    }
    encode(o, a, $ = 0) {
        return this.layout.encode(o, a, $ + this.offset)
    }
};
Layout$7.OffsetLayout = OffsetLayout$3;
let UInt$3 = class extends Layout$6 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readUIntLE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeUIntLE(o, $, this.span), this.span
    }
};
Layout$7.UInt = UInt$3;
let UIntBE$3 = class extends Layout$6 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readUIntBE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeUIntBE(o, $, this.span), this.span
    }
};
Layout$7.UIntBE = UIntBE$3;
let Int$2 = class extends Layout$6 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readIntLE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeIntLE(o, $, this.span), this.span
    }
};
Layout$7.Int = Int$2;
let IntBE$2 = class extends Layout$6 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readIntBE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeIntBE(o, $, this.span), this.span
    }
};
Layout$7.IntBE = IntBE$2;
const V2E32$3 = Math.pow(2, 32);

function divmodInt64$3(s) {
    const o = Math.floor(s / V2E32$3),
        a = s - o * V2E32$3;
    return {
        hi32: o,
        lo32: a
    }
}

function roundedInt64$3(s, o) {
    return s * V2E32$3 + o
}
let NearUInt64$3 = class extends Layout$6 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer$1(o),
            j = $.readUInt32LE(a),
            _e = $.readUInt32LE(a + 4);
        return roundedInt64$3(_e, j)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$3(o),
            _e = uint8ArrayToBuffer$1(a);
        return _e.writeUInt32LE(j.lo32, $), _e.writeUInt32LE(j.hi32, $ + 4), 8
    }
};
Layout$7.NearUInt64 = NearUInt64$3;
let NearUInt64BE$2 = class extends Layout$6 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer$1(o),
            j = $.readUInt32BE(a),
            _e = $.readUInt32BE(a + 4);
        return roundedInt64$3(j, _e)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$3(o),
            _e = uint8ArrayToBuffer$1(a);
        return _e.writeUInt32BE(j.hi32, $), _e.writeUInt32BE(j.lo32, $ + 4), 8
    }
};
Layout$7.NearUInt64BE = NearUInt64BE$2;
let NearInt64$3 = class extends Layout$6 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer$1(o),
            j = $.readUInt32LE(a),
            _e = $.readInt32LE(a + 4);
        return roundedInt64$3(_e, j)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$3(o),
            _e = uint8ArrayToBuffer$1(a);
        return _e.writeUInt32LE(j.lo32, $), _e.writeInt32LE(j.hi32, $ + 4), 8
    }
};
Layout$7.NearInt64 = NearInt64$3;
let NearInt64BE$2 = class extends Layout$6 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer$1(o),
            j = $.readInt32BE(a),
            _e = $.readUInt32BE(a + 4);
        return roundedInt64$3(j, _e)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$3(o),
            _e = uint8ArrayToBuffer$1(a);
        return _e.writeInt32BE(j.hi32, $), _e.writeUInt32BE(j.lo32, $ + 4), 8
    }
};
Layout$7.NearInt64BE = NearInt64BE$2;
let Float$2 = class extends Layout$6 {
    constructor(o) {
        super(4, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readFloatLE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeFloatLE(o, $), 4
    }
};
Layout$7.Float = Float$2;
let FloatBE$2 = class extends Layout$6 {
    constructor(o) {
        super(4, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readFloatBE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeFloatBE(o, $), 4
    }
};
Layout$7.FloatBE = FloatBE$2;
let Double$2 = class extends Layout$6 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readDoubleLE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeDoubleLE(o, $), 8
    }
};
Layout$7.Double = Double$2;
let DoubleBE$2 = class extends Layout$6 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer$1(o).readDoubleBE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer$1(a).writeDoubleBE(o, $), 8
    }
};
Layout$7.DoubleBE = DoubleBE$2;
let Sequence$2 = class extends Layout$6 {
    constructor(o, a, $) {
        if (!(o instanceof Layout$6)) throw new TypeError("elementLayout must be a Layout");
        if (!(a instanceof ExternalLayout$3 && a.isCount() || Number.isInteger(a) && 0 <= a)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let j = -1;
        !(a instanceof ExternalLayout$3) && 0 < o.span && (j = a * o.span), super(j, $), this.elementLayout = o, this.count = a
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        let $ = 0,
            j = this.count;
        if (j instanceof ExternalLayout$3 && (j = j.decode(o, a)), 0 < this.elementLayout.span) $ = j * this.elementLayout.span;
        else {
            let _e = 0;
            for (; _e < j;) $ += this.elementLayout.getSpan(o, a + $), ++_e
        }
        return $
    }
    decode(o, a = 0) {
        const $ = [];
        let j = 0,
            _e = this.count;
        for (_e instanceof ExternalLayout$3 && (_e = _e.decode(o, a)); j < _e;) $.push(this.elementLayout.decode(o, a)), a += this.elementLayout.getSpan(o, a), j += 1;
        return $
    }
    encode(o, a, $ = 0) {
        const j = this.elementLayout,
            _e = o.reduce((et, tt) => et + j.encode(tt, a, $ + et), 0);
        return this.count instanceof ExternalLayout$3 && this.count.encode(o.length, a, $), _e
    }
};
Layout$7.Sequence = Sequence$2;
let Structure$3 = class extends Layout$6 {
    constructor(o, a, $) {
        if (!(Array.isArray(o) && o.reduce((_e, et) => _e && et instanceof Layout$6, !0))) throw new TypeError("fields must be array of Layout instances");
        typeof a == "boolean" && $ === void 0 && ($ = a, a = void 0);
        for (const _e of o)
            if (0 > _e.span && _e.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
        let j = -1;
        try {
            j = o.reduce((_e, et) => _e + et.getSpan(), 0)
        } catch {}
        super(j, a), this.fields = o, this.decodePrefixes = !!$
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        let $ = 0;
        try {
            $ = this.fields.reduce((j, _e) => {
                const et = _e.getSpan(o, a);
                return a += et, j + et
            }, 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return $
    }
    decode(o, a = 0) {
        checkUint8Array$1(o);
        const $ = this.makeDestinationObject();
        for (const j of this.fields)
            if (j.property !== void 0 && ($[j.property] = j.decode(o, a)), a += j.getSpan(o, a), this.decodePrefixes && o.length === a) break;
        return $
    }
    encode(o, a, $ = 0) {
        const j = $;
        let _e = 0,
            et = 0;
        for (const tt of this.fields) {
            let nt = tt.span;
            if (et = 0 < nt ? nt : 0, tt.property !== void 0) {
                const rt = o[tt.property];
                rt !== void 0 && (et = tt.encode(rt, a, $), 0 > nt && (nt = tt.getSpan(a, $)))
            }
            _e = $, $ += nt
        }
        return _e + et - j
    }
    fromArray(o) {
        const a = this.makeDestinationObject();
        for (const $ of this.fields) $.property !== void 0 && 0 < o.length && (a[$.property] = o.shift());
        return a
    }
    layoutFor(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        for (const a of this.fields)
            if (a.property === o) return a
    }
    offsetOf(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        let a = 0;
        for (const $ of this.fields) {
            if ($.property === o) return a;
            0 > $.span ? a = -1 : 0 <= a && (a += $.span)
        }
    }
};
Layout$7.Structure = Structure$3;
let UnionDiscriminator$3 = class {
    constructor(o) {
        this.property = o
    }
    decode(o, a) {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode(o, a, $) {
        throw new Error("UnionDiscriminator is abstract")
    }
};
Layout$7.UnionDiscriminator = UnionDiscriminator$3;
let UnionLayoutDiscriminator$3 = class extends UnionDiscriminator$3 {
    constructor(o, a) {
        if (!(o instanceof ExternalLayout$3 && o.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(a || o.property || "variant"), this.layout = o
    }
    decode(o, a) {
        return this.layout.decode(o, a)
    }
    encode(o, a, $) {
        return this.layout.encode(o, a, $)
    }
};
Layout$7.UnionLayoutDiscriminator = UnionLayoutDiscriminator$3;
let Union$3 = class extends Layout$6 {
    constructor(o, a, $) {
        let j;
        if (o instanceof UInt$3 || o instanceof UIntBE$3) j = new UnionLayoutDiscriminator$3(new OffsetLayout$3(o));
        else if (o instanceof ExternalLayout$3 && o.isCount()) j = new UnionLayoutDiscriminator$3(o);
        else if (o instanceof UnionDiscriminator$3) j = o;
        else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (a === void 0 && (a = null), !(a === null || a instanceof Layout$6)) throw new TypeError("defaultLayout must be null or a Layout");
        if (a !== null) {
            if (0 > a.span) throw new Error("defaultLayout must have constant span");
            a.property === void 0 && (a = a.replicate("content"))
        }
        let _e = -1;
        a && (_e = a.span, 0 <= _e && (o instanceof UInt$3 || o instanceof UIntBE$3) && (_e += j.layout.span)), super(_e, $), this.discriminator = j, this.usesPrefixDiscriminator = o instanceof UInt$3 || o instanceof UIntBE$3, this.defaultLayout = a, this.registry = {};
        let et = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(tt) {
            return et(tt)
        }, this.configGetSourceVariant = function(tt) {
            et = tt.bind(this)
        }
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        const $ = this.getVariant(o, a);
        if (!$) throw new Error("unable to determine span for unrecognized variant");
        return $.getSpan(o, a)
    }
    defaultGetSourceVariant(o) {
        if (Object.prototype.hasOwnProperty.call(o, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(o, this.defaultLayout.property)) return;
            const a = this.registry[o[this.discriminator.property]];
            if (a && (!a.layout || a.property && Object.prototype.hasOwnProperty.call(o, a.property))) return a
        } else
            for (const a in this.registry) {
                const $ = this.registry[a];
                if ($.property && Object.prototype.hasOwnProperty.call(o, $.property)) return $
            }
        throw new Error("unable to infer src variant")
    }
    decode(o, a = 0) {
        let $;
        const j = this.discriminator,
            _e = j.decode(o, a),
            et = this.registry[_e];
        if (et === void 0) {
            const tt = this.defaultLayout;
            let nt = 0;
            this.usesPrefixDiscriminator && (nt = j.layout.span), $ = this.makeDestinationObject(), $[j.property] = _e, $[tt.property] = tt.decode(o, a + nt)
        } else $ = et.decode(o, a);
        return $
    }
    encode(o, a, $ = 0) {
        const j = this.getSourceVariant(o);
        if (j === void 0) {
            const _e = this.discriminator,
                et = this.defaultLayout;
            let tt = 0;
            return this.usesPrefixDiscriminator && (tt = _e.layout.span), _e.encode(o[_e.property], a, $), tt + et.encode(o[et.property], a, $ + tt)
        }
        return j.encode(o, a, $)
    }
    addVariant(o, a, $) {
        const j = new VariantLayout$3(this, o, a, $);
        return this.registry[o] = j, j
    }
    getVariant(o, a = 0) {
        let $;
        return o instanceof Uint8Array ? $ = this.discriminator.decode(o, a) : $ = o, this.registry[$]
    }
};
Layout$7.Union = Union$3;
let VariantLayout$3 = class extends Layout$6 {
    constructor(o, a, $, j) {
        if (!(o instanceof Union$3)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(a) || 0 > a) throw new TypeError("variant must be a (non-negative) integer");
        if (typeof $ == "string" && j === void 0 && (j = $, $ = null), $) {
            if (!($ instanceof Layout$6)) throw new TypeError("layout must be a Layout");
            if (o.defaultLayout !== null && 0 <= $.span && $.span > o.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
            if (typeof j != "string") throw new TypeError("variant must have a String property")
        }
        let _e = o.span;
        0 > o.span && (_e = $ ? $.span : 0, 0 <= _e && o.usesPrefixDiscriminator && (_e += o.discriminator.layout.span)), super(_e, j), this.union = o, this.variant = a, this.layout = $ || null
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        let $ = 0;
        this.union.usesPrefixDiscriminator && ($ = this.union.discriminator.layout.span);
        let j = 0;
        return this.layout && (j = this.layout.getSpan(o, a + $)), $ + j
    }
    decode(o, a = 0) {
        const $ = this.makeDestinationObject();
        if (this !== this.union.getVariant(o, a)) throw new Error("variant mismatch");
        let j = 0;
        return this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout ? $[this.property] = this.layout.decode(o, a + j) : this.property ? $[this.property] = !0 : this.union.usesPrefixDiscriminator && ($[this.union.discriminator.property] = this.variant), $
    }
    encode(o, a, $ = 0) {
        let j = 0;
        if (this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(o, this.property)) throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, a, $);
        let _e = j;
        if (this.layout && (this.layout.encode(o[this.property], a, $ + j), _e += this.layout.getSpan(a, $ + j), 0 <= this.union.span && _e > this.union.span)) throw new Error("encoded variant overruns containing union");
        return _e
    }
    fromArray(o) {
        if (this.layout) return this.layout.fromArray(o)
    }
};
Layout$7.VariantLayout = VariantLayout$3;

function fixBitwiseResult$2(s) {
    return 0 > s && (s += 4294967296), s
}
let BitStructure$2 = class extends Layout$6 {
    constructor(o, a, $) {
        if (!(o instanceof UInt$3 || o instanceof UIntBE$3)) throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof a == "string" && $ === void 0 && ($ = a, a = !1), 4 < o.span) throw new RangeError("word cannot exceed 32 bits");
        super(o.span, $), this.word = o, this.msb = !!a, this.fields = [];
        let j = 0;
        this._packedSetValue = function(_e) {
            return j = fixBitwiseResult$2(_e), this
        }, this._packedGetValue = function() {
            return j
        }
    }
    decode(o, a = 0) {
        const $ = this.makeDestinationObject(),
            j = this.word.decode(o, a);
        this._packedSetValue(j);
        for (const _e of this.fields) _e.property !== void 0 && ($[_e.property] = _e.decode(o));
        return $
    }
    encode(o, a, $ = 0) {
        const j = this.word.decode(a, $);
        this._packedSetValue(j);
        for (const _e of this.fields)
            if (_e.property !== void 0) {
                const et = o[_e.property];
                et !== void 0 && _e.encode(et)
            }
        return this.word.encode(this._packedGetValue(), a, $)
    }
    addField(o, a) {
        const $ = new BitField$2(this, o, a);
        return this.fields.push($), $
    }
    addBoolean(o) {
        const a = new Boolean$3(this, o);
        return this.fields.push(a), a
    }
    fieldFor(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        for (const a of this.fields)
            if (a.property === o) return a
    }
};
Layout$7.BitStructure = BitStructure$2;
let BitField$2 = class {
    constructor(o, a, $) {
        if (!(o instanceof BitStructure$2)) throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(a) || 0 >= a) throw new TypeError("bits must be positive integer");
        const j = 8 * o.span,
            _e = o.fields.reduce((et, tt) => et + tt.bits, 0);
        if (a + _e > j) throw new Error("bits too long for span remainder (" + (j - _e) + " of " + j + " remain)");
        this.container = o, this.bits = a, this.valueMask = (1 << a) - 1, a === 32 && (this.valueMask = 4294967295), this.start = _e, this.container.msb && (this.start = j - _e - a), this.wordMask = fixBitwiseResult$2(this.valueMask << this.start), this.property = $
    }
    decode(o, a) {
        const $ = this.container._packedGetValue();
        return fixBitwiseResult$2($ & this.wordMask) >>> this.start
    }
    encode(o) {
        if (typeof o != "number" || !Number.isInteger(o) || o !== fixBitwiseResult$2(o & this.valueMask)) throw new TypeError(nameWithProperty$3("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const a = this.container._packedGetValue(),
            $ = fixBitwiseResult$2(o << this.start);
        this.container._packedSetValue(fixBitwiseResult$2(a & ~this.wordMask) | $)
    }
};
Layout$7.BitField = BitField$2;
let Boolean$3 = class extends BitField$2 {
    constructor(o, a) {
        super(o, 1, a)
    }
    decode(o, a) {
        return !!super.decode(o, a)
    }
    encode(o) {
        typeof o == "boolean" && (o = +o), super.encode(o)
    }
};
Layout$7.Boolean = Boolean$3;
let Blob$4 = class extends Layout$6 {
    constructor(o, a) {
        if (!(o instanceof ExternalLayout$3 && o.isCount() || Number.isInteger(o) && 0 <= o)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let $ = -1;
        o instanceof ExternalLayout$3 || ($ = o), super($, a), this.length = o
    }
    getSpan(o, a) {
        let $ = this.span;
        return 0 > $ && ($ = this.length.decode(o, a)), $
    }
    decode(o, a = 0) {
        let $ = this.span;
        return 0 > $ && ($ = this.length.decode(o, a)), uint8ArrayToBuffer$1(o).slice(a, a + $)
    }
    encode(o, a, $) {
        let j = this.length;
        if (this.length instanceof ExternalLayout$3 && (j = o.length), !(o instanceof Uint8Array && j === o.length)) throw new TypeError(nameWithProperty$3("Blob.encode", this) + " requires (length " + j + ") Uint8Array as src");
        if ($ + j > a.length) throw new RangeError("encoding overruns Uint8Array");
        const _e = uint8ArrayToBuffer$1(o);
        return uint8ArrayToBuffer$1(a).write(_e.toString("hex"), $, j, "hex"), this.length instanceof ExternalLayout$3 && this.length.encode(j, a, $), j
    }
};
Layout$7.Blob = Blob$4;
let CString$2 = class extends Layout$6 {
    constructor(o) {
        super(-1, o)
    }
    getSpan(o, a = 0) {
        checkUint8Array$1(o);
        let $ = a;
        for (; $ < o.length && o[$] !== 0;) $ += 1;
        return 1 + $ - a
    }
    decode(o, a = 0) {
        const $ = this.getSpan(o, a);
        return uint8ArrayToBuffer$1(o).slice(a, a + $ - 1).toString("utf-8")
    }
    encode(o, a, $ = 0) {
        typeof o != "string" && (o = String(o));
        const j = buffer_1$1.Buffer.from(o, "utf8"),
            _e = j.length;
        if ($ + _e > a.length) throw new RangeError("encoding overruns Buffer");
        const et = uint8ArrayToBuffer$1(a);
        return j.copy(et, $), et[$ + _e] = 0, _e + 1
    }
};
Layout$7.CString = CString$2;
let UTF8$2 = class extends Layout$6 {
    constructor(o, a) {
        if (typeof o == "string" && a === void 0 && (a = o, o = void 0), o === void 0) o = -1;
        else if (!Number.isInteger(o)) throw new TypeError("maxSpan must be an integer");
        super(-1, a), this.maxSpan = o
    }
    getSpan(o, a = 0) {
        return checkUint8Array$1(o), o.length - a
    }
    decode(o, a = 0) {
        const $ = this.getSpan(o, a);
        if (0 <= this.maxSpan && this.maxSpan < $) throw new RangeError("text length exceeds maxSpan");
        return uint8ArrayToBuffer$1(o).slice(a, a + $).toString("utf-8")
    }
    encode(o, a, $ = 0) {
        typeof o != "string" && (o = String(o));
        const j = buffer_1$1.Buffer.from(o, "utf8"),
            _e = j.length;
        if (0 <= this.maxSpan && this.maxSpan < _e) throw new RangeError("text length exceeds maxSpan");
        if ($ + _e > a.length) throw new RangeError("encoding overruns Buffer");
        return j.copy(uint8ArrayToBuffer$1(a), $), _e
    }
};
Layout$7.UTF8 = UTF8$2;
let Constant$2 = class extends Layout$6 {
    constructor(o, a) {
        super(0, a), this.value = o
    }
    decode(o, a) {
        return this.value
    }
    encode(o, a, $) {
        return 0
    }
};
Layout$7.Constant = Constant$2;
Layout$7.greedy = (s, o) => new GreedyCount$2(s, o);
var offset$2 = Layout$7.offset = (s, o, a) => new OffsetLayout$3(s, o, a),
    u8$2 = Layout$7.u8 = s => new UInt$3(1, s),
    u16$1 = Layout$7.u16 = s => new UInt$3(2, s);
Layout$7.u24 = s => new UInt$3(3, s);
var u32$3 = Layout$7.u32 = s => new UInt$3(4, s);
Layout$7.u40 = s => new UInt$3(5, s);
Layout$7.u48 = s => new UInt$3(6, s);
var nu64$2 = Layout$7.nu64 = s => new NearUInt64$3(s);
Layout$7.u16be = s => new UIntBE$3(2, s);
Layout$7.u24be = s => new UIntBE$3(3, s);
Layout$7.u32be = s => new UIntBE$3(4, s);
Layout$7.u40be = s => new UIntBE$3(5, s);
Layout$7.u48be = s => new UIntBE$3(6, s);
Layout$7.nu64be = s => new NearUInt64BE$2(s);
Layout$7.s8 = s => new Int$2(1, s);
Layout$7.s16 = s => new Int$2(2, s);
Layout$7.s24 = s => new Int$2(3, s);
Layout$7.s32 = s => new Int$2(4, s);
Layout$7.s40 = s => new Int$2(5, s);
Layout$7.s48 = s => new Int$2(6, s);
var ns64$2 = Layout$7.ns64 = s => new NearInt64$3(s);
Layout$7.s16be = s => new IntBE$2(2, s);
Layout$7.s24be = s => new IntBE$2(3, s);
Layout$7.s32be = s => new IntBE$2(4, s);
Layout$7.s40be = s => new IntBE$2(5, s);
Layout$7.s48be = s => new IntBE$2(6, s);
Layout$7.ns64be = s => new NearInt64BE$2(s);
Layout$7.f32 = s => new Float$2(s);
Layout$7.f32be = s => new FloatBE$2(s);
Layout$7.f64 = s => new Double$2(s);
Layout$7.f64be = s => new DoubleBE$2(s);
var struct$2 = Layout$7.struct = (s, o, a) => new Structure$3(s, o, a);
Layout$7.bits = (s, o, a) => new BitStructure$2(s, o, a);
var seq$1 = Layout$7.seq = (s, o, a) => new Sequence$2(s, o, a);
Layout$7.union = (s, o, a) => new Union$3(s, o, a);
Layout$7.unionLayoutDiscriminator = (s, o) => new UnionLayoutDiscriminator$3(s, o);
var blob$2 = Layout$7.blob = (s, o) => new Blob$4(s, o);
Layout$7.cstr = s => new CString$2(s);
Layout$7.utf8 = (s, o) => new UTF8$2(s, o);
Layout$7.constant = (s, o) => new Constant$2(s, o);
var browser$4 = {};
Object.defineProperty(browser$4, "__esModule", {
    value: !0
});

function toBigIntLE$1(s) {
    {
        const o = Buffer.from(s);
        o.reverse();
        const a = o.toString("hex");
        return a.length === 0 ? BigInt(0) : BigInt(`0x${a}`)
    }
}
var toBigIntLE_1$1 = browser$4.toBigIntLE = toBigIntLE$1;

function toBigIntBE$1(s) {
    {
        const o = s.toString("hex");
        return o.length === 0 ? BigInt(0) : BigInt(`0x${o}`)
    }
}
browser$4.toBigIntBE = toBigIntBE$1;

function toBufferLE$1(s, o) {
    {
        const a = s.toString(16),
            $ = Buffer.from(a.padStart(o * 2, "0").slice(0, o * 2), "hex");
        return $.reverse(), $
    }
}
var toBufferLE_1$1 = browser$4.toBufferLE = toBufferLE$1;

function toBufferBE$1(s, o) {
    {
        const a = s.toString(16);
        return Buffer.from(a.padStart(o * 2, "0").slice(0, o * 2), "hex")
    }
}
browser$4.toBufferBE = toBufferBE$1;
let StructError$2 = class extends TypeError {
    constructor(o, a) {
        let $;
        const {
            message: j,
            explanation: _e,
            ...et
        } = o, {
            path: tt
        } = o, nt = tt.length === 0 ? j : `At path: ${tt.join(".")} -- ${j}`;
        super(_e ? ? nt), _e != null && (this.cause = nt), Object.assign(this, et), this.name = this.constructor.name, this.failures = () => $ ? ? ($ = [o, ...a()])
    }
};

function isIterable$2(s) {
    return isObject$2(s) && typeof s[Symbol.iterator] == "function"
}

function isObject$2(s) {
    return typeof s == "object" && s != null
}

function isNonArrayObject$1(s) {
    return isObject$2(s) && !Array.isArray(s)
}

function print$2(s) {
    return typeof s == "symbol" ? s.toString() : typeof s == "string" ? JSON.stringify(s) : `${s}`
}

function shiftIterator$2(s) {
    const {
        done: o,
        value: a
    } = s.next();
    return o ? void 0 : a
}

function toFailure$2(s, o, a, $) {
    if (s === !0) return;
    s === !1 ? s = {} : typeof s == "string" && (s = {
        message: s
    });
    const {
        path: j,
        branch: _e
    } = o, {
        type: et
    } = a, {
        refinement: tt,
        message: nt = `Expected a value of type \`${et}\`${tt?` with refinement \`${tt}\``:""}, but received: \`${print$2($)}\``
    } = s;
    return {
        value: $,
        type: et,
        refinement: tt,
        key: j[j.length - 1],
        path: j,
        branch: _e,
        ...s,
        message: nt
    }
}

function* toFailures$2(s, o, a, $) {
    isIterable$2(s) || (s = [s]);
    for (const j of s) {
        const _e = toFailure$2(j, o, a, $);
        _e && (yield _e)
    }
}

function* run$2(s, o, a = {}) {
    const {
        path: $ = [],
        branch: j = [s],
        coerce: _e = !1,
        mask: et = !1
    } = a, tt = {
        path: $,
        branch: j,
        mask: et
    };
    _e && (s = o.coercer(s, tt));
    let nt = "valid";
    for (const rt of o.validator(s, tt)) rt.explanation = a.message, nt = "not_valid", yield [rt, void 0];
    for (let [rt, ot, st] of o.entries(s, tt)) {
        const lt = run$2(ot, st, {
            path: rt === void 0 ? $ : [...$, rt],
            branch: rt === void 0 ? j : [...j, ot],
            coerce: _e,
            mask: et,
            message: a.message
        });
        for (const ft of lt) ft[0] ? (nt = ft[0].refinement != null ? "not_refined" : "not_valid", yield [ft[0], void 0]) : _e && (ot = ft[1], rt === void 0 ? s = ot : s instanceof Map ? s.set(rt, ot) : s instanceof Set ? s.add(ot) : isObject$2(s) && (ot !== void 0 || rt in s) && (s[rt] = ot))
    }
    if (nt !== "not_valid")
        for (const rt of o.refiner(s, tt)) rt.explanation = a.message, nt = "not_refined", yield [rt, void 0];
    nt === "valid" && (yield [void 0, s])
}
let Struct$4 = class {
    constructor(o) {
        const {
            type: a,
            schema: $,
            validator: j,
            refiner: _e,
            coercer: et = nt => nt,
            entries: tt = function*() {}
        } = o;
        this.type = a, this.schema = $, this.entries = tt, this.coercer = et, j ? this.validator = (nt, rt) => {
            const ot = j(nt, rt);
            return toFailures$2(ot, rt, this, nt)
        } : this.validator = () => [], _e ? this.refiner = (nt, rt) => {
            const ot = _e(nt, rt);
            return toFailures$2(ot, rt, this, nt)
        } : this.refiner = () => []
    }
    assert(o, a) {
        return assert$5(o, this, a)
    }
    create(o, a) {
        return create$2(o, this, a)
    }
    is(o) {
        return is$2(o, this)
    }
    mask(o, a) {
        return mask$2(o, this, a)
    }
    validate(o, a = {}) {
        return validate$4(o, this, a)
    }
};

function assert$5(s, o, a) {
    const $ = validate$4(s, o, {
        message: a
    });
    if ($[0]) throw $[0]
}

function create$2(s, o, a) {
    const $ = validate$4(s, o, {
        coerce: !0,
        message: a
    });
    if ($[0]) throw $[0];
    return $[1]
}

function mask$2(s, o, a) {
    const $ = validate$4(s, o, {
        coerce: !0,
        mask: !0,
        message: a
    });
    if ($[0]) throw $[0];
    return $[1]
}

function is$2(s, o) {
    return !validate$4(s, o)[0]
}

function validate$4(s, o, a = {}) {
    const $ = run$2(s, o, a),
        j = shiftIterator$2($);
    return j[0] ? [new StructError$2(j[0], function*() {
        for (const et of $) et[0] && (yield et[0])
    }), void 0] : [void 0, j[1]]
}

function define$3(s, o) {
    return new Struct$4({
        type: s,
        schema: null,
        validator: o
    })
}

function any$2() {
    return define$3("any", () => !0)
}

function array$2(s) {
    return new Struct$4({
        type: "array",
        schema: s,
        * entries(o) {
            if (s && Array.isArray(o))
                for (const [a, $] of o.entries()) yield [a, $, s]
        },
        coercer(o) {
            return Array.isArray(o) ? o.slice() : o
        },
        validator(o) {
            return Array.isArray(o) || `Expected an array value, but received: ${print$2(o)}`
        }
    })
}

function boolean$2() {
    return define$3("boolean", s => typeof s == "boolean")
}

function instance$1(s) {
    return define$3("instance", o => o instanceof s || `Expected a \`${s.name}\` instance, but received: ${print$2(o)}`)
}

function literal$2(s) {
    const o = print$2(s),
        a = typeof s;
    return new Struct$4({
        type: "literal",
        schema: a === "string" || a === "number" || a === "boolean" ? s : null,
        validator($) {
            return $ === s || `Expected the literal \`${o}\`, but received: ${print$2($)}`
        }
    })
}

function never$1() {
    return define$3("never", () => !1)
}

function nullable$2(s) {
    return new Struct$4({ ...s,
        validator: (o, a) => o === null || s.validator(o, a),
        refiner: (o, a) => o === null || s.refiner(o, a)
    })
}

function number$3() {
    return define$3("number", s => typeof s == "number" && !isNaN(s) || `Expected a number, but received: ${print$2(s)}`)
}

function optional$2(s) {
    return new Struct$4({ ...s,
        validator: (o, a) => o === void 0 || s.validator(o, a),
        refiner: (o, a) => o === void 0 || s.refiner(o, a)
    })
}

function record$1(s, o) {
    return new Struct$4({
        type: "record",
        schema: null,
        * entries(a) {
            if (isObject$2(a))
                for (const $ in a) {
                    const j = a[$];
                    yield [$, $, s], yield [$, j, o]
                }
        },
        validator(a) {
            return isNonArrayObject$1(a) || `Expected an object, but received: ${print$2(a)}`
        },
        coercer(a) {
            return isNonArrayObject$1(a) ? { ...a
            } : a
        }
    })
}

function string$2() {
    return define$3("string", s => typeof s == "string" || `Expected a string, but received: ${print$2(s)}`)
}

function tuple$1(s) {
    const o = never$1();
    return new Struct$4({
        type: "tuple",
        schema: null,
        * entries(a) {
            if (Array.isArray(a)) {
                const $ = Math.max(s.length, a.length);
                for (let j = 0; j < $; j++) yield [j, a[j], s[j] || o]
            }
        },
        validator(a) {
            return Array.isArray(a) || `Expected an array, but received: ${print$2(a)}`
        },
        coercer(a) {
            return Array.isArray(a) ? a.slice() : a
        }
    })
}

function type$3(s) {
    const o = Object.keys(s);
    return new Struct$4({
        type: "type",
        schema: s,
        * entries(a) {
            if (isObject$2(a))
                for (const $ of o) yield [$, a[$], s[$]]
        },
        validator(a) {
            return isNonArrayObject$1(a) || `Expected an object, but received: ${print$2(a)}`
        },
        coercer(a) {
            return isNonArrayObject$1(a) ? { ...a
            } : a
        }
    })
}

function union$3(s) {
    const o = s.map(a => a.type).join(" | ");
    return new Struct$4({
        type: "union",
        schema: null,
        coercer(a, $) {
            for (const j of s) {
                const [_e, et] = j.validate(a, {
                    coerce: !0,
                    mask: $.mask
                });
                if (!_e) return et
            }
            return a
        },
        validator(a, $) {
            const j = [];
            for (const _e of s) {
                const [...et] = run$2(a, _e, $), [tt] = et;
                if (tt[0])
                    for (const [nt] of et) nt && j.push(nt);
                else return []
            }
            return [`Expected the value to satisfy a union of \`${o}\`, but received: ${print$2(a)}`, ...j]
        }
    })
}

function unknown$2() {
    return define$3("unknown", () => !0)
}

function coerce$2(s, o, a) {
    return new Struct$4({ ...s,
        coercer: ($, j) => is$2($, o) ? s.coercer(a($, j), j) : s.coercer($, j)
    })
}
var getRandomValues$1, rnds8$1 = new Uint8Array(16);

function rng$1() {
    if (!getRandomValues$1 && (getRandomValues$1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues$1)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return getRandomValues$1(rnds8$1)
}
const REGEX$1 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate$3(s) {
    return typeof s == "string" && REGEX$1.test(s)
}
var byteToHex$1 = [];
for (var i$2 = 0; i$2 < 256; ++i$2) byteToHex$1.push((i$2 + 256).toString(16).substr(1));

function stringify$3(s) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        a = (byteToHex$1[s[o + 0]] + byteToHex$1[s[o + 1]] + byteToHex$1[s[o + 2]] + byteToHex$1[s[o + 3]] + "-" + byteToHex$1[s[o + 4]] + byteToHex$1[s[o + 5]] + "-" + byteToHex$1[s[o + 6]] + byteToHex$1[s[o + 7]] + "-" + byteToHex$1[s[o + 8]] + byteToHex$1[s[o + 9]] + "-" + byteToHex$1[s[o + 10]] + byteToHex$1[s[o + 11]] + byteToHex$1[s[o + 12]] + byteToHex$1[s[o + 13]] + byteToHex$1[s[o + 14]] + byteToHex$1[s[o + 15]]).toLowerCase();
    if (!validate$3(a)) throw TypeError("Stringified UUID is invalid");
    return a
}
var _nodeId$1, _clockseq$1, _lastMSecs$1 = 0,
    _lastNSecs$1 = 0;

function v1$1(s, o, a) {
    var $ = o && a || 0,
        j = o || new Array(16);
    s = s || {};
    var _e = s.node || _nodeId$1,
        et = s.clockseq !== void 0 ? s.clockseq : _clockseq$1;
    if (_e == null || et == null) {
        var tt = s.random || (s.rng || rng$1)();
        _e == null && (_e = _nodeId$1 = [tt[0] | 1, tt[1], tt[2], tt[3], tt[4], tt[5]]), et == null && (et = _clockseq$1 = (tt[6] << 8 | tt[7]) & 16383)
    }
    var nt = s.msecs !== void 0 ? s.msecs : Date.now(),
        rt = s.nsecs !== void 0 ? s.nsecs : _lastNSecs$1 + 1,
        ot = nt - _lastMSecs$1 + (rt - _lastNSecs$1) / 1e4;
    if (ot < 0 && s.clockseq === void 0 && (et = et + 1 & 16383), (ot < 0 || nt > _lastMSecs$1) && s.nsecs === void 0 && (rt = 0), rt >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs$1 = nt, _lastNSecs$1 = rt, _clockseq$1 = et, nt += 122192928e5;
    var st = ((nt & 268435455) * 1e4 + rt) % 4294967296;
    j[$++] = st >>> 24 & 255, j[$++] = st >>> 16 & 255, j[$++] = st >>> 8 & 255, j[$++] = st & 255;
    var lt = nt / 4294967296 * 1e4 & 268435455;
    j[$++] = lt >>> 8 & 255, j[$++] = lt & 255, j[$++] = lt >>> 24 & 15 | 16, j[$++] = lt >>> 16 & 255, j[$++] = et >>> 8 | 128, j[$++] = et & 255;
    for (var ft = 0; ft < 6; ++ft) j[$ + ft] = _e[ft];
    return o || stringify$3(j)
}

function parse$1(s) {
    if (!validate$3(s)) throw TypeError("Invalid UUID");
    var o, a = new Uint8Array(16);
    return a[0] = (o = parseInt(s.slice(0, 8), 16)) >>> 24, a[1] = o >>> 16 & 255, a[2] = o >>> 8 & 255, a[3] = o & 255, a[4] = (o = parseInt(s.slice(9, 13), 16)) >>> 8, a[5] = o & 255, a[6] = (o = parseInt(s.slice(14, 18), 16)) >>> 8, a[7] = o & 255, a[8] = (o = parseInt(s.slice(19, 23), 16)) >>> 8, a[9] = o & 255, a[10] = (o = parseInt(s.slice(24, 36), 16)) / 1099511627776 & 255, a[11] = o / 4294967296 & 255, a[12] = o >>> 24 & 255, a[13] = o >>> 16 & 255, a[14] = o >>> 8 & 255, a[15] = o & 255, a
}

function stringToBytes$1(s) {
    s = unescape(encodeURIComponent(s));
    for (var o = [], a = 0; a < s.length; ++a) o.push(s.charCodeAt(a));
    return o
}
var DNS$1 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    URL$2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";

function v35$1(s, o, a) {
    function $(j, _e, et, tt) {
        if (typeof j == "string" && (j = stringToBytes$1(j)), typeof _e == "string" && (_e = parse$1(_e)), _e.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var nt = new Uint8Array(16 + j.length);
        if (nt.set(_e), nt.set(j, _e.length), nt = a(nt), nt[6] = nt[6] & 15 | o, nt[8] = nt[8] & 63 | 128, et) {
            tt = tt || 0;
            for (var rt = 0; rt < 16; ++rt) et[tt + rt] = nt[rt];
            return et
        }
        return stringify$3(nt)
    }
    try {
        $.name = s
    } catch {}
    return $.DNS = DNS$1, $.URL = URL$2, $
}

function md5$1(s) {
    if (typeof s == "string") {
        var o = unescape(encodeURIComponent(s));
        s = new Uint8Array(o.length);
        for (var a = 0; a < o.length; ++a) s[a] = o.charCodeAt(a)
    }
    return md5ToHexEncodedArray$1(wordsToMd5$1(bytesToWords$1(s), s.length * 8))
}

function md5ToHexEncodedArray$1(s) {
    for (var o = [], a = s.length * 32, $ = "0123456789abcdef", j = 0; j < a; j += 8) {
        var _e = s[j >> 5] >>> j % 32 & 255,
            et = parseInt($.charAt(_e >>> 4 & 15) + $.charAt(_e & 15), 16);
        o.push(et)
    }
    return o
}

function getOutputLength$1(s) {
    return (s + 64 >>> 9 << 4) + 14 + 1
}

function wordsToMd5$1(s, o) {
    s[o >> 5] |= 128 << o % 32, s[getOutputLength$1(o) - 1] = o;
    for (var a = 1732584193, $ = -271733879, j = -1732584194, _e = 271733878, et = 0; et < s.length; et += 16) {
        var tt = a,
            nt = $,
            rt = j,
            ot = _e;
        a = md5ff$1(a, $, j, _e, s[et], 7, -680876936), _e = md5ff$1(_e, a, $, j, s[et + 1], 12, -389564586), j = md5ff$1(j, _e, a, $, s[et + 2], 17, 606105819), $ = md5ff$1($, j, _e, a, s[et + 3], 22, -1044525330), a = md5ff$1(a, $, j, _e, s[et + 4], 7, -176418897), _e = md5ff$1(_e, a, $, j, s[et + 5], 12, 1200080426), j = md5ff$1(j, _e, a, $, s[et + 6], 17, -1473231341), $ = md5ff$1($, j, _e, a, s[et + 7], 22, -45705983), a = md5ff$1(a, $, j, _e, s[et + 8], 7, 1770035416), _e = md5ff$1(_e, a, $, j, s[et + 9], 12, -1958414417), j = md5ff$1(j, _e, a, $, s[et + 10], 17, -42063), $ = md5ff$1($, j, _e, a, s[et + 11], 22, -1990404162), a = md5ff$1(a, $, j, _e, s[et + 12], 7, 1804603682), _e = md5ff$1(_e, a, $, j, s[et + 13], 12, -40341101), j = md5ff$1(j, _e, a, $, s[et + 14], 17, -1502002290), $ = md5ff$1($, j, _e, a, s[et + 15], 22, 1236535329), a = md5gg$1(a, $, j, _e, s[et + 1], 5, -165796510), _e = md5gg$1(_e, a, $, j, s[et + 6], 9, -1069501632), j = md5gg$1(j, _e, a, $, s[et + 11], 14, 643717713), $ = md5gg$1($, j, _e, a, s[et], 20, -373897302), a = md5gg$1(a, $, j, _e, s[et + 5], 5, -701558691), _e = md5gg$1(_e, a, $, j, s[et + 10], 9, 38016083), j = md5gg$1(j, _e, a, $, s[et + 15], 14, -660478335), $ = md5gg$1($, j, _e, a, s[et + 4], 20, -405537848), a = md5gg$1(a, $, j, _e, s[et + 9], 5, 568446438), _e = md5gg$1(_e, a, $, j, s[et + 14], 9, -1019803690), j = md5gg$1(j, _e, a, $, s[et + 3], 14, -187363961), $ = md5gg$1($, j, _e, a, s[et + 8], 20, 1163531501), a = md5gg$1(a, $, j, _e, s[et + 13], 5, -1444681467), _e = md5gg$1(_e, a, $, j, s[et + 2], 9, -51403784), j = md5gg$1(j, _e, a, $, s[et + 7], 14, 1735328473), $ = md5gg$1($, j, _e, a, s[et + 12], 20, -1926607734), a = md5hh$1(a, $, j, _e, s[et + 5], 4, -378558), _e = md5hh$1(_e, a, $, j, s[et + 8], 11, -2022574463), j = md5hh$1(j, _e, a, $, s[et + 11], 16, 1839030562), $ = md5hh$1($, j, _e, a, s[et + 14], 23, -35309556), a = md5hh$1(a, $, j, _e, s[et + 1], 4, -1530992060), _e = md5hh$1(_e, a, $, j, s[et + 4], 11, 1272893353), j = md5hh$1(j, _e, a, $, s[et + 7], 16, -155497632), $ = md5hh$1($, j, _e, a, s[et + 10], 23, -1094730640), a = md5hh$1(a, $, j, _e, s[et + 13], 4, 681279174), _e = md5hh$1(_e, a, $, j, s[et], 11, -358537222), j = md5hh$1(j, _e, a, $, s[et + 3], 16, -722521979), $ = md5hh$1($, j, _e, a, s[et + 6], 23, 76029189), a = md5hh$1(a, $, j, _e, s[et + 9], 4, -640364487), _e = md5hh$1(_e, a, $, j, s[et + 12], 11, -421815835), j = md5hh$1(j, _e, a, $, s[et + 15], 16, 530742520), $ = md5hh$1($, j, _e, a, s[et + 2], 23, -995338651), a = md5ii$1(a, $, j, _e, s[et], 6, -198630844), _e = md5ii$1(_e, a, $, j, s[et + 7], 10, 1126891415), j = md5ii$1(j, _e, a, $, s[et + 14], 15, -1416354905), $ = md5ii$1($, j, _e, a, s[et + 5], 21, -57434055), a = md5ii$1(a, $, j, _e, s[et + 12], 6, 1700485571), _e = md5ii$1(_e, a, $, j, s[et + 3], 10, -1894986606), j = md5ii$1(j, _e, a, $, s[et + 10], 15, -1051523), $ = md5ii$1($, j, _e, a, s[et + 1], 21, -2054922799), a = md5ii$1(a, $, j, _e, s[et + 8], 6, 1873313359), _e = md5ii$1(_e, a, $, j, s[et + 15], 10, -30611744), j = md5ii$1(j, _e, a, $, s[et + 6], 15, -1560198380), $ = md5ii$1($, j, _e, a, s[et + 13], 21, 1309151649), a = md5ii$1(a, $, j, _e, s[et + 4], 6, -145523070), _e = md5ii$1(_e, a, $, j, s[et + 11], 10, -1120210379), j = md5ii$1(j, _e, a, $, s[et + 2], 15, 718787259), $ = md5ii$1($, j, _e, a, s[et + 9], 21, -343485551), a = safeAdd$1(a, tt), $ = safeAdd$1($, nt), j = safeAdd$1(j, rt), _e = safeAdd$1(_e, ot)
    }
    return [a, $, j, _e]
}

function bytesToWords$1(s) {
    if (s.length === 0) return [];
    for (var o = s.length * 8, a = new Uint32Array(getOutputLength$1(o)), $ = 0; $ < o; $ += 8) a[$ >> 5] |= (s[$ / 8] & 255) << $ % 32;
    return a
}

function safeAdd$1(s, o) {
    var a = (s & 65535) + (o & 65535),
        $ = (s >> 16) + (o >> 16) + (a >> 16);
    return $ << 16 | a & 65535
}

function bitRotateLeft$1(s, o) {
    return s << o | s >>> 32 - o
}

function md5cmn$1(s, o, a, $, j, _e) {
    return safeAdd$1(bitRotateLeft$1(safeAdd$1(safeAdd$1(o, s), safeAdd$1($, _e)), j), a)
}

function md5ff$1(s, o, a, $, j, _e, et) {
    return md5cmn$1(o & a | ~o & $, s, o, j, _e, et)
}

function md5gg$1(s, o, a, $, j, _e, et) {
    return md5cmn$1(o & $ | a & ~$, s, o, j, _e, et)
}

function md5hh$1(s, o, a, $, j, _e, et) {
    return md5cmn$1(o ^ a ^ $, s, o, j, _e, et)
}

function md5ii$1(s, o, a, $, j, _e, et) {
    return md5cmn$1(a ^ (o | ~$), s, o, j, _e, et)
}
var v3$2 = v35$1("v3", 48, md5$1);
const v3$3 = v3$2;

function v4$1(s, o, a) {
    s = s || {};
    var $ = s.random || (s.rng || rng$1)();
    if ($[6] = $[6] & 15 | 64, $[8] = $[8] & 63 | 128, o) {
        a = a || 0;
        for (var j = 0; j < 16; ++j) o[a + j] = $[j];
        return o
    }
    return stringify$3($)
}

function f$1(s, o, a, $) {
    switch (s) {
        case 0:
            return o & a ^ ~o & $;
        case 1:
            return o ^ a ^ $;
        case 2:
            return o & a ^ o & $ ^ a & $;
        case 3:
            return o ^ a ^ $
    }
}

function ROTL$1(s, o) {
    return s << o | s >>> 32 - o
}

function sha1$1(s) {
    var o = [1518500249, 1859775393, 2400959708, 3395469782],
        a = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof s == "string") {
        var $ = unescape(encodeURIComponent(s));
        s = [];
        for (var j = 0; j < $.length; ++j) s.push($.charCodeAt(j))
    } else Array.isArray(s) || (s = Array.prototype.slice.call(s));
    s.push(128);
    for (var _e = s.length / 4 + 2, et = Math.ceil(_e / 16), tt = new Array(et), nt = 0; nt < et; ++nt) {
        for (var rt = new Uint32Array(16), ot = 0; ot < 16; ++ot) rt[ot] = s[nt * 64 + ot * 4] << 24 | s[nt * 64 + ot * 4 + 1] << 16 | s[nt * 64 + ot * 4 + 2] << 8 | s[nt * 64 + ot * 4 + 3];
        tt[nt] = rt
    }
    tt[et - 1][14] = (s.length - 1) * 8 / Math.pow(2, 32), tt[et - 1][14] = Math.floor(tt[et - 1][14]), tt[et - 1][15] = (s.length - 1) * 8 & 4294967295;
    for (var st = 0; st < et; ++st) {
        for (var lt = new Uint32Array(80), ft = 0; ft < 16; ++ft) lt[ft] = tt[st][ft];
        for (var yt = 16; yt < 80; ++yt) lt[yt] = ROTL$1(lt[yt - 3] ^ lt[yt - 8] ^ lt[yt - 14] ^ lt[yt - 16], 1);
        for (var bt = a[0], ht = a[1], vt = a[2], wt = a[3], gt = a[4], At = 0; At < 80; ++At) {
            var Pt = Math.floor(At / 20),
                Bt = ROTL$1(bt, 5) + f$1(Pt, ht, vt, wt) + gt + o[Pt] + lt[At] >>> 0;
            gt = wt, wt = vt, vt = ROTL$1(ht, 30) >>> 0, ht = bt, bt = Bt
        }
        a[0] = a[0] + bt >>> 0, a[1] = a[1] + ht >>> 0, a[2] = a[2] + vt >>> 0, a[3] = a[3] + wt >>> 0, a[4] = a[4] + gt >>> 0
    }
    return [a[0] >> 24 & 255, a[0] >> 16 & 255, a[0] >> 8 & 255, a[0] & 255, a[1] >> 24 & 255, a[1] >> 16 & 255, a[1] >> 8 & 255, a[1] & 255, a[2] >> 24 & 255, a[2] >> 16 & 255, a[2] >> 8 & 255, a[2] & 255, a[3] >> 24 & 255, a[3] >> 16 & 255, a[3] >> 8 & 255, a[3] & 255, a[4] >> 24 & 255, a[4] >> 16 & 255, a[4] >> 8 & 255, a[4] & 255]
}
var v5$2 = v35$1("v5", 80, sha1$1);
const v5$3 = v5$2,
    nil$1 = "00000000-0000-0000-0000-000000000000";

function version$2(s) {
    if (!validate$3(s)) throw TypeError("Invalid UUID");
    return parseInt(s.substr(14, 1), 16)
}
const esmBrowser$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        NIL: nil$1,
        parse: parse$1,
        stringify: stringify$3,
        v1: v1$1,
        v3: v3$3,
        v4: v4$1,
        v5: v5$3,
        validate: validate$3,
        version: version$2
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    require$$4 = getAugmentedNamespace(esmBrowser$1),
    uuid$3 = require$$4.v4,
    generateRequest$3 = function(s, o, a, $) {
        if (typeof s != "string") throw new TypeError(s + " must be a string");
        $ = $ || {};
        const j = typeof $.version == "number" ? $.version : 2;
        if (j !== 1 && j !== 2) throw new TypeError(j + " must be 1 or 2");
        const _e = {
            method: s
        };
        if (j === 2 && (_e.jsonrpc = "2.0"), o) {
            if (typeof o != "object" && !Array.isArray(o)) throw new TypeError(o + " must be an object, array or omitted");
            _e.params = o
        }
        if (typeof a > "u") {
            const et = typeof $.generator == "function" ? $.generator : function() {
                return uuid$3()
            };
            _e.id = et(_e, $)
        } else j === 2 && a === null ? $.notificationIdNull && (_e.id = null) : _e.id = a;
        return _e
    };
var generateRequest_1$1 = generateRequest$3;
const uuid$2 = require$$4.v4,
    generateRequest$2 = generateRequest_1$1,
    ClientBrowser$1 = function(s, o) {
        if (!(this instanceof ClientBrowser$1)) return new ClientBrowser$1(s, o);
        o || (o = {}), this.options = {
            reviver: typeof o.reviver < "u" ? o.reviver : null,
            replacer: typeof o.replacer < "u" ? o.replacer : null,
            generator: typeof o.generator < "u" ? o.generator : function() {
                return uuid$2()
            },
            version: typeof o.version < "u" ? o.version : 2,
            notificationIdNull: typeof o.notificationIdNull == "boolean" ? o.notificationIdNull : !1
        }, this.callServer = s
    };
var browser$3 = ClientBrowser$1;
ClientBrowser$1.prototype.request = function(s, o, a, $) {
    const j = this;
    let _e = null;
    const et = Array.isArray(s) && typeof o == "function";
    if (this.options.version === 1 && et) throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (et || !et && s && typeof s == "object" && typeof o == "function") $ = o, _e = s;
    else {
        typeof a == "function" && ($ = a, a = void 0);
        const rt = typeof $ == "function";
        try {
            _e = generateRequest$2(s, o, a, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            })
        } catch (ot) {
            if (rt) return $(ot);
            throw ot
        }
        if (!rt) return _e
    }
    let nt;
    try {
        nt = JSON.stringify(_e, this.options.replacer)
    } catch (rt) {
        return $(rt)
    }
    return this.callServer(nt, function(rt, ot) {
        j._parseResponse(rt, ot, $)
    }), _e
};
ClientBrowser$1.prototype._parseResponse = function(s, o, a) {
    if (s) {
        a(s);
        return
    }
    if (!o) return a();
    let $;
    try {
        $ = JSON.parse(o, this.options.reviver)
    } catch (j) {
        return a(j)
    }
    if (a.length === 3)
        if (Array.isArray($)) {
            const j = function(et) {
                    return typeof et.error < "u"
                },
                _e = function(et) {
                    return !j(et)
                };
            return a(null, $.filter(j), $.filter(_e))
        } else return a(null, $.error, $.result);
    a(null, $)
};
const RpcClient$1 = getDefaultExportFromCjs$3(browser$3);
var eventemitter3$3 = {
    exports: {}
};
(function(s) {
    var o = Object.prototype.hasOwnProperty,
        a = "~";

    function $() {}
    Object.create && ($.prototype = Object.create(null), new $().__proto__ || (a = !1));

    function j(nt, rt, ot) {
        this.fn = nt, this.context = rt, this.once = ot || !1
    }

    function _e(nt, rt, ot, st, lt) {
        if (typeof ot != "function") throw new TypeError("The listener must be a function");
        var ft = new j(ot, st || nt, lt),
            yt = a ? a + rt : rt;
        return nt._events[yt] ? nt._events[yt].fn ? nt._events[yt] = [nt._events[yt], ft] : nt._events[yt].push(ft) : (nt._events[yt] = ft, nt._eventsCount++), nt
    }

    function et(nt, rt) {
        --nt._eventsCount === 0 ? nt._events = new $ : delete nt._events[rt]
    }

    function tt() {
        this._events = new $, this._eventsCount = 0
    }
    tt.prototype.eventNames = function() {
        var rt = [],
            ot, st;
        if (this._eventsCount === 0) return rt;
        for (st in ot = this._events) o.call(ot, st) && rt.push(a ? st.slice(1) : st);
        return Object.getOwnPropertySymbols ? rt.concat(Object.getOwnPropertySymbols(ot)) : rt
    }, tt.prototype.listeners = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        if (!st) return [];
        if (st.fn) return [st.fn];
        for (var lt = 0, ft = st.length, yt = new Array(ft); lt < ft; lt++) yt[lt] = st[lt].fn;
        return yt
    }, tt.prototype.listenerCount = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        return st ? st.fn ? 1 : st.length : 0
    }, tt.prototype.emit = function(rt, ot, st, lt, ft, yt) {
        var bt = a ? a + rt : rt;
        if (!this._events[bt]) return !1;
        var ht = this._events[bt],
            vt = arguments.length,
            wt, gt;
        if (ht.fn) {
            switch (ht.once && this.removeListener(rt, ht.fn, void 0, !0), vt) {
                case 1:
                    return ht.fn.call(ht.context), !0;
                case 2:
                    return ht.fn.call(ht.context, ot), !0;
                case 3:
                    return ht.fn.call(ht.context, ot, st), !0;
                case 4:
                    return ht.fn.call(ht.context, ot, st, lt), !0;
                case 5:
                    return ht.fn.call(ht.context, ot, st, lt, ft), !0;
                case 6:
                    return ht.fn.call(ht.context, ot, st, lt, ft, yt), !0
            }
            for (gt = 1, wt = new Array(vt - 1); gt < vt; gt++) wt[gt - 1] = arguments[gt];
            ht.fn.apply(ht.context, wt)
        } else {
            var At = ht.length,
                Pt;
            for (gt = 0; gt < At; gt++) switch (ht[gt].once && this.removeListener(rt, ht[gt].fn, void 0, !0), vt) {
                case 1:
                    ht[gt].fn.call(ht[gt].context);
                    break;
                case 2:
                    ht[gt].fn.call(ht[gt].context, ot);
                    break;
                case 3:
                    ht[gt].fn.call(ht[gt].context, ot, st);
                    break;
                case 4:
                    ht[gt].fn.call(ht[gt].context, ot, st, lt);
                    break;
                default:
                    if (!wt)
                        for (Pt = 1, wt = new Array(vt - 1); Pt < vt; Pt++) wt[Pt - 1] = arguments[Pt];
                    ht[gt].fn.apply(ht[gt].context, wt)
            }
        }
        return !0
    }, tt.prototype.on = function(rt, ot, st) {
        return _e(this, rt, ot, st, !1)
    }, tt.prototype.once = function(rt, ot, st) {
        return _e(this, rt, ot, st, !0)
    }, tt.prototype.removeListener = function(rt, ot, st, lt) {
        var ft = a ? a + rt : rt;
        if (!this._events[ft]) return this;
        if (!ot) return et(this, ft), this;
        var yt = this._events[ft];
        if (yt.fn) yt.fn === ot && (!lt || yt.once) && (!st || yt.context === st) && et(this, ft);
        else {
            for (var bt = 0, ht = [], vt = yt.length; bt < vt; bt++)(yt[bt].fn !== ot || lt && !yt[bt].once || st && yt[bt].context !== st) && ht.push(yt[bt]);
            ht.length ? this._events[ft] = ht.length === 1 ? ht[0] : ht : et(this, ft)
        }
        return this
    }, tt.prototype.removeAllListeners = function(rt) {
        var ot;
        return rt ? (ot = a ? a + rt : rt, this._events[ot] && et(this, ot)) : (this._events = new $, this._eventsCount = 0), this
    }, tt.prototype.off = tt.prototype.removeListener, tt.prototype.addListener = tt.prototype.on, tt.prefixed = a, tt.EventEmitter = tt, s.exports = tt
})(eventemitter3$3);
var eventemitter3Exports$3 = eventemitter3$3.exports;
const EventEmitter$3 = getDefaultExportFromCjs$3(eventemitter3Exports$3);
var WebSocketBrowserImpl$1 = class extends EventEmitter$3 {
    constructor(a, $, j) {
        super();
        jn(this, "socket");
        this.socket = new window.WebSocket(a, j), this.socket.onopen = () => this.emit("open"), this.socket.onmessage = _e => this.emit("message", _e.data), this.socket.onerror = _e => this.emit("error", _e), this.socket.onclose = _e => {
            this.emit("close", _e.code, _e.reason)
        }
    }
    send(a, $, j) {
        const _e = j || $;
        try {
            this.socket.send(a), _e()
        } catch (et) {
            _e(et)
        }
    }
    close(a, $) {
        this.socket.close(a, $)
    }
    addEventListener(a, $, j) {
        this.socket.addEventListener(a, $, j)
    }
};

function WebSocket$2(s, o) {
    return new WebSocketBrowserImpl$1(s, o)
}
var DefaultDataPack$1 = class {
        encode(o) {
            return JSON.stringify(o)
        }
        decode(o) {
            return JSON.parse(o)
        }
    },
    CommonClient$1 = class extends EventEmitter$3 {
        constructor(a, $ = "ws://localhost:8080", {
            autoconnect: j = !0,
            reconnect: _e = !0,
            reconnect_interval: et = 1e3,
            max_reconnects: tt = 5,
            ...nt
        } = {}, rt, ot) {
            super();
            jn(this, "address");
            jn(this, "rpc_id");
            jn(this, "queue");
            jn(this, "options");
            jn(this, "autoconnect");
            jn(this, "ready");
            jn(this, "reconnect");
            jn(this, "reconnect_timer_id");
            jn(this, "reconnect_interval");
            jn(this, "max_reconnects");
            jn(this, "rest_options");
            jn(this, "current_reconnects");
            jn(this, "generate_request_id");
            jn(this, "socket");
            jn(this, "webSocketFactory");
            jn(this, "dataPack");
            this.webSocketFactory = a, this.queue = {}, this.rpc_id = 0, this.address = $, this.autoconnect = j, this.ready = !1, this.reconnect = _e, this.reconnect_timer_id = void 0, this.reconnect_interval = et, this.max_reconnects = tt, this.rest_options = nt, this.current_reconnects = 0, this.generate_request_id = rt || (() => ++this.rpc_id), ot ? this.dataPack = ot : this.dataPack = new DefaultDataPack$1, this.autoconnect && this._connect(this.address, {
                autoconnect: this.autoconnect,
                reconnect: this.reconnect,
                reconnect_interval: this.reconnect_interval,
                max_reconnects: this.max_reconnects,
                ...this.rest_options
            })
        }
        connect() {
            this.socket || this._connect(this.address, {
                autoconnect: this.autoconnect,
                reconnect: this.reconnect,
                reconnect_interval: this.reconnect_interval,
                max_reconnects: this.max_reconnects,
                ...this.rest_options
            })
        }
        call(a, $, j, _e) {
            return !_e && typeof j == "object" && (_e = j, j = null), new Promise((et, tt) => {
                if (!this.ready) return tt(new Error("socket not ready"));
                const nt = this.generate_request_id(a, $),
                    rt = {
                        jsonrpc: "2.0",
                        method: a,
                        params: $ || void 0,
                        id: nt
                    };
                this.socket.send(this.dataPack.encode(rt), _e, ot => {
                    if (ot) return tt(ot);
                    this.queue[nt] = {
                        promise: [et, tt]
                    }, j && (this.queue[nt].timeout = setTimeout(() => {
                        delete this.queue[nt], tt(new Error("reply timeout"))
                    }, j))
                })
            })
        }
        async login(a) {
            const $ = await this.call("rpc.login", a);
            if (!$) throw new Error("authentication failed");
            return $
        }
        async listMethods() {
            return await this.call("__listMethods")
        }
        notify(a, $) {
            return new Promise((j, _e) => {
                if (!this.ready) return _e(new Error("socket not ready"));
                const et = {
                    jsonrpc: "2.0",
                    method: a,
                    params: $
                };
                this.socket.send(this.dataPack.encode(et), tt => {
                    if (tt) return _e(tt);
                    j()
                })
            })
        }
        async subscribe(a) {
            typeof a == "string" && (a = [a]);
            const $ = await this.call("rpc.on", a);
            if (typeof a == "string" && $[a] !== "ok") throw new Error("Failed subscribing to an event '" + a + "' with: " + $[a]);
            return $
        }
        async unsubscribe(a) {
            typeof a == "string" && (a = [a]);
            const $ = await this.call("rpc.off", a);
            if (typeof a == "string" && $[a] !== "ok") throw new Error("Failed unsubscribing from an event with: " + $);
            return $
        }
        close(a, $) {
            this.socket.close(a || 1e3, $)
        }
        setAutoReconnect(a) {
            this.reconnect = a
        }
        setReconnectInterval(a) {
            this.reconnect_interval = a
        }
        setMaxReconnects(a) {
            this.max_reconnects = a
        }
        _connect(a, $) {
            clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(a, $), this.socket.addEventListener("open", () => {
                this.ready = !0, this.emit("open"), this.current_reconnects = 0
            }), this.socket.addEventListener("message", ({
                data: j
            }) => {
                j instanceof ArrayBuffer && (j = buffer$1.Buffer.from(j).toString());
                try {
                    j = this.dataPack.decode(j)
                } catch {
                    return
                }
                if (j.notification && this.listeners(j.notification).length) {
                    if (!Object.keys(j.params).length) return this.emit(j.notification);
                    const _e = [j.notification];
                    if (j.params.constructor === Object) _e.push(j.params);
                    else
                        for (let et = 0; et < j.params.length; et++) _e.push(j.params[et]);
                    return Promise.resolve().then(() => {
                        this.emit.apply(this, _e)
                    })
                }
                if (!this.queue[j.id]) return j.method ? Promise.resolve().then(() => {
                    this.emit(j.method, j == null ? void 0 : j.params)
                }) : void 0;
                "error" in j == "result" in j && this.queue[j.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), this.queue[j.id].timeout && clearTimeout(this.queue[j.id].timeout), j.error ? this.queue[j.id].promise[1](j.error) : this.queue[j.id].promise[0](j.result), delete this.queue[j.id]
            }), this.socket.addEventListener("error", j => this.emit("error", j)), this.socket.addEventListener("close", ({
                code: j,
                reason: _e
            }) => {
                this.ready && setTimeout(() => this.emit("close", j, _e), 0), this.ready = !1, this.socket = void 0, j !== 1e3 && (this.current_reconnects++, this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout(() => this._connect(a, $), this.reconnect_interval)))
            })
        }
    };
let HMAC$1 = class extends Hash$1 {
    constructor(o, a) {
        super(), this.finished = !1, this.destroyed = !1, hash$2(o);
        const $ = toBytes$1(a);
        if (this.iHash = o.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const j = this.blockLen,
            _e = new Uint8Array(j);
        _e.set($.length > j ? o.create().update($).digest() : $);
        for (let et = 0; et < _e.length; et++) _e[et] ^= 54;
        this.iHash.update(_e), this.oHash = o.create();
        for (let et = 0; et < _e.length; et++) _e[et] ^= 106;
        this.oHash.update(_e), _e.fill(0)
    }
    update(o) {
        return exists$1(this), this.iHash.update(o), this
    }
    digestInto(o) {
        exists$1(this), bytes$1(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy()
    }
    digest() {
        const o = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(o), o
    }
    _cloneInto(o) {
        o || (o = Object.create(Object.getPrototypeOf(this), {}));
        const {
            oHash: a,
            iHash: $,
            finished: j,
            destroyed: _e,
            blockLen: et,
            outputLen: tt
        } = this;
        return o = o, o.finished = j, o.destroyed = _e, o.blockLen = et, o.outputLen = tt, o.oHash = a._cloneInto(o.oHash), o.iHash = $._cloneInto(o.iHash), o
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
    }
};
const hmac$1 = (s, o, a) => new HMAC$1(s, o).update(a).digest();
hmac$1.create = (s, o) => new HMAC$1(s, o); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts$1(s) {
    s.lowS !== void 0 && abool$1("lowS", s.lowS), s.prehash !== void 0 && abool$1("prehash", s.prehash)
}

function validatePointOpts$1(s) {
    const o = validateBasic$1(s);
    validateObject$1(o, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {
        endo: a,
        Fp: $,
        a: j
    } = o;
    if (a) {
        if (!$.eql(j, $.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof a != "object" || typeof a.beta != "bigint" || typeof a.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({ ...o
    })
}
const {
    bytesToNumberBE: b2n$1,
    hexToBytes: h2b$1
} = ut$1, DER$1 = {
    Err: class extends Error {
        constructor(o = "") {
            super(o)
        }
    },
    _tlv: {
        encode: (s, o) => {
            const {
                Err: a
            } = DER$1;
            if (s < 0 || s > 256) throw new a("tlv.encode: wrong tag");
            if (o.length & 1) throw new a("tlv.encode: unpadded data");
            const $ = o.length / 2,
                j = numberToHexUnpadded$1($);
            if (j.length / 2 & 128) throw new a("tlv.encode: long form length too big");
            const _e = $ > 127 ? numberToHexUnpadded$1(j.length / 2 | 128) : "";
            return `${numberToHexUnpadded$1(s)}${_e}${j}${o}`
        },
        decode(s, o) {
            const {
                Err: a
            } = DER$1;
            let $ = 0;
            if (s < 0 || s > 256) throw new a("tlv.encode: wrong tag");
            if (o.length < 2 || o[$++] !== s) throw new a("tlv.decode: wrong tlv");
            const j = o[$++],
                _e = !!(j & 128);
            let et = 0;
            if (!_e) et = j;
            else {
                const nt = j & 127;
                if (!nt) throw new a("tlv.decode(long): indefinite length not supported");
                if (nt > 4) throw new a("tlv.decode(long): byte length is too big");
                const rt = o.subarray($, $ + nt);
                if (rt.length !== nt) throw new a("tlv.decode: length bytes not complete");
                if (rt[0] === 0) throw new a("tlv.decode(long): zero leftmost byte");
                for (const ot of rt) et = et << 8 | ot;
                if ($ += nt, et < 128) throw new a("tlv.decode(long): not minimal encoding")
            }
            const tt = o.subarray($, $ + et);
            if (tt.length !== et) throw new a("tlv.decode: wrong value length");
            return {
                v: tt,
                l: o.subarray($ + et)
            }
        }
    },
    _int: {
        encode(s) {
            const {
                Err: o
            } = DER$1;
            if (s < _0n$6) throw new o("integer: negative integers are not allowed");
            let a = numberToHexUnpadded$1(s);
            if (Number.parseInt(a[0], 16) & 8 && (a = "00" + a), a.length & 1) throw new o("unexpected assertion");
            return a
        },
        decode(s) {
            const {
                Err: o
            } = DER$1;
            if (s[0] & 128) throw new o("Invalid signature integer: negative");
            if (s[0] === 0 && !(s[1] & 128)) throw new o("Invalid signature integer: unnecessary leading zero");
            return b2n$1(s)
        }
    },
    toSig(s) {
        const {
            Err: o,
            _int: a,
            _tlv: $
        } = DER$1, j = typeof s == "string" ? h2b$1(s) : s;
        abytes$1(j);
        const {
            v: _e,
            l: et
        } = $.decode(48, j);
        if (et.length) throw new o("Invalid signature: left bytes after parsing");
        const {
            v: tt,
            l: nt
        } = $.decode(2, _e), {
            v: rt,
            l: ot
        } = $.decode(2, nt);
        if (ot.length) throw new o("Invalid signature: left bytes after parsing");
        return {
            r: a.decode(tt),
            s: a.decode(rt)
        }
    },
    hexFromSig(s) {
        const {
            _tlv: o,
            _int: a
        } = DER$1, $ = `${o.encode(2,a.encode(s.r))}${o.encode(2,a.encode(s.s))}`;
        return o.encode(48, $)
    }
}, _0n$6 = BigInt(0), _1n$9 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);

function weierstrassPoints$1(s) {
    const o = validatePointOpts$1(s),
        {
            Fp: a
        } = o,
        $ = Field$1(o.n, o.nBitLength),
        j = o.toBytes || ((bt, ht, vt) => {
            const wt = ht.toAffine();
            return concatBytes$2(Uint8Array.from([4]), a.toBytes(wt.x), a.toBytes(wt.y))
        }),
        _e = o.fromBytes || (bt => {
            const ht = bt.subarray(1),
                vt = a.fromBytes(ht.subarray(0, a.BYTES)),
                wt = a.fromBytes(ht.subarray(a.BYTES, 2 * a.BYTES));
            return {
                x: vt,
                y: wt
            }
        });

    function et(bt) {
        const {
            a: ht,
            b: vt
        } = o, wt = a.sqr(bt), gt = a.mul(wt, bt);
        return a.add(a.add(gt, a.mul(bt, ht)), vt)
    }
    if (!a.eql(a.sqr(o.Gy), et(o.Gx))) throw new Error("bad generator point: equation left != right");

    function tt(bt) {
        return inRange$3(bt, _1n$9, o.n)
    }

    function nt(bt) {
        const {
            allowedPrivateKeyLengths: ht,
            nByteLength: vt,
            wrapPrivateKey: wt,
            n: gt
        } = o;
        if (ht && typeof bt != "bigint") {
            if (isBytes$2(bt) && (bt = bytesToHex$1(bt)), typeof bt != "string" || !ht.includes(bt.length)) throw new Error("Invalid key");
            bt = bt.padStart(vt * 2, "0")
        }
        let At;
        try {
            At = typeof bt == "bigint" ? bt : bytesToNumberBE$1(ensureBytes$1("private key", bt, vt))
        } catch {
            throw new Error(`private key must be ${vt} bytes, hex or bigint, not ${typeof bt}`)
        }
        return wt && (At = mod$1(At, gt)), aInRange$1("private key", At, _1n$9, gt), At
    }

    function rt(bt) {
        if (!(bt instanceof lt)) throw new Error("ProjectivePoint expected")
    }
    const ot = memoized$1((bt, ht) => {
            const {
                px: vt,
                py: wt,
                pz: gt
            } = bt;
            if (a.eql(gt, a.ONE)) return {
                x: vt,
                y: wt
            };
            const At = bt.is0();
            ht == null && (ht = At ? a.ONE : a.inv(gt));
            const Pt = a.mul(vt, ht),
                Bt = a.mul(wt, ht),
                Lt = a.mul(gt, ht);
            if (At) return {
                x: a.ZERO,
                y: a.ZERO
            };
            if (!a.eql(Lt, a.ONE)) throw new Error("invZ was invalid");
            return {
                x: Pt,
                y: Bt
            }
        }),
        st = memoized$1(bt => {
            if (bt.is0()) {
                if (o.allowInfinityPoint && !a.is0(bt.py)) return;
                throw new Error("bad point: ZERO")
            }
            const {
                x: ht,
                y: vt
            } = bt.toAffine();
            if (!a.isValid(ht) || !a.isValid(vt)) throw new Error("bad point: x or y not FE");
            const wt = a.sqr(vt),
                gt = et(ht);
            if (!a.eql(wt, gt)) throw new Error("bad point: equation left != right");
            if (!bt.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0
        });
    class lt {
        constructor(ht, vt, wt) {
            if (this.px = ht, this.py = vt, this.pz = wt, ht == null || !a.isValid(ht)) throw new Error("x required");
            if (vt == null || !a.isValid(vt)) throw new Error("y required");
            if (wt == null || !a.isValid(wt)) throw new Error("z required");
            Object.freeze(this)
        }
        static fromAffine(ht) {
            const {
                x: vt,
                y: wt
            } = ht || {};
            if (!ht || !a.isValid(vt) || !a.isValid(wt)) throw new Error("invalid affine point");
            if (ht instanceof lt) throw new Error("projective point not allowed");
            const gt = At => a.eql(At, a.ZERO);
            return gt(vt) && gt(wt) ? lt.ZERO : new lt(vt, wt, a.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(ht) {
            const vt = a.invertBatch(ht.map(wt => wt.pz));
            return ht.map((wt, gt) => wt.toAffine(vt[gt])).map(lt.fromAffine)
        }
        static fromHex(ht) {
            const vt = lt.fromAffine(_e(ensureBytes$1("pointHex", ht)));
            return vt.assertValidity(), vt
        }
        static fromPrivateKey(ht) {
            return lt.BASE.multiply(nt(ht))
        }
        static msm(ht, vt) {
            return pippenger$1(lt, $, ht, vt)
        }
        _setWindowSize(ht) {
            yt.setWindowSize(this, ht)
        }
        assertValidity() {
            st(this)
        }
        hasEvenY() {
            const {
                y: ht
            } = this.toAffine();
            if (a.isOdd) return !a.isOdd(ht);
            throw new Error("Field doesn't support isOdd")
        }
        equals(ht) {
            rt(ht);
            const {
                px: vt,
                py: wt,
                pz: gt
            } = this, {
                px: At,
                py: Pt,
                pz: Bt
            } = ht, Lt = a.eql(a.mul(vt, Bt), a.mul(At, gt)), Nt = a.eql(a.mul(wt, Bt), a.mul(Pt, gt));
            return Lt && Nt
        }
        negate() {
            return new lt(this.px, a.neg(this.py), this.pz)
        }
        double() {
            const {
                a: ht,
                b: vt
            } = o, wt = a.mul(vt, _3n$2), {
                px: gt,
                py: At,
                pz: Pt
            } = this;
            let Bt = a.ZERO,
                Lt = a.ZERO,
                Nt = a.ZERO,
                Ut = a.mul(gt, gt),
                Vt = a.mul(At, At),
                Ft = a.mul(Pt, Pt),
                Wt = a.mul(gt, At);
            return Wt = a.add(Wt, Wt), Nt = a.mul(gt, Pt), Nt = a.add(Nt, Nt), Bt = a.mul(ht, Nt), Lt = a.mul(wt, Ft), Lt = a.add(Bt, Lt), Bt = a.sub(Vt, Lt), Lt = a.add(Vt, Lt), Lt = a.mul(Bt, Lt), Bt = a.mul(Wt, Bt), Nt = a.mul(wt, Nt), Ft = a.mul(ht, Ft), Wt = a.sub(Ut, Ft), Wt = a.mul(ht, Wt), Wt = a.add(Wt, Nt), Nt = a.add(Ut, Ut), Ut = a.add(Nt, Ut), Ut = a.add(Ut, Ft), Ut = a.mul(Ut, Wt), Lt = a.add(Lt, Ut), Ft = a.mul(At, Pt), Ft = a.add(Ft, Ft), Ut = a.mul(Ft, Wt), Bt = a.sub(Bt, Ut), Nt = a.mul(Ft, Vt), Nt = a.add(Nt, Nt), Nt = a.add(Nt, Nt), new lt(Bt, Lt, Nt)
        }
        add(ht) {
            rt(ht);
            const {
                px: vt,
                py: wt,
                pz: gt
            } = this, {
                px: At,
                py: Pt,
                pz: Bt
            } = ht;
            let Lt = a.ZERO,
                Nt = a.ZERO,
                Ut = a.ZERO;
            const Vt = o.a,
                Ft = a.mul(o.b, _3n$2);
            let Wt = a.mul(vt, At),
                Ct = a.mul(wt, Pt),
                it = a.mul(gt, Bt),
                at = a.add(vt, wt),
                mt = a.add(At, Pt);
            at = a.mul(at, mt), mt = a.add(Wt, Ct), at = a.sub(at, mt), mt = a.add(vt, gt);
            let xt = a.add(At, Bt);
            return mt = a.mul(mt, xt), xt = a.add(Wt, it), mt = a.sub(mt, xt), xt = a.add(wt, gt), Lt = a.add(Pt, Bt), xt = a.mul(xt, Lt), Lt = a.add(Ct, it), xt = a.sub(xt, Lt), Ut = a.mul(Vt, mt), Lt = a.mul(Ft, it), Ut = a.add(Lt, Ut), Lt = a.sub(Ct, Ut), Ut = a.add(Ct, Ut), Nt = a.mul(Lt, Ut), Ct = a.add(Wt, Wt), Ct = a.add(Ct, Wt), it = a.mul(Vt, it), mt = a.mul(Ft, mt), Ct = a.add(Ct, it), it = a.sub(Wt, it), it = a.mul(Vt, it), mt = a.add(mt, it), Wt = a.mul(Ct, mt), Nt = a.add(Nt, Wt), Wt = a.mul(xt, mt), Lt = a.mul(at, Lt), Lt = a.sub(Lt, Wt), Wt = a.mul(at, Ct), Ut = a.mul(xt, Ut), Ut = a.add(Ut, Wt), new lt(Lt, Nt, Ut)
        }
        subtract(ht) {
            return this.add(ht.negate())
        }
        is0() {
            return this.equals(lt.ZERO)
        }
        wNAF(ht) {
            return yt.wNAFCached(this, ht, lt.normalizeZ)
        }
        multiplyUnsafe(ht) {
            aInRange$1("scalar", ht, _0n$6, o.n);
            const vt = lt.ZERO;
            if (ht === _0n$6) return vt;
            if (ht === _1n$9) return this;
            const {
                endo: wt
            } = o;
            if (!wt) return yt.unsafeLadder(this, ht);
            let {
                k1neg: gt,
                k1: At,
                k2neg: Pt,
                k2: Bt
            } = wt.splitScalar(ht), Lt = vt, Nt = vt, Ut = this;
            for (; At > _0n$6 || Bt > _0n$6;) At & _1n$9 && (Lt = Lt.add(Ut)), Bt & _1n$9 && (Nt = Nt.add(Ut)), Ut = Ut.double(), At >>= _1n$9, Bt >>= _1n$9;
            return gt && (Lt = Lt.negate()), Pt && (Nt = Nt.negate()), Nt = new lt(a.mul(Nt.px, wt.beta), Nt.py, Nt.pz), Lt.add(Nt)
        }
        multiply(ht) {
            const {
                endo: vt,
                n: wt
            } = o;
            aInRange$1("scalar", ht, _1n$9, wt);
            let gt, At;
            if (vt) {
                const {
                    k1neg: Pt,
                    k1: Bt,
                    k2neg: Lt,
                    k2: Nt
                } = vt.splitScalar(ht);
                let {
                    p: Ut,
                    f: Vt
                } = this.wNAF(Bt), {
                    p: Ft,
                    f: Wt
                } = this.wNAF(Nt);
                Ut = yt.constTimeNegate(Pt, Ut), Ft = yt.constTimeNegate(Lt, Ft), Ft = new lt(a.mul(Ft.px, vt.beta), Ft.py, Ft.pz), gt = Ut.add(Ft), At = Vt.add(Wt)
            } else {
                const {
                    p: Pt,
                    f: Bt
                } = this.wNAF(ht);
                gt = Pt, At = Bt
            }
            return lt.normalizeZ([gt, At])[0]
        }
        multiplyAndAddUnsafe(ht, vt, wt) {
            const gt = lt.BASE,
                At = (Bt, Lt) => Lt === _0n$6 || Lt === _1n$9 || !Bt.equals(gt) ? Bt.multiplyUnsafe(Lt) : Bt.multiply(Lt),
                Pt = At(this, vt).add(At(ht, wt));
            return Pt.is0() ? void 0 : Pt
        }
        toAffine(ht) {
            return ot(this, ht)
        }
        isTorsionFree() {
            const {
                h: ht,
                isTorsionFree: vt
            } = o;
            if (ht === _1n$9) return !0;
            if (vt) return vt(lt, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {
                h: ht,
                clearCofactor: vt
            } = o;
            return ht === _1n$9 ? this : vt ? vt(lt, this) : this.multiplyUnsafe(o.h)
        }
        toRawBytes(ht = !0) {
            return abool$1("isCompressed", ht), this.assertValidity(), j(lt, this, ht)
        }
        toHex(ht = !0) {
            return abool$1("isCompressed", ht), bytesToHex$1(this.toRawBytes(ht))
        }
    }
    lt.BASE = new lt(o.Gx, o.Gy, a.ONE), lt.ZERO = new lt(a.ZERO, a.ONE, a.ZERO);
    const ft = o.nBitLength,
        yt = wNAF$1(lt, o.endo ? Math.ceil(ft / 2) : ft);
    return {
        CURVE: o,
        ProjectivePoint: lt,
        normPrivateKeyToScalar: nt,
        weierstrassEquation: et,
        isWithinCurveOrder: tt
    }
}

function validateOpts$2(s) {
    const o = validateBasic$1(s);
    return validateObject$1(o, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...o
    })
}

function weierstrass$1(s) {
    const o = validateOpts$2(s),
        {
            Fp: a,
            n: $
        } = o,
        j = a.BYTES + 1,
        _e = 2 * a.BYTES + 1;

    function et(it) {
        return mod$1(it, $)
    }

    function tt(it) {
        return invert$1(it, $)
    }
    const {
        ProjectivePoint: nt,
        normPrivateKeyToScalar: rt,
        weierstrassEquation: ot,
        isWithinCurveOrder: st
    } = weierstrassPoints$1({ ...o,
        toBytes(it, at, mt) {
            const xt = at.toAffine(),
                $t = a.toBytes(xt.x),
                Rt = concatBytes$2;
            return abool$1("isCompressed", mt), mt ? Rt(Uint8Array.from([at.hasEvenY() ? 2 : 3]), $t) : Rt(Uint8Array.from([4]), $t, a.toBytes(xt.y))
        },
        fromBytes(it) {
            const at = it.length,
                mt = it[0],
                xt = it.subarray(1);
            if (at === j && (mt === 2 || mt === 3)) {
                const $t = bytesToNumberBE$1(xt);
                if (!inRange$3($t, _1n$9, a.ORDER)) throw new Error("Point is not on curve");
                const Rt = ot($t);
                let It;
                try {
                    It = a.sqrt(Rt)
                } catch (Et) {
                    const Ot = Et instanceof Error ? ": " + Et.message : "";
                    throw new Error("Point is not on curve" + Ot)
                }
                const Tt = (It & _1n$9) === _1n$9;
                return (mt & 1) === 1 !== Tt && (It = a.neg(It)), {
                    x: $t,
                    y: It
                }
            } else if (at === _e && mt === 4) {
                const $t = a.fromBytes(xt.subarray(0, a.BYTES)),
                    Rt = a.fromBytes(xt.subarray(a.BYTES, 2 * a.BYTES));
                return {
                    x: $t,
                    y: Rt
                }
            } else throw new Error(`Point of length ${at} was invalid. Expected ${j} compressed bytes or ${_e} uncompressed bytes`)
        }
    }), lt = it => bytesToHex$1(numberToBytesBE$1(it, o.nByteLength));

    function ft(it) {
        const at = $ >> _1n$9;
        return it > at
    }

    function yt(it) {
        return ft(it) ? et(-it) : it
    }
    const bt = (it, at, mt) => bytesToNumberBE$1(it.slice(at, mt));
    class ht {
        constructor(at, mt, xt) {
            this.r = at, this.s = mt, this.recovery = xt, this.assertValidity()
        }
        static fromCompact(at) {
            const mt = o.nByteLength;
            return at = ensureBytes$1("compactSignature", at, mt * 2), new ht(bt(at, 0, mt), bt(at, mt, 2 * mt))
        }
        static fromDER(at) {
            const {
                r: mt,
                s: xt
            } = DER$1.toSig(ensureBytes$1("DER", at));
            return new ht(mt, xt)
        }
        assertValidity() {
            aInRange$1("r", this.r, _1n$9, $), aInRange$1("s", this.s, _1n$9, $)
        }
        addRecoveryBit(at) {
            return new ht(this.r, this.s, at)
        }
        recoverPublicKey(at) {
            const {
                r: mt,
                s: xt,
                recovery: $t
            } = this, Rt = Bt(ensureBytes$1("msgHash", at));
            if ($t == null || ![0, 1, 2, 3].includes($t)) throw new Error("recovery id invalid");
            const It = $t === 2 || $t === 3 ? mt + o.n : mt;
            if (It >= a.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const Tt = $t & 1 ? "03" : "02",
                dt = nt.fromHex(Tt + lt(It)),
                Et = tt(It),
                Ot = et(-Rt * Et),
                Mt = et(xt * Et),
                jt = nt.BASE.multiplyAndAddUnsafe(dt, Ot, Mt);
            if (!jt) throw new Error("point at infinify");
            return jt.assertValidity(), jt
        }
        hasHighS() {
            return ft(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new ht(this.r, et(-this.s), this.recovery) : this
        }
        toDERRawBytes() {
            return hexToBytes$1(this.toDERHex())
        }
        toDERHex() {
            return DER$1.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return hexToBytes$1(this.toCompactHex())
        }
        toCompactHex() {
            return lt(this.r) + lt(this.s)
        }
    }
    const vt = {
        isValidPrivateKey(it) {
            try {
                return rt(it), !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: rt,
        randomPrivateKey: () => {
            const it = getMinHashLength$1(o.n);
            return mapHashToField$1(o.randomBytes(it), o.n)
        },
        precompute(it = 8, at = nt.BASE) {
            return at._setWindowSize(it), at.multiply(BigInt(3)), at
        }
    };

    function wt(it, at = !0) {
        return nt.fromPrivateKey(it).toRawBytes(at)
    }

    function gt(it) {
        const at = isBytes$2(it),
            mt = typeof it == "string",
            xt = (at || mt) && it.length;
        return at ? xt === j || xt === _e : mt ? xt === 2 * j || xt === 2 * _e : it instanceof nt
    }

    function At(it, at, mt = !0) {
        if (gt(it)) throw new Error("first arg must be private key");
        if (!gt(at)) throw new Error("second arg must be public key");
        return nt.fromHex(at).multiply(rt(it)).toRawBytes(mt)
    }
    const Pt = o.bits2int || function(it) {
            const at = bytesToNumberBE$1(it),
                mt = it.length * 8 - o.nBitLength;
            return mt > 0 ? at >> BigInt(mt) : at
        },
        Bt = o.bits2int_modN || function(it) {
            return et(Pt(it))
        },
        Lt = bitMask$1(o.nBitLength);

    function Nt(it) {
        return aInRange$1(`num < 2^${o.nBitLength}`, it, _0n$6, Lt), numberToBytesBE$1(it, o.nByteLength)
    }

    function Ut(it, at, mt = Vt) {
        if (["recovered", "canonical"].some(Kt => Kt in mt)) throw new Error("sign() legacy options not supported");
        const {
            hash: xt,
            randomBytes: $t
        } = o;
        let {
            lowS: Rt,
            prehash: It,
            extraEntropy: Tt
        } = mt;
        Rt == null && (Rt = !0), it = ensureBytes$1("msgHash", it), validateSigVerOpts$1(mt), It && (it = ensureBytes$1("prehashed msgHash", xt(it)));
        const dt = Bt(it),
            Et = rt(at),
            Ot = [Nt(Et), Nt(dt)];
        if (Tt != null && Tt !== !1) {
            const Kt = Tt === !0 ? $t(a.BYTES) : Tt;
            Ot.push(ensureBytes$1("extraEntropy", Kt))
        }
        const Mt = concatBytes$2(...Ot),
            jt = dt;

        function Qt(Kt) {
            const qt = Pt(Kt);
            if (!st(qt)) return;
            const Jt = tt(qt),
                Zt = nt.BASE.multiply(qt).toAffine(),
                en = et(Zt.x);
            if (en === _0n$6) return;
            const ln = et(Jt * et(jt + en * Et));
            if (ln === _0n$6) return;
            let cn = (Zt.x === en ? 0 : 2) | Number(Zt.y & _1n$9),
                un = ln;
            return Rt && ft(ln) && (un = yt(ln), cn ^= 1), new ht(en, un, cn)
        }
        return {
            seed: Mt,
            k2sig: Qt
        }
    }
    const Vt = {
            lowS: o.lowS,
            prehash: !1
        },
        Ft = {
            lowS: o.lowS,
            prehash: !1
        };

    function Wt(it, at, mt = Vt) {
        const {
            seed: xt,
            k2sig: $t
        } = Ut(it, at, mt), Rt = o;
        return createHmacDrbg$1(Rt.hash.outputLen, Rt.nByteLength, Rt.hmac)(xt, $t)
    }
    nt.BASE._setWindowSize(8);

    function Ct(it, at, mt, xt = Ft) {
        var Zt;
        const $t = it;
        if (at = ensureBytes$1("msgHash", at), mt = ensureBytes$1("publicKey", mt), "strict" in xt) throw new Error("options.strict was renamed to lowS");
        validateSigVerOpts$1(xt);
        const {
            lowS: Rt,
            prehash: It
        } = xt;
        let Tt, dt;
        try {
            if (typeof $t == "string" || isBytes$2($t)) try {
                Tt = ht.fromDER($t)
            } catch (en) {
                if (!(en instanceof DER$1.Err)) throw en;
                Tt = ht.fromCompact($t)
            } else if (typeof $t == "object" && typeof $t.r == "bigint" && typeof $t.s == "bigint") {
                const {
                    r: en,
                    s: ln
                } = $t;
                Tt = new ht(en, ln)
            } else throw new Error("PARSE");
            dt = nt.fromHex(mt)
        } catch (en) {
            if (en.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (Rt && Tt.hasHighS()) return !1;
        It && (at = o.hash(at));
        const {
            r: Et,
            s: Ot
        } = Tt, Mt = Bt(at), jt = tt(Ot), Qt = et(Mt * jt), Kt = et(Et * jt), qt = (Zt = nt.BASE.multiplyAndAddUnsafe(dt, Qt, Kt)) == null ? void 0 : Zt.toAffine();
        return qt ? et(qt.x) === Et : !1
    }
    return {
        CURVE: o,
        getPublicKey: wt,
        getSharedSecret: At,
        sign: Wt,
        verify: Ct,
        ProjectivePoint: nt,
        Signature: ht,
        utils: vt
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(s) {
    return {
        hash: s,
        hmac: (o, ...a) => hmac$1(s, o, concatBytes$3(...a)),
        randomBytes: randomBytes$1
    }
}

function createCurve$1(s, o) {
    const a = $ => weierstrass$1({ ...s,
        ...getHash$1($)
    });
    return Object.freeze({ ...a(o),
        create: a
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    _1n$8 = BigInt(1),
    _2n$6 = BigInt(2),
    divNearest$1 = (s, o) => (s + o / _2n$6) / o;

function sqrtMod$1(s) {
    const o = secp256k1P$1,
        a = BigInt(3),
        $ = BigInt(6),
        j = BigInt(11),
        _e = BigInt(22),
        et = BigInt(23),
        tt = BigInt(44),
        nt = BigInt(88),
        rt = s * s * s % o,
        ot = rt * rt * s % o,
        st = pow2$1(ot, a, o) * ot % o,
        lt = pow2$1(st, a, o) * ot % o,
        ft = pow2$1(lt, _2n$6, o) * rt % o,
        yt = pow2$1(ft, j, o) * ft % o,
        bt = pow2$1(yt, _e, o) * yt % o,
        ht = pow2$1(bt, tt, o) * bt % o,
        vt = pow2$1(ht, nt, o) * ht % o,
        wt = pow2$1(vt, tt, o) * bt % o,
        gt = pow2$1(wt, a, o) * ot % o,
        At = pow2$1(gt, et, o) * yt % o,
        Pt = pow2$1(At, $, o) * rt % o,
        Bt = pow2$1(Pt, _2n$6, o);
    if (!Fp$2.eql(Fp$2.sqr(Bt), s)) throw new Error("Cannot find square root");
    return Bt
}
const Fp$2 = Field$1(secp256k1P$1, void 0, void 0, {
        sqrt: sqrtMod$1
    }),
    secp256k1$1 = createCurve$1({
        a: BigInt(0),
        b: BigInt(7),
        Fp: Fp$2,
        n: secp256k1N$1,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: s => {
                const o = secp256k1N$1,
                    a = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    $ = -_1n$8 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    j = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                    _e = a,
                    et = BigInt("0x100000000000000000000000000000000"),
                    tt = divNearest$1(_e * s, o),
                    nt = divNearest$1(-$ * s, o);
                let rt = mod$1(s - tt * a - nt * j, o),
                    ot = mod$1(-tt * $ - nt * _e, o);
                const st = rt > et,
                    lt = ot > et;
                if (st && (rt = o - rt), lt && (ot = o - ot), rt > et || ot > et) throw new Error("splitScalar: Endomorphism failed, k=" + s);
                return {
                    k1neg: st,
                    k1: rt,
                    k2neg: lt,
                    k2: ot
                }
            }
        }
    }, sha256$3);
BigInt(0);
secp256k1$1.ProjectivePoint;

function isOnCurve$1(s) {
    try {
        return ed25519$1.ExtendedPoint.fromHex(s), !0
    } catch {
        return !1
    }
}
const sign$1 = (s, o) => ed25519$1.sign(s, o.slice(0, 32)),
    verify$1 = ed25519$1.verify,
    toBuffer$2 = s => buffer$1.Buffer.isBuffer(s) ? s : s instanceof Uint8Array ? buffer$1.Buffer.from(s.buffer, s.byteOffset, s.byteLength) : buffer$1.Buffer.from(s);
let Struct$3 = class {
    constructor(o) {
        Object.assign(this, o)
    }
    encode() {
        return buffer$1.Buffer.from(serialize_1$1(SOLANA_SCHEMA$1, this))
    }
    static decode(o) {
        return deserialize_1$1(SOLANA_SCHEMA$1, this, o)
    }
    static decodeUnchecked(o) {
        return deserializeUnchecked_1$1(SOLANA_SCHEMA$1, this, o)
    }
};
const SOLANA_SCHEMA$1 = new Map;
var _PublicKey$1;
const MAX_SEED_LENGTH$1 = 32,
    PUBLIC_KEY_LENGTH$1 = 32;

function isPublicKeyData$1(s) {
    return s._bn !== void 0
}
let uniquePublicKeyCounter$1 = 1,
    PublicKey$1 = class dr extends Struct$3 {
        constructor(o) {
            if (super({}), this._bn = void 0, isPublicKeyData$1(o)) this._bn = o._bn;
            else {
                if (typeof o == "string") {
                    const a = bs58$5.decode(o);
                    if (a.length != PUBLIC_KEY_LENGTH$1) throw new Error("Invalid public key input");
                    this._bn = new BN$1(a)
                } else this._bn = new BN$1(o);
                if (this._bn.byteLength() > PUBLIC_KEY_LENGTH$1) throw new Error("Invalid public key input")
            }
        }
        static unique() {
            const o = new dr(uniquePublicKeyCounter$1);
            return uniquePublicKeyCounter$1 += 1, new dr(o.toBuffer())
        }
        equals(o) {
            return this._bn.eq(o._bn)
        }
        toBase58() {
            return bs58$5.encode(this.toBytes())
        }
        toJSON() {
            return this.toBase58()
        }
        toBytes() {
            const o = this.toBuffer();
            return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
        }
        toBuffer() {
            const o = this._bn.toArrayLike(buffer$1.Buffer);
            if (o.length === PUBLIC_KEY_LENGTH$1) return o;
            const a = buffer$1.Buffer.alloc(32);
            return o.copy(a, 32 - o.length), a
        }
        get[Symbol.toStringTag]() {
            return `PublicKey(${this.toString()})`
        }
        toString() {
            return this.toBase58()
        }
        static async createWithSeed(o, a, $) {
            const j = buffer$1.Buffer.concat([o.toBuffer(), buffer$1.Buffer.from(a), $.toBuffer()]),
                _e = sha256$3(j);
            return new dr(_e)
        }
        static createProgramAddressSync(o, a) {
            let $ = buffer$1.Buffer.alloc(0);
            o.forEach(function(_e) {
                if (_e.length > MAX_SEED_LENGTH$1) throw new TypeError("Max seed length exceeded");
                $ = buffer$1.Buffer.concat([$, toBuffer$2(_e)])
            }), $ = buffer$1.Buffer.concat([$, a.toBuffer(), buffer$1.Buffer.from("ProgramDerivedAddress")]);
            const j = sha256$3($);
            if (isOnCurve$1(j)) throw new Error("Invalid seeds, address must fall off the curve");
            return new dr(j)
        }
        static async createProgramAddress(o, a) {
            return this.createProgramAddressSync(o, a)
        }
        static findProgramAddressSync(o, a) {
            let $ = 255,
                j;
            for (; $ != 0;) {
                try {
                    const _e = o.concat(buffer$1.Buffer.from([$]));
                    j = this.createProgramAddressSync(_e, a)
                } catch (_e) {
                    if (_e instanceof TypeError) throw _e;
                    $--;
                    continue
                }
                return [j, $]
            }
            throw new Error("Unable to find a viable program address nonce")
        }
        static async findProgramAddress(o, a) {
            return this.findProgramAddressSync(o, a)
        }
        static isOnCurve(o) {
            const a = new dr(o);
            return isOnCurve$1(a.toBytes())
        }
    };
_PublicKey$1 = PublicKey$1;
PublicKey$1.default = new _PublicKey$1("11111111111111111111111111111111");
SOLANA_SCHEMA$1.set(PublicKey$1, {
    kind: "struct",
    fields: [
        ["_bn", "u256"]
    ]
});
new PublicKey$1("BPFLoader1111111111111111111111111111111111");
const PACKET_DATA_SIZE$1 = 1232,
    VERSION_PREFIX_MASK$1 = 127,
    SIGNATURE_LENGTH_IN_BYTES$2 = 64;
let TransactionExpiredBlockheightExceededError$1 = class extends Error {
    constructor(o) {
        super(`Signature ${o} has expired: block height exceeded.`), this.signature = void 0, this.signature = o
    }
};
Object.defineProperty(TransactionExpiredBlockheightExceededError$1.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
let TransactionExpiredTimeoutError$1 = class extends Error {
    constructor(o, a) {
        super(`Transaction was not confirmed in ${a.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${o} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = o
    }
};
Object.defineProperty(TransactionExpiredTimeoutError$1.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});
let TransactionExpiredNonceInvalidError$1 = class extends Error {
    constructor(o) {
        super(`Signature ${o} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = o
    }
};
Object.defineProperty(TransactionExpiredNonceInvalidError$1.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
});
let MessageAccountKeys$1 = class {
    constructor(o, a) {
        this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = o, this.accountKeysFromLookups = a
    }
    keySegments() {
        const o = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (o.push(this.accountKeysFromLookups.writable), o.push(this.accountKeysFromLookups.readonly)), o
    }
    get(o) {
        for (const a of this.keySegments()) {
            if (o < a.length) return a[o];
            o -= a.length
        }
    }
    get length() {
        return this.keySegments().flat().length
    }
    compileInstructions(o) {
        if (this.length > 256) throw new Error("Account index overflow encountered during compilation");
        const $ = new Map;
        this.keySegments().flat().forEach((_e, et) => {
            $.set(_e.toBase58(), et)
        });
        const j = _e => {
            const et = $.get(_e.toBase58());
            if (et === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
            return et
        };
        return o.map(_e => ({
            programIdIndex: j(_e.programId),
            accountKeyIndexes: _e.keys.map(et => j(et.pubkey)),
            data: _e.data
        }))
    }
};
const publicKey$4 = (s = "publicKey") => blob$2(32, s),
    signature$1 = (s = "signature") => blob$2(64, s),
    rustString$1 = (s = "string") => {
        const o = struct$2([u32$3("length"), u32$3("lengthPadding"), blob$2(offset$2(u32$3(), -8), "chars")], s),
            a = o.decode.bind(o),
            $ = o.encode.bind(o),
            j = o;
        return j.decode = (_e, et) => a(_e, et).chars.toString(), j.encode = (_e, et, tt) => {
            const nt = {
                chars: buffer$1.Buffer.from(_e, "utf8")
            };
            return $(nt, et, tt)
        }, j.alloc = _e => u32$3().span + u32$3().span + buffer$1.Buffer.from(_e, "utf8").length, j
    },
    authorized$1 = (s = "authorized") => struct$2([publicKey$4("staker"), publicKey$4("withdrawer")], s),
    lockup$1 = (s = "lockup") => struct$2([ns64$2("unixTimestamp"), ns64$2("epoch"), publicKey$4("custodian")], s),
    voteInit$1 = (s = "voteInit") => struct$2([publicKey$4("nodePubkey"), publicKey$4("authorizedVoter"), publicKey$4("authorizedWithdrawer"), u8$2("commission")], s),
    voteAuthorizeWithSeedArgs$1 = (s = "voteAuthorizeWithSeedArgs") => struct$2([u32$3("voteAuthorizationType"), publicKey$4("currentAuthorityDerivedKeyOwnerPubkey"), rustString$1("currentAuthorityDerivedKeySeed"), publicKey$4("newAuthorized")], s);

function decodeLength$1(s) {
    let o = 0,
        a = 0;
    for (;;) {
        let $ = s.shift();
        if (o |= ($ & 127) << a * 7, a += 1, !($ & 128)) break
    }
    return o
}

function encodeLength$1(s, o) {
    let a = o;
    for (;;) {
        let $ = a & 127;
        if (a >>= 7, a == 0) {
            s.push($);
            break
        } else $ |= 128, s.push($)
    }
}

function assert$4(s, o) {
    if (!s) throw new Error(o || "Assertion failed")
}
let CompiledKeys$1 = class mr {
    constructor(o, a) {
        this.payer = void 0, this.keyMetaMap = void 0, this.payer = o, this.keyMetaMap = a
    }
    static compile(o, a) {
        const $ = new Map,
            j = et => {
                const tt = et.toBase58();
                let nt = $.get(tt);
                return nt === void 0 && (nt = {
                    isSigner: !1,
                    isWritable: !1,
                    isInvoked: !1
                }, $.set(tt, nt)), nt
            },
            _e = j(a);
        _e.isSigner = !0, _e.isWritable = !0;
        for (const et of o) {
            j(et.programId).isInvoked = !0;
            for (const tt of et.keys) {
                const nt = j(tt.pubkey);
                nt.isSigner || (nt.isSigner = tt.isSigner), nt.isWritable || (nt.isWritable = tt.isWritable)
            }
        }
        return new mr(a, $)
    }
    getMessageComponents() {
        const o = [...this.keyMetaMap.entries()];
        assert$4(o.length <= 256, "Max static account keys length exceeded");
        const a = o.filter(([, nt]) => nt.isSigner && nt.isWritable),
            $ = o.filter(([, nt]) => nt.isSigner && !nt.isWritable),
            j = o.filter(([, nt]) => !nt.isSigner && nt.isWritable),
            _e = o.filter(([, nt]) => !nt.isSigner && !nt.isWritable),
            et = {
                numRequiredSignatures: a.length + $.length,
                numReadonlySignedAccounts: $.length,
                numReadonlyUnsignedAccounts: _e.length
            }; {
            assert$4(a.length > 0, "Expected at least one writable signer key");
            const [nt] = a[0];
            assert$4(nt === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        const tt = [...a.map(([nt]) => new PublicKey$1(nt)), ...$.map(([nt]) => new PublicKey$1(nt)), ...j.map(([nt]) => new PublicKey$1(nt)), ..._e.map(([nt]) => new PublicKey$1(nt))];
        return [et, tt]
    }
    extractTableLookup(o) {
        const [a, $] = this.drainKeysFoundInLookupTable(o.state.addresses, et => !et.isSigner && !et.isInvoked && et.isWritable), [j, _e] = this.drainKeysFoundInLookupTable(o.state.addresses, et => !et.isSigner && !et.isInvoked && !et.isWritable);
        if (!(a.length === 0 && j.length === 0)) return [{
            accountKey: o.key,
            writableIndexes: a,
            readonlyIndexes: j
        }, {
            writable: $,
            readonly: _e
        }]
    }
    drainKeysFoundInLookupTable(o, a) {
        const $ = new Array,
            j = new Array;
        for (const [_e, et] of this.keyMetaMap.entries())
            if (a(et)) {
                const tt = new PublicKey$1(_e),
                    nt = o.findIndex(rt => rt.equals(tt));
                nt >= 0 && (assert$4(nt < 256, "Max lookup table index exceeded"), $.push(nt), j.push(tt), this.keyMetaMap.delete(_e))
            }
        return [$, j]
    }
};
const END_OF_BUFFER_ERROR_MESSAGE$1 = "Reached end of buffer unexpectedly";

function guardedShift$1(s) {
    if (s.length === 0) throw new Error(END_OF_BUFFER_ERROR_MESSAGE$1);
    return s.shift()
}

function guardedSplice$1(s, ...o) {
    const [a] = o;
    if (o.length === 2 ? a + (o[1] ? ? 0) > s.length : a >= s.length) throw new Error(END_OF_BUFFER_ERROR_MESSAGE$1);
    return s.splice(...o)
}
let Message$1 = class fr {
        constructor(o) {
            this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = o.header, this.accountKeys = o.accountKeys.map(a => new PublicKey$1(a)), this.recentBlockhash = o.recentBlockhash, this.instructions = o.instructions, this.instructions.forEach(a => this.indexToProgramIds.set(a.programIdIndex, this.accountKeys[a.programIdIndex]))
        }
        get version() {
            return "legacy"
        }
        get staticAccountKeys() {
            return this.accountKeys
        }
        get compiledInstructions() {
            return this.instructions.map(o => ({
                programIdIndex: o.programIdIndex,
                accountKeyIndexes: o.accounts,
                data: bs58$5.decode(o.data)
            }))
        }
        get addressTableLookups() {
            return []
        }
        getAccountKeys() {
            return new MessageAccountKeys$1(this.staticAccountKeys)
        }
        static compile(o) {
            const a = CompiledKeys$1.compile(o.instructions, o.payerKey),
                [$, j] = a.getMessageComponents(),
                et = new MessageAccountKeys$1(j).compileInstructions(o.instructions).map(tt => ({
                    programIdIndex: tt.programIdIndex,
                    accounts: tt.accountKeyIndexes,
                    data: bs58$5.encode(tt.data)
                }));
            return new fr({
                header: $,
                accountKeys: j,
                recentBlockhash: o.recentBlockhash,
                instructions: et
            })
        }
        isAccountSigner(o) {
            return o < this.header.numRequiredSignatures
        }
        isAccountWritable(o) {
            const a = this.header.numRequiredSignatures;
            if (o >= this.header.numRequiredSignatures) {
                const $ = o - a,
                    _e = this.accountKeys.length - a - this.header.numReadonlyUnsignedAccounts;
                return $ < _e
            } else {
                const $ = a - this.header.numReadonlySignedAccounts;
                return o < $
            }
        }
        isProgramId(o) {
            return this.indexToProgramIds.has(o)
        }
        programIds() {
            return [...this.indexToProgramIds.values()]
        }
        nonProgramIds() {
            return this.accountKeys.filter((o, a) => !this.isProgramId(a))
        }
        serialize() {
            const o = this.accountKeys.length;
            let a = [];
            encodeLength$1(a, o);
            const $ = this.instructions.map(st => {
                const {
                    accounts: lt,
                    programIdIndex: ft
                } = st, yt = Array.from(bs58$5.decode(st.data));
                let bt = [];
                encodeLength$1(bt, lt.length);
                let ht = [];
                return encodeLength$1(ht, yt.length), {
                    programIdIndex: ft,
                    keyIndicesCount: buffer$1.Buffer.from(bt),
                    keyIndices: lt,
                    dataLength: buffer$1.Buffer.from(ht),
                    data: yt
                }
            });
            let j = [];
            encodeLength$1(j, $.length);
            let _e = buffer$1.Buffer.alloc(PACKET_DATA_SIZE$1);
            buffer$1.Buffer.from(j).copy(_e);
            let et = j.length;
            $.forEach(st => {
                const ft = struct$2([u8$2("programIdIndex"), blob$2(st.keyIndicesCount.length, "keyIndicesCount"), seq$1(u8$2("keyIndex"), st.keyIndices.length, "keyIndices"), blob$2(st.dataLength.length, "dataLength"), seq$1(u8$2("userdatum"), st.data.length, "data")]).encode(st, _e, et);
                et += ft
            }), _e = _e.slice(0, et);
            const tt = struct$2([blob$2(1, "numRequiredSignatures"), blob$2(1, "numReadonlySignedAccounts"), blob$2(1, "numReadonlyUnsignedAccounts"), blob$2(a.length, "keyCount"), seq$1(publicKey$4("key"), o, "keys"), publicKey$4("recentBlockhash")]),
                nt = {
                    numRequiredSignatures: buffer$1.Buffer.from([this.header.numRequiredSignatures]),
                    numReadonlySignedAccounts: buffer$1.Buffer.from([this.header.numReadonlySignedAccounts]),
                    numReadonlyUnsignedAccounts: buffer$1.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                    keyCount: buffer$1.Buffer.from(a),
                    keys: this.accountKeys.map(st => toBuffer$2(st.toBytes())),
                    recentBlockhash: bs58$5.decode(this.recentBlockhash)
                };
            let rt = buffer$1.Buffer.alloc(2048);
            const ot = tt.encode(nt, rt);
            return _e.copy(rt, ot), rt.slice(0, ot + _e.length)
        }
        static from(o) {
            let a = [...o];
            const $ = guardedShift$1(a);
            if ($ !== ($ & VERSION_PREFIX_MASK$1)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
            const j = guardedShift$1(a),
                _e = guardedShift$1(a),
                et = decodeLength$1(a);
            let tt = [];
            for (let lt = 0; lt < et; lt++) {
                const ft = guardedSplice$1(a, 0, PUBLIC_KEY_LENGTH$1);
                tt.push(new PublicKey$1(buffer$1.Buffer.from(ft)))
            }
            const nt = guardedSplice$1(a, 0, PUBLIC_KEY_LENGTH$1),
                rt = decodeLength$1(a);
            let ot = [];
            for (let lt = 0; lt < rt; lt++) {
                const ft = guardedShift$1(a),
                    yt = decodeLength$1(a),
                    bt = guardedSplice$1(a, 0, yt),
                    ht = decodeLength$1(a),
                    vt = guardedSplice$1(a, 0, ht),
                    wt = bs58$5.encode(buffer$1.Buffer.from(vt));
                ot.push({
                    programIdIndex: ft,
                    accounts: bt,
                    data: wt
                })
            }
            const st = {
                header: {
                    numRequiredSignatures: $,
                    numReadonlySignedAccounts: j,
                    numReadonlyUnsignedAccounts: _e
                },
                recentBlockhash: bs58$5.encode(buffer$1.Buffer.from(nt)),
                accountKeys: tt,
                instructions: ot
            };
            return new fr(st)
        }
    },
    MessageV0$1 = class pr {
        constructor(o) {
            this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = o.header, this.staticAccountKeys = o.staticAccountKeys, this.recentBlockhash = o.recentBlockhash, this.compiledInstructions = o.compiledInstructions, this.addressTableLookups = o.addressTableLookups
        }
        get version() {
            return 0
        }
        get numAccountKeysFromLookups() {
            let o = 0;
            for (const a of this.addressTableLookups) o += a.readonlyIndexes.length + a.writableIndexes.length;
            return o
        }
        getAccountKeys(o) {
            let a;
            if (o && "accountKeysFromLookups" in o && o.accountKeysFromLookups) {
                if (this.numAccountKeysFromLookups != o.accountKeysFromLookups.writable.length + o.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
                a = o.accountKeysFromLookups
            } else if (o && "addressLookupTableAccounts" in o && o.addressLookupTableAccounts) a = this.resolveAddressTableLookups(o.addressLookupTableAccounts);
            else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
            return new MessageAccountKeys$1(this.staticAccountKeys, a)
        }
        isAccountSigner(o) {
            return o < this.header.numRequiredSignatures
        }
        isAccountWritable(o) {
            const a = this.header.numRequiredSignatures,
                $ = this.staticAccountKeys.length;
            if (o >= $) {
                const j = o - $,
                    _e = this.addressTableLookups.reduce((et, tt) => et + tt.writableIndexes.length, 0);
                return j < _e
            } else if (o >= this.header.numRequiredSignatures) {
                const j = o - a,
                    et = $ - a - this.header.numReadonlyUnsignedAccounts;
                return j < et
            } else {
                const j = a - this.header.numReadonlySignedAccounts;
                return o < j
            }
        }
        resolveAddressTableLookups(o) {
            const a = {
                writable: [],
                readonly: []
            };
            for (const $ of this.addressTableLookups) {
                const j = o.find(_e => _e.key.equals($.accountKey));
                if (!j) throw new Error(`Failed to find address lookup table account for table key ${$.accountKey.toBase58()}`);
                for (const _e of $.writableIndexes)
                    if (_e < j.state.addresses.length) a.writable.push(j.state.addresses[_e]);
                    else throw new Error(`Failed to find address for index ${_e} in address lookup table ${$.accountKey.toBase58()}`);
                for (const _e of $.readonlyIndexes)
                    if (_e < j.state.addresses.length) a.readonly.push(j.state.addresses[_e]);
                    else throw new Error(`Failed to find address for index ${_e} in address lookup table ${$.accountKey.toBase58()}`)
            }
            return a
        }
        static compile(o) {
            const a = CompiledKeys$1.compile(o.instructions, o.payerKey),
                $ = new Array,
                j = {
                    writable: new Array,
                    readonly: new Array
                },
                _e = o.addressLookupTableAccounts || [];
            for (const ot of _e) {
                const st = a.extractTableLookup(ot);
                if (st !== void 0) {
                    const [lt, {
                        writable: ft,
                        readonly: yt
                    }] = st;
                    $.push(lt), j.writable.push(...ft), j.readonly.push(...yt)
                }
            }
            const [et, tt] = a.getMessageComponents(), rt = new MessageAccountKeys$1(tt, j).compileInstructions(o.instructions);
            return new pr({
                header: et,
                staticAccountKeys: tt,
                recentBlockhash: o.recentBlockhash,
                compiledInstructions: rt,
                addressTableLookups: $
            })
        }
        serialize() {
            const o = Array();
            encodeLength$1(o, this.staticAccountKeys.length);
            const a = this.serializeInstructions(),
                $ = Array();
            encodeLength$1($, this.compiledInstructions.length);
            const j = this.serializeAddressTableLookups(),
                _e = Array();
            encodeLength$1(_e, this.addressTableLookups.length);
            const et = struct$2([u8$2("prefix"), struct$2([u8$2("numRequiredSignatures"), u8$2("numReadonlySignedAccounts"), u8$2("numReadonlyUnsignedAccounts")], "header"), blob$2(o.length, "staticAccountKeysLength"), seq$1(publicKey$4(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey$4("recentBlockhash"), blob$2($.length, "instructionsLength"), blob$2(a.length, "serializedInstructions"), blob$2(_e.length, "addressTableLookupsLength"), blob$2(j.length, "serializedAddressTableLookups")]),
                tt = new Uint8Array(PACKET_DATA_SIZE$1),
                rt = et.encode({
                    prefix: 128,
                    header: this.header,
                    staticAccountKeysLength: new Uint8Array(o),
                    staticAccountKeys: this.staticAccountKeys.map(ot => ot.toBytes()),
                    recentBlockhash: bs58$5.decode(this.recentBlockhash),
                    instructionsLength: new Uint8Array($),
                    serializedInstructions: a,
                    addressTableLookupsLength: new Uint8Array(_e),
                    serializedAddressTableLookups: j
                }, tt);
            return tt.slice(0, rt)
        }
        serializeInstructions() {
            let o = 0;
            const a = new Uint8Array(PACKET_DATA_SIZE$1);
            for (const $ of this.compiledInstructions) {
                const j = Array();
                encodeLength$1(j, $.accountKeyIndexes.length);
                const _e = Array();
                encodeLength$1(_e, $.data.length);
                const et = struct$2([u8$2("programIdIndex"), blob$2(j.length, "encodedAccountKeyIndexesLength"), seq$1(u8$2(), $.accountKeyIndexes.length, "accountKeyIndexes"), blob$2(_e.length, "encodedDataLength"), blob$2($.data.length, "data")]);
                o += et.encode({
                    programIdIndex: $.programIdIndex,
                    encodedAccountKeyIndexesLength: new Uint8Array(j),
                    accountKeyIndexes: $.accountKeyIndexes,
                    encodedDataLength: new Uint8Array(_e),
                    data: $.data
                }, a, o)
            }
            return a.slice(0, o)
        }
        serializeAddressTableLookups() {
            let o = 0;
            const a = new Uint8Array(PACKET_DATA_SIZE$1);
            for (const $ of this.addressTableLookups) {
                const j = Array();
                encodeLength$1(j, $.writableIndexes.length);
                const _e = Array();
                encodeLength$1(_e, $.readonlyIndexes.length);
                const et = struct$2([publicKey$4("accountKey"), blob$2(j.length, "encodedWritableIndexesLength"), seq$1(u8$2(), $.writableIndexes.length, "writableIndexes"), blob$2(_e.length, "encodedReadonlyIndexesLength"), seq$1(u8$2(), $.readonlyIndexes.length, "readonlyIndexes")]);
                o += et.encode({
                    accountKey: $.accountKey.toBytes(),
                    encodedWritableIndexesLength: new Uint8Array(j),
                    writableIndexes: $.writableIndexes,
                    encodedReadonlyIndexesLength: new Uint8Array(_e),
                    readonlyIndexes: $.readonlyIndexes
                }, a, o)
            }
            return a.slice(0, o)
        }
        static deserialize(o) {
            let a = [...o];
            const $ = guardedShift$1(a),
                j = $ & VERSION_PREFIX_MASK$1;
            assert$4($ !== j, "Expected versioned message but received legacy message");
            const _e = j;
            assert$4(_e === 0, `Expected versioned message with version 0 but found version ${_e}`);
            const et = {
                    numRequiredSignatures: guardedShift$1(a),
                    numReadonlySignedAccounts: guardedShift$1(a),
                    numReadonlyUnsignedAccounts: guardedShift$1(a)
                },
                tt = [],
                nt = decodeLength$1(a);
            for (let yt = 0; yt < nt; yt++) tt.push(new PublicKey$1(guardedSplice$1(a, 0, PUBLIC_KEY_LENGTH$1)));
            const rt = bs58$5.encode(guardedSplice$1(a, 0, PUBLIC_KEY_LENGTH$1)),
                ot = decodeLength$1(a),
                st = [];
            for (let yt = 0; yt < ot; yt++) {
                const bt = guardedShift$1(a),
                    ht = decodeLength$1(a),
                    vt = guardedSplice$1(a, 0, ht),
                    wt = decodeLength$1(a),
                    gt = new Uint8Array(guardedSplice$1(a, 0, wt));
                st.push({
                    programIdIndex: bt,
                    accountKeyIndexes: vt,
                    data: gt
                })
            }
            const lt = decodeLength$1(a),
                ft = [];
            for (let yt = 0; yt < lt; yt++) {
                const bt = new PublicKey$1(guardedSplice$1(a, 0, PUBLIC_KEY_LENGTH$1)),
                    ht = decodeLength$1(a),
                    vt = guardedSplice$1(a, 0, ht),
                    wt = decodeLength$1(a),
                    gt = guardedSplice$1(a, 0, wt);
                ft.push({
                    accountKey: bt,
                    writableIndexes: vt,
                    readonlyIndexes: gt
                })
            }
            return new pr({
                header: et,
                staticAccountKeys: tt,
                recentBlockhash: rt,
                compiledInstructions: st,
                addressTableLookups: ft
            })
        }
    };
const VersionedMessage$1 = {
    deserializeMessageVersion(s) {
        const o = s[0],
            a = o & VERSION_PREFIX_MASK$1;
        return a === o ? "legacy" : a
    },
    deserialize: s => {
        const o = VersionedMessage$1.deserializeMessageVersion(s);
        if (o === "legacy") return Message$1.from(s);
        if (o === 0) return MessageV0$1.deserialize(s);
        throw new Error(`Transaction message version ${o} deserialization is not supported`)
    }
};
let TransactionStatus$1 = function(s) {
    return s[s.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", s[s.PROCESSED = 1] = "PROCESSED", s[s.TIMED_OUT = 2] = "TIMED_OUT", s[s.NONCE_INVALID = 3] = "NONCE_INVALID", s
}({});
const DEFAULT_SIGNATURE$1 = buffer$1.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES$2).fill(0);
let TransactionInstruction$1 = class {
        constructor(o) {
            this.keys = void 0, this.programId = void 0, this.data = buffer$1.Buffer.alloc(0), this.programId = o.programId, this.keys = o.keys, o.data && (this.data = o.data)
        }
        toJSON() {
            return {
                keys: this.keys.map(({
                    pubkey: o,
                    isSigner: a,
                    isWritable: $
                }) => ({
                    pubkey: o.toJSON(),
                    isSigner: a,
                    isWritable: $
                })),
                programId: this.programId.toJSON(),
                data: [...this.data]
            }
        }
    },
    Transaction$1 = class hr {
        get signature() {
            return this.signatures.length > 0 ? this.signatures[0].signature : null
        }
        constructor(o) {
            if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!o)
                if (o.feePayer && (this.feePayer = o.feePayer), o.signatures && (this.signatures = o.signatures), Object.prototype.hasOwnProperty.call(o, "nonceInfo")) {
                    const {
                        minContextSlot: a,
                        nonceInfo: $
                    } = o;
                    this.minNonceContextSlot = a, this.nonceInfo = $
                } else if (Object.prototype.hasOwnProperty.call(o, "lastValidBlockHeight")) {
                const {
                    blockhash: a,
                    lastValidBlockHeight: $
                } = o;
                this.recentBlockhash = a, this.lastValidBlockHeight = $
            } else {
                const {
                    recentBlockhash: a,
                    nonceInfo: $
                } = o;
                $ && (this.nonceInfo = $), this.recentBlockhash = a
            }
        }
        toJSON() {
            return {
                recentBlockhash: this.recentBlockhash || null,
                feePayer: this.feePayer ? this.feePayer.toJSON() : null,
                nonceInfo: this.nonceInfo ? {
                    nonce: this.nonceInfo.nonce,
                    nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
                } : null,
                instructions: this.instructions.map(o => o.toJSON()),
                signers: this.signatures.map(({
                    publicKey: o
                }) => o.toJSON())
            }
        }
        add(...o) {
            if (o.length === 0) throw new Error("No instructions");
            return o.forEach(a => {
                "instructions" in a ? this.instructions = this.instructions.concat(a.instructions) : "data" in a && "programId" in a && "keys" in a ? this.instructions.push(a) : this.instructions.push(new TransactionInstruction$1(a))
            }), this
        }
        compileMessage() {
            if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
            let o, a;
            if (this.nonceInfo ? (o = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? a = [this.nonceInfo.nonceInstruction, ...this.instructions] : a = this.instructions) : (o = this.recentBlockhash, a = this.instructions), !o) throw new Error("Transaction recentBlockhash required");
            a.length < 1 && console.warn("No instructions provided");
            let $;
            if (this.feePayer) $ = this.feePayer;
            else if (this.signatures.length > 0 && this.signatures[0].publicKey) $ = this.signatures[0].publicKey;
            else throw new Error("Transaction fee payer required");
            for (let bt = 0; bt < a.length; bt++)
                if (a[bt].programId === void 0) throw new Error(`Transaction instruction index ${bt} has undefined program id`);
            const j = [],
                _e = [];
            a.forEach(bt => {
                bt.keys.forEach(vt => {
                    _e.push({ ...vt
                    })
                });
                const ht = bt.programId.toString();
                j.includes(ht) || j.push(ht)
            }), j.forEach(bt => {
                _e.push({
                    pubkey: new PublicKey$1(bt),
                    isSigner: !1,
                    isWritable: !1
                })
            });
            const et = [];
            _e.forEach(bt => {
                const ht = bt.pubkey.toString(),
                    vt = et.findIndex(wt => wt.pubkey.toString() === ht);
                vt > -1 ? (et[vt].isWritable = et[vt].isWritable || bt.isWritable, et[vt].isSigner = et[vt].isSigner || bt.isSigner) : et.push(bt)
            }), et.sort(function(bt, ht) {
                if (bt.isSigner !== ht.isSigner) return bt.isSigner ? -1 : 1;
                if (bt.isWritable !== ht.isWritable) return bt.isWritable ? -1 : 1;
                const vt = {
                    localeMatcher: "best fit",
                    usage: "sort",
                    sensitivity: "variant",
                    ignorePunctuation: !1,
                    numeric: !1,
                    caseFirst: "lower"
                };
                return bt.pubkey.toBase58().localeCompare(ht.pubkey.toBase58(), "en", vt)
            });
            const tt = et.findIndex(bt => bt.pubkey.equals($));
            if (tt > -1) {
                const [bt] = et.splice(tt, 1);
                bt.isSigner = !0, bt.isWritable = !0, et.unshift(bt)
            } else et.unshift({
                pubkey: $,
                isSigner: !0,
                isWritable: !0
            });
            for (const bt of this.signatures) {
                const ht = et.findIndex(vt => vt.pubkey.equals(bt.publicKey));
                if (ht > -1) et[ht].isSigner || (et[ht].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
                else throw new Error(`unknown signer: ${bt.publicKey.toString()}`)
            }
            let nt = 0,
                rt = 0,
                ot = 0;
            const st = [],
                lt = [];
            et.forEach(({
                pubkey: bt,
                isSigner: ht,
                isWritable: vt
            }) => {
                ht ? (st.push(bt.toString()), nt += 1, vt || (rt += 1)) : (lt.push(bt.toString()), vt || (ot += 1))
            });
            const ft = st.concat(lt),
                yt = a.map(bt => {
                    const {
                        data: ht,
                        programId: vt
                    } = bt;
                    return {
                        programIdIndex: ft.indexOf(vt.toString()),
                        accounts: bt.keys.map(wt => ft.indexOf(wt.pubkey.toString())),
                        data: bs58$5.encode(ht)
                    }
                });
            return yt.forEach(bt => {
                assert$4(bt.programIdIndex >= 0), bt.accounts.forEach(ht => assert$4(ht >= 0))
            }), new Message$1({
                header: {
                    numRequiredSignatures: nt,
                    numReadonlySignedAccounts: rt,
                    numReadonlyUnsignedAccounts: ot
                },
                accountKeys: ft,
                recentBlockhash: o,
                instructions: yt
            })
        }
        _compile() {
            const o = this.compileMessage(),
                a = o.accountKeys.slice(0, o.header.numRequiredSignatures);
            return this.signatures.length === a.length && this.signatures.every((j, _e) => a[_e].equals(j.publicKey)) || (this.signatures = a.map($ => ({
                signature: null,
                publicKey: $
            }))), o
        }
        serializeMessage() {
            return this._compile().serialize()
        }
        async getEstimatedFee(o) {
            return (await o.getFeeForMessage(this.compileMessage())).value
        }
        setSigners(...o) {
            if (o.length === 0) throw new Error("No signers");
            const a = new Set;
            this.signatures = o.filter($ => {
                const j = $.toString();
                return a.has(j) ? !1 : (a.add(j), !0)
            }).map($ => ({
                signature: null,
                publicKey: $
            }))
        }
        sign(...o) {
            if (o.length === 0) throw new Error("No signers");
            const a = new Set,
                $ = [];
            for (const _e of o) {
                const et = _e.publicKey.toString();
                a.has(et) || (a.add(et), $.push(_e))
            }
            this.signatures = $.map(_e => ({
                signature: null,
                publicKey: _e.publicKey
            }));
            const j = this._compile();
            this._partialSign(j, ...$)
        }
        partialSign(...o) {
            if (o.length === 0) throw new Error("No signers");
            const a = new Set,
                $ = [];
            for (const _e of o) {
                const et = _e.publicKey.toString();
                a.has(et) || (a.add(et), $.push(_e))
            }
            const j = this._compile();
            this._partialSign(j, ...$)
        }
        _partialSign(o, ...a) {
            const $ = o.serialize();
            a.forEach(j => {
                const _e = sign$1($, j.secretKey);
                this._addSignature(j.publicKey, toBuffer$2(_e))
            })
        }
        addSignature(o, a) {
            this._compile(), this._addSignature(o, a)
        }
        _addSignature(o, a) {
            assert$4(a.length === 64);
            const $ = this.signatures.findIndex(j => o.equals(j.publicKey));
            if ($ < 0) throw new Error(`unknown signer: ${o.toString()}`);
            this.signatures[$].signature = buffer$1.Buffer.from(a)
        }
        verifySignatures(o = !0) {
            return !this._getMessageSignednessErrors(this.serializeMessage(), o)
        }
        _getMessageSignednessErrors(o, a) {
            const $ = {};
            for (const {
                    signature: j,
                    publicKey: _e
                } of this.signatures) j === null ? a && ($.missing || ($.missing = [])).push(_e) : verify$1(j, o, _e.toBytes()) || ($.invalid || ($.invalid = [])).push(_e);
            return $.invalid || $.missing ? $ : void 0
        }
        serialize(o) {
            const {
                requireAllSignatures: a,
                verifySignatures: $
            } = Object.assign({
                requireAllSignatures: !0,
                verifySignatures: !0
            }, o), j = this.serializeMessage();
            if ($) {
                const _e = this._getMessageSignednessErrors(j, a);
                if (_e) {
                    let et = "Signature verification failed.";
                    throw _e.invalid && (et += `
Invalid signature for public key${_e.invalid.length===1?"":"(s)"} [\`${_e.invalid.map(tt=>tt.toBase58()).join("`, `")}\`].`), _e.missing && (et += `
Missing signature for public key${_e.missing.length===1?"":"(s)"} [\`${_e.missing.map(tt=>tt.toBase58()).join("`, `")}\`].`), new Error(et)
                }
            }
            return this._serialize(j)
        }
        _serialize(o) {
            const {
                signatures: a
            } = this, $ = [];
            encodeLength$1($, a.length);
            const j = $.length + a.length * 64 + o.length,
                _e = buffer$1.Buffer.alloc(j);
            return assert$4(a.length < 256), buffer$1.Buffer.from($).copy(_e, 0), a.forEach(({
                signature: et
            }, tt) => {
                et !== null && (assert$4(et.length === 64, "signature has invalid length"), buffer$1.Buffer.from(et).copy(_e, $.length + tt * 64))
            }), o.copy(_e, $.length + a.length * 64), assert$4(_e.length <= PACKET_DATA_SIZE$1, `Transaction too large: ${_e.length} > ${PACKET_DATA_SIZE$1}`), _e
        }
        get keys() {
            return assert$4(this.instructions.length === 1), this.instructions[0].keys.map(o => o.pubkey)
        }
        get programId() {
            return assert$4(this.instructions.length === 1), this.instructions[0].programId
        }
        get data() {
            return assert$4(this.instructions.length === 1), this.instructions[0].data
        }
        static from(o) {
            let a = [...o];
            const $ = decodeLength$1(a);
            let j = [];
            for (let _e = 0; _e < $; _e++) {
                const et = guardedSplice$1(a, 0, SIGNATURE_LENGTH_IN_BYTES$2);
                j.push(bs58$5.encode(buffer$1.Buffer.from(et)))
            }
            return hr.populate(Message$1.from(a), j)
        }
        static populate(o, a = []) {
            const $ = new hr;
            return $.recentBlockhash = o.recentBlockhash, o.header.numRequiredSignatures > 0 && ($.feePayer = o.accountKeys[0]), a.forEach((j, _e) => {
                const et = {
                    signature: j == bs58$5.encode(DEFAULT_SIGNATURE$1) ? null : bs58$5.decode(j),
                    publicKey: o.accountKeys[_e]
                };
                $.signatures.push(et)
            }), o.instructions.forEach(j => {
                const _e = j.accounts.map(et => {
                    const tt = o.accountKeys[et];
                    return {
                        pubkey: tt,
                        isSigner: $.signatures.some(nt => nt.publicKey.toString() === tt.toString()) || o.isAccountSigner(et),
                        isWritable: o.isAccountWritable(et)
                    }
                });
                $.instructions.push(new TransactionInstruction$1({
                    keys: _e,
                    programId: o.accountKeys[j.programIdIndex],
                    data: bs58$5.decode(j.data)
                }))
            }), $._message = o, $._json = $.toJSON(), $
        }
    },
    VersionedTransaction$1 = class gr {
        get version() {
            return this.message.version
        }
        constructor(o, a) {
            if (this.signatures = void 0, this.message = void 0, a !== void 0) assert$4(a.length === o.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = a;
            else {
                const $ = [];
                for (let j = 0; j < o.header.numRequiredSignatures; j++) $.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES$2));
                this.signatures = $
            }
            this.message = o
        }
        serialize() {
            const o = this.message.serialize(),
                a = Array();
            encodeLength$1(a, this.signatures.length);
            const $ = struct$2([blob$2(a.length, "encodedSignaturesLength"), seq$1(signature$1(), this.signatures.length, "signatures"), blob$2(o.length, "serializedMessage")]),
                j = new Uint8Array(2048),
                _e = $.encode({
                    encodedSignaturesLength: new Uint8Array(a),
                    signatures: this.signatures,
                    serializedMessage: o
                }, j);
            return j.slice(0, _e)
        }
        static deserialize(o) {
            let a = [...o];
            const $ = [],
                j = decodeLength$1(a);
            for (let et = 0; et < j; et++) $.push(new Uint8Array(guardedSplice$1(a, 0, SIGNATURE_LENGTH_IN_BYTES$2)));
            const _e = VersionedMessage$1.deserialize(new Uint8Array(a));
            return new gr(_e, $)
        }
        sign(o) {
            const a = this.message.serialize(),
                $ = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
            for (const j of o) {
                const _e = $.findIndex(et => et.equals(j.publicKey));
                assert$4(_e >= 0, `Cannot sign with non signer key ${j.publicKey.toBase58()}`), this.signatures[_e] = sign$1(a, j.secretKey)
            }
        }
        addSignature(o, a) {
            assert$4(a.byteLength === 64, "Signature must be 64 bytes long");
            const j = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(_e => _e.equals(o));
            assert$4(j >= 0, `Can not add signature; \`${o.toBase58()}\` is not required to sign this transaction`), this.signatures[j] = a
        }
    };
const NUM_TICKS_PER_SECOND$1 = 160,
    DEFAULT_TICKS_PER_SLOT$1 = 64,
    NUM_SLOTS_PER_SECOND$1 = NUM_TICKS_PER_SECOND$1 / DEFAULT_TICKS_PER_SLOT$1,
    MS_PER_SLOT$1 = 1e3 / NUM_SLOTS_PER_SECOND$1;
new PublicKey$1("SysvarC1ock11111111111111111111111111111111");
new PublicKey$1("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey$1("Sysvar1nstructions1111111111111111111111111");
new PublicKey$1("SysvarRecentB1ockHashes11111111111111111111");
new PublicKey$1("SysvarRent111111111111111111111111111111111");
new PublicKey$1("SysvarRewards111111111111111111111111111111");
new PublicKey$1("SysvarS1otHashes111111111111111111111111111");
new PublicKey$1("SysvarS1otHistory11111111111111111111111111");
new PublicKey$1("SysvarStakeHistory1111111111111111111111111");
let SendTransactionError$1 = class extends Error {
        constructor({
            action: o,
            signature: a,
            transactionMessage: $,
            logs: j
        }) {
            const _e = j ? `Logs: 
${JSON.stringify(j.slice(-10),null,2)}. ` : "",
                et = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
            let tt;
            switch (o) {
                case "send":
                    tt = `Transaction ${a} resulted in an error. 
${$}. ` + _e + et;
                    break;
                case "simulate":
                    tt = `Simulation failed. 
Message: ${$}. 
` + _e + et;
                    break;
                default:
                    tt = `Unknown action '${(nt=>nt)(o)}'`
            }
            super(tt), this.signature = void 0, this.transactionMessage = void 0, this.transactionLogs = void 0, this.signature = a, this.transactionMessage = $, this.transactionLogs = j || void 0
        }
        get transactionError() {
            return {
                message: this.transactionMessage,
                logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
            }
        }
        get logs() {
            const o = this.transactionLogs;
            if (!(o != null && typeof o == "object" && "then" in o)) return o
        }
        async getLogs(o) {
            return Array.isArray(this.transactionLogs) || (this.transactionLogs = new Promise((a, $) => {
                o.getTransaction(this.signature).then(j => {
                    if (j && j.meta && j.meta.logMessages) {
                        const _e = j.meta.logMessages;
                        this.transactionLogs = _e, a(_e)
                    } else $(new Error("Log messages not found"))
                }).catch($)
            })), await this.transactionLogs
        }
    },
    SolanaJSONRPCError$1 = class extends Error {
        constructor({
            code: o,
            message: a,
            data: $
        }, j) {
            super(j != null ? `${j}: ${a}` : a), this.code = void 0, this.data = void 0, this.code = o, this.data = $, this.name = "SolanaJSONRPCError"
        }
    };

function sleep$1(s) {
    return new Promise(o => setTimeout(o, s))
}
const FeeCalculatorLayout$1 = nu64$2("lamportsPerSignature"),
    NonceAccountLayout$1 = struct$2([u32$3("version"), u32$3("state"), publicKey$4("authorizedPubkey"), publicKey$4("nonce"), struct$2([FeeCalculatorLayout$1], "feeCalculator")]);
NonceAccountLayout$1.span;
let NonceAccount$1 = class yr {
    constructor(o) {
        this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = o.authorizedPubkey, this.nonce = o.nonce, this.feeCalculator = o.feeCalculator
    }
    static fromAccountData(o) {
        const a = NonceAccountLayout$1.decode(toBuffer$2(o), 0);
        return new yr({
            authorizedPubkey: new PublicKey$1(a.authorizedPubkey),
            nonce: new PublicKey$1(a.nonce).toString(),
            feeCalculator: a.feeCalculator
        })
    }
};
const encodeDecode$1 = s => {
        const o = s.decode.bind(s),
            a = s.encode.bind(s);
        return {
            decode: o,
            encode: a
        }
    },
    bigInt$1 = s => o => {
        const a = blob$2(s, o),
            {
                encode: $,
                decode: j
            } = encodeDecode$1(a),
            _e = a;
        return _e.decode = (et, tt) => {
            const nt = j(et, tt);
            return toBigIntLE_1$1(buffer$1.Buffer.from(nt))
        }, _e.encode = (et, tt, nt) => {
            const rt = toBufferLE_1$1(et, s);
            return $(rt, tt, nt)
        }, _e
    },
    u64$3 = bigInt$1(8);
Object.freeze({
    Create: {
        index: 0,
        layout: struct$2([u32$3("instruction"), ns64$2("lamports"), ns64$2("space"), publicKey$4("programId")])
    },
    Assign: {
        index: 1,
        layout: struct$2([u32$3("instruction"), publicKey$4("programId")])
    },
    Transfer: {
        index: 2,
        layout: struct$2([u32$3("instruction"), u64$3("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: struct$2([u32$3("instruction"), publicKey$4("base"), rustString$1("seed"), ns64$2("lamports"), ns64$2("space"), publicKey$4("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: struct$2([u32$3("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: struct$2([u32$3("instruction"), ns64$2("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: struct$2([u32$3("instruction"), publicKey$4("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: struct$2([u32$3("instruction"), publicKey$4("authorized")])
    },
    Allocate: {
        index: 8,
        layout: struct$2([u32$3("instruction"), ns64$2("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: struct$2([u32$3("instruction"), publicKey$4("base"), rustString$1("seed"), ns64$2("space"), publicKey$4("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: struct$2([u32$3("instruction"), publicKey$4("base"), rustString$1("seed"), publicKey$4("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: struct$2([u32$3("instruction"), u64$3("lamports"), rustString$1("seed"), publicKey$4("programId")])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: struct$2([u32$3("instruction")])
    }
});
new PublicKey$1("11111111111111111111111111111111");
new PublicKey$1("BPFLoader2111111111111111111111111111111111");

function getDefaultExportFromCjs$2(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}
var objToString$1 = Object.prototype.toString,
    objKeys$1 = Object.keys || function(s) {
        var o = [];
        for (var a in s) o.push(a);
        return o
    };

function stringify$2(s, o) {
    var a, $, j, _e, et, tt, nt;
    if (s === !0) return "true";
    if (s === !1) return "false";
    switch (typeof s) {
        case "object":
            if (s === null) return null;
            if (s.toJSON && typeof s.toJSON == "function") return stringify$2(s.toJSON(), o);
            if (nt = objToString$1.call(s), nt === "[object Array]") {
                for (j = "[", $ = s.length - 1, a = 0; a < $; a++) j += stringify$2(s[a], !0) + ",";
                return $ > -1 && (j += stringify$2(s[a], !0)), j + "]"
            } else if (nt === "[object Object]") {
                for (_e = objKeys$1(s).sort(), $ = _e.length, j = "", a = 0; a < $;) et = _e[a], tt = stringify$2(s[et], !1), tt !== void 0 && (j && (j += ","), j += JSON.stringify(et) + ":" + tt), a++;
                return "{" + j + "}"
            } else return JSON.stringify(s);
        case "function":
        case "undefined":
            return o ? null : void 0;
        case "string":
            return JSON.stringify(s);
        default:
            return isFinite(s) ? s : null
    }
}
var fastStableStringify$2 = function(s) {
        var o = stringify$2(s, !1);
        if (o !== void 0) return "" + o
    },
    fastStableStringify$1$1 = getDefaultExportFromCjs$2(fastStableStringify$2);
const MINIMUM_SLOT_PER_EPOCH$1 = 32;

function trailingZeros$1(s) {
    let o = 0;
    for (; s > 1;) s /= 2, o++;
    return o
}

function nextPowerOfTwo$1(s) {
    return s === 0 ? 1 : (s--, s |= s >> 1, s |= s >> 2, s |= s >> 4, s |= s >> 8, s |= s >> 16, s |= s >> 32, s + 1)
}
let EpochSchedule$1 = class {
    constructor(o, a, $, j, _e) {
        this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = o, this.leaderScheduleSlotOffset = a, this.warmup = $, this.firstNormalEpoch = j, this.firstNormalSlot = _e
    }
    getEpoch(o) {
        return this.getEpochAndSlotIndex(o)[0]
    }
    getEpochAndSlotIndex(o) {
        if (o < this.firstNormalSlot) {
            const a = trailingZeros$1(nextPowerOfTwo$1(o + MINIMUM_SLOT_PER_EPOCH$1 + 1)) - trailingZeros$1(MINIMUM_SLOT_PER_EPOCH$1) - 1,
                $ = this.getSlotsInEpoch(a),
                j = o - ($ - MINIMUM_SLOT_PER_EPOCH$1);
            return [a, j]
        } else {
            const a = o - this.firstNormalSlot,
                $ = Math.floor(a / this.slotsPerEpoch),
                j = this.firstNormalEpoch + $,
                _e = a % this.slotsPerEpoch;
            return [j, _e]
        }
    }
    getFirstSlotInEpoch(o) {
        return o <= this.firstNormalEpoch ? (Math.pow(2, o) - 1) * MINIMUM_SLOT_PER_EPOCH$1 : (o - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }
    getLastSlotInEpoch(o) {
        return this.getFirstSlotInEpoch(o) + this.getSlotsInEpoch(o) - 1
    }
    getSlotsInEpoch(o) {
        return o < this.firstNormalEpoch ? Math.pow(2, o + trailingZeros$1(MINIMUM_SLOT_PER_EPOCH$1)) : this.slotsPerEpoch
    }
};
var fetchImpl$1 = globalThis.fetch;
let RpcWebSocketClient$1 = class extends CommonClient$1 {
    constructor(o, a, $) {
        const j = _e => {
            const et = WebSocket$2(_e, {
                autoconnect: !0,
                max_reconnects: 5,
                reconnect: !0,
                reconnect_interval: 1e3,
                ...a
            });
            return "socket" in et ? this.underlyingSocket = et.socket : this.underlyingSocket = et, et
        };
        super(j, o, a, $), this.underlyingSocket = void 0
    }
    call(...o) {
        var $;
        const a = ($ = this.underlyingSocket) == null ? void 0 : $.readyState;
        return a === 1 ? super.call(...o) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + o[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + a + ")"))
    }
    notify(...o) {
        var $;
        const a = ($ = this.underlyingSocket) == null ? void 0 : $.readyState;
        return a === 1 ? super.notify(...o) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + o[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + a + ")"))
    }
};

function decodeData$2(s, o) {
    let a;
    try {
        a = s.layout.decode(o)
    } catch ($) {
        throw new Error("invalid instruction; " + $)
    }
    if (a.typeIndex !== s.index) throw new Error(`invalid account data; account type mismatch ${a.typeIndex} != ${s.index}`);
    return a
}
const LOOKUP_TABLE_META_SIZE$1 = 56;
let AddressLookupTableAccount$1 = class {
    constructor(o) {
        this.key = void 0, this.state = void 0, this.key = o.key, this.state = o.state
    }
    isActive() {
        const o = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === o
    }
    static deserialize(o) {
        const a = decodeData$2(LookupTableMetaLayout$1, o),
            $ = o.length - LOOKUP_TABLE_META_SIZE$1;
        assert$4($ >= 0, "lookup table is invalid"), assert$4($ % 32 === 0, "lookup table is invalid");
        const j = $ / 32,
            {
                addresses: _e
            } = struct$2([seq$1(publicKey$4(), j, "addresses")]).decode(o.slice(LOOKUP_TABLE_META_SIZE$1));
        return {
            deactivationSlot: a.deactivationSlot,
            lastExtendedSlot: a.lastExtendedSlot,
            lastExtendedSlotStartIndex: a.lastExtendedStartIndex,
            authority: a.authority.length !== 0 ? new PublicKey$1(a.authority[0]) : void 0,
            addresses: _e.map(et => new PublicKey$1(et))
        }
    }
};
const LookupTableMetaLayout$1 = {
        index: 1,
        layout: struct$2([u32$3("typeIndex"), u64$3("deactivationSlot"), nu64$2("lastExtendedSlot"), u8$2("lastExtendedStartIndex"), u8$2(), seq$1(publicKey$4(), offset$2(u8$2(), -1), "authority")])
    },
    URL_RE$1 = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;

function makeWebsocketUrl$1(s) {
    const o = s.match(URL_RE$1);
    if (o == null) throw TypeError(`Failed to validate endpoint URL \`${s}\``);
    const [a, $, j, _e] = o, et = s.startsWith("https:") ? "wss:" : "ws:", tt = j == null ? null : parseInt(j.slice(1), 10), nt = tt == null ? "" : `:${tt+1}`;
    return `${et}//${$}${nt}${_e}`
}
const PublicKeyFromString$1 = coerce$2(instance$1(PublicKey$1), string$2(), s => new PublicKey$1(s)),
    RawAccountDataResult$1 = tuple$1([string$2(), literal$2("base64")]),
    BufferFromRawAccountData$1 = coerce$2(instance$1(buffer$1.Buffer), RawAccountDataResult$1, s => buffer$1.Buffer.from(s[0], "base64")),
    BLOCKHASH_CACHE_TIMEOUT_MS$1 = 30 * 1e3;

function assertEndpointUrl$1(s) {
    if (/^https?:/.test(s) === !1) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return s
}

function extractCommitmentFromConfig$1(s) {
    let o, a;
    if (typeof s == "string") o = s;
    else if (s) {
        const {
            commitment: $,
            ...j
        } = s;
        o = $, a = j
    }
    return {
        commitment: o,
        config: a
    }
}

function applyDefaultMemcmpEncodingToFilters$1(s) {
    return s.map(o => "memcmp" in o ? { ...o,
        memcmp: { ...o.memcmp,
            encoding: o.memcmp.encoding ? ? "base58"
        }
    } : o)
}

function createRpcResult$2(s) {
    return union$3([type$3({
        jsonrpc: literal$2("2.0"),
        id: string$2(),
        result: s
    }), type$3({
        jsonrpc: literal$2("2.0"),
        id: string$2(),
        error: type$3({
            code: unknown$2(),
            message: string$2(),
            data: optional$2(any$2())
        })
    })])
}
const UnknownRpcResult$2 = createRpcResult$2(unknown$2());

function jsonRpcResult$2(s) {
    return coerce$2(createRpcResult$2(s), UnknownRpcResult$2, o => "error" in o ? o : { ...o,
        result: create$2(o.result, s)
    })
}

function jsonRpcResultAndContext$2(s) {
    return jsonRpcResult$2(type$3({
        context: type$3({
            slot: number$3()
        }),
        value: s
    }))
}

function notificationResultAndContext$1(s) {
    return type$3({
        context: type$3({
            slot: number$3()
        }),
        value: s
    })
}

function versionedMessageFromResponse$1(s, o) {
    return s === 0 ? new MessageV0$1({
        header: o.header,
        staticAccountKeys: o.accountKeys.map(a => new PublicKey$1(a)),
        recentBlockhash: o.recentBlockhash,
        compiledInstructions: o.instructions.map(a => ({
            programIdIndex: a.programIdIndex,
            accountKeyIndexes: a.accounts,
            data: bs58$5.decode(a.data)
        })),
        addressTableLookups: o.addressTableLookups
    }) : new Message$1(o)
}
const GetInflationGovernorResult$1 = type$3({
        foundation: number$3(),
        foundationTerm: number$3(),
        initial: number$3(),
        taper: number$3(),
        terminal: number$3()
    }),
    GetInflationRewardResult$1 = jsonRpcResult$2(array$2(nullable$2(type$3({
        epoch: number$3(),
        effectiveSlot: number$3(),
        amount: number$3(),
        postBalance: number$3(),
        commission: optional$2(nullable$2(number$3()))
    })))),
    GetRecentPrioritizationFeesResult$1 = array$2(type$3({
        slot: number$3(),
        prioritizationFee: number$3()
    })),
    GetInflationRateResult$1 = type$3({
        total: number$3(),
        validator: number$3(),
        foundation: number$3(),
        epoch: number$3()
    }),
    GetEpochInfoResult$1 = type$3({
        epoch: number$3(),
        slotIndex: number$3(),
        slotsInEpoch: number$3(),
        absoluteSlot: number$3(),
        blockHeight: optional$2(number$3()),
        transactionCount: optional$2(number$3())
    }),
    GetEpochScheduleResult$1 = type$3({
        slotsPerEpoch: number$3(),
        leaderScheduleSlotOffset: number$3(),
        warmup: boolean$2(),
        firstNormalEpoch: number$3(),
        firstNormalSlot: number$3()
    }),
    GetLeaderScheduleResult$1 = record$1(string$2(), array$2(number$3())),
    TransactionErrorResult$1 = nullable$2(union$3([type$3({}), string$2()])),
    SignatureStatusResult$1 = type$3({
        err: TransactionErrorResult$1
    }),
    SignatureReceivedResult$1 = literal$2("receivedSignature"),
    VersionResult$1 = type$3({
        "solana-core": string$2(),
        "feature-set": optional$2(number$3())
    }),
    ParsedInstructionStruct$1 = type$3({
        program: string$2(),
        programId: PublicKeyFromString$1,
        parsed: unknown$2()
    }),
    PartiallyDecodedInstructionStruct$1 = type$3({
        programId: PublicKeyFromString$1,
        accounts: array$2(PublicKeyFromString$1),
        data: string$2()
    }),
    SimulatedTransactionResponseStruct$2 = jsonRpcResultAndContext$2(type$3({
        err: nullable$2(union$3([type$3({}), string$2()])),
        logs: nullable$2(array$2(string$2())),
        accounts: optional$2(nullable$2(array$2(nullable$2(type$3({
            executable: boolean$2(),
            owner: string$2(),
            lamports: number$3(),
            data: array$2(string$2()),
            rentEpoch: optional$2(number$3())
        }))))),
        unitsConsumed: optional$2(number$3()),
        returnData: optional$2(nullable$2(type$3({
            programId: string$2(),
            data: tuple$1([string$2(), literal$2("base64")])
        }))),
        innerInstructions: optional$2(nullable$2(array$2(type$3({
            index: number$3(),
            instructions: array$2(union$3([ParsedInstructionStruct$1, PartiallyDecodedInstructionStruct$1]))
        }))))
    })),
    BlockProductionResponseStruct$1 = jsonRpcResultAndContext$2(type$3({
        byIdentity: record$1(string$2(), array$2(number$3())),
        range: type$3({
            firstSlot: number$3(),
            lastSlot: number$3()
        })
    }));

function createRpcClient$1(s, o, a, $, j, _e) {
    const et = a || fetchImpl$1;
    let tt;
    _e != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    let nt;
    return $ && (nt = async (ot, st) => {
        const lt = await new Promise((ft, yt) => {
            try {
                $(ot, st, (bt, ht) => ft([bt, ht]))
            } catch (bt) {
                yt(bt)
            }
        });
        return await et(...lt)
    }), new RpcClient$1(async (ot, st) => {
        const lt = {
            method: "POST",
            body: ot,
            agent: tt,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, o || {}, COMMON_HTTP_HEADERS$1)
        };
        try {
            let ft = 5,
                yt, bt = 500;
            for (; nt ? yt = await nt(s, lt) : yt = await et(s, lt), !(yt.status !== 429 || j === !0 || (ft -= 1, ft === 0));) console.error(`Server responded with ${yt.status} ${yt.statusText}.  Retrying after ${bt}ms delay...`), await sleep$1(bt), bt *= 2;
            const ht = await yt.text();
            yt.ok ? st(null, ht) : st(new Error(`${yt.status} ${yt.statusText}: ${ht}`))
        } catch (ft) {
            ft instanceof Error && st(ft)
        }
    }, {})
}

function createRpcRequest$1(s) {
    return (o, a) => new Promise(($, j) => {
        s.request(o, a, (_e, et) => {
            if (_e) {
                j(_e);
                return
            }
            $(et)
        })
    })
}

function createRpcBatchRequest$1(s) {
    return o => new Promise((a, $) => {
        o.length === 0 && a([]);
        const j = o.map(_e => s.request(_e.methodName, _e.args));
        s.request(j, (_e, et) => {
            if (_e) {
                $(_e);
                return
            }
            a(et)
        })
    })
}
const GetInflationGovernorRpcResult$1 = jsonRpcResult$2(GetInflationGovernorResult$1),
    GetInflationRateRpcResult$1 = jsonRpcResult$2(GetInflationRateResult$1),
    GetRecentPrioritizationFeesRpcResult$1 = jsonRpcResult$2(GetRecentPrioritizationFeesResult$1),
    GetEpochInfoRpcResult$1 = jsonRpcResult$2(GetEpochInfoResult$1),
    GetEpochScheduleRpcResult$1 = jsonRpcResult$2(GetEpochScheduleResult$1),
    GetLeaderScheduleRpcResult$1 = jsonRpcResult$2(GetLeaderScheduleResult$1),
    SlotRpcResult$1 = jsonRpcResult$2(number$3()),
    GetSupplyRpcResult$1 = jsonRpcResultAndContext$2(type$3({
        total: number$3(),
        circulating: number$3(),
        nonCirculating: number$3(),
        nonCirculatingAccounts: array$2(PublicKeyFromString$1)
    })),
    TokenAmountResult$1 = type$3({
        amount: string$2(),
        uiAmount: nullable$2(number$3()),
        decimals: number$3(),
        uiAmountString: optional$2(string$2())
    }),
    GetTokenLargestAccountsResult$1 = jsonRpcResultAndContext$2(array$2(type$3({
        address: PublicKeyFromString$1,
        amount: string$2(),
        uiAmount: nullable$2(number$3()),
        decimals: number$3(),
        uiAmountString: optional$2(string$2())
    }))),
    GetTokenAccountsByOwner$1 = jsonRpcResultAndContext$2(array$2(type$3({
        pubkey: PublicKeyFromString$1,
        account: type$3({
            executable: boolean$2(),
            owner: PublicKeyFromString$1,
            lamports: number$3(),
            data: BufferFromRawAccountData$1,
            rentEpoch: number$3()
        })
    }))),
    ParsedAccountDataResult$1 = type$3({
        program: string$2(),
        parsed: unknown$2(),
        space: number$3()
    }),
    GetParsedTokenAccountsByOwner$1 = jsonRpcResultAndContext$2(array$2(type$3({
        pubkey: PublicKeyFromString$1,
        account: type$3({
            executable: boolean$2(),
            owner: PublicKeyFromString$1,
            lamports: number$3(),
            data: ParsedAccountDataResult$1,
            rentEpoch: number$3()
        })
    }))),
    GetLargestAccountsRpcResult$1 = jsonRpcResultAndContext$2(array$2(type$3({
        lamports: number$3(),
        address: PublicKeyFromString$1
    }))),
    AccountInfoResult$1 = type$3({
        executable: boolean$2(),
        owner: PublicKeyFromString$1,
        lamports: number$3(),
        data: BufferFromRawAccountData$1,
        rentEpoch: number$3()
    }),
    KeyedAccountInfoResult$1 = type$3({
        pubkey: PublicKeyFromString$1,
        account: AccountInfoResult$1
    }),
    ParsedOrRawAccountData$1 = coerce$2(union$3([instance$1(buffer$1.Buffer), ParsedAccountDataResult$1]), union$3([RawAccountDataResult$1, ParsedAccountDataResult$1]), s => Array.isArray(s) ? create$2(s, BufferFromRawAccountData$1) : s),
    ParsedAccountInfoResult$1 = type$3({
        executable: boolean$2(),
        owner: PublicKeyFromString$1,
        lamports: number$3(),
        data: ParsedOrRawAccountData$1,
        rentEpoch: number$3()
    }),
    KeyedParsedAccountInfoResult$1 = type$3({
        pubkey: PublicKeyFromString$1,
        account: ParsedAccountInfoResult$1
    }),
    StakeActivationResult$1 = type$3({
        state: union$3([literal$2("active"), literal$2("inactive"), literal$2("activating"), literal$2("deactivating")]),
        active: number$3(),
        inactive: number$3()
    }),
    GetConfirmedSignaturesForAddress2RpcResult$1 = jsonRpcResult$2(array$2(type$3({
        signature: string$2(),
        slot: number$3(),
        err: TransactionErrorResult$1,
        memo: nullable$2(string$2()),
        blockTime: optional$2(nullable$2(number$3()))
    }))),
    GetSignaturesForAddressRpcResult$1 = jsonRpcResult$2(array$2(type$3({
        signature: string$2(),
        slot: number$3(),
        err: TransactionErrorResult$1,
        memo: nullable$2(string$2()),
        blockTime: optional$2(nullable$2(number$3()))
    }))),
    AccountNotificationResult$1 = type$3({
        subscription: number$3(),
        result: notificationResultAndContext$1(AccountInfoResult$1)
    }),
    ProgramAccountInfoResult$1 = type$3({
        pubkey: PublicKeyFromString$1,
        account: AccountInfoResult$1
    }),
    ProgramAccountNotificationResult$1 = type$3({
        subscription: number$3(),
        result: notificationResultAndContext$1(ProgramAccountInfoResult$1)
    }),
    SlotInfoResult$1 = type$3({
        parent: number$3(),
        slot: number$3(),
        root: number$3()
    }),
    SlotNotificationResult$1 = type$3({
        subscription: number$3(),
        result: SlotInfoResult$1
    }),
    SlotUpdateResult$1 = union$3([type$3({
        type: union$3([literal$2("firstShredReceived"), literal$2("completed"), literal$2("optimisticConfirmation"), literal$2("root")]),
        slot: number$3(),
        timestamp: number$3()
    }), type$3({
        type: literal$2("createdBank"),
        parent: number$3(),
        slot: number$3(),
        timestamp: number$3()
    }), type$3({
        type: literal$2("frozen"),
        slot: number$3(),
        timestamp: number$3(),
        stats: type$3({
            numTransactionEntries: number$3(),
            numSuccessfulTransactions: number$3(),
            numFailedTransactions: number$3(),
            maxTransactionsPerEntry: number$3()
        })
    }), type$3({
        type: literal$2("dead"),
        slot: number$3(),
        timestamp: number$3(),
        err: string$2()
    })]),
    SlotUpdateNotificationResult$1 = type$3({
        subscription: number$3(),
        result: SlotUpdateResult$1
    }),
    SignatureNotificationResult$1 = type$3({
        subscription: number$3(),
        result: notificationResultAndContext$1(union$3([SignatureStatusResult$1, SignatureReceivedResult$1]))
    }),
    RootNotificationResult$1 = type$3({
        subscription: number$3(),
        result: number$3()
    }),
    ContactInfoResult$1 = type$3({
        pubkey: string$2(),
        gossip: nullable$2(string$2()),
        tpu: nullable$2(string$2()),
        rpc: nullable$2(string$2()),
        version: nullable$2(string$2())
    }),
    VoteAccountInfoResult$1 = type$3({
        votePubkey: string$2(),
        nodePubkey: string$2(),
        activatedStake: number$3(),
        epochVoteAccount: boolean$2(),
        epochCredits: array$2(tuple$1([number$3(), number$3(), number$3()])),
        commission: number$3(),
        lastVote: number$3(),
        rootSlot: nullable$2(number$3())
    }),
    GetVoteAccounts$1 = jsonRpcResult$2(type$3({
        current: array$2(VoteAccountInfoResult$1),
        delinquent: array$2(VoteAccountInfoResult$1)
    })),
    ConfirmationStatus$1 = union$3([literal$2("processed"), literal$2("confirmed"), literal$2("finalized")]),
    SignatureStatusResponse$1 = type$3({
        slot: number$3(),
        confirmations: nullable$2(number$3()),
        err: TransactionErrorResult$1,
        confirmationStatus: optional$2(ConfirmationStatus$1)
    }),
    GetSignatureStatusesRpcResult$1 = jsonRpcResultAndContext$2(array$2(nullable$2(SignatureStatusResponse$1))),
    GetMinimumBalanceForRentExemptionRpcResult$1 = jsonRpcResult$2(number$3()),
    AddressTableLookupStruct$1 = type$3({
        accountKey: PublicKeyFromString$1,
        writableIndexes: array$2(number$3()),
        readonlyIndexes: array$2(number$3())
    }),
    ConfirmedTransactionResult$1 = type$3({
        signatures: array$2(string$2()),
        message: type$3({
            accountKeys: array$2(string$2()),
            header: type$3({
                numRequiredSignatures: number$3(),
                numReadonlySignedAccounts: number$3(),
                numReadonlyUnsignedAccounts: number$3()
            }),
            instructions: array$2(type$3({
                accounts: array$2(number$3()),
                data: string$2(),
                programIdIndex: number$3()
            })),
            recentBlockhash: string$2(),
            addressTableLookups: optional$2(array$2(AddressTableLookupStruct$1))
        })
    }),
    AnnotatedAccountKey$1 = type$3({
        pubkey: PublicKeyFromString$1,
        signer: boolean$2(),
        writable: boolean$2(),
        source: optional$2(union$3([literal$2("transaction"), literal$2("lookupTable")]))
    }),
    ConfirmedTransactionAccountsModeResult$1 = type$3({
        accountKeys: array$2(AnnotatedAccountKey$1),
        signatures: array$2(string$2())
    }),
    ParsedInstructionResult$1 = type$3({
        parsed: unknown$2(),
        program: string$2(),
        programId: PublicKeyFromString$1
    }),
    RawInstructionResult$1 = type$3({
        accounts: array$2(PublicKeyFromString$1),
        data: string$2(),
        programId: PublicKeyFromString$1
    }),
    InstructionResult$1 = union$3([RawInstructionResult$1, ParsedInstructionResult$1]),
    UnknownInstructionResult$1 = union$3([type$3({
        parsed: unknown$2(),
        program: string$2(),
        programId: string$2()
    }), type$3({
        accounts: array$2(string$2()),
        data: string$2(),
        programId: string$2()
    })]),
    ParsedOrRawInstruction$1 = coerce$2(InstructionResult$1, UnknownInstructionResult$1, s => "accounts" in s ? create$2(s, RawInstructionResult$1) : create$2(s, ParsedInstructionResult$1)),
    ParsedConfirmedTransactionResult$1 = type$3({
        signatures: array$2(string$2()),
        message: type$3({
            accountKeys: array$2(AnnotatedAccountKey$1),
            instructions: array$2(ParsedOrRawInstruction$1),
            recentBlockhash: string$2(),
            addressTableLookups: optional$2(nullable$2(array$2(AddressTableLookupStruct$1)))
        })
    }),
    TokenBalanceResult$1 = type$3({
        accountIndex: number$3(),
        mint: string$2(),
        owner: optional$2(string$2()),
        uiTokenAmount: TokenAmountResult$1
    }),
    LoadedAddressesResult$1 = type$3({
        writable: array$2(PublicKeyFromString$1),
        readonly: array$2(PublicKeyFromString$1)
    }),
    ConfirmedTransactionMetaResult$1 = type$3({
        err: TransactionErrorResult$1,
        fee: number$3(),
        innerInstructions: optional$2(nullable$2(array$2(type$3({
            index: number$3(),
            instructions: array$2(type$3({
                accounts: array$2(number$3()),
                data: string$2(),
                programIdIndex: number$3()
            }))
        })))),
        preBalances: array$2(number$3()),
        postBalances: array$2(number$3()),
        logMessages: optional$2(nullable$2(array$2(string$2()))),
        preTokenBalances: optional$2(nullable$2(array$2(TokenBalanceResult$1))),
        postTokenBalances: optional$2(nullable$2(array$2(TokenBalanceResult$1))),
        loadedAddresses: optional$2(LoadedAddressesResult$1),
        computeUnitsConsumed: optional$2(number$3())
    }),
    ParsedConfirmedTransactionMetaResult$1 = type$3({
        err: TransactionErrorResult$1,
        fee: number$3(),
        innerInstructions: optional$2(nullable$2(array$2(type$3({
            index: number$3(),
            instructions: array$2(ParsedOrRawInstruction$1)
        })))),
        preBalances: array$2(number$3()),
        postBalances: array$2(number$3()),
        logMessages: optional$2(nullable$2(array$2(string$2()))),
        preTokenBalances: optional$2(nullable$2(array$2(TokenBalanceResult$1))),
        postTokenBalances: optional$2(nullable$2(array$2(TokenBalanceResult$1))),
        loadedAddresses: optional$2(LoadedAddressesResult$1),
        computeUnitsConsumed: optional$2(number$3())
    }),
    TransactionVersionStruct$1 = union$3([literal$2(0), literal$2("legacy")]),
    RewardsResult$1 = type$3({
        pubkey: string$2(),
        lamports: number$3(),
        postBalance: nullable$2(number$3()),
        rewardType: nullable$2(string$2()),
        commission: optional$2(nullable$2(number$3()))
    }),
    GetBlockRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        transactions: array$2(type$3({
            transaction: ConfirmedTransactionResult$1,
            meta: nullable$2(ConfirmedTransactionMetaResult$1),
            version: optional$2(TransactionVersionStruct$1)
        })),
        rewards: optional$2(array$2(RewardsResult$1)),
        blockTime: nullable$2(number$3()),
        blockHeight: nullable$2(number$3())
    }))),
    GetNoneModeBlockRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        rewards: optional$2(array$2(RewardsResult$1)),
        blockTime: nullable$2(number$3()),
        blockHeight: nullable$2(number$3())
    }))),
    GetAccountsModeBlockRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        transactions: array$2(type$3({
            transaction: ConfirmedTransactionAccountsModeResult$1,
            meta: nullable$2(ConfirmedTransactionMetaResult$1),
            version: optional$2(TransactionVersionStruct$1)
        })),
        rewards: optional$2(array$2(RewardsResult$1)),
        blockTime: nullable$2(number$3()),
        blockHeight: nullable$2(number$3())
    }))),
    GetParsedBlockRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        transactions: array$2(type$3({
            transaction: ParsedConfirmedTransactionResult$1,
            meta: nullable$2(ParsedConfirmedTransactionMetaResult$1),
            version: optional$2(TransactionVersionStruct$1)
        })),
        rewards: optional$2(array$2(RewardsResult$1)),
        blockTime: nullable$2(number$3()),
        blockHeight: nullable$2(number$3())
    }))),
    GetParsedAccountsModeBlockRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        transactions: array$2(type$3({
            transaction: ConfirmedTransactionAccountsModeResult$1,
            meta: nullable$2(ParsedConfirmedTransactionMetaResult$1),
            version: optional$2(TransactionVersionStruct$1)
        })),
        rewards: optional$2(array$2(RewardsResult$1)),
        blockTime: nullable$2(number$3()),
        blockHeight: nullable$2(number$3())
    }))),
    GetParsedNoneModeBlockRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        rewards: optional$2(array$2(RewardsResult$1)),
        blockTime: nullable$2(number$3()),
        blockHeight: nullable$2(number$3())
    }))),
    GetConfirmedBlockRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        transactions: array$2(type$3({
            transaction: ConfirmedTransactionResult$1,
            meta: nullable$2(ConfirmedTransactionMetaResult$1)
        })),
        rewards: optional$2(array$2(RewardsResult$1)),
        blockTime: nullable$2(number$3())
    }))),
    GetBlockSignaturesRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        blockhash: string$2(),
        previousBlockhash: string$2(),
        parentSlot: number$3(),
        signatures: array$2(string$2()),
        blockTime: nullable$2(number$3())
    }))),
    GetTransactionRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        slot: number$3(),
        meta: nullable$2(ConfirmedTransactionMetaResult$1),
        blockTime: optional$2(nullable$2(number$3())),
        transaction: ConfirmedTransactionResult$1,
        version: optional$2(TransactionVersionStruct$1)
    }))),
    GetParsedTransactionRpcResult$1 = jsonRpcResult$2(nullable$2(type$3({
        slot: number$3(),
        transaction: ParsedConfirmedTransactionResult$1,
        meta: nullable$2(ParsedConfirmedTransactionMetaResult$1),
        blockTime: optional$2(nullable$2(number$3())),
        version: optional$2(TransactionVersionStruct$1)
    }))),
    GetRecentBlockhashAndContextRpcResult$1 = jsonRpcResultAndContext$2(type$3({
        blockhash: string$2(),
        feeCalculator: type$3({
            lamportsPerSignature: number$3()
        })
    })),
    GetLatestBlockhashRpcResult$1 = jsonRpcResultAndContext$2(type$3({
        blockhash: string$2(),
        lastValidBlockHeight: number$3()
    })),
    IsBlockhashValidRpcResult$1 = jsonRpcResultAndContext$2(boolean$2()),
    PerfSampleResult$1 = type$3({
        slot: number$3(),
        numTransactions: number$3(),
        numSlots: number$3(),
        samplePeriodSecs: number$3()
    }),
    GetRecentPerformanceSamplesRpcResult$1 = jsonRpcResult$2(array$2(PerfSampleResult$1)),
    GetFeeCalculatorRpcResult$1 = jsonRpcResultAndContext$2(nullable$2(type$3({
        feeCalculator: type$3({
            lamportsPerSignature: number$3()
        })
    }))),
    RequestAirdropRpcResult$1 = jsonRpcResult$2(string$2()),
    SendTransactionRpcResult$1 = jsonRpcResult$2(string$2()),
    LogsResult$1 = type$3({
        err: TransactionErrorResult$1,
        logs: array$2(string$2()),
        signature: string$2()
    }),
    LogsNotificationResult$1 = type$3({
        result: notificationResultAndContext$1(LogsResult$1),
        subscription: number$3()
    }),
    COMMON_HTTP_HEADERS$1 = {
        "solana-client": "js/1.0.0-maintenance"
    };
let Connection$1 = class {
    constructor(o, a) {
        this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set, this.getBlockHeight = (() => {
            const rt = {};
            return async ot => {
                const {
                    commitment: st,
                    config: lt
                } = extractCommitmentFromConfig$1(ot), ft = this._buildArgs([], st, void 0, lt), yt = fastStableStringify$1$1(ft);
                return rt[yt] = rt[yt] ? ? (async () => {
                    try {
                        const bt = await this._rpcRequest("getBlockHeight", ft),
                            ht = create$2(bt, jsonRpcResult$2(number$3()));
                        if ("error" in ht) throw new SolanaJSONRPCError$1(ht.error, "failed to get block height information");
                        return ht.result
                    } finally {
                        delete rt[yt]
                    }
                })(), await rt[yt]
            }
        })();
        let $, j, _e, et, tt, nt;
        a && typeof a == "string" ? this._commitment = a : a && (this._commitment = a.commitment, this._confirmTransactionInitialTimeout = a.confirmTransactionInitialTimeout, $ = a.wsEndpoint, j = a.httpHeaders, _e = a.fetch, et = a.fetchMiddleware, tt = a.disableRetryOnRateLimit, nt = a.httpAgent), this._rpcEndpoint = assertEndpointUrl$1(o), this._rpcWsEndpoint = $ || makeWebsocketUrl$1(o), this._rpcClient = createRpcClient$1(o, j, _e, et, tt, nt), this._rpcRequest = createRpcRequest$1(this._rpcClient), this._rpcBatchRequest = createRpcBatchRequest$1(this._rpcClient), this._rpcWebSocket = new RpcWebSocketClient$1(this._rpcWsEndpoint, {
            autoconnect: !1,
            max_reconnects: 1 / 0
        }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }
    get commitment() {
        return this._commitment
    }
    get rpcEndpoint() {
        return this._rpcEndpoint
    }
    async getBalanceAndContext(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgs([o.toBase58()], $, void 0, j), et = await this._rpcRequest("getBalance", _e), tt = create$2(et, jsonRpcResultAndContext$2(number$3()));
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, `failed to get balance for ${o.toBase58()}`);
        return tt.result
    }
    async getBalance(o, a) {
        return await this.getBalanceAndContext(o, a).then($ => $.value).catch($ => {
            throw new Error("failed to get balance of account " + o.toBase58() + ": " + $)
        })
    }
    async getBlockTime(o) {
        const a = await this._rpcRequest("getBlockTime", [o]),
            $ = create$2(a, jsonRpcResult$2(nullable$2(number$3())));
        if ("error" in $) throw new SolanaJSONRPCError$1($.error, `failed to get block time for slot ${o}`);
        return $.result
    }
    async getMinimumLedgerSlot() {
        const o = await this._rpcRequest("minimumLedgerSlot", []),
            a = create$2(o, jsonRpcResult$2(number$3()));
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get minimum ledger slot");
        return a.result
    }
    async getFirstAvailableBlock() {
        const o = await this._rpcRequest("getFirstAvailableBlock", []),
            a = create$2(o, SlotRpcResult$1);
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get first available block");
        return a.result
    }
    async getSupply(o) {
        let a = {};
        typeof o == "string" ? a = {
            commitment: o
        } : o ? a = { ...o,
            commitment: o && o.commitment || this.commitment
        } : a = {
            commitment: this.commitment
        };
        const $ = await this._rpcRequest("getSupply", [a]),
            j = create$2($, GetSupplyRpcResult$1);
        if ("error" in j) throw new SolanaJSONRPCError$1(j.error, "failed to get supply");
        return j.result
    }
    async getTokenSupply(o, a) {
        const $ = this._buildArgs([o.toBase58()], a),
            j = await this._rpcRequest("getTokenSupply", $),
            _e = create$2(j, jsonRpcResultAndContext$2(TokenAmountResult$1));
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get token supply");
        return _e.result
    }
    async getTokenAccountBalance(o, a) {
        const $ = this._buildArgs([o.toBase58()], a),
            j = await this._rpcRequest("getTokenAccountBalance", $),
            _e = create$2(j, jsonRpcResultAndContext$2(TokenAmountResult$1));
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get token account balance");
        return _e.result
    }
    async getTokenAccountsByOwner(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig$1($);
        let et = [o.toBase58()];
        "mint" in a ? et.push({
            mint: a.mint.toBase58()
        }) : et.push({
            programId: a.programId.toBase58()
        });
        const tt = this._buildArgs(et, j, "base64", _e),
            nt = await this._rpcRequest("getTokenAccountsByOwner", tt),
            rt = create$2(nt, GetTokenAccountsByOwner$1);
        if ("error" in rt) throw new SolanaJSONRPCError$1(rt.error, `failed to get token accounts owned by account ${o.toBase58()}`);
        return rt.result
    }
    async getParsedTokenAccountsByOwner(o, a, $) {
        let j = [o.toBase58()];
        "mint" in a ? j.push({
            mint: a.mint.toBase58()
        }) : j.push({
            programId: a.programId.toBase58()
        });
        const _e = this._buildArgs(j, $, "jsonParsed"),
            et = await this._rpcRequest("getTokenAccountsByOwner", _e),
            tt = create$2(et, GetParsedTokenAccountsByOwner$1);
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, `failed to get token accounts owned by account ${o.toBase58()}`);
        return tt.result
    }
    async getLargestAccounts(o) {
        const a = { ...o,
                commitment: o && o.commitment || this.commitment
            },
            $ = a.filter || a.commitment ? [a] : [],
            j = await this._rpcRequest("getLargestAccounts", $),
            _e = create$2(j, GetLargestAccountsRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get largest accounts");
        return _e.result
    }
    async getTokenLargestAccounts(o, a) {
        const $ = this._buildArgs([o.toBase58()], a),
            j = await this._rpcRequest("getTokenLargestAccounts", $),
            _e = create$2(j, GetTokenLargestAccountsResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get token largest accounts");
        return _e.result
    }
    async getAccountInfoAndContext(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgs([o.toBase58()], $, "base64", j), et = await this._rpcRequest("getAccountInfo", _e), tt = create$2(et, jsonRpcResultAndContext$2(nullable$2(AccountInfoResult$1)));
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, `failed to get info about account ${o.toBase58()}`);
        return tt.result
    }
    async getParsedAccountInfo(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgs([o.toBase58()], $, "jsonParsed", j), et = await this._rpcRequest("getAccountInfo", _e), tt = create$2(et, jsonRpcResultAndContext$2(nullable$2(ParsedAccountInfoResult$1)));
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, `failed to get info about account ${o.toBase58()}`);
        return tt.result
    }
    async getAccountInfo(o, a) {
        try {
            return (await this.getAccountInfoAndContext(o, a)).value
        } catch ($) {
            throw new Error("failed to get info about account " + o.toBase58() + ": " + $)
        }
    }
    async getMultipleParsedAccounts(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = o.map(rt => rt.toBase58()), et = this._buildArgs([_e], $, "jsonParsed", j), tt = await this._rpcRequest("getMultipleAccounts", et), nt = create$2(tt, jsonRpcResultAndContext$2(array$2(nullable$2(ParsedAccountInfoResult$1))));
        if ("error" in nt) throw new SolanaJSONRPCError$1(nt.error, `failed to get info for accounts ${_e}`);
        return nt.result
    }
    async getMultipleAccountsInfoAndContext(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = o.map(rt => rt.toBase58()), et = this._buildArgs([_e], $, "base64", j), tt = await this._rpcRequest("getMultipleAccounts", et), nt = create$2(tt, jsonRpcResultAndContext$2(array$2(nullable$2(AccountInfoResult$1))));
        if ("error" in nt) throw new SolanaJSONRPCError$1(nt.error, `failed to get info for accounts ${_e}`);
        return nt.result
    }
    async getMultipleAccountsInfo(o, a) {
        return (await this.getMultipleAccountsInfoAndContext(o, a)).value
    }
    async getStakeActivation(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig$1(a), et = this._buildArgs([o.toBase58()], j, void 0, { ..._e,
            epoch: $ ? ? (_e == null ? void 0 : _e.epoch)
        }), tt = await this._rpcRequest("getStakeActivation", et), nt = create$2(tt, jsonRpcResult$2(StakeActivationResult$1));
        if ("error" in nt) throw new SolanaJSONRPCError$1(nt.error, `failed to get Stake Activation ${o.toBase58()}`);
        return nt.result
    }
    async getProgramAccounts(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), {
            encoding: _e,
            ...et
        } = j || {}, tt = this._buildArgs([o.toBase58()], $, _e || "base64", { ...et,
            ...et.filters ? {
                filters: applyDefaultMemcmpEncodingToFilters$1(et.filters)
            } : null
        }), nt = await this._rpcRequest("getProgramAccounts", tt), rt = array$2(KeyedAccountInfoResult$1), ot = et.withContext === !0 ? create$2(nt, jsonRpcResultAndContext$2(rt)) : create$2(nt, jsonRpcResult$2(rt));
        if ("error" in ot) throw new SolanaJSONRPCError$1(ot.error, `failed to get accounts owned by program ${o.toBase58()}`);
        return ot.result
    }
    async getParsedProgramAccounts(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgs([o.toBase58()], $, "jsonParsed", j), et = await this._rpcRequest("getProgramAccounts", _e), tt = create$2(et, jsonRpcResult$2(array$2(KeyedParsedAccountInfoResult$1)));
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, `failed to get accounts owned by program ${o.toBase58()}`);
        return tt.result
    }
    async confirmTransaction(o, a) {
        var _e;
        let $;
        if (typeof o == "string") $ = o;
        else {
            const et = o;
            if ((_e = et.abortSignal) != null && _e.aborted) return Promise.reject(et.abortSignal.reason);
            $ = et.signature
        }
        let j;
        try {
            j = bs58$5.decode($)
        } catch {
            throw new Error("signature must be base58 encoded: " + $)
        }
        return assert$4(j.length === 64, "signature has invalid length"), typeof o == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: a || this.commitment,
            signature: $
        }) : "lastValidBlockHeight" in o ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: a || this.commitment,
            strategy: o
        }) : await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: a || this.commitment,
            strategy: o
        })
    }
    getCancellationPromise(o) {
        return new Promise((a, $) => {
            o != null && (o.aborted ? $(o.reason) : o.addEventListener("abort", () => {
                $(o.reason)
            }))
        })
    }
    getTransactionConfirmationPromise({
        commitment: o,
        signature: a
    }) {
        let $, j, _e = !1;
        const et = new Promise((nt, rt) => {
            try {
                $ = this.onSignature(a, (st, lt) => {
                    $ = void 0;
                    const ft = {
                        context: lt,
                        value: st
                    };
                    nt({
                        __type: TransactionStatus$1.PROCESSED,
                        response: ft
                    })
                }, o);
                const ot = new Promise(st => {
                    $ == null ? st() : j = this._onSubscriptionStateChange($, lt => {
                        lt === "subscribed" && st()
                    })
                });
                (async () => {
                    if (await ot, _e) return;
                    const st = await this.getSignatureStatus(a);
                    if (_e || st == null) return;
                    const {
                        context: lt,
                        value: ft
                    } = st;
                    if (ft != null)
                        if (ft != null && ft.err) rt(ft.err);
                        else {
                            switch (o) {
                                case "confirmed":
                                case "single":
                                case "singleGossip":
                                    {
                                        if (ft.confirmationStatus === "processed") return;
                                        break
                                    }
                                case "finalized":
                                case "max":
                                case "root":
                                    {
                                        if (ft.confirmationStatus === "processed" || ft.confirmationStatus === "confirmed") return;
                                        break
                                    }
                                case "processed":
                                case "recent":
                            }
                            _e = !0, nt({
                                __type: TransactionStatus$1.PROCESSED,
                                response: {
                                    context: lt,
                                    value: ft
                                }
                            })
                        }
                })()
            } catch (ot) {
                rt(ot)
            }
        });
        return {
            abortConfirmation: () => {
                j && (j(), j = void 0), $ != null && (this.removeSignatureListener($), $ = void 0)
            },
            confirmationPromise: et
        }
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: o,
        strategy: {
            abortSignal: a,
            lastValidBlockHeight: $,
            signature: j
        }
    }) {
        let _e = !1;
        const et = new Promise(st => {
                const lt = async () => {
                    try {
                        return await this.getBlockHeight(o)
                    } catch {
                        return -1
                    }
                };
                (async () => {
                    let ft = await lt();
                    if (!_e) {
                        for (; ft <= $;)
                            if (await sleep$1(1e3), _e || (ft = await lt(), _e)) return;
                        st({
                            __type: TransactionStatus$1.BLOCKHEIGHT_EXCEEDED
                        })
                    }
                })()
            }),
            {
                abortConfirmation: tt,
                confirmationPromise: nt
            } = this.getTransactionConfirmationPromise({
                commitment: o,
                signature: j
            }),
            rt = this.getCancellationPromise(a);
        let ot;
        try {
            const st = await Promise.race([rt, nt, et]);
            if (st.__type === TransactionStatus$1.PROCESSED) ot = st.response;
            else throw new TransactionExpiredBlockheightExceededError$1(j)
        } finally {
            _e = !0, tt()
        }
        return ot
    }
    async confirmTransactionUsingDurableNonceStrategy({
        commitment: o,
        strategy: {
            abortSignal: a,
            minContextSlot: $,
            nonceAccountPubkey: j,
            nonceValue: _e,
            signature: et
        }
    }) {
        let tt = !1;
        const nt = new Promise(ft => {
                let yt = _e,
                    bt = null;
                const ht = async () => {
                    try {
                        const {
                            context: vt,
                            value: wt
                        } = await this.getNonceAndContext(j, {
                            commitment: o,
                            minContextSlot: $
                        });
                        return bt = vt.slot, wt == null ? void 0 : wt.nonce
                    } catch {
                        return yt
                    }
                };
                (async () => {
                    if (yt = await ht(), !tt)
                        for (;;) {
                            if (_e !== yt) {
                                ft({
                                    __type: TransactionStatus$1.NONCE_INVALID,
                                    slotInWhichNonceDidAdvance: bt
                                });
                                return
                            }
                            if (await sleep$1(2e3), tt || (yt = await ht(), tt)) return
                        }
                })()
            }),
            {
                abortConfirmation: rt,
                confirmationPromise: ot
            } = this.getTransactionConfirmationPromise({
                commitment: o,
                signature: et
            }),
            st = this.getCancellationPromise(a);
        let lt;
        try {
            const ft = await Promise.race([st, ot, nt]);
            if (ft.__type === TransactionStatus$1.PROCESSED) lt = ft.response;
            else {
                let yt;
                for (;;) {
                    const bt = await this.getSignatureStatus(et);
                    if (bt == null) break;
                    if (bt.context.slot < (ft.slotInWhichNonceDidAdvance ? ? $)) {
                        await sleep$1(400);
                        continue
                    }
                    yt = bt;
                    break
                }
                if (yt != null && yt.value) {
                    const bt = o || "finalized",
                        {
                            confirmationStatus: ht
                        } = yt.value;
                    switch (bt) {
                        case "processed":
                        case "recent":
                            if (ht !== "processed" && ht !== "confirmed" && ht !== "finalized") throw new TransactionExpiredNonceInvalidError$1(et);
                            break;
                        case "confirmed":
                        case "single":
                        case "singleGossip":
                            if (ht !== "confirmed" && ht !== "finalized") throw new TransactionExpiredNonceInvalidError$1(et);
                            break;
                        case "finalized":
                        case "max":
                        case "root":
                            if (ht !== "finalized") throw new TransactionExpiredNonceInvalidError$1(et);
                            break;
                        default:
                    }
                    lt = {
                        context: yt.context,
                        value: {
                            err: yt.value.err
                        }
                    }
                } else throw new TransactionExpiredNonceInvalidError$1(et)
            }
        } finally {
            tt = !0, rt()
        }
        return lt
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: o,
        signature: a
    }) {
        let $;
        const j = new Promise(nt => {
                let rt = this._confirmTransactionInitialTimeout || 6e4;
                switch (o) {
                    case "processed":
                    case "recent":
                    case "single":
                    case "confirmed":
                    case "singleGossip":
                        {
                            rt = this._confirmTransactionInitialTimeout || 3e4;
                            break
                        }
                }
                $ = setTimeout(() => nt({
                    __type: TransactionStatus$1.TIMED_OUT,
                    timeoutMs: rt
                }), rt)
            }),
            {
                abortConfirmation: _e,
                confirmationPromise: et
            } = this.getTransactionConfirmationPromise({
                commitment: o,
                signature: a
            });
        let tt;
        try {
            const nt = await Promise.race([et, j]);
            if (nt.__type === TransactionStatus$1.PROCESSED) tt = nt.response;
            else throw new TransactionExpiredTimeoutError$1(a, nt.timeoutMs / 1e3)
        } finally {
            clearTimeout($), _e()
        }
        return tt
    }
    async getClusterNodes() {
        const o = await this._rpcRequest("getClusterNodes", []),
            a = create$2(o, jsonRpcResult$2(array$2(ContactInfoResult$1)));
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get cluster nodes");
        return a.result
    }
    async getVoteAccounts(o) {
        const a = this._buildArgs([], o),
            $ = await this._rpcRequest("getVoteAccounts", a),
            j = create$2($, GetVoteAccounts$1);
        if ("error" in j) throw new SolanaJSONRPCError$1(j.error, "failed to get vote accounts");
        return j.result
    }
    async getSlot(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig$1(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getSlot", j), et = create$2(_e, jsonRpcResult$2(number$3()));
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get slot");
        return et.result
    }
    async getSlotLeader(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig$1(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getSlotLeader", j), et = create$2(_e, jsonRpcResult$2(string$2()));
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get slot leader");
        return et.result
    }
    async getSlotLeaders(o, a) {
        const $ = [o, a],
            j = await this._rpcRequest("getSlotLeaders", $),
            _e = create$2(j, jsonRpcResult$2(array$2(PublicKeyFromString$1)));
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get slot leaders");
        return _e.result
    }
    async getSignatureStatus(o, a) {
        const {
            context: $,
            value: j
        } = await this.getSignatureStatuses([o], a);
        assert$4(j.length === 1);
        const _e = j[0];
        return {
            context: $,
            value: _e
        }
    }
    async getSignatureStatuses(o, a) {
        const $ = [o];
        a && $.push(a);
        const j = await this._rpcRequest("getSignatureStatuses", $),
            _e = create$2(j, GetSignatureStatusesRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get signature status");
        return _e.result
    }
    async getTransactionCount(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig$1(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getTransactionCount", j), et = create$2(_e, jsonRpcResult$2(number$3()));
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get transaction count");
        return et.result
    }
    async getTotalSupply(o) {
        return (await this.getSupply({
            commitment: o,
            excludeNonCirculatingAccountsList: !0
        })).value.total
    }
    async getInflationGovernor(o) {
        const a = this._buildArgs([], o),
            $ = await this._rpcRequest("getInflationGovernor", a),
            j = create$2($, GetInflationGovernorRpcResult$1);
        if ("error" in j) throw new SolanaJSONRPCError$1(j.error, "failed to get inflation");
        return j.result
    }
    async getInflationReward(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig$1($), et = this._buildArgs([o.map(rt => rt.toBase58())], j, void 0, { ..._e,
            epoch: a ? ? (_e == null ? void 0 : _e.epoch)
        }), tt = await this._rpcRequest("getInflationReward", et), nt = create$2(tt, GetInflationRewardResult$1);
        if ("error" in nt) throw new SolanaJSONRPCError$1(nt.error, "failed to get inflation reward");
        return nt.result
    }
    async getInflationRate() {
        const o = await this._rpcRequest("getInflationRate", []),
            a = create$2(o, GetInflationRateRpcResult$1);
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get inflation rate");
        return a.result
    }
    async getEpochInfo(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig$1(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getEpochInfo", j), et = create$2(_e, GetEpochInfoRpcResult$1);
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get epoch info");
        return et.result
    }
    async getEpochSchedule() {
        const o = await this._rpcRequest("getEpochSchedule", []),
            a = create$2(o, GetEpochScheduleRpcResult$1);
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get epoch schedule");
        const $ = a.result;
        return new EpochSchedule$1($.slotsPerEpoch, $.leaderScheduleSlotOffset, $.warmup, $.firstNormalEpoch, $.firstNormalSlot)
    }
    async getLeaderSchedule() {
        const o = await this._rpcRequest("getLeaderSchedule", []),
            a = create$2(o, GetLeaderScheduleRpcResult$1);
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get leader schedule");
        return a.result
    }
    async getMinimumBalanceForRentExemption(o, a) {
        const $ = this._buildArgs([o], a),
            j = await this._rpcRequest("getMinimumBalanceForRentExemption", $),
            _e = create$2(j, GetMinimumBalanceForRentExemptionRpcResult$1);
        return "error" in _e ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : _e.result
    }
    async getRecentBlockhashAndContext(o) {
        const a = this._buildArgs([], o),
            $ = await this._rpcRequest("getRecentBlockhash", a),
            j = create$2($, GetRecentBlockhashAndContextRpcResult$1);
        if ("error" in j) throw new SolanaJSONRPCError$1(j.error, "failed to get recent blockhash");
        return j.result
    }
    async getRecentPerformanceSamples(o) {
        const a = await this._rpcRequest("getRecentPerformanceSamples", o ? [o] : []),
            $ = create$2(a, GetRecentPerformanceSamplesRpcResult$1);
        if ("error" in $) throw new SolanaJSONRPCError$1($.error, "failed to get recent performance samples");
        return $.result
    }
    async getFeeCalculatorForBlockhash(o, a) {
        const $ = this._buildArgs([o], a),
            j = await this._rpcRequest("getFeeCalculatorForBlockhash", $),
            _e = create$2(j, GetFeeCalculatorRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get fee calculator");
        const {
            context: et,
            value: tt
        } = _e.result;
        return {
            context: et,
            value: tt !== null ? tt.feeCalculator : null
        }
    }
    async getFeeForMessage(o, a) {
        const $ = toBuffer$2(o.serialize()).toString("base64"),
            j = this._buildArgs([$], a),
            _e = await this._rpcRequest("getFeeForMessage", j),
            et = create$2(_e, jsonRpcResultAndContext$2(nullable$2(number$3())));
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get fee for message");
        if (et.result === null) throw new Error("invalid blockhash");
        return et.result
    }
    async getRecentPrioritizationFees(o) {
        var et;
        const a = (et = o == null ? void 0 : o.lockedWritableAccounts) == null ? void 0 : et.map(tt => tt.toBase58()),
            $ = a != null && a.length ? [a] : [],
            j = await this._rpcRequest("getRecentPrioritizationFees", $),
            _e = create$2(j, GetRecentPrioritizationFeesRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get recent prioritization fees");
        return _e.result
    }
    async getRecentBlockhash(o) {
        try {
            return (await this.getRecentBlockhashAndContext(o)).value
        } catch (a) {
            throw new Error("failed to get recent blockhash: " + a)
        }
    }
    async getLatestBlockhash(o) {
        try {
            return (await this.getLatestBlockhashAndContext(o)).value
        } catch (a) {
            throw new Error("failed to get recent blockhash: " + a)
        }
    }
    async getLatestBlockhashAndContext(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig$1(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getLatestBlockhash", j), et = create$2(_e, GetLatestBlockhashRpcResult$1);
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get latest blockhash");
        return et.result
    }
    async isBlockhashValid(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgs([o], $, void 0, j), et = await this._rpcRequest("isBlockhashValid", _e), tt = create$2(et, IsBlockhashValidRpcResult$1);
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, "failed to determine if the blockhash `" + o + "`is valid");
        return tt.result
    }
    async getVersion() {
        const o = await this._rpcRequest("getVersion", []),
            a = create$2(o, jsonRpcResult$2(VersionResult$1));
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get version");
        return a.result
    }
    async getGenesisHash() {
        const o = await this._rpcRequest("getGenesisHash", []),
            a = create$2(o, jsonRpcResult$2(string$2()));
        if ("error" in a) throw new SolanaJSONRPCError$1(a.error, "failed to get genesis hash");
        return a.result
    }
    async getBlock(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgsAtLeastConfirmed([o], $, void 0, j), et = await this._rpcRequest("getBlock", _e);
        try {
            switch (j == null ? void 0 : j.transactionDetails) {
                case "accounts":
                    {
                        const tt = create$2(et, GetAccountsModeBlockRpcResult$1);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                case "none":
                    {
                        const tt = create$2(et, GetNoneModeBlockRpcResult$1);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                default:
                    {
                        const tt = create$2(et, GetBlockRpcResult$1);
                        if ("error" in tt) throw tt.error;
                        const {
                            result: nt
                        } = tt;
                        return nt ? { ...nt,
                            transactions: nt.transactions.map(({
                                transaction: rt,
                                meta: ot,
                                version: st
                            }) => ({
                                meta: ot,
                                transaction: { ...rt,
                                    message: versionedMessageFromResponse$1(st, rt.message)
                                },
                                version: st
                            }))
                        } : null
                    }
            }
        } catch (tt) {
            throw new SolanaJSONRPCError$1(tt, "failed to get confirmed block")
        }
    }
    async getParsedBlock(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgsAtLeastConfirmed([o], $, "jsonParsed", j), et = await this._rpcRequest("getBlock", _e);
        try {
            switch (j == null ? void 0 : j.transactionDetails) {
                case "accounts":
                    {
                        const tt = create$2(et, GetParsedAccountsModeBlockRpcResult$1);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                case "none":
                    {
                        const tt = create$2(et, GetParsedNoneModeBlockRpcResult$1);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                default:
                    {
                        const tt = create$2(et, GetParsedBlockRpcResult$1);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
            }
        } catch (tt) {
            throw new SolanaJSONRPCError$1(tt, "failed to get block")
        }
    }
    async getBlockProduction(o) {
        let a, $;
        if (typeof o == "string") $ = o;
        else if (o) {
            const {
                commitment: tt,
                ...nt
            } = o;
            $ = tt, a = nt
        }
        const j = this._buildArgs([], $, "base64", a),
            _e = await this._rpcRequest("getBlockProduction", j),
            et = create$2(_e, BlockProductionResponseStruct$1);
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get block production information");
        return et.result
    }
    async getTransaction(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgsAtLeastConfirmed([o], $, void 0, j), et = await this._rpcRequest("getTransaction", _e), tt = create$2(et, GetTransactionRpcResult$1);
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, "failed to get transaction");
        const nt = tt.result;
        return nt && { ...nt,
            transaction: { ...nt.transaction,
                message: versionedMessageFromResponse$1(nt.version, nt.transaction.message)
            }
        }
    }
    async getParsedTransaction(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = this._buildArgsAtLeastConfirmed([o], $, "jsonParsed", j), et = await this._rpcRequest("getTransaction", _e), tt = create$2(et, GetParsedTransactionRpcResult$1);
        if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, "failed to get transaction");
        return tt.result
    }
    async getParsedTransactions(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = o.map(nt => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([nt], $, "jsonParsed", j)
        }));
        return (await this._rpcBatchRequest(_e)).map(nt => {
            const rt = create$2(nt, GetParsedTransactionRpcResult$1);
            if ("error" in rt) throw new SolanaJSONRPCError$1(rt.error, "failed to get transactions");
            return rt.result
        })
    }
    async getTransactions(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig$1(a), _e = o.map(nt => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([nt], $, void 0, j)
        }));
        return (await this._rpcBatchRequest(_e)).map(nt => {
            const rt = create$2(nt, GetTransactionRpcResult$1);
            if ("error" in rt) throw new SolanaJSONRPCError$1(rt.error, "failed to get transactions");
            const ot = rt.result;
            return ot && { ...ot,
                transaction: { ...ot.transaction,
                    message: versionedMessageFromResponse$1(ot.version, ot.transaction.message)
                }
            }
        })
    }
    async getConfirmedBlock(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a),
            j = await this._rpcRequest("getConfirmedBlock", $),
            _e = create$2(j, GetConfirmedBlockRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get confirmed block");
        const et = _e.result;
        if (!et) throw new Error("Confirmed block " + o + " not found");
        const tt = { ...et,
            transactions: et.transactions.map(({
                transaction: nt,
                meta: rt
            }) => {
                const ot = new Message$1(nt.message);
                return {
                    meta: rt,
                    transaction: { ...nt,
                        message: ot
                    }
                }
            })
        };
        return { ...tt,
            transactions: tt.transactions.map(({
                transaction: nt,
                meta: rt
            }) => ({
                meta: rt,
                transaction: Transaction$1.populate(nt.message, nt.signatures)
            }))
        }
    }
    async getBlocks(o, a, $) {
        const j = this._buildArgsAtLeastConfirmed(a !== void 0 ? [o, a] : [o], $),
            _e = await this._rpcRequest("getBlocks", j),
            et = create$2(_e, jsonRpcResult$2(array$2(number$3())));
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get blocks");
        return et.result
    }
    async getBlockSignatures(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            }),
            j = await this._rpcRequest("getBlock", $),
            _e = create$2(j, GetBlockSignaturesRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get block");
        const et = _e.result;
        if (!et) throw new Error("Block " + o + " not found");
        return et
    }
    async getConfirmedBlockSignatures(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            }),
            j = await this._rpcRequest("getConfirmedBlock", $),
            _e = create$2(j, GetBlockSignaturesRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get confirmed block");
        const et = _e.result;
        if (!et) throw new Error("Confirmed block " + o + " not found");
        return et
    }
    async getConfirmedTransaction(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a),
            j = await this._rpcRequest("getConfirmedTransaction", $),
            _e = create$2(j, GetTransactionRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get transaction");
        const et = _e.result;
        if (!et) return et;
        const tt = new Message$1(et.transaction.message),
            nt = et.transaction.signatures;
        return { ...et,
            transaction: Transaction$1.populate(tt, nt)
        }
    }
    async getParsedConfirmedTransaction(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a, "jsonParsed"),
            j = await this._rpcRequest("getConfirmedTransaction", $),
            _e = create$2(j, GetParsedTransactionRpcResult$1);
        if ("error" in _e) throw new SolanaJSONRPCError$1(_e.error, "failed to get confirmed transaction");
        return _e.result
    }
    async getParsedConfirmedTransactions(o, a) {
        const $ = o.map(et => ({
            methodName: "getConfirmedTransaction",
            args: this._buildArgsAtLeastConfirmed([et], a, "jsonParsed")
        }));
        return (await this._rpcBatchRequest($)).map(et => {
            const tt = create$2(et, GetParsedTransactionRpcResult$1);
            if ("error" in tt) throw new SolanaJSONRPCError$1(tt.error, "failed to get confirmed transactions");
            return tt.result
        })
    }
    async getConfirmedSignaturesForAddress(o, a, $) {
        let j = {},
            _e = await this.getFirstAvailableBlock();
        for (; !("until" in j) && (a--, !(a <= 0 || a < _e));) try {
            const nt = await this.getConfirmedBlockSignatures(a, "finalized");
            nt.signatures.length > 0 && (j.until = nt.signatures[nt.signatures.length - 1].toString())
        } catch (nt) {
            if (nt instanceof Error && nt.message.includes("skipped")) continue;
            throw nt
        }
        let et = await this.getSlot("finalized");
        for (; !("before" in j) && ($++, !($ > et));) try {
            const nt = await this.getConfirmedBlockSignatures($);
            nt.signatures.length > 0 && (j.before = nt.signatures[nt.signatures.length - 1].toString())
        } catch (nt) {
            if (nt instanceof Error && nt.message.includes("skipped")) continue;
            throw nt
        }
        return (await this.getConfirmedSignaturesForAddress2(o, j)).map(nt => nt.signature)
    }
    async getConfirmedSignaturesForAddress2(o, a, $) {
        const j = this._buildArgsAtLeastConfirmed([o.toBase58()], $, void 0, a),
            _e = await this._rpcRequest("getConfirmedSignaturesForAddress2", j),
            et = create$2(_e, GetConfirmedSignaturesForAddress2RpcResult$1);
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get confirmed signatures for address");
        return et.result
    }
    async getSignaturesForAddress(o, a, $) {
        const j = this._buildArgsAtLeastConfirmed([o.toBase58()], $, void 0, a),
            _e = await this._rpcRequest("getSignaturesForAddress", j),
            et = create$2(_e, GetSignaturesForAddressRpcResult$1);
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get signatures for address");
        return et.result
    }
    async getAddressLookupTable(o, a) {
        const {
            context: $,
            value: j
        } = await this.getAccountInfoAndContext(o, a);
        let _e = null;
        return j !== null && (_e = new AddressLookupTableAccount$1({
            key: o,
            state: AddressLookupTableAccount$1.deserialize(j.data)
        })), {
            context: $,
            value: _e
        }
    }
    async getNonceAndContext(o, a) {
        const {
            context: $,
            value: j
        } = await this.getAccountInfoAndContext(o, a);
        let _e = null;
        return j !== null && (_e = NonceAccount$1.fromAccountData(j.data)), {
            context: $,
            value: _e
        }
    }
    async getNonce(o, a) {
        return await this.getNonceAndContext(o, a).then($ => $.value).catch($ => {
            throw new Error("failed to get nonce for account " + o.toBase58() + ": " + $)
        })
    }
    async requestAirdrop(o, a) {
        const $ = await this._rpcRequest("requestAirdrop", [o.toBase58(), a]),
            j = create$2($, RequestAirdropRpcResult$1);
        if ("error" in j) throw new SolanaJSONRPCError$1(j.error, `airdrop to ${o.toBase58()} failed`);
        return j.result
    }
    async _blockhashWithExpiryBlockHeight(o) {
        if (!o) {
            for (; this._pollingBlockhash;) await sleep$1(100);
            const $ = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS$1;
            if (this._blockhashInfo.latestBlockhash !== null && !$) return this._blockhashInfo.latestBlockhash
        }
        return await this._pollNewBlockhash()
    }
    async _pollNewBlockhash() {
        this._pollingBlockhash = !0;
        try {
            const o = Date.now(),
                a = this._blockhashInfo.latestBlockhash,
                $ = a ? a.blockhash : null;
            for (let j = 0; j < 50; j++) {
                const _e = await this.getLatestBlockhash("finalized");
                if ($ !== _e.blockhash) return this._blockhashInfo = {
                    latestBlockhash: _e,
                    lastFetch: Date.now(),
                    transactionSignatures: [],
                    simulatedSignatures: []
                }, _e;
                await sleep$1(MS_PER_SLOT$1 / 2)
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now()-o}ms`)
        } finally {
            this._pollingBlockhash = !1
        }
    }
    async getStakeMinimumDelegation(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig$1(o), j = this._buildArgs([], a, "base64", $), _e = await this._rpcRequest("getStakeMinimumDelegation", j), et = create$2(_e, jsonRpcResultAndContext$2(number$3()));
        if ("error" in et) throw new SolanaJSONRPCError$1(et.error, "failed to get stake minimum delegation");
        return et.result
    }
    async simulateTransaction(o, a, $) {
        if ("message" in o) {
            const bt = o.serialize(),
                ht = buffer$1.Buffer.from(bt).toString("base64");
            if (Array.isArray(a) || $ !== void 0) throw new Error("Invalid arguments");
            const vt = a || {};
            vt.encoding = "base64", "commitment" in vt || (vt.commitment = this.commitment), a && typeof a == "object" && "innerInstructions" in a && (vt.innerInstructions = a.innerInstructions);
            const wt = [ht, vt],
                gt = await this._rpcRequest("simulateTransaction", wt),
                At = create$2(gt, SimulatedTransactionResponseStruct$2);
            if ("error" in At) throw new Error("failed to simulate transaction: " + At.error.message);
            return At.result
        }
        let j;
        if (o instanceof Transaction$1) {
            let yt = o;
            j = new Transaction$1, j.feePayer = yt.feePayer, j.instructions = o.instructions, j.nonceInfo = yt.nonceInfo, j.signatures = yt.signatures
        } else j = Transaction$1.populate(o), j._message = j._json = void 0;
        if (a !== void 0 && !Array.isArray(a)) throw new Error("Invalid arguments");
        const _e = a;
        if (j.nonceInfo && _e) j.sign(..._e);
        else {
            let yt = this._disableBlockhashCaching;
            for (;;) {
                const bt = await this._blockhashWithExpiryBlockHeight(yt);
                if (j.lastValidBlockHeight = bt.lastValidBlockHeight, j.recentBlockhash = bt.blockhash, !_e) break;
                if (j.sign(..._e), !j.signature) throw new Error("!signature");
                const ht = j.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(ht) && !this._blockhashInfo.transactionSignatures.includes(ht)) {
                    this._blockhashInfo.simulatedSignatures.push(ht);
                    break
                } else yt = !0
            }
        }
        const et = j._compile(),
            tt = et.serialize(),
            rt = j._serialize(tt).toString("base64"),
            ot = {
                encoding: "base64",
                commitment: this.commitment
            };
        if ($) {
            const yt = (Array.isArray($) ? $ : et.nonProgramIds()).map(bt => bt.toBase58());
            ot.accounts = {
                encoding: "base64",
                addresses: yt
            }
        }
        _e && (ot.sigVerify = !0), a && typeof a == "object" && "innerInstructions" in a && (ot.innerInstructions = a.innerInstructions);
        const st = [rt, ot],
            lt = await this._rpcRequest("simulateTransaction", st),
            ft = create$2(lt, SimulatedTransactionResponseStruct$2);
        if ("error" in ft) {
            let yt;
            if ("data" in ft.error && (yt = ft.error.data.logs, yt && Array.isArray(yt))) {
                const bt = `
    `,
                    ht = bt + yt.join(bt);
                console.error(ft.error.message, ht)
            }
            throw new SendTransactionError$1({
                action: "simulate",
                signature: "",
                transactionMessage: ft.error.message,
                logs: yt
            })
        }
        return ft.result
    }
    async sendTransaction(o, a, $) {
        if ("version" in o) {
            if (a && Array.isArray(a)) throw new Error("Invalid arguments");
            const et = o.serialize();
            return await this.sendRawTransaction(et, a)
        }
        if (a === void 0 || !Array.isArray(a)) throw new Error("Invalid arguments");
        const j = a;
        if (o.nonceInfo) o.sign(...j);
        else {
            let et = this._disableBlockhashCaching;
            for (;;) {
                const tt = await this._blockhashWithExpiryBlockHeight(et);
                if (o.lastValidBlockHeight = tt.lastValidBlockHeight, o.recentBlockhash = tt.blockhash, o.sign(...j), !o.signature) throw new Error("!signature");
                const nt = o.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(nt)) et = !0;
                else {
                    this._blockhashInfo.transactionSignatures.push(nt);
                    break
                }
            }
        }
        const _e = o.serialize();
        return await this.sendRawTransaction(_e, $)
    }
    async sendRawTransaction(o, a) {
        const $ = toBuffer$2(o).toString("base64");
        return await this.sendEncodedTransaction($, a)
    }
    async sendEncodedTransaction(o, a) {
        const $ = {
                encoding: "base64"
            },
            j = a && a.skipPreflight,
            _e = j === !0 ? "processed" : a && a.preflightCommitment || this.commitment;
        a && a.maxRetries != null && ($.maxRetries = a.maxRetries), a && a.minContextSlot != null && ($.minContextSlot = a.minContextSlot), j && ($.skipPreflight = j), _e && ($.preflightCommitment = _e);
        const et = [o, $],
            tt = await this._rpcRequest("sendTransaction", et),
            nt = create$2(tt, SendTransactionRpcResult$1);
        if ("error" in nt) {
            let rt;
            throw "data" in nt.error && (rt = nt.error.data.logs), new SendTransactionError$1({
                action: j ? "send" : "simulate",
                signature: "",
                transactionMessage: nt.error.message,
                logs: rt
            })
        }
        return nt.result
    }
    _wsOnOpen() {
        this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
            (async () => {
                try {
                    await this._rpcWebSocket.notify("ping")
                } catch {}
            })()
        }, 5e3), this._updateSubscriptions()
    }
    _wsOnError(o) {
        this._rpcWebSocketConnected = !1, console.error("ws error:", o.message)
    }
    _wsOnClose(o) {
        if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), o === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([a, $]) => {
            this._setSubscription(a, { ...$,
                state: "pending"
            })
        })
    }
    _setSubscription(o, a) {
        var j;
        const $ = (j = this._subscriptionsByHash[o]) == null ? void 0 : j.state;
        if (this._subscriptionsByHash[o] = a, $ !== a.state) {
            const _e = this._subscriptionStateChangeCallbacksByHash[o];
            _e && _e.forEach(et => {
                try {
                    et(a.state)
                } catch {}
            })
        }
    }
    _onSubscriptionStateChange(o, a) {
        var _e;
        const $ = this._subscriptionHashByClientSubscriptionId[o];
        if ($ == null) return () => {};
        const j = (_e = this._subscriptionStateChangeCallbacksByHash)[$] || (_e[$] = new Set);
        return j.add(a), () => {
            j.delete(a), j.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[$]
        }
    }
    async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                    this._rpcWebSocket.close()
                } catch ($) {
                    $ instanceof Error && console.log(`Error when closing socket connection: ${$.message}`)
                }
            }, 500));
            return
        }
        if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return
        }
        const o = this._rpcWebSocketGeneration,
            a = () => o === this._rpcWebSocketGeneration;
        await Promise.all(Object.keys(this._subscriptionsByHash).map(async $ => {
            const j = this._subscriptionsByHash[$];
            if (j !== void 0) switch (j.state) {
                case "pending":
                case "unsubscribed":
                    if (j.callbacks.size === 0) {
                        delete this._subscriptionsByHash[$], j.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[j.serverSubscriptionId], await this._updateSubscriptions();
                        return
                    }
                    await (async () => {
                        const {
                            args: _e,
                            method: et
                        } = j;
                        try {
                            this._setSubscription($, { ...j,
                                state: "subscribing"
                            });
                            const tt = await this._rpcWebSocket.call(et, _e);
                            this._setSubscription($, { ...j,
                                serverSubscriptionId: tt,
                                state: "subscribed"
                            }), this._subscriptionCallbacksByServerSubscriptionId[tt] = j.callbacks, await this._updateSubscriptions()
                        } catch (tt) {
                            if (tt instanceof Error && console.error(`${et} error for argument`, _e, tt.message), !a()) return;
                            this._setSubscription($, { ...j,
                                state: "pending"
                            }), await this._updateSubscriptions()
                        }
                    })();
                    break;
                case "subscribed":
                    j.callbacks.size === 0 && await (async () => {
                        const {
                            serverSubscriptionId: _e,
                            unsubscribeMethod: et
                        } = j;
                        if (this._subscriptionsAutoDisposedByRpc.has(_e)) this._subscriptionsAutoDisposedByRpc.delete(_e);
                        else {
                            this._setSubscription($, { ...j,
                                state: "unsubscribing"
                            }), this._setSubscription($, { ...j,
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(et, [_e])
                            } catch (tt) {
                                if (tt instanceof Error && console.error(`${et} error:`, tt.message), !a()) return;
                                this._setSubscription($, { ...j,
                                    state: "subscribed"
                                }), await this._updateSubscriptions();
                                return
                            }
                        }
                        this._setSubscription($, { ...j,
                            state: "unsubscribed"
                        }), await this._updateSubscriptions()
                    })();
                    break
            }
        }))
    }
    _handleServerNotification(o, a) {
        const $ = this._subscriptionCallbacksByServerSubscriptionId[o];
        $ !== void 0 && $.forEach(j => {
            try {
                j(...a)
            } catch (_e) {
                console.error(_e)
            }
        })
    }
    _wsOnAccountNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$2(o, AccountNotificationResult$1);
        this._handleServerNotification($, [a.value, a.context])
    }
    _makeSubscription(o, a) {
        const $ = this._nextClientSubscriptionId++,
            j = fastStableStringify$1$1([o.method, a]),
            _e = this._subscriptionsByHash[j];
        return _e === void 0 ? this._subscriptionsByHash[j] = { ...o,
            args: a,
            callbacks: new Set([o.callback]),
            state: "pending"
        } : _e.callbacks.add(o.callback), this._subscriptionHashByClientSubscriptionId[$] = j, this._subscriptionDisposeFunctionsByClientSubscriptionId[$] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[$], delete this._subscriptionHashByClientSubscriptionId[$];
            const et = this._subscriptionsByHash[j];
            assert$4(et !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${$}`), et.callbacks.delete(o.callback), await this._updateSubscriptions()
        }, this._updateSubscriptions(), $
    }
    onAccountChange(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig$1($), et = this._buildArgs([o.toBase58()], j || this._commitment || "finalized", "base64", _e);
        return this._makeSubscription({
            callback: a,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, et)
    }
    async removeAccountChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "account change")
    }
    _wsOnProgramAccountNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$2(o, ProgramAccountNotificationResult$1);
        this._handleServerNotification($, [{
            accountId: a.value.pubkey,
            accountInfo: a.value.account
        }, a.context])
    }
    onProgramAccountChange(o, a, $, j) {
        const {
            commitment: _e,
            config: et
        } = extractCommitmentFromConfig$1($), tt = this._buildArgs([o.toBase58()], _e || this._commitment || "finalized", "base64", et || (j ? {
            filters: applyDefaultMemcmpEncodingToFilters$1(j)
        } : void 0));
        return this._makeSubscription({
            callback: a,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, tt)
    }
    async removeProgramAccountChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "program account change")
    }
    onLogs(o, a, $) {
        const j = this._buildArgs([typeof o == "object" ? {
            mentions: [o.toString()]
        } : o], $ || this._commitment || "finalized");
        return this._makeSubscription({
            callback: a,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, j)
    }
    async removeOnLogsListener(o) {
        await this._unsubscribeClientSubscription(o, "logs")
    }
    _wsOnLogsNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$2(o, LogsNotificationResult$1);
        this._handleServerNotification($, [a.value, a.context])
    }
    _wsOnSlotNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$2(o, SlotNotificationResult$1);
        this._handleServerNotification($, [a])
    }
    onSlotChange(o) {
        return this._makeSubscription({
            callback: o,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, [])
    }
    async removeSlotChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "slot change")
    }
    _wsOnSlotUpdatesNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$2(o, SlotUpdateNotificationResult$1);
        this._handleServerNotification($, [a])
    }
    onSlotUpdate(o) {
        return this._makeSubscription({
            callback: o,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }
    async removeSlotUpdateListener(o) {
        await this._unsubscribeClientSubscription(o, "slot update")
    }
    async _unsubscribeClientSubscription(o, a) {
        const $ = this._subscriptionDisposeFunctionsByClientSubscriptionId[o];
        $ ? await $() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${o}\` for '${a}' events could not be found.`)
    }
    _buildArgs(o, a, $, j) {
        const _e = a || this._commitment;
        if (_e || $ || j) {
            let et = {};
            $ && (et.encoding = $), _e && (et.commitment = _e), j && (et = Object.assign(et, j)), o.push(et)
        }
        return o
    }
    _buildArgsAtLeastConfirmed(o, a, $, j) {
        const _e = a || this._commitment;
        if (_e && !["confirmed", "finalized"].includes(_e)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(o, a, $, j)
    }
    _wsOnSignatureNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$2(o, SignatureNotificationResult$1);
        a.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add($), this._handleServerNotification($, a.value === "receivedSignature" ? [{
            type: "received"
        }, a.context] : [{
            type: "status",
            result: a.value
        }, a.context])
    }
    onSignature(o, a, $) {
        const j = this._buildArgs([o], $ || this._commitment || "finalized"),
            _e = this._makeSubscription({
                callback: (et, tt) => {
                    if (et.type === "status") {
                        a(et.result, tt);
                        try {
                            this.removeSignatureListener(_e)
                        } catch {}
                    }
                },
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe"
            }, j);
        return _e
    }
    onSignatureWithOptions(o, a, $) {
        const {
            commitment: j,
            ..._e
        } = { ...$,
            commitment: $ && $.commitment || this._commitment || "finalized"
        }, et = this._buildArgs([o], j, void 0, _e), tt = this._makeSubscription({
            callback: (nt, rt) => {
                a(nt, rt);
                try {
                    this.removeSignatureListener(tt)
                } catch {}
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, et);
        return tt
    }
    async removeSignatureListener(o) {
        await this._unsubscribeClientSubscription(o, "signature result")
    }
    _wsOnRootNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$2(o, RootNotificationResult$1);
        this._handleServerNotification($, [a])
    }
    onRootChange(o) {
        return this._makeSubscription({
            callback: o,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, [])
    }
    async removeRootChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "root change")
    }
};
Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: struct$2([u32$3("instruction"), u64$3("recentSlot"), u8$2("bumpSeed")])
    },
    FreezeLookupTable: {
        index: 1,
        layout: struct$2([u32$3("instruction")])
    },
    ExtendLookupTable: {
        index: 2,
        layout: struct$2([u32$3("instruction"), u64$3(), seq$1(publicKey$4(), offset$2(u32$3(), -8), "addresses")])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: struct$2([u32$3("instruction")])
    },
    CloseLookupTable: {
        index: 4,
        layout: struct$2([u32$3("instruction")])
    }
});
new PublicKey$1("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
    RequestUnits: {
        index: 0,
        layout: struct$2([u8$2("instruction"), u32$3("units"), u32$3("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: struct$2([u8$2("instruction"), u32$3("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: struct$2([u8$2("instruction"), u32$3("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: struct$2([u8$2("instruction"), u64$3("microLamports")])
    }
});
new PublicKey$1("ComputeBudget111111111111111111111111111111");
struct$2([u8$2("numSignatures"), u8$2("padding"), u16$1("signatureOffset"), u16$1("signatureInstructionIndex"), u16$1("publicKeyOffset"), u16$1("publicKeyInstructionIndex"), u16$1("messageDataOffset"), u16$1("messageDataSize"), u16$1("messageInstructionIndex")]);
new PublicKey$1("Ed25519SigVerify111111111111111111111111111");
secp256k1$1.utils.isValidPrivateKey;
secp256k1$1.getPublicKey;
struct$2([u8$2("numSignatures"), u16$1("signatureOffset"), u8$2("signatureInstructionIndex"), u16$1("ethAddressOffset"), u8$2("ethAddressInstructionIndex"), u16$1("messageDataOffset"), u16$1("messageDataSize"), u8$2("messageInstructionIndex"), blob$2(20, "ethAddress"), blob$2(64, "signature"), u8$2("recoveryId")]);
new PublicKey$1("KeccakSecp256k11111111111111111111111111111");
var _Lockup$1;
new PublicKey$1("StakeConfig11111111111111111111111111111111");
let Lockup$1 = class {
    constructor(o, a, $) {
        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = o, this.epoch = a, this.custodian = $
    }
};
_Lockup$1 = Lockup$1;
Lockup$1.default = new _Lockup$1(0, 0, PublicKey$1.default);
Object.freeze({
    Initialize: {
        index: 0,
        layout: struct$2([u32$3("instruction"), authorized$1(), lockup$1()])
    },
    Authorize: {
        index: 1,
        layout: struct$2([u32$3("instruction"), publicKey$4("newAuthorized"), u32$3("stakeAuthorizationType")])
    },
    Delegate: {
        index: 2,
        layout: struct$2([u32$3("instruction")])
    },
    Split: {
        index: 3,
        layout: struct$2([u32$3("instruction"), ns64$2("lamports")])
    },
    Withdraw: {
        index: 4,
        layout: struct$2([u32$3("instruction"), ns64$2("lamports")])
    },
    Deactivate: {
        index: 5,
        layout: struct$2([u32$3("instruction")])
    },
    Merge: {
        index: 7,
        layout: struct$2([u32$3("instruction")])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: struct$2([u32$3("instruction"), publicKey$4("newAuthorized"), u32$3("stakeAuthorizationType"), rustString$1("authoritySeed"), publicKey$4("authorityOwner")])
    }
});
new PublicKey$1("Stake11111111111111111111111111111111111111");
Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: struct$2([u32$3("instruction"), voteInit$1()])
    },
    Authorize: {
        index: 1,
        layout: struct$2([u32$3("instruction"), publicKey$4("newAuthorized"), u32$3("voteAuthorizationType")])
    },
    Withdraw: {
        index: 3,
        layout: struct$2([u32$3("instruction"), ns64$2("lamports")])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: struct$2([u32$3("instruction")])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: struct$2([u32$3("instruction"), voteAuthorizeWithSeedArgs$1()])
    }
});
new PublicKey$1("Vote111111111111111111111111111111111111111");
new PublicKey$1("Va1idator1nfo111111111111111111111111111111");
type$3({
    name: string$2(),
    website: optional$2(string$2()),
    details: optional$2(string$2()),
    iconUrl: optional$2(string$2()),
    keybaseUsername: optional$2(string$2())
});
new PublicKey$1("Vote111111111111111111111111111111111111111");
struct$2([publicKey$4("nodePubkey"), publicKey$4("authorizedWithdrawer"), u8$2("commission"), nu64$2(), seq$1(struct$2([nu64$2("slot"), u32$3("confirmationCount")]), offset$2(u32$3(), -8), "votes"), u8$2("rootSlotValid"), nu64$2("rootSlot"), nu64$2(), seq$1(struct$2([nu64$2("epoch"), publicKey$4("authorizedVoter")]), offset$2(u32$3(), -8), "authorizedVoters"), struct$2([seq$1(struct$2([publicKey$4("authorizedPubkey"), nu64$2("epochOfLastAuthorizedSwitch"), nu64$2("targetEpoch")]), 32, "buf"), nu64$2("idx"), u8$2("isEmpty")], "priorVoters"), nu64$2(), seq$1(struct$2([nu64$2("epoch"), nu64$2("credits"), nu64$2("prevCredits")]), offset$2(u32$3(), -8), "epochCredits"), struct$2([nu64$2("slot"), nu64$2("timestamp")], "lastTimestamp")]);
const ConnectionContext = reactExports.createContext({});

function useConnection() {
    return reactExports.useContext(ConnectionContext)
}
const ConnectionProvider = ({
    children: s,
    endpoint: o,
    config: a = {
        commitment: "confirmed"
    }
}) => {
    const $ = reactExports.useMemo(() => new Connection$1(o, a), [o, a]);
    return React$1.createElement(ConnectionContext.Provider, {
        value: {
            connection: $
        }
    }, s)
};
var eventemitter3$2 = {
    exports: {}
};
(function(s) {
    var o = Object.prototype.hasOwnProperty,
        a = "~";

    function $() {}
    Object.create && ($.prototype = Object.create(null), new $().__proto__ || (a = !1));

    function j(nt, rt, ot) {
        this.fn = nt, this.context = rt, this.once = ot || !1
    }

    function _e(nt, rt, ot, st, lt) {
        if (typeof ot != "function") throw new TypeError("The listener must be a function");
        var ft = new j(ot, st || nt, lt),
            yt = a ? a + rt : rt;
        return nt._events[yt] ? nt._events[yt].fn ? nt._events[yt] = [nt._events[yt], ft] : nt._events[yt].push(ft) : (nt._events[yt] = ft, nt._eventsCount++), nt
    }

    function et(nt, rt) {
        --nt._eventsCount === 0 ? nt._events = new $ : delete nt._events[rt]
    }

    function tt() {
        this._events = new $, this._eventsCount = 0
    }
    tt.prototype.eventNames = function() {
        var rt = [],
            ot, st;
        if (this._eventsCount === 0) return rt;
        for (st in ot = this._events) o.call(ot, st) && rt.push(a ? st.slice(1) : st);
        return Object.getOwnPropertySymbols ? rt.concat(Object.getOwnPropertySymbols(ot)) : rt
    }, tt.prototype.listeners = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        if (!st) return [];
        if (st.fn) return [st.fn];
        for (var lt = 0, ft = st.length, yt = new Array(ft); lt < ft; lt++) yt[lt] = st[lt].fn;
        return yt
    }, tt.prototype.listenerCount = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        return st ? st.fn ? 1 : st.length : 0
    }, tt.prototype.emit = function(rt, ot, st, lt, ft, yt) {
        var bt = a ? a + rt : rt;
        if (!this._events[bt]) return !1;
        var ht = this._events[bt],
            vt = arguments.length,
            wt, gt;
        if (ht.fn) {
            switch (ht.once && this.removeListener(rt, ht.fn, void 0, !0), vt) {
                case 1:
                    return ht.fn.call(ht.context), !0;
                case 2:
                    return ht.fn.call(ht.context, ot), !0;
                case 3:
                    return ht.fn.call(ht.context, ot, st), !0;
                case 4:
                    return ht.fn.call(ht.context, ot, st, lt), !0;
                case 5:
                    return ht.fn.call(ht.context, ot, st, lt, ft), !0;
                case 6:
                    return ht.fn.call(ht.context, ot, st, lt, ft, yt), !0
            }
            for (gt = 1, wt = new Array(vt - 1); gt < vt; gt++) wt[gt - 1] = arguments[gt];
            ht.fn.apply(ht.context, wt)
        } else {
            var At = ht.length,
                Pt;
            for (gt = 0; gt < At; gt++) switch (ht[gt].once && this.removeListener(rt, ht[gt].fn, void 0, !0), vt) {
                case 1:
                    ht[gt].fn.call(ht[gt].context);
                    break;
                case 2:
                    ht[gt].fn.call(ht[gt].context, ot);
                    break;
                case 3:
                    ht[gt].fn.call(ht[gt].context, ot, st);
                    break;
                case 4:
                    ht[gt].fn.call(ht[gt].context, ot, st, lt);
                    break;
                default:
                    if (!wt)
                        for (Pt = 1, wt = new Array(vt - 1); Pt < vt; Pt++) wt[Pt - 1] = arguments[Pt];
                    ht[gt].fn.apply(ht[gt].context, wt)
            }
        }
        return !0
    }, tt.prototype.on = function(rt, ot, st) {
        return _e(this, rt, ot, st, !1)
    }, tt.prototype.once = function(rt, ot, st) {
        return _e(this, rt, ot, st, !0)
    }, tt.prototype.removeListener = function(rt, ot, st, lt) {
        var ft = a ? a + rt : rt;
        if (!this._events[ft]) return this;
        if (!ot) return et(this, ft), this;
        var yt = this._events[ft];
        if (yt.fn) yt.fn === ot && (!lt || yt.once) && (!st || yt.context === st) && et(this, ft);
        else {
            for (var bt = 0, ht = [], vt = yt.length; bt < vt; bt++)(yt[bt].fn !== ot || lt && !yt[bt].once || st && yt[bt].context !== st) && ht.push(yt[bt]);
            ht.length ? this._events[ft] = ht.length === 1 ? ht[0] : ht : et(this, ft)
        }
        return this
    }, tt.prototype.removeAllListeners = function(rt) {
        var ot;
        return rt ? (ot = a ? a + rt : rt, this._events[ot] && et(this, ot)) : (this._events = new $, this._eventsCount = 0), this
    }, tt.prototype.off = tt.prototype.removeListener, tt.prototype.addListener = tt.prototype.on, tt.prefixed = a, tt.EventEmitter = tt, s.exports = tt
})(eventemitter3$2);
var eventemitter3Exports$2 = eventemitter3$2.exports;
const EventEmitter$2 = getDefaultExportFromCjs$3(eventemitter3Exports$2);
class WalletError extends Error {
    constructor(o, a) {
        super(o), this.error = a
    }
}
class WalletNotReadyError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletNotReadyError"
    }
}
class WalletConfigError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletConfigError"
    }
}
class WalletConnectionError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletConnectionError"
    }
}
class WalletDisconnectedError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletDisconnectedError"
    }
}
class WalletDisconnectionError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletDisconnectionError"
    }
}
class WalletAccountError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletAccountError"
    }
}
class WalletPublicKeyError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletPublicKeyError"
    }
}
class WalletNotConnectedError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletNotConnectedError"
    }
}
class WalletSendTransactionError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletSendTransactionError"
    }
}
class WalletSignTransactionError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletSignTransactionError"
    }
}
class WalletSignMessageError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletSignMessageError"
    }
}
class WalletSignInError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletSignInError"
    }
}
var WalletReadyState;
(function(s) {
    s.Installed = "Installed", s.NotDetected = "NotDetected", s.Loadable = "Loadable", s.Unsupported = "Unsupported"
})(WalletReadyState || (WalletReadyState = {}));
class BaseWalletAdapter extends EventEmitter$2 {
    get connected() {
        return !!this.publicKey
    }
    async autoConnect() {
        await this.connect()
    }
    async prepareTransaction(o, a, $ = {}) {
        const j = this.publicKey;
        if (!j) throw new WalletNotConnectedError;
        return o.feePayer = o.feePayer || j, o.recentBlockhash = o.recentBlockhash || (await a.getLatestBlockhash({
            commitment: $.preflightCommitment,
            minContextSlot: $.minContextSlot
        })).blockhash, o
    }
}

function scopePollingDetectionStrategy(s) {
    if (typeof window > "u" || typeof document > "u") return;
    const o = [];

    function a() {
        if (s())
            for (const _e of o) _e()
    }
    const $ = setInterval(a, 1e3);
    o.push(() => clearInterval($)), document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", a, {
        once: !0
    }), o.push(() => document.removeEventListener("DOMContentLoaded", a))), document.readyState !== "complete" && (window.addEventListener("load", a, {
        once: !0
    }), o.push(() => window.removeEventListener("load", a))), a()
}

function isIosAndRedirectable() {
    if (!navigator) return !1;
    const s = navigator.userAgent.toLowerCase(),
        o = s.includes("iphone") || s.includes("ipad"),
        a = s.includes("safari");
    return o && a
}

function isVersionedTransaction$1(s) {
    return "version" in s
}
class BaseSignerWalletAdapter extends BaseWalletAdapter {
    async sendTransaction(o, a, $ = {}) {
        let j = !0;
        try {
            if (isVersionedTransaction$1(o)) {
                if (!this.supportedTransactionVersions) throw new WalletSendTransactionError("Sending versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(o.version)) throw new WalletSendTransactionError(`Sending transaction version ${o.version} isn't supported by this wallet`);
                try {
                    o = await this.signTransaction(o);
                    const _e = o.serialize();
                    return await a.sendRawTransaction(_e, $)
                } catch (_e) {
                    throw _e instanceof WalletSignTransactionError ? (j = !1, _e) : new WalletSendTransactionError(_e == null ? void 0 : _e.message, _e)
                }
            } else try {
                const {
                    signers: _e,
                    ...et
                } = $;
                o = await this.prepareTransaction(o, a, et), _e != null && _e.length && o.partialSign(..._e), o = await this.signTransaction(o);
                const tt = o.serialize();
                return await a.sendRawTransaction(tt, et)
            } catch (_e) {
                throw _e instanceof WalletSignTransactionError ? (j = !1, _e) : new WalletSendTransactionError(_e == null ? void 0 : _e.message, _e)
            }
        } catch (_e) {
            throw j && this.emit("error", _e), _e
        }
    }
    async signAllTransactions(o) {
        for (const $ of o)
            if (isVersionedTransaction$1($)) {
                if (!this.supportedTransactionVersions) throw new WalletSignTransactionError("Signing versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has($.version)) throw new WalletSignTransactionError(`Signing transaction version ${$.version} isn't supported by this wallet`)
            }
        const a = [];
        for (const $ of o) a.push(await this.signTransaction($));
        return a
    }
}
class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {}
class BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {}
const SolanaSignAndSendTransaction = "solana:signAndSendTransaction",
    SolanaSignIn = "solana:signIn",
    SolanaSignMessage = "solana:signMessage",
    SolanaSignTransaction = "solana:signTransaction",
    StandardConnect = "standard:connect",
    StandardDisconnect = "standard:disconnect",
    StandardEvents = "standard:events";

function isWalletAdapterCompatibleStandardWallet(s) {
    return StandardConnect in s.features && StandardEvents in s.features && (SolanaSignAndSendTransaction in s.features || SolanaSignTransaction in s.features)
}
class WalletNotSelectedError extends WalletError {
    constructor() {
        super(...arguments), this.name = "WalletNotSelectedError"
    }
}
const EMPTY_ARRAY = [],
    DEFAULT_CONTEXT = {
        autoConnect: !1,
        connecting: !1,
        connected: !1,
        disconnecting: !1,
        select() {
            logMissingProviderError("call", "select")
        },
        connect() {
            return Promise.reject(logMissingProviderError("call", "connect"))
        },
        disconnect() {
            return Promise.reject(logMissingProviderError("call", "disconnect"))
        },
        sendTransaction() {
            return Promise.reject(logMissingProviderError("call", "sendTransaction"))
        },
        signTransaction() {
            return Promise.reject(logMissingProviderError("call", "signTransaction"))
        },
        signAllTransactions() {
            return Promise.reject(logMissingProviderError("call", "signAllTransactions"))
        },
        signMessage() {
            return Promise.reject(logMissingProviderError("call", "signMessage"))
        },
        signIn() {
            return Promise.reject(logMissingProviderError("call", "signIn"))
        }
    };
Object.defineProperty(DEFAULT_CONTEXT, "wallets", {
    get() {
        return logMissingProviderError("read", "wallets"), EMPTY_ARRAY
    }
});
Object.defineProperty(DEFAULT_CONTEXT, "wallet", {
    get() {
        return logMissingProviderError("read", "wallet"), null
    }
});
Object.defineProperty(DEFAULT_CONTEXT, "publicKey", {
    get() {
        return logMissingProviderError("read", "publicKey"), null
    }
});

function logMissingProviderError(s, o) {
    const a = new Error(`You have tried to ${s} "${o}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.`);
    return console.error(a), a
}
const WalletContext = reactExports.createContext(DEFAULT_CONTEXT);

function useWallet() {
    return reactExports.useContext(WalletContext)
}

function useLocalStorage(s, o) {
    const a = reactExports.useState(() => {
            try {
                const _e = localStorage.getItem(s);
                if (_e) return JSON.parse(_e)
            } catch (_e) {
                typeof window < "u" && console.error(_e)
            }
            return o
        }),
        $ = a[0],
        j = reactExports.useRef(!0);
    return reactExports.useEffect(() => {
        if (j.current) {
            j.current = !1;
            return
        }
        try {
            $ === null ? localStorage.removeItem(s) : localStorage.setItem(s, JSON.stringify($))
        } catch (_e) {
            typeof window < "u" && console.error(_e)
        }
    }, [$, s]), a
}

function getCommitment(s) {
    switch (s) {
        case "processed":
        case "confirmed":
        case "finalized":
        case void 0:
            return s;
        case "recent":
            return "processed";
        case "single":
        case "singleGossip":
            return "confirmed";
        case "max":
        case "root":
            return "finalized";
        default:
            return
    }
}
const SOLANA_MAINNET_CHAIN = "solana:mainnet",
    SOLANA_DEVNET_CHAIN = "solana:devnet",
    SOLANA_TESTNET_CHAIN = "solana:testnet",
    SOLANA_LOCALNET_CHAIN = "solana:localnet",
    MAINNET_ENDPOINT = "https://api.mainnet-beta.solana.com";

function getChainForEndpoint(s) {
    return s.includes(MAINNET_ENDPOINT) ? SOLANA_MAINNET_CHAIN : /\bdevnet\b/i.test(s) ? SOLANA_DEVNET_CHAIN : /\btestnet\b/i.test(s) ? SOLANA_TESTNET_CHAIN : /\blocalhost\b/i.test(s) || /\b127\.0\.0\.1\b/.test(s) ? SOLANA_LOCALNET_CHAIN : SOLANA_MAINNET_CHAIN
}

function createSignInMessageText(s) {
    let o = `${s.domain} wants you to sign in with your Solana account:
`;
    o += `${s.address}`, s.statement && (o += `

${s.statement}`);
    const a = [];
    if (s.uri && a.push(`URI: ${s.uri}`), s.version && a.push(`Version: ${s.version}`), s.chainId && a.push(`Chain ID: ${s.chainId}`), s.nonce && a.push(`Nonce: ${s.nonce}`), s.issuedAt && a.push(`Issued At: ${s.issuedAt}`), s.expirationTime && a.push(`Expiration Time: ${s.expirationTime}`), s.notBefore && a.push(`Not Before: ${s.notBefore}`), s.requestId && a.push(`Request ID: ${s.requestId}`), s.resources) {
        a.push("Resources:");
        for (const $ of s.resources) a.push(`- ${$}`)
    }
    return a.length && (o += `

${a.join(`
`)}`), o
}
const SolanaMobileWalletAdapterErrorCode = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
    ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
    ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
    ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
    ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
    ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
    ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION"
};
class SolanaMobileWalletAdapterError extends Error {
    constructor(...o) {
        const [a, $, j] = o;
        super($), this.code = a, this.data = j, this.name = "SolanaMobileWalletAdapterError"
    }
}
class SolanaMobileWalletAdapterProtocolError extends Error {
    constructor(...o) {
        const [a, $, j, _e] = o;
        super(j), this.code = $, this.data = _e, this.jsonRpcMessageId = a, this.name = "SolanaMobileWalletAdapterProtocolError"
    }
}

function __awaiter$2(s, o, a, $) {
    function j(_e) {
        return _e instanceof a ? _e : new a(function(et) {
            et(_e)
        })
    }
    return new(a || (a = Promise))(function(_e, et) {
        function tt(ot) {
            try {
                rt($.next(ot))
            } catch (st) {
                et(st)
            }
        }

        function nt(ot) {
            try {
                rt($.throw(ot))
            } catch (st) {
                et(st)
            }
        }

        function rt(ot) {
            ot.done ? _e(ot.value) : j(ot.value).then(tt, nt)
        }
        rt(($ = $.apply(s, [])).next())
    })
}

function createHelloReq(s, o) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const a = yield crypto.subtle.exportKey("raw", s), $ = yield crypto.subtle.sign({
            hash: "SHA-256",
            name: "ECDSA"
        }, o, a), j = new Uint8Array(a.byteLength + $.byteLength);
        return j.set(new Uint8Array(a), 0), j.set(new Uint8Array($), a.byteLength), j
    })
}

function encode$4(s) {
    return window.btoa(s)
}

function createSIWSMessage(s) {
    return createSignInMessageText(s)
}

function createSIWSMessageBase64(s) {
    return encode$4(createSIWSMessage(s))
}
const SolanaSignTransactions = "solana:signTransactions",
    SolanaCloneAuthorization = "solana:cloneAuthorization";

function createMobileWalletProxy(s, o) {
    return new Proxy({}, {
        get(a, $) {
            return a[$] == null && (a[$] = function(j) {
                return __awaiter$2(this, void 0, void 0, function*() {
                    const {
                        method: _e,
                        params: et
                    } = handleMobileWalletRequest($, j, s), tt = yield o(_e, et);
                    return _e === "authorize" && et.sign_in_payload && !tt.sign_in_result && (tt.sign_in_result = yield signInFallback(et.sign_in_payload, tt, o)), handleMobileWalletResponse($, tt, s)
                })
            }), a[$]
        },
        defineProperty() {
            return !1
        },
        deleteProperty() {
            return !1
        }
    })
}

function handleMobileWalletRequest(s, o, a) {
    let $ = o,
        j = s.toString().replace(/[A-Z]/g, _e => `_${_e.toLowerCase()}`).toLowerCase();
    switch (s) {
        case "authorize":
            {
                let {
                    chain: _e
                } = $;
                if (a === "legacy") {
                    switch (_e) {
                        case "solana:testnet":
                            {
                                _e = "testnet";
                                break
                            }
                        case "solana:devnet":
                            {
                                _e = "devnet";
                                break
                            }
                        case "solana:mainnet":
                            {
                                _e = "mainnet-beta";
                                break
                            }
                        default:
                            _e = $.cluster
                    }
                    $.cluster = _e
                } else {
                    switch (_e) {
                        case "testnet":
                        case "devnet":
                            {
                                _e = `solana:${_e}`;
                                break
                            }
                        case "mainnet-beta":
                            {
                                _e = "solana:mainnet";
                                break
                            }
                    }
                    $.chain = _e
                }
            }
        case "reauthorize":
            {
                const {
                    auth_token: _e,
                    identity: et
                } = $;
                if (_e) switch (a) {
                    case "legacy":
                        {
                            j = "reauthorize",
                            $ = {
                                auth_token: _e,
                                identity: et
                            };
                            break
                        }
                    default:
                        {
                            j = "authorize";
                            break
                        }
                }
                break
            }
    }
    return {
        method: j,
        params: $
    }
}

function handleMobileWalletResponse(s, o, a) {
    switch (s) {
        case "getCapabilities":
            {
                const $ = o;
                switch (a) {
                    case "legacy":
                        {
                            const j = [SolanaSignTransactions];
                            return $.supports_clone_authorization === !0 && j.push(SolanaCloneAuthorization),
                            Object.assign(Object.assign({}, $), {
                                features: j
                            })
                        }
                    case "v1":
                        return Object.assign(Object.assign({}, $), {
                            supports_sign_and_send_transactions: !0,
                            supports_clone_authorization: $.features.includes(SolanaCloneAuthorization)
                        })
                }
            }
    }
    return o
}

function signInFallback(s, o, a) {
    var $;
    return __awaiter$2(this, void 0, void 0, function*() {
        const j = ($ = s.domain) !== null && $ !== void 0 ? $ : window.location.host,
            _e = o.accounts[0].address,
            et = createSIWSMessageBase64(Object.assign(Object.assign({}, s), {
                domain: j,
                address: _e
            })),
            tt = yield a("sign_messages", {
                addresses: [_e],
                payloads: [et]
            });
        return {
            address: _e,
            signed_message: et,
            signature: tt.signed_payloads[0].slice(et.length)
        }
    })
}
const SEQUENCE_NUMBER_BYTES = 4;

function createSequenceNumberVector(s) {
    if (s >= 4294967296) throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
    const o = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);
    return new DataView(o).setUint32(0, s, !1), new Uint8Array(o)
}
const INITIALIZATION_VECTOR_BYTES = 12,
    ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;

function encryptMessage(s, o, a) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const $ = createSequenceNumberVector(o),
            j = new Uint8Array(INITIALIZATION_VECTOR_BYTES);
        crypto.getRandomValues(j);
        const _e = yield crypto.subtle.encrypt(getAlgorithmParams($, j), a, new TextEncoder().encode(s)), et = new Uint8Array($.byteLength + j.byteLength + _e.byteLength);
        return et.set(new Uint8Array($), 0), et.set(new Uint8Array(j), $.byteLength), et.set(new Uint8Array(_e), $.byteLength + j.byteLength), et
    })
}

function decryptMessage(s, o) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const a = s.slice(0, SEQUENCE_NUMBER_BYTES),
            $ = s.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES),
            j = s.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES),
            _e = yield crypto.subtle.decrypt(getAlgorithmParams(a, $), o, j);
        return getUtf8Decoder().decode(_e)
    })
}

function getAlgorithmParams(s, o) {
    return {
        additionalData: s,
        iv: o,
        name: "AES-GCM",
        tagLength: 128
    }
}
let _utf8Decoder;

function getUtf8Decoder() {
    return _utf8Decoder === void 0 && (_utf8Decoder = new TextDecoder("utf-8")), _utf8Decoder
}

function generateAssociationKeypair() {
    return __awaiter$2(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDSA",
            namedCurve: "P-256"
        }, !1, ["sign"])
    })
}

function generateECDHKeypair() {
    return __awaiter$2(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, ["deriveKey", "deriveBits"])
    })
}

function encryptJsonRpcMessage(s, o) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const a = JSON.stringify(s),
            $ = s.id;
        return encryptMessage(a, $, o)
    })
}

function decryptJsonRpcMessage(s, o) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const a = yield decryptMessage(s, o), $ = JSON.parse(a);
        if (Object.hasOwnProperty.call($, "error")) throw new SolanaMobileWalletAdapterProtocolError($.id, $.error.code, $.error.message);
        return $
    })
}

function parseHelloRsp(s, o, a) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const [$, j] = yield Promise.all([crypto.subtle.exportKey("raw", o), crypto.subtle.importKey("raw", s.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), {
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, [])]), _e = yield crypto.subtle.deriveBits({
            name: "ECDH",
            public: j
        }, a, 256), et = yield crypto.subtle.importKey("raw", _e, "HKDF", !1, ["deriveKey"]);
        return yield crypto.subtle.deriveKey({
            name: "HKDF",
            hash: "SHA-256",
            salt: new Uint8Array($),
            info: new Uint8Array
        }, et, {
            name: "AES-GCM",
            length: 128
        }, !1, ["encrypt", "decrypt"])
    })
}

function parseSessionProps(s, o) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const a = yield decryptMessage(s, o), $ = JSON.parse(a);
        let j = "legacy";
        if (Object.hasOwnProperty.call($, "v")) switch ($.v) {
            case 1:
            case "1":
            case "v1":
                j = "v1";
                break;
            case "legacy":
                j = "legacy";
                break;
            default:
                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${$.v}`)
        }
        return {
            protocol_version: j
        }
    })
}

function getRandomAssociationPort() {
    return assertAssociationPort(49152 + Math.floor(Math.random() * 16384))
}

function assertAssociationPort(s) {
    if (s < 49152 || s > 65535) throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${s} given.`, {
        port: s
    });
    return s
}

function arrayBufferToBase64String(s) {
    let o = "";
    const a = new Uint8Array(s),
        $ = a.byteLength;
    for (let j = 0; j < $; j++) o += String.fromCharCode(a[j]);
    return window.btoa(o)
}

function getStringWithURLUnsafeCharactersReplaced(s) {
    return s.replace(/[/+=]/g, o => ({
        "/": "_",
        "+": "-",
        "=": "."
    })[o])
}
const INTENT_NAME = "solana-wallet";

function getPathParts(s) {
    return s.replace(/(^\/+|\/+$)/g, "").split("/")
}

function getIntentURL(s, o) {
    let a = null;
    if (o) {
        try {
            a = new URL(o)
        } catch {}
        if ((a == null ? void 0 : a.protocol) !== "https:") throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs")
    }
    a || (a = new URL(`${INTENT_NAME}:/`));
    const $ = s.startsWith("/") ? s : [...getPathParts(a.pathname), ...getPathParts(s)].join("/");
    return new URL($, a)
}

function getAssociateAndroidIntentURL(s, o, a, $ = ["v1"]) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const j = assertAssociationPort(o),
            _e = yield crypto.subtle.exportKey("raw", s), et = arrayBufferToBase64String(_e), tt = getIntentURL("v1/associate/local", a);
        return tt.searchParams.set("association", getStringWithURLUnsafeCharactersReplaced(et)), tt.searchParams.set("port", `${j}`), $.forEach(nt => {
            tt.searchParams.set("v", nt)
        }), tt
    })
}
const Browser = {
    Firefox: 0,
    Other: 1
};

function assertUnreachable(s) {
    return s
}

function getBrowser() {
    return navigator.userAgent.indexOf("Firefox/") !== -1 ? Browser.Firefox : Browser.Other
}

function getDetectionPromise() {
    return new Promise((s, o) => {
        function a() {
            clearTimeout(j), window.removeEventListener("blur", $)
        }

        function $() {
            a(), s()
        }
        window.addEventListener("blur", $);
        const j = setTimeout(() => {
            a(), o()
        }, 2e3)
    })
}
let _frame = null;

function launchUrlThroughHiddenFrame(s) {
    _frame == null && (_frame = document.createElement("iframe"), _frame.style.display = "none", document.body.appendChild(_frame)), _frame.contentWindow.location.href = s.toString()
}

function startSession(s, o) {
    return __awaiter$2(this, void 0, void 0, function*() {
        const a = getRandomAssociationPort(),
            $ = yield getAssociateAndroidIntentURL(s, a, o);
        if ($.protocol === "https:") window.location.assign($);
        else try {
            const j = getBrowser();
            switch (j) {
                case Browser.Firefox:
                    launchUrlThroughHiddenFrame($);
                    break;
                case Browser.Other:
                    {
                        const _e = getDetectionPromise();window.location.assign($),
                        yield _e;
                        break
                    }
                default:
            }
        } catch {
            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, "Found no installed wallet that supports the mobile wallet protocol.")
        }
        return a
    })
}
const WEBSOCKET_CONNECTION_CONFIG = {
        retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
        timeoutMs: 3e4
    },
    WEBSOCKET_PROTOCOL = "com.solana.mobilewalletadapter.v1";

function assertSecureContext() {
    if (typeof window > "u" || window.isSecureContext !== !0) throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, "The mobile wallet adapter protocol must be used in a secure context (`https`).")
}

function assertSecureEndpointSpecificURI(s) {
    let o;
    try {
        o = new URL(s)
    } catch {
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, "Invalid base URL supplied by wallet")
    }
    if (o.protocol !== "https:") throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs")
}

function getSequenceNumberFromByteArray(s) {
    return new DataView(s).getUint32(0, !1)
}

function transact$1(s, o) {
    return __awaiter$2(this, void 0, void 0, function*() {
        assertSecureContext();
        const a = yield generateAssociationKeypair(), $ = yield startSession(a.publicKey, o == null ? void 0 : o.baseUri), j = `ws://localhost:${$}/solana-wallet`;
        let _e;
        const et = (() => {
            const ot = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];
            return () => ot.length > 1 ? ot.shift() : ot[0]
        })();
        let tt = 1,
            nt = 0,
            rt = {
                __type: "disconnected"
            };
        return new Promise((ot, st) => {
            let lt;
            const ft = {},
                yt = () => __awaiter$2(this, void 0, void 0, function*() {
                    if (rt.__type !== "connecting") {
                        console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${rt.__type}\`.`);
                        return
                    }
                    const {
                        associationKeypair: Pt
                    } = rt;
                    lt.removeEventListener("open", yt);
                    const Bt = yield generateECDHKeypair();
                    lt.send(yield createHelloReq(Bt.publicKey, Pt.privateKey)), rt = {
                        __type: "hello_req_sent",
                        associationPublicKey: Pt.publicKey,
                        ecdhPrivateKey: Bt.privateKey
                    }
                }),
                bt = Pt => {
                    Pt.wasClean ? rt = {
                        __type: "disconnected"
                    } : st(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${Pt.code}: ${Pt.reason}).`, {
                        closeEvent: Pt
                    })), wt()
                },
                ht = Pt => __awaiter$2(this, void 0, void 0, function*() {
                    wt(), Date.now() - _e >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs ? st(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket on port ${$}.`)) : (yield new Promise(Bt => {
                        const Lt = et();
                        gt = window.setTimeout(Bt, Lt)
                    }), At())
                }),
                vt = Pt => __awaiter$2(this, void 0, void 0, function*() {
                    const Bt = yield Pt.data.arrayBuffer();
                    switch (rt.__type) {
                        case "connected":
                            try {
                                const Lt = Bt.slice(0, SEQUENCE_NUMBER_BYTES),
                                    Nt = getSequenceNumberFromByteArray(Lt);
                                if (Nt !== nt + 1) throw new Error("Encrypted message has invalid sequence number");
                                nt = Nt;
                                const Ut = yield decryptJsonRpcMessage(Bt, rt.sharedSecret), Vt = ft[Ut.id];
                                delete ft[Ut.id], Vt.resolve(Ut.result)
                            } catch (Lt) {
                                if (Lt instanceof SolanaMobileWalletAdapterProtocolError) {
                                    const Nt = ft[Lt.jsonRpcMessageId];
                                    delete ft[Lt.jsonRpcMessageId], Nt.reject(Lt)
                                } else throw Lt
                            }
                            break;
                        case "hello_req_sent":
                            {
                                const Lt = yield parseHelloRsp(Bt, rt.associationPublicKey, rt.ecdhPrivateKey), Nt = Bt.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES), Ut = Nt.byteLength !== 0 ? yield __awaiter$2(this, void 0, void 0, function*() {
                                    const Ft = Nt.slice(0, SEQUENCE_NUMBER_BYTES),
                                        Wt = getSequenceNumberFromByteArray(Ft);
                                    if (Wt !== nt + 1) throw new Error("Encrypted message has invalid sequence number");
                                    return nt = Wt, parseSessionProps(Nt, Lt)
                                }): {
                                    protocol_version: "legacy"
                                };rt = {
                                    __type: "connected",
                                    sharedSecret: Lt,
                                    sessionProperties: Ut
                                };
                                const Vt = createMobileWalletProxy(Ut.protocol_version, (Ft, Wt) => __awaiter$2(this, void 0, void 0, function*() {
                                    const Ct = tt++;
                                    return lt.send(yield encryptJsonRpcMessage({
                                        id: Ct,
                                        jsonrpc: "2.0",
                                        method: Ft,
                                        params: Wt ? ? {}
                                    }, Lt)), new Promise((it, at) => {
                                        ft[Ct] = {
                                            resolve(mt) {
                                                switch (Ft) {
                                                    case "authorize":
                                                    case "reauthorize":
                                                        {
                                                            const {
                                                                wallet_uri_base: xt
                                                            } = mt;
                                                            if (xt != null) try {
                                                                assertSecureEndpointSpecificURI(xt)
                                                            } catch ($t) {
                                                                at($t);
                                                                return
                                                            }
                                                            break
                                                        }
                                                }
                                                it(mt)
                                            },
                                            reject: at
                                        }
                                    })
                                }));
                                try {
                                    ot(yield s(Vt))
                                } catch (Ft) {
                                    st(Ft)
                                } finally {
                                    wt(), lt.close()
                                }
                                break
                            }
                    }
                });
            let wt, gt;
            const At = () => {
                wt && wt(), rt = {
                    __type: "connecting",
                    associationKeypair: a
                }, _e === void 0 && (_e = Date.now()), lt = new WebSocket(j, [WEBSOCKET_PROTOCOL]), lt.addEventListener("open", yt), lt.addEventListener("close", bt), lt.addEventListener("error", ht), lt.addEventListener("message", vt), wt = () => {
                    window.clearTimeout(gt), lt.removeEventListener("open", yt), lt.removeEventListener("close", bt), lt.removeEventListener("error", ht), lt.removeEventListener("message", vt)
                }
            };
            At()
        })
    })
}

function base$1(s) {
    if (s.length >= 255) throw new TypeError("Alphabet too long");
    for (var o = new Uint8Array(256), a = 0; a < o.length; a++) o[a] = 255;
    for (var $ = 0; $ < s.length; $++) {
        var j = s.charAt($),
            _e = j.charCodeAt(0);
        if (o[_e] !== 255) throw new TypeError(j + " is ambiguous");
        o[_e] = $
    }
    var et = s.length,
        tt = s.charAt(0),
        nt = Math.log(et) / Math.log(256),
        rt = Math.log(256) / Math.log(et);

    function ot(ft) {
        if (ft instanceof Uint8Array || (ArrayBuffer.isView(ft) ? ft = new Uint8Array(ft.buffer, ft.byteOffset, ft.byteLength) : Array.isArray(ft) && (ft = Uint8Array.from(ft))), !(ft instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (ft.length === 0) return "";
        for (var yt = 0, bt = 0, ht = 0, vt = ft.length; ht !== vt && ft[ht] === 0;) ht++, yt++;
        for (var wt = (vt - ht) * rt + 1 >>> 0, gt = new Uint8Array(wt); ht !== vt;) {
            for (var At = ft[ht], Pt = 0, Bt = wt - 1;
                (At !== 0 || Pt < bt) && Bt !== -1; Bt--, Pt++) At += 256 * gt[Bt] >>> 0, gt[Bt] = At % et >>> 0, At = At / et >>> 0;
            if (At !== 0) throw new Error("Non-zero carry");
            bt = Pt, ht++
        }
        for (var Lt = wt - bt; Lt !== wt && gt[Lt] === 0;) Lt++;
        for (var Nt = tt.repeat(yt); Lt < wt; ++Lt) Nt += s.charAt(gt[Lt]);
        return Nt
    }

    function st(ft) {
        if (typeof ft != "string") throw new TypeError("Expected String");
        if (ft.length === 0) return new Uint8Array;
        for (var yt = 0, bt = 0, ht = 0; ft[yt] === tt;) bt++, yt++;
        for (var vt = (ft.length - yt) * nt + 1 >>> 0, wt = new Uint8Array(vt); ft[yt];) {
            var gt = o[ft.charCodeAt(yt)];
            if (gt === 255) return;
            for (var At = 0, Pt = vt - 1;
                (gt !== 0 || At < ht) && Pt !== -1; Pt--, At++) gt += et * wt[Pt] >>> 0, wt[Pt] = gt % 256 >>> 0, gt = gt / 256 >>> 0;
            if (gt !== 0) throw new Error("Non-zero carry");
            ht = At, yt++
        }
        for (var Bt = vt - ht; Bt !== vt && wt[Bt] === 0;) Bt++;
        for (var Lt = new Uint8Array(bt + (vt - Bt)), Nt = bt; Bt !== vt;) Lt[Nt++] = wt[Bt++];
        return Lt
    }

    function lt(ft) {
        var yt = st(ft);
        if (yt) return yt;
        throw new Error("Non-base" + et + " character")
    }
    return {
        encode: ot,
        decodeUnsafe: st,
        decode: lt
    }
}
var src$1 = base$1;
const basex$1 = src$1,
    ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$2 = basex$1(ALPHABET$1);
const base58 = getDefaultExportFromCjs$3(bs58$2);

function __rest(s, o) {
    var a = {};
    for (var $ in s) Object.prototype.hasOwnProperty.call(s, $) && o.indexOf($) < 0 && (a[$] = s[$]);
    if (s != null && typeof Object.getOwnPropertySymbols == "function")
        for (var j = 0, $ = Object.getOwnPropertySymbols(s); j < $.length; j++) o.indexOf($[j]) < 0 && Object.prototype.propertyIsEnumerable.call(s, $[j]) && (a[$[j]] = s[$[j]]);
    return a
}

function __awaiter$1(s, o, a, $) {
    function j(_e) {
        return _e instanceof a ? _e : new a(function(et) {
            et(_e)
        })
    }
    return new(a || (a = Promise))(function(_e, et) {
        function tt(ot) {
            try {
                rt($.next(ot))
            } catch (st) {
                et(st)
            }
        }

        function nt(ot) {
            try {
                rt($.throw(ot))
            } catch (st) {
                et(st)
            }
        }

        function rt(ot) {
            ot.done ? _e(ot.value) : j(ot.value).then(tt, nt)
        }
        rt(($ = $.apply(s, [])).next())
    })
}

function fromUint8Array(s) {
    return window.btoa(String.fromCharCode.call(null, ...s))
}

function toUint8Array$1(s) {
    return new Uint8Array(window.atob(s).split("").map(o => o.charCodeAt(0)))
}

function getPayloadFromTransaction(s) {
    const o = "version" in s ? s.serialize() : s.serialize({
        requireAllSignatures: !1,
        verifySignatures: !1
    });
    return fromUint8Array(o)
}

function getTransactionFromWireMessage(s) {
    const a = s[0] * SIGNATURE_LENGTH_IN_BYTES$2 + 1;
    return VersionedMessage$1.deserializeMessageVersion(s.slice(a, s.length)) === "legacy" ? Transaction$1.from(s) : VersionedTransaction$1.deserialize(s)
}

function transact(s, o) {
    return __awaiter$1(this, void 0, void 0, function*() {
        return yield transact$1($ => {
            const j = new Proxy({}, {
                get(_e, et) {
                    if (_e[et] == null) switch (et) {
                        case "signAndSendTransactions":
                            _e[et] = function(tt) {
                                var {
                                    minContextSlot: nt,
                                    commitment: rt,
                                    skipPreflight: ot,
                                    maxRetries: st,
                                    waitForCommitmentToSendNextTransaction: lt,
                                    transactions: ft
                                } = tt, yt = __rest(tt, ["minContextSlot", "commitment", "skipPreflight", "maxRetries", "waitForCommitmentToSendNextTransaction", "transactions"]);
                                return __awaiter$1(this, void 0, void 0, function*() {
                                    const bt = ft.map(getPayloadFromTransaction),
                                        ht = {
                                            min_context_slot: nt,
                                            commitment: rt,
                                            skip_preflight: ot,
                                            max_retries: st,
                                            wait_for_commitment_to_send_next_transaction: lt
                                        },
                                        {
                                            signatures: vt
                                        } = yield $.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, yt), Object.values(ht).some(gt => gt != null) ? {
                                            options: ht
                                        } : null), {
                                            payloads: bt
                                        }));
                                    return vt.map(toUint8Array$1).map(base58.encode)
                                })
                            };
                            break;
                        case "signMessages":
                            _e[et] = function(tt) {
                                var {
                                    payloads: nt
                                } = tt, rt = __rest(tt, ["payloads"]);
                                return __awaiter$1(this, void 0, void 0, function*() {
                                    const ot = nt.map(fromUint8Array),
                                        {
                                            signed_payloads: st
                                        } = yield $.signMessages(Object.assign(Object.assign({}, rt), {
                                            payloads: ot
                                        }));
                                    return st.map(toUint8Array$1)
                                })
                            };
                            break;
                        case "signTransactions":
                            _e[et] = function(tt) {
                                var {
                                    transactions: nt
                                } = tt, rt = __rest(tt, ["transactions"]);
                                return __awaiter$1(this, void 0, void 0, function*() {
                                    const ot = nt.map(getPayloadFromTransaction),
                                        {
                                            signed_payloads: st
                                        } = yield $.signTransactions(Object.assign(Object.assign({}, rt), {
                                            payloads: ot
                                        }));
                                    return st.map(toUint8Array$1).map(getTransactionFromWireMessage)
                                })
                            };
                            break;
                        default:
                            {
                                _e[et] = $[et];
                                break
                            }
                    }
                    return _e[et]
                },
                defineProperty() {
                    return !1
                },
                deleteProperty() {
                    return !1
                }
            });
            return s(j)
        }, o)
    })
}

function __awaiter(s, o, a, $) {
    function j(_e) {
        return _e instanceof a ? _e : new a(function(et) {
            et(_e)
        })
    }
    return new(a || (a = Promise))(function(_e, et) {
        function tt(ot) {
            try {
                rt($.next(ot))
            } catch (st) {
                et(st)
            }
        }

        function nt(ot) {
            try {
                rt($.throw(ot))
            } catch (st) {
                et(st)
            }
        }

        function rt(ot) {
            ot.done ? _e(ot.value) : j(ot.value).then(tt, nt)
        }
        rt(($ = $.apply(s, [])).next())
    })
}

function toUint8Array(s) {
    return new Uint8Array(window.atob(s).split("").map(o => o.charCodeAt(0)))
}

function getIsSupported() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && /android/i.test(navigator.userAgent)
}
const SolanaMobileWalletAdapterWalletName = "Mobile Wallet Adapter",
    SIGNATURE_LENGTH_IN_BYTES$1 = 64;

function getPublicKeyFromAddress(s) {
    const o = toUint8Array(s);
    return new PublicKey$1(o)
}

function isVersionedTransaction(s) {
    return "version" in s
}
class SolanaMobileWalletAdapter extends BaseSignInMessageSignerWalletAdapter {
    constructor(o) {
        var a;
        super(), this.supportedTransactionVersions = new Set(["legacy", 0]), this.name = SolanaMobileWalletAdapterWalletName, this.url = "https://solanamobile.com/wallets", this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==", this._connecting = !1, this._connectionGeneration = 0, this._readyState = getIsSupported() ? WalletReadyState.Loadable : WalletReadyState.Unsupported, this._authorizationResultCache = o.authorizationResultCache, this._addressSelector = o.addressSelector, this._appIdentity = o.appIdentity, this._chain = (a = o.chain) !== null && a !== void 0 ? a : o.cluster, this._onWalletNotFound = o.onWalletNotFound, this._readyState !== WalletReadyState.Unsupported && this._authorizationResultCache.get().then($ => {
            $ && this.declareWalletAsInstalled()
        })
    }
    get publicKey() {
        if (this._publicKey == null && this._selectedAddress != null) try {
            this._publicKey = getPublicKeyFromAddress(this._selectedAddress)
        } catch (o) {
            throw new WalletPublicKeyError(o instanceof Error && (o == null ? void 0 : o.message) || "Unknown error", o)
        }
        return this._publicKey ? this._publicKey : null
    }
    get connected() {
        return !!this._authorizationResult
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    declareWalletAsInstalled() {
        this._readyState !== WalletReadyState.Installed && this.emit("readyStateChange", this._readyState = WalletReadyState.Installed)
    }
    runWithGuard(o) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                return yield o()
            } catch (a) {
                throw this.emit("error", a), a
            }
        })
    }
    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.autoConnect()
        })
    }
    autoConnect() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected)) return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function*() {
                if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError;
                this._connecting = !0;
                try {
                    const o = yield this._authorizationResultCache.get();
                    o && this.handleAuthorizationResult(o)
                } catch (o) {
                    throw new WalletConnectionError(o instanceof Error && o.message || "Unknown error", o)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
    connect() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected)) return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function*() {
                if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError;
                this._connecting = !0;
                try {
                    yield this.performAuthorization()
                } catch (o) {
                    throw new WalletConnectionError(o instanceof Error && o.message || "Unknown error", o)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
    performAuthorization(o) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const a = yield this._authorizationResultCache.get();
                return a ? (this.handleAuthorizationResult(a), a) : yield this.transact($ => __awaiter(this, void 0, void 0, function*() {
                    const j = yield $.authorize({
                        chain: this._chain,
                        identity: this._appIdentity,
                        sign_in_payload: o
                    });
                    return Promise.all([this._authorizationResultCache.set(j), this.handleAuthorizationResult(j)]), j
                }))
            } catch (a) {
                throw new WalletConnectionError(a instanceof Error && a.message || "Unknown error", a)
            }
        })
    }
    handleAuthorizationResult(o) {
        var a;
        return __awaiter(this, void 0, void 0, function*() {
            const $ = this._authorizationResult == null || ((a = this._authorizationResult) === null || a === void 0 ? void 0 : a.accounts.length) !== o.accounts.length || this._authorizationResult.accounts.some((j, _e) => j.address !== o.accounts[_e].address);
            if (this._authorizationResult = o, this.declareWalletAsInstalled(), $) {
                const j = yield this._addressSelector.select(o.accounts.map(({
                    address: _e
                }) => _e));
                j !== this._selectedAddress && (this._selectedAddress = j, delete this._publicKey, this.emit("connect", this.publicKey))
            }
        })
    }
    performReauthorization(o, a) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const $ = yield o.authorize({
                    auth_token: a,
                    identity: this._appIdentity
                });
                Promise.all([this._authorizationResultCache.set($), this.handleAuthorizationResult($)])
            } catch ($) {
                throw this.disconnect(), new WalletDisconnectedError($ instanceof Error && ($ == null ? void 0 : $.message) || "Unknown error", $)
            }
        })
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function*() {
            this._authorizationResultCache.clear(), this._connecting = !1, this._connectionGeneration++, delete this._authorizationResult, delete this._publicKey, delete this._selectedAddress, this.emit("disconnect")
        })
    }
    transact(o) {
        var a;
        return __awaiter(this, void 0, void 0, function*() {
            const $ = (a = this._authorizationResult) === null || a === void 0 ? void 0 : a.wallet_uri_base,
                j = $ ? {
                    baseUri: $
                } : void 0,
                _e = this._connectionGeneration;
            try {
                return yield transact(o, j)
            } catch (et) {
                throw this._connectionGeneration !== _e && (yield new Promise(() => {})), et instanceof Error && et.name === "SolanaMobileWalletAdapterError" && et.code === "ERROR_WALLET_NOT_FOUND" && (yield this._onWalletNotFound(this)), et
            }
        })
    }
    assertIsAuthorized() {
        if (!this._authorizationResult || !this._selectedAddress) throw new WalletNotConnectedError;
        return {
            authToken: this._authorizationResult.auth_token,
            selectedAddress: this._selectedAddress
        }
    }
    performSignTransactions(o) {
        return __awaiter(this, void 0, void 0, function*() {
            const {
                authToken: a
            } = this.assertIsAuthorized();
            try {
                return yield this.transact($ => __awaiter(this, void 0, void 0, function*() {
                    return yield this.performReauthorization($, a), yield $.signTransactions({
                        transactions: o
                    })
                }))
            } catch ($) {
                throw new WalletSignTransactionError($ == null ? void 0 : $.message, $)
            }
        })
    }
    sendTransaction(o, a, $) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function*() {
                const {
                    authToken: j
                } = this.assertIsAuthorized(), _e = $ == null ? void 0 : $.minContextSlot;
                try {
                    return yield this.transact(et => __awaiter(this, void 0, void 0, function*() {
                        function tt() {
                            let st;
                            switch (a.commitment) {
                                case "confirmed":
                                case "finalized":
                                case "processed":
                                    st = a.commitment;
                                    break;
                                default:
                                    st = "finalized"
                            }
                            let lt;
                            switch ($ == null ? void 0 : $.preflightCommitment) {
                                case "confirmed":
                                case "finalized":
                                case "processed":
                                    lt = $.preflightCommitment;
                                    break;
                                case void 0:
                                    lt = st;
                                    break;
                                default:
                                    lt = "finalized"
                            }
                            return (lt === "finalized" ? 2 : lt === "confirmed" ? 1 : 0) < (st === "finalized" ? 2 : st === "confirmed" ? 1 : 0) ? lt : st
                        }
                        const [nt, rt, ot] = yield Promise.all([et.getCapabilities(), this.performReauthorization(et, j), isVersionedTransaction(o) ? null : __awaiter(this, void 0, void 0, function*() {
                            var st;
                            if (o.feePayer || (o.feePayer = (st = this.publicKey) !== null && st !== void 0 ? st : void 0), o.recentBlockhash == null) {
                                const {
                                    blockhash: lt
                                } = yield a.getLatestBlockhash({
                                    commitment: tt()
                                });
                                o.recentBlockhash = lt
                            }
                        })]);
                        if (nt.supports_sign_and_send_transactions) return (yield et.signAndSendTransactions({
                            minContextSlot: _e,
                            transactions: [o]
                        }))[0]; {
                            const [st] = yield et.signTransactions({
                                transactions: [o]
                            });
                            if (isVersionedTransaction(st)) return yield a.sendTransaction(st); {
                                const lt = st.serialize();
                                return yield a.sendRawTransaction(lt, Object.assign(Object.assign({}, $), {
                                    preflightCommitment: tt()
                                }))
                            }
                        }
                    }))
                } catch (et) {
                    throw new WalletSendTransactionError(et == null ? void 0 : et.message, et)
                }
            }))
        })
    }
    signTransaction(o) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function*() {
                const [a] = yield this.performSignTransactions([o]);
                return a
            }))
        })
    }
    signAllTransactions(o) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function*() {
                return yield this.performSignTransactions(o)
            }))
        })
    }
    signMessage(o) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function*() {
                const {
                    authToken: a,
                    selectedAddress: $
                } = this.assertIsAuthorized();
                try {
                    return yield this.transact(j => __awaiter(this, void 0, void 0, function*() {
                        yield this.performReauthorization(j, a);
                        const [_e] = yield j.signMessages({
                            addresses: [$],
                            payloads: [o]
                        });
                        return _e.slice(-SIGNATURE_LENGTH_IN_BYTES$1)
                    }))
                } catch (j) {
                    throw new WalletSignMessageError(j == null ? void 0 : j.message, j)
                }
            }))
        })
    }
    signIn(o) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function*() {
                var a, $;
                if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError;
                this._connecting = !0;
                try {
                    const j = yield this.performAuthorization(Object.assign(Object.assign({}, o), {
                        domain: (a = o == null ? void 0 : o.domain) !== null && a !== void 0 ? a : window.location.host
                    }));
                    if (!j.sign_in_result) throw new Error("Sign in failed, no sign in result returned by wallet");
                    const _e = j.sign_in_result.address;
                    return {
                        account: Object.assign(Object.assign({}, ($ = j.accounts.find(tt => tt.address == _e)) !== null && $ !== void 0 ? $ : {
                            address: _e
                        }), {
                            publicKey: toUint8Array(_e)
                        }),
                        signedMessage: toUint8Array(j.sign_in_result.signed_message),
                        signature: toUint8Array(j.sign_in_result.signature)
                    }
                } catch (j) {
                    throw new WalletConnectionError(j instanceof Error && j.message || "Unknown error", j)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
}

function createDefaultAddressSelector() {
    return {
        select(s) {
            return __awaiter(this, void 0, void 0, function*() {
                return s[0]
            })
        }
    }
}
const CACHE_KEY = "SolanaMobileWalletAdapterDefaultAuthorizationCache";

function createDefaultAuthorizationResultCache() {
    let s;
    try {
        s = window.localStorage
    } catch {}
    return {
        clear() {
            return __awaiter(this, void 0, void 0, function*() {
                if (s) try {
                    s.removeItem(CACHE_KEY)
                } catch {}
            })
        },
        get() {
            return __awaiter(this, void 0, void 0, function*() {
                if (s) try {
                    return JSON.parse(s.getItem(CACHE_KEY)) || void 0
                } catch {}
            })
        },
        set(o) {
            return __awaiter(this, void 0, void 0, function*() {
                if (s) try {
                    s.setItem(CACHE_KEY, JSON.stringify(o))
                } catch {}
            })
        }
    }
}

function defaultWalletNotFoundHandler(s) {
    return __awaiter(this, void 0, void 0, function*() {
        typeof window < "u" && window.location.assign(s.url)
    })
}

function createDefaultWalletNotFoundHandler() {
    return defaultWalletNotFoundHandler
}

function arraysEqual(s, o) {
    if (s === o) return !0;
    const a = s.length;
    if (a !== o.length) return !1;
    for (let $ = 0; $ < a; $++)
        if (s[$] !== o[$]) return !1;
    return !0
}
var __classPrivateFieldSet$1 = function(s, o, a, $, j) {
        if ($ === "m") throw new TypeError("Private method is not writable");
        if ($ === "a" && !j) throw new TypeError("Private accessor was defined without a setter");
        if (typeof o == "function" ? s !== o || !j : !o.has(s)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return $ === "a" ? j.call(s, a) : j ? j.value = a : o.set(s, a), a
    },
    __classPrivateFieldGet$1 = function(s, o, a, $) {
        if (a === "a" && !$) throw new TypeError("Private accessor was defined without a getter");
        if (typeof o == "function" ? s !== o || !$ : !o.has(s)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return a === "m" ? $ : a === "a" ? $.call(s) : $ ? $.value : o.get(s)
    },
    _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;
class StandardWalletAdapter extends BaseWalletAdapter {
    constructor({
        wallet: o
    }) {
        super(), _StandardWalletAdapter_instances.add(this), _StandardWalletAdapter_account.set(this, void 0), _StandardWalletAdapter_publicKey.set(this, void 0), _StandardWalletAdapter_connecting.set(this, void 0), _StandardWalletAdapter_disconnecting.set(this, void 0), _StandardWalletAdapter_off.set(this, void 0), _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0), _StandardWalletAdapter_wallet.set(this, void 0), _StandardWalletAdapter_readyState.set(this, typeof window > "u" || typeof document > "u" ? WalletReadyState.Unsupported : WalletReadyState.Installed), _StandardWalletAdapter_changed.set(this, a => {
            if ("accounts" in a) {
                const $ = __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").accounts[0];
                __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f") && !__classPrivateFieldGet$1(this, _StandardWalletAdapter_disconnecting, "f") && $ !== __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f") && ($ ? __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, $) : (this.emit("error", new WalletDisconnectedError), __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_disconnected).call(this)))
            }
            "features" in a && __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this)
        }), __classPrivateFieldSet$1(this, _StandardWalletAdapter_wallet, o, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_account, null, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_publicKey, null, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_connecting, !1, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_disconnecting, !1, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_off, __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[StandardEvents].on("change", __classPrivateFieldGet$1(this, _StandardWalletAdapter_changed, "f")), "f"), __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this)
    }
    get name() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").name
    }
    get url() {
        return "https://github.com/solana-labs/wallet-standard"
    }
    get icon() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").icon
    }
    get readyState() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_readyState, "f")
    }
    get publicKey() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_publicKey, "f")
    }
    get connecting() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_connecting, "f")
    }
    get supportedTransactionVersions() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_supportedTransactionVersions, "f")
    }
    get wallet() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f")
    }
    get standard() {
        return !0
    }
    destroy() {
        __classPrivateFieldSet$1(this, _StandardWalletAdapter_account, null, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_publicKey, null, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_connecting, !1, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_disconnecting, !1, "f");
        const o = __classPrivateFieldGet$1(this, _StandardWalletAdapter_off, "f");
        o && (__classPrivateFieldSet$1(this, _StandardWalletAdapter_off, null, "f"), o())
    }
    async autoConnect() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connect).call(this, {
            silent: !0
        })
    }
    async connect() {
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connect).call(this)
    }
    async disconnect() {
        if (StandardDisconnect in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features) try {
            __classPrivateFieldSet$1(this, _StandardWalletAdapter_disconnecting, !0, "f"), await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[StandardDisconnect].disconnect()
        } catch (o) {
            this.emit("error", new WalletDisconnectionError(o == null ? void 0 : o.message, o))
        } finally {
            __classPrivateFieldSet$1(this, _StandardWalletAdapter_disconnecting, !1, "f")
        }
        __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_disconnected).call(this)
    }
    async sendTransaction(o, a, $ = {}) {
        try {
            const j = __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f");
            if (!j) throw new WalletNotConnectedError;
            let _e;
            if (SolanaSignAndSendTransaction in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features)
                if (j.features.includes(SolanaSignAndSendTransaction)) _e = SolanaSignAndSendTransaction;
                else if (SolanaSignTransaction in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features && j.features.includes(SolanaSignTransaction)) _e = SolanaSignTransaction;
            else throw new WalletAccountError;
            else if (SolanaSignTransaction in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features) {
                if (!j.features.includes(SolanaSignTransaction)) throw new WalletAccountError;
                _e = SolanaSignTransaction
            } else throw new WalletConfigError;
            const et = getChainForEndpoint(a.rpcEndpoint);
            if (!j.chains.includes(et)) throw new WalletSendTransactionError;
            try {
                const {
                    signers: tt,
                    ...nt
                } = $;
                let rt;
                if (isVersionedTransaction$1(o) ? (tt != null && tt.length && o.sign(tt), rt = o.serialize()) : (o = await this.prepareTransaction(o, a, nt), tt != null && tt.length && o.partialSign(...tt), rt = new Uint8Array(o.serialize({
                        requireAllSignatures: !1,
                        verifySignatures: !1
                    }))), _e === SolanaSignAndSendTransaction) {
                    const [ot] = await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignAndSendTransaction].signAndSendTransaction({
                        account: j,
                        chain: et,
                        transaction: rt,
                        options: {
                            preflightCommitment: getCommitment(nt.preflightCommitment || a.commitment),
                            skipPreflight: nt.skipPreflight,
                            maxRetries: nt.maxRetries,
                            minContextSlot: nt.minContextSlot
                        }
                    });
                    return base58.encode(ot.signature)
                } else {
                    const [ot] = await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction({
                        account: j,
                        chain: et,
                        transaction: rt,
                        options: {
                            preflightCommitment: getCommitment(nt.preflightCommitment || a.commitment),
                            minContextSlot: nt.minContextSlot
                        }
                    });
                    return await a.sendRawTransaction(ot.signedTransaction, { ...nt,
                        preflightCommitment: getCommitment(nt.preflightCommitment || a.commitment)
                    })
                }
            } catch (tt) {
                throw tt instanceof WalletError ? tt : new WalletSendTransactionError(tt == null ? void 0 : tt.message, tt)
            }
        } catch (j) {
            throw this.emit("error", j), j
        }
    }
}
_StandardWalletAdapter_account = new WeakMap, _StandardWalletAdapter_publicKey = new WeakMap, _StandardWalletAdapter_connecting = new WeakMap, _StandardWalletAdapter_disconnecting = new WeakMap, _StandardWalletAdapter_off = new WeakMap, _StandardWalletAdapter_supportedTransactionVersions = new WeakMap, _StandardWalletAdapter_wallet = new WeakMap, _StandardWalletAdapter_readyState = new WeakMap, _StandardWalletAdapter_changed = new WeakMap, _StandardWalletAdapter_instances = new WeakSet, _StandardWalletAdapter_connect = async function s(o) {
    try {
        if (this.connected || this.connecting) return;
        if (__classPrivateFieldGet$1(this, _StandardWalletAdapter_readyState, "f") !== WalletReadyState.Installed) throw new WalletNotReadyError;
        if (__classPrivateFieldSet$1(this, _StandardWalletAdapter_connecting, !0, "f"), !__classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").accounts.length) try {
            await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[StandardConnect].connect(o)
        } catch ($) {
            throw new WalletConnectionError($ == null ? void 0 : $.message, $)
        }
        const a = __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").accounts[0];
        if (!a) throw new WalletAccountError;
        __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, a)
    } catch (a) {
        throw this.emit("error", a), a
    } finally {
        __classPrivateFieldSet$1(this, _StandardWalletAdapter_connecting, !1, "f")
    }
}, _StandardWalletAdapter_connected = function s(o) {
    let a;
    try {
        a = new PublicKey$1(o.address)
    } catch ($) {
        throw new WalletPublicKeyError($ == null ? void 0 : $.message, $)
    }
    __classPrivateFieldSet$1(this, _StandardWalletAdapter_account, o, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_publicKey, a, "f"), __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this), this.emit("connect", a)
}, _StandardWalletAdapter_disconnected = function s() {
    __classPrivateFieldSet$1(this, _StandardWalletAdapter_account, null, "f"), __classPrivateFieldSet$1(this, _StandardWalletAdapter_publicKey, null, "f"), __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this), this.emit("disconnect")
}, _StandardWalletAdapter_reset = function s() {
    var a, $;
    const o = SolanaSignAndSendTransaction in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features ? __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignAndSendTransaction].supportedTransactionVersions : __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].supportedTransactionVersions;
    __classPrivateFieldSet$1(this, _StandardWalletAdapter_supportedTransactionVersions, arraysEqual(o, ["legacy"]) ? null : new Set(o), "f"), SolanaSignTransaction in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features && ((a = __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f")) != null && a.features.includes(SolanaSignTransaction)) ? (this.signTransaction = __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signTransaction), this.signAllTransactions = __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signAllTransactions)) : (delete this.signTransaction, delete this.signAllTransactions), SolanaSignMessage in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features && (($ = __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f")) != null && $.features.includes(SolanaSignMessage)) ? this.signMessage = __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signMessage) : delete this.signMessage, SolanaSignIn in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features ? this.signIn = __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signIn) : delete this.signIn
}, _StandardWalletAdapter_signTransaction = async function s(o) {
    try {
        const a = __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f");
        if (!a) throw new WalletNotConnectedError;
        if (!(SolanaSignTransaction in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features)) throw new WalletConfigError;
        if (!a.features.includes(SolanaSignTransaction)) throw new WalletAccountError;
        try {
            const j = (await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction({
                account: a,
                transaction: isVersionedTransaction$1(o) ? o.serialize() : new Uint8Array(o.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            }))[0].signedTransaction;
            return isVersionedTransaction$1(o) ? VersionedTransaction$1.deserialize(j) : Transaction$1.from(j)
        } catch ($) {
            throw $ instanceof WalletError ? $ : new WalletSignTransactionError($ == null ? void 0 : $.message, $)
        }
    } catch (a) {
        throw this.emit("error", a), a
    }
}, _StandardWalletAdapter_signAllTransactions = async function s(o) {
    try {
        const a = __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f");
        if (!a) throw new WalletNotConnectedError;
        if (!(SolanaSignTransaction in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features)) throw new WalletConfigError;
        if (!a.features.includes(SolanaSignTransaction)) throw new WalletAccountError;
        try {
            const $ = await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction(...o.map(j => ({
                account: a,
                transaction: isVersionedTransaction$1(j) ? j.serialize() : new Uint8Array(j.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            })));
            return o.map((j, _e) => {
                const et = $[_e].signedTransaction;
                return isVersionedTransaction$1(j) ? VersionedTransaction$1.deserialize(et) : Transaction$1.from(et)
            })
        } catch ($) {
            throw new WalletSignTransactionError($ == null ? void 0 : $.message, $)
        }
    } catch (a) {
        throw this.emit("error", a), a
    }
}, _StandardWalletAdapter_signMessage = async function s(o) {
    try {
        const a = __classPrivateFieldGet$1(this, _StandardWalletAdapter_account, "f");
        if (!a) throw new WalletNotConnectedError;
        if (!(SolanaSignMessage in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features)) throw new WalletConfigError;
        if (!a.features.includes(SolanaSignMessage)) throw new WalletAccountError;
        try {
            return (await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignMessage].signMessage({
                account: a,
                message: o
            }))[0].signature
        } catch ($) {
            throw new WalletSignMessageError($ == null ? void 0 : $.message, $)
        }
    } catch (a) {
        throw this.emit("error", a), a
    }
}, _StandardWalletAdapter_signIn = async function s(o = {}) {
    try {
        if (!(SolanaSignIn in __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features)) throw new WalletConfigError;
        let a;
        try {
            [a] = await __classPrivateFieldGet$1(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignIn].signIn(o)
        } catch ($) {
            throw new WalletSignInError($ == null ? void 0 : $.message, $)
        }
        if (!a) throw new WalletSignInError;
        return __classPrivateFieldGet$1(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, a.account), a
    } catch (a) {
        throw this.emit("error", a), a
    }
};
const isWalletAdapterCompatibleWallet = isWalletAdapterCompatibleStandardWallet;
var __classPrivateFieldSet = function(s, o, a, $, j) {
        if ($ === "m") throw new TypeError("Private method is not writable");
        if ($ === "a" && !j) throw new TypeError("Private accessor was defined without a setter");
        if (typeof o == "function" ? s !== o || !j : !o.has(s)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return $ === "a" ? j.call(s, a) : j ? j.value = a : o.set(s, a), a
    },
    __classPrivateFieldGet = function(s, o, a, $) {
        if (a === "a" && !$) throw new TypeError("Private accessor was defined without a getter");
        if (typeof o == "function" ? s !== o || !$ : !o.has(s)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return a === "m" ? $ : a === "a" ? $.call(s) : $ ? $.value : o.get(s)
    },
    _AppReadyEvent_detail;
let wallets;
const registered = new Set,
    listeners = {};

function getWallets() {
    if (wallets || (wallets = Object.freeze({
            register,
            get,
            on
        }), typeof window > "u")) return wallets;
    const s = Object.freeze({
        register
    });
    try {
        window.addEventListener("wallet-standard:register-wallet", ({
            detail: o
        }) => o(s))
    } catch (o) {
        console.error(`wallet-standard:register-wallet event listener could not be added
`, o)
    }
    try {
        window.dispatchEvent(new AppReadyEvent(s))
    } catch (o) {
        console.error(`wallet-standard:app-ready event could not be dispatched
`, o)
    }
    return wallets
}

function register(...s) {
    var o;
    return s = s.filter(a => !registered.has(a)), s.length ? (s.forEach(a => registered.add(a)), (o = listeners.register) == null || o.forEach(a => guard(() => a(...s))), function() {
        var $;
        s.forEach(j => registered.delete(j)), ($ = listeners.unregister) == null || $.forEach(j => guard(() => j(...s)))
    }) : () => {}
}

function get() {
    return [...registered]
}

function on(s, o) {
    var a;
    return (a = listeners[s]) != null && a.push(o) || (listeners[s] = [o]),
        function() {
            var j;
            listeners[s] = (j = listeners[s]) == null ? void 0 : j.filter(_e => o !== _e)
        }
}

function guard(s) {
    try {
        s()
    } catch (o) {
        console.error(o)
    }
}
class AppReadyEvent extends Event {
    constructor(o) {
        super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }), _AppReadyEvent_detail.set(this, void 0), __classPrivateFieldSet(this, _AppReadyEvent_detail, o, "f")
    }
    get detail() {
        return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f")
    }
    get type() {
        return "wallet-standard:app-ready"
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
_AppReadyEvent_detail = new WeakMap;

function DEPRECATED_getWallets() {
    if (wallets || (wallets = getWallets(), typeof window > "u")) return wallets;
    const s = window.navigator.wallets || [];
    if (!Array.isArray(s)) return console.error("window.navigator.wallets is not an array"), wallets;
    const {
        register: o
    } = wallets, a = (...$) => $.forEach(j => guard(() => j({
        register: o
    })));
    try {
        Object.defineProperty(window.navigator, "wallets", {
            value: Object.freeze({
                push: a
            })
        })
    } catch {
        return console.error("window.navigator.wallets could not be set"), wallets
    }
    return a(...s), wallets
}

function useStandardWalletAdapters(s) {
    const o = useConstant(() => new Set),
        {
            get: a,
            on: $
        } = useConstant(() => DEPRECATED_getWallets()),
        [j, _e] = reactExports.useState(() => wrapWalletsWithAdapters(a()));
    reactExports.useEffect(() => {
        const tt = [$("register", (...nt) => _e(rt => [...rt, ...wrapWalletsWithAdapters(nt)])), $("unregister", (...nt) => _e(rt => rt.filter(ot => nt.some(st => st === ot.wallet))))];
        return () => tt.forEach(nt => nt())
    }, [$]);
    const et = usePrevious(j);
    return reactExports.useEffect(() => {
        if (!et) return;
        const tt = new Set(j);
        new Set(et.filter(rt => !tt.has(rt))).forEach(rt => rt.destroy())
    }, [et, j]), reactExports.useEffect(() => () => j.forEach(tt => tt.destroy()), []), reactExports.useMemo(() => [...j, ...s.filter(({
        name: tt
    }) => j.some(nt => nt.name === tt) ? (o.has(tt) || (o.add(tt), console.warn(`${tt} was registered as a Standard Wallet. The Wallet Adapter for ${tt} can be removed from your app.`)), !1) : !0)], [j, s, o])
}

function useConstant(s) {
    const o = reactExports.useRef();
    return o.current || (o.current = {
        value: s()
    }), o.current.value
}

function usePrevious(s) {
    const o = reactExports.useRef();
    return reactExports.useEffect(() => {
        o.current = s
    }), o.current
}

function wrapWalletsWithAdapters(s) {
    return s.filter(isWalletAdapterCompatibleWallet).map(o => new StandardWalletAdapter({
        wallet: o
    }))
}
var Environment;
(function(s) {
    s[s.DESKTOP_WEB = 0] = "DESKTOP_WEB", s[s.MOBILE_WEB = 1] = "MOBILE_WEB"
})(Environment || (Environment = {}));

function isWebView(s) {
    return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(s)
}

function getEnvironment({
    adapters: s,
    userAgentString: o
}) {
    return s.some(a => a.name !== SolanaMobileWalletAdapterWalletName && a.readyState === WalletReadyState.Installed) ? Environment.DESKTOP_WEB : o && /android/i.test(o) && !isWebView(o) ? Environment.MOBILE_WEB : Environment.DESKTOP_WEB
}

function getInferredClusterFromEndpoint(s) {
    return s ? /devnet/i.test(s) ? "devnet" : /testnet/i.test(s) ? "testnet" : "mainnet-beta" : "mainnet-beta"
}

function WalletProviderBase({
    children: s,
    wallets: o,
    adapter: a,
    isUnloadingRef: $,
    onAutoConnectRequest: j,
    onConnectError: _e,
    onError: et,
    onSelectWallet: tt
}) {
    const nt = reactExports.useRef(!1),
        [rt, ot] = reactExports.useState(!1),
        st = reactExports.useRef(!1),
        [lt, ft] = reactExports.useState(!1),
        [yt, bt] = reactExports.useState(() => (a == null ? void 0 : a.publicKey) ? ? null),
        [ht, vt] = reactExports.useState(() => (a == null ? void 0 : a.connected) ? ? !1),
        wt = reactExports.useRef(et);
    reactExports.useEffect(() => (wt.current = et, () => {
        wt.current = void 0
    }), [et]);
    const gt = reactExports.useRef((at, mt) => ($.current || (wt.current ? wt.current(at, mt) : (console.error(at, mt), at instanceof WalletNotReadyError && typeof window < "u" && mt && window.open(mt.url, "_blank"))), at)),
        [At, Pt] = reactExports.useState(() => o.map(at => ({
            adapter: at,
            readyState: at.readyState
        })).filter(({
            readyState: at
        }) => at !== WalletReadyState.Unsupported));
    reactExports.useEffect(() => {
        Pt(mt => o.map((xt, $t) => {
            const Rt = mt[$t];
            return Rt && Rt.adapter === xt && Rt.readyState === xt.readyState ? Rt : {
                adapter: xt,
                readyState: xt.readyState
            }
        }).filter(({
            readyState: xt
        }) => xt !== WalletReadyState.Unsupported));

        function at(mt) {
            Pt(xt => {
                const $t = xt.findIndex(({
                    adapter: It
                }) => It === this);
                if ($t === -1) return xt;
                const {
                    adapter: Rt
                } = xt[$t];
                return [...xt.slice(0, $t), {
                    adapter: Rt,
                    readyState: mt
                }, ...xt.slice($t + 1)].filter(({
                    readyState: It
                }) => It !== WalletReadyState.Unsupported)
            })
        }
        return o.forEach(mt => mt.on("readyStateChange", at, mt)), () => {
            o.forEach(mt => mt.off("readyStateChange", at, mt))
        }
    }, [a, o]);
    const Bt = reactExports.useMemo(() => At.find(at => at.adapter === a) ? ? null, [a, At]);
    reactExports.useEffect(() => {
        if (!a) return;
        const at = $t => {
                bt($t), nt.current = !1, ot(!1), vt(!0), st.current = !1, ft(!1)
            },
            mt = () => {
                $.current || (bt(null), nt.current = !1, ot(!1), vt(!1), st.current = !1, ft(!1))
            },
            xt = $t => {
                gt.current($t, a)
            };
        return a.on("connect", at), a.on("disconnect", mt), a.on("error", xt), () => {
            a.off("connect", at), a.off("disconnect", mt), a.off("error", xt), mt()
        }
    }, [a, $]);
    const Lt = reactExports.useRef(!1);
    reactExports.useEffect(() => () => {
        Lt.current = !1
    }, [a]), reactExports.useEffect(() => {
        Lt.current || nt.current || ht || !j || !((Bt == null ? void 0 : Bt.readyState) === WalletReadyState.Installed || (Bt == null ? void 0 : Bt.readyState) === WalletReadyState.Loadable) || (nt.current = !0, ot(!0), Lt.current = !0, async function() {
            try {
                await j()
            } catch {
                _e()
            } finally {
                ot(!1), nt.current = !1
            }
        }())
    }, [ht, j, _e, Bt]);
    const Nt = reactExports.useCallback(async (at, mt, xt) => {
            if (!a) throw gt.current(new WalletNotSelectedError);
            if (!ht) throw gt.current(new WalletNotConnectedError, a);
            return await a.sendTransaction(at, mt, xt)
        }, [a, ht]),
        Ut = reactExports.useMemo(() => a && "signTransaction" in a ? async at => {
            if (!ht) throw gt.current(new WalletNotConnectedError, a);
            return await a.signTransaction(at)
        } : void 0, [a, ht]),
        Vt = reactExports.useMemo(() => a && "signAllTransactions" in a ? async at => {
            if (!ht) throw gt.current(new WalletNotConnectedError, a);
            return await a.signAllTransactions(at)
        } : void 0, [a, ht]),
        Ft = reactExports.useMemo(() => a && "signMessage" in a ? async at => {
            if (!ht) throw gt.current(new WalletNotConnectedError, a);
            return await a.signMessage(at)
        } : void 0, [a, ht]),
        Wt = reactExports.useMemo(() => a && "signIn" in a ? async at => await a.signIn(at) : void 0, [a]),
        Ct = reactExports.useCallback(async () => {
            if (nt.current || st.current || Bt != null && Bt.adapter.connected) return;
            if (!Bt) throw gt.current(new WalletNotSelectedError);
            const {
                adapter: at,
                readyState: mt
            } = Bt;
            if (!(mt === WalletReadyState.Installed || mt === WalletReadyState.Loadable)) throw gt.current(new WalletNotReadyError, at);
            nt.current = !0, ot(!0);
            try {
                await at.connect()
            } catch (xt) {
                throw _e(), xt
            } finally {
                ot(!1), nt.current = !1
            }
        }, [_e, Bt]),
        it = reactExports.useCallback(async () => {
            if (!st.current && a) {
                st.current = !0, ft(!0);
                try {
                    await a.disconnect()
                } finally {
                    ft(!1), st.current = !1
                }
            }
        }, [a]);
    return React$1.createElement(WalletContext.Provider, {
        value: {
            autoConnect: !!j,
            wallets: At,
            wallet: Bt,
            publicKey: yt,
            connected: ht,
            connecting: rt,
            disconnecting: lt,
            select: tt,
            connect: Ct,
            disconnect: it,
            sendTransaction: Nt,
            signTransaction: Ut,
            signAllTransactions: Vt,
            signMessage: Ft,
            signIn: Wt
        }
    }, s)
}
let _userAgent;

function getUserAgent() {
    var s;
    return _userAgent === void 0 && (_userAgent = ((s = globalThis.navigator) == null ? void 0 : s.userAgent) ? ? null), _userAgent
}

function getIsMobile(s) {
    const o = getUserAgent();
    return getEnvironment({
        adapters: s,
        userAgentString: o
    }) === Environment.MOBILE_WEB
}

function getUriForAppIdentity() {
    const s = globalThis.location;
    if (s) return `${s.protocol}//${s.host}`
}

function WalletProvider({
    children: s,
    wallets: o,
    autoConnect: a,
    localStorageKey: $ = "walletName",
    onError: j
}) {
    const {
        connection: _e
    } = useConnection(), et = useStandardWalletAdapters(o), tt = reactExports.useMemo(() => {
        if (!getIsMobile(et)) return null;
        const wt = et.find(gt => gt.name === SolanaMobileWalletAdapterWalletName);
        return wt || new SolanaMobileWalletAdapter({
            addressSelector: createDefaultAddressSelector(),
            appIdentity: {
                uri: getUriForAppIdentity()
            },
            authorizationResultCache: createDefaultAuthorizationResultCache(),
            cluster: getInferredClusterFromEndpoint(_e == null ? void 0 : _e.rpcEndpoint),
            onWalletNotFound: createDefaultWalletNotFoundHandler()
        })
    }, [et, _e == null ? void 0 : _e.rpcEndpoint]), nt = reactExports.useMemo(() => tt == null || et.indexOf(tt) !== -1 ? et : [tt, ...et], [et, tt]), [rt, ot] = useLocalStorage($, getIsMobile(et) ? SolanaMobileWalletAdapterWalletName : null), st = reactExports.useMemo(() => nt.find(wt => wt.name === rt) ? ? null, [nt, rt]), lt = reactExports.useCallback(wt => {
        rt !== wt && (st && st.name !== SolanaMobileWalletAdapterWalletName && st.disconnect(), ot(wt))
    }, [st, ot, rt]);
    reactExports.useEffect(() => {
        if (!st) return;

        function wt() {
            bt.current || rt === SolanaMobileWalletAdapterWalletName && getIsMobile(et) || ot(null)
        }
        return st.on("disconnect", wt), () => {
            st.off("disconnect", wt)
        }
    }, [st, et, ot, rt]);
    const ft = reactExports.useRef(!1),
        yt = reactExports.useMemo(() => {
            if (!(!a || !st)) return async () => {
                (a === !0 || await a(st)) && (ft.current ? await st.connect() : await st.autoConnect())
            }
        }, [a, st]),
        bt = reactExports.useRef(!1);
    reactExports.useEffect(() => {
        if (rt === SolanaMobileWalletAdapterWalletName && getIsMobile(et)) {
            bt.current = !1;
            return
        }

        function wt() {
            bt.current = !0
        }
        return window.addEventListener("beforeunload", wt), () => {
            window.removeEventListener("beforeunload", wt)
        }
    }, [et, rt]);
    const ht = reactExports.useCallback(() => {
            st && st.name !== SolanaMobileWalletAdapterWalletName && lt(null)
        }, [st, lt]),
        vt = reactExports.useCallback(wt => {
            ft.current = !0, lt(wt)
        }, [lt]);
    return React$1.createElement(WalletProviderBase, {
        wallets: nt,
        adapter: st,
        isUnloadingRef: bt,
        onAutoConnectRequest: yt,
        onConnectError: ht,
        onError: j,
        onSelectWallet: vt
    }, s)
}

function useWalletMultiButton({
    onSelectWallet: s
}) {
    const {
        connect: o,
        connected: a,
        connecting: $,
        disconnect: j,
        disconnecting: _e,
        publicKey: et,
        select: tt,
        wallet: nt,
        wallets: rt
    } = useWallet();
    let ot;
    $ ? ot = "connecting" : a ? ot = "connected" : _e ? ot = "disconnecting" : nt ? ot = "has-wallet" : ot = "no-wallet";
    const st = reactExports.useCallback(() => {
            o().catch(() => {})
        }, [o]),
        lt = reactExports.useCallback(() => {
            j().catch(() => {})
        }, [j]),
        ft = reactExports.useCallback(() => {
            s({
                onSelectWallet: tt,
                wallets: rt
            })
        }, [s, tt, rt]);
    return {
        buttonState: ot,
        onConnect: ot === "has-wallet" ? st : void 0,
        onDisconnect: ot !== "disconnecting" && ot !== "no-wallet" ? lt : void 0,
        onSelectWallet: ft,
        publicKey: et ? ? void 0,
        walletIcon: nt == null ? void 0 : nt.adapter.icon,
        walletName: nt == null ? void 0 : nt.adapter.name
    }
}
const Button = s => React$1.createElement("button", {
        className: `wallet-adapter-button ${s.className||""}`,
        disabled: s.disabled,
        style: s.style,
        onClick: s.onClick,
        tabIndex: s.tabIndex || 0,
        type: "button"
    }, s.startIcon && React$1.createElement("i", {
        className: "wallet-adapter-button-start-icon"
    }, s.startIcon), s.children, s.endIcon && React$1.createElement("i", {
        className: "wallet-adapter-button-end-icon"
    }, s.endIcon)),
    WalletIcon = ({
        wallet: s,
        ...o
    }) => s && React$1.createElement("img", {
        src: s.adapter.icon,
        alt: `${s.adapter.name} icon`,
        ...o
    });

function BaseWalletConnectionButton({
    walletIcon: s,
    walletName: o,
    ...a
}) {
    return React$1.createElement(Button, { ...a,
        className: "wallet-adapter-button-trigger",
        startIcon: s && o ? React$1.createElement(WalletIcon, {
            wallet: {
                adapter: {
                    icon: s,
                    name: o
                }
            }
        }) : void 0
    })
}

function BaseWalletMultiButton({
    children: s,
    labels: o,
    ...a
}) {
    const {
        setVisible: $
    } = useWalletModal(), {
        buttonState: j,
        onConnect: _e,
        onDisconnect: et,
        publicKey: tt,
        walletIcon: nt,
        walletName: rt
    } = useWalletMultiButton({
        onSelectWallet() {
            $(!0)
        }
    }), [ot, st] = reactExports.useState(!1), [lt, ft] = reactExports.useState(!1), yt = reactExports.useRef(null);
    reactExports.useEffect(() => {
        const ht = vt => {
            const wt = yt.current;
            !wt || wt.contains(vt.target) || ft(!1)
        };
        return document.addEventListener("mousedown", ht), document.addEventListener("touchstart", ht), () => {
            document.removeEventListener("mousedown", ht), document.removeEventListener("touchstart", ht)
        }
    }, []);
    const bt = reactExports.useMemo(() => {
        if (s) return s;
        if (tt) {
            const ht = tt.toBase58();
            return ht.slice(0, 4) + ".." + ht.slice(-4)
        } else return j === "connecting" || j === "has-wallet" ? o[j] : o["no-wallet"]
    }, [j, s, o, tt]);
    return React$1.createElement("div", {
        className: "wallet-adapter-dropdown"
    }, React$1.createElement(BaseWalletConnectionButton, { ...a,
        "aria-expanded": lt,
        style: {
            pointerEvents: lt ? "none" : "auto",
            ...a.style
        },
        onClick: () => {
            switch (j) {
                case "no-wallet":
                    $(!0);
                    break;
                case "has-wallet":
                    _e && _e();
                    break;
                case "connected":
                    ft(!0);
                    break
            }
        },
        walletIcon: nt,
        walletName: rt
    }, bt), React$1.createElement("ul", {
        "aria-label": "dropdown-list",
        className: `wallet-adapter-dropdown-list ${lt&&"wallet-adapter-dropdown-list-active"}`,
        ref: yt,
        role: "menu"
    }, tt ? React$1.createElement("li", {
        className: "wallet-adapter-dropdown-list-item",
        onClick: async () => {
            await navigator.clipboard.writeText(tt.toBase58()), st(!0), setTimeout(() => st(!1), 400)
        },
        role: "menuitem"
    }, ot ? o.copied : o["copy-address"]) : null, React$1.createElement("li", {
        className: "wallet-adapter-dropdown-list-item",
        onClick: () => {
            $(!0), ft(!1)
        },
        role: "menuitem"
    }, o["change-wallet"]), et ? React$1.createElement("li", {
        className: "wallet-adapter-dropdown-list-item",
        onClick: () => {
            et(), ft(!1)
        },
        role: "menuitem"
    }, o.disconnect) : null))
}
const Collapse = ({
        id: s,
        children: o,
        expanded: a = !1
    }) => {
        const $ = reactExports.useRef(null),
            j = reactExports.useRef(!0),
            _e = "height 250ms ease-out",
            et = () => {
                const nt = $.current;
                nt && requestAnimationFrame(() => {
                    nt.style.height = nt.scrollHeight + "px"
                })
            },
            tt = () => {
                const nt = $.current;
                nt && requestAnimationFrame(() => {
                    nt.style.height = nt.offsetHeight + "px", nt.style.overflow = "hidden", requestAnimationFrame(() => {
                        nt.style.height = "0"
                    })
                })
            };
        return reactExports.useLayoutEffect(() => {
            a ? et() : tt()
        }, [a]), reactExports.useLayoutEffect(() => {
            const nt = $.current;
            if (!nt) return;

            function rt() {
                nt && (nt.style.overflow = a ? "initial" : "hidden", a && (nt.style.height = "auto"))
            }

            function ot(st) {
                nt && st.target === nt && st.propertyName === "height" && rt()
            }
            return j.current && (rt(), j.current = !1), nt.addEventListener("transitionend", ot), () => nt.removeEventListener("transitionend", ot)
        }, [a]), React$1.createElement("div", {
            className: "wallet-adapter-collapse",
            id: s,
            ref: $,
            role: "region",
            style: {
                height: 0,
                transition: j.current ? void 0 : _e
            }
        }, o)
    },
    WalletListItem = ({
        handleClick: s,
        tabIndex: o,
        wallet: a
    }) => React$1.createElement("li", null, React$1.createElement(Button, {
        onClick: s,
        startIcon: React$1.createElement(WalletIcon, {
            wallet: a
        }),
        tabIndex: o
    }, a.adapter.name, a.readyState === WalletReadyState.Installed && React$1.createElement("span", null, "Detected"))),
    WalletSVG = () => React$1.createElement("svg", {
        width: "97",
        height: "96",
        viewBox: "0 0 97 96",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, React$1.createElement("circle", {
        cx: "48.5",
        cy: "48",
        r: "48",
        fill: "url(#paint0_linear_880_5115)",
        fillOpacity: "0.1"
    }), React$1.createElement("circle", {
        cx: "48.5",
        cy: "48",
        r: "47",
        stroke: "url(#paint1_linear_880_5115)",
        strokeOpacity: "0.4",
        strokeWidth: "2"
    }), React$1.createElement("g", {
        clipPath: "url(#clip0_880_5115)"
    }, React$1.createElement("path", {
        d: "M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z",
        fill: "url(#paint2_linear_880_5115)"
    }), React$1.createElement("path", {
        d: "M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z",
        fill: "url(#paint3_linear_880_5115)"
    })), React$1.createElement("defs", null, React$1.createElement("linearGradient", {
        id: "paint0_linear_880_5115",
        x1: "3.41664",
        y1: "98.0933",
        x2: "103.05",
        y2: "8.42498",
        gradientUnits: "userSpaceOnUse"
    }, React$1.createElement("stop", {
        stopColor: "#9945FF"
    }), React$1.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), React$1.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), React$1.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), React$1.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), React$1.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), React$1.createElement("linearGradient", {
        id: "paint1_linear_880_5115",
        x1: "3.41664",
        y1: "98.0933",
        x2: "103.05",
        y2: "8.42498",
        gradientUnits: "userSpaceOnUse"
    }, React$1.createElement("stop", {
        stopColor: "#9945FF"
    }), React$1.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), React$1.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), React$1.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), React$1.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), React$1.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), React$1.createElement("linearGradient", {
        id: "paint2_linear_880_5115",
        x1: "25.9583",
        y1: "68.7101",
        x2: "67.2337",
        y2: "23.7879",
        gradientUnits: "userSpaceOnUse"
    }, React$1.createElement("stop", {
        stopColor: "#9945FF"
    }), React$1.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), React$1.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), React$1.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), React$1.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), React$1.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), React$1.createElement("linearGradient", {
        id: "paint3_linear_880_5115",
        x1: "58.3326",
        y1: "49.4467",
        x2: "61.0002",
        y2: "45.4453",
        gradientUnits: "userSpaceOnUse"
    }, React$1.createElement("stop", {
        stopColor: "#9945FF"
    }), React$1.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), React$1.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), React$1.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), React$1.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), React$1.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), React$1.createElement("clipPath", {
        id: "clip0_880_5115"
    }, React$1.createElement("rect", {
        width: "48",
        height: "48",
        fill: "white",
        transform: "translate(24.5 24)"
    })))),
    WalletModal = ({
        className: s = "",
        container: o = "body"
    }) => {
        const a = reactExports.useRef(null),
            {
                wallets: $,
                select: j
            } = useWallet(),
            {
                setVisible: _e
            } = useWalletModal(),
            [et, tt] = reactExports.useState(!1),
            [nt, rt] = reactExports.useState(!1),
            [ot, st] = reactExports.useState(null),
            [lt, ft] = reactExports.useMemo(() => {
                const gt = [],
                    At = [];
                for (const Pt of $) Pt.readyState === WalletReadyState.Installed ? gt.push(Pt) : At.push(Pt);
                return gt.length ? [gt, At] : [At, []]
            }, [$]),
            yt = reactExports.useCallback(() => {
                rt(!1), setTimeout(() => _e(!1), 150)
            }, [_e]),
            bt = reactExports.useCallback(gt => {
                gt.preventDefault(), yt()
            }, [yt]),
            ht = reactExports.useCallback((gt, At) => {
                j(At), bt(gt)
            }, [j, bt]),
            vt = reactExports.useCallback(() => tt(!et), [et]),
            wt = reactExports.useCallback(gt => {
                const At = a.current;
                if (!At) return;
                const Pt = At.querySelectorAll("button"),
                    Bt = Pt[0],
                    Lt = Pt[Pt.length - 1];
                gt.shiftKey ? document.activeElement === Bt && (Lt.focus(), gt.preventDefault()) : document.activeElement === Lt && (Bt.focus(), gt.preventDefault())
            }, [a]);
        return reactExports.useLayoutEffect(() => {
            const gt = Pt => {
                    Pt.key === "Escape" ? yt() : Pt.key === "Tab" && wt(Pt)
                },
                {
                    overflow: At
                } = window.getComputedStyle(document.body);
            return setTimeout(() => rt(!0), 0), document.body.style.overflow = "hidden", window.addEventListener("keydown", gt, !1), () => {
                document.body.style.overflow = At, window.removeEventListener("keydown", gt, !1)
            }
        }, [yt, wt]), reactExports.useLayoutEffect(() => st(document.querySelector(o)), [o]), ot && reactDomExports.createPortal(React$1.createElement("div", {
            "aria-labelledby": "wallet-adapter-modal-title",
            "aria-modal": "true",
            className: `wallet-adapter-modal ${nt&&"wallet-adapter-modal-fade-in"} ${s}`,
            ref: a,
            role: "dialog"
        }, React$1.createElement("div", {
            className: "wallet-adapter-modal-container"
        }, React$1.createElement("div", {
            className: "wallet-adapter-modal-wrapper"
        }, React$1.createElement("button", {
            onClick: bt,
            className: "wallet-adapter-modal-button-close"
        }, React$1.createElement("svg", {
            width: "14",
            height: "14"
        }, React$1.createElement("path", {
            d: "M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z"
        }))), lt.length ? React$1.createElement(React$1.Fragment, null, React$1.createElement("h1", {
            className: "wallet-adapter-modal-title"
        }, "Connect a wallet on Solana to continue"), React$1.createElement("ul", {
            className: "wallet-adapter-modal-list"
        }, lt.map(gt => React$1.createElement(WalletListItem, {
            key: gt.adapter.name,
            handleClick: At => ht(At, gt.adapter.name),
            wallet: gt
        })), ft.length ? React$1.createElement(Collapse, {
            expanded: et,
            id: "wallet-adapter-modal-collapse"
        }, ft.map(gt => React$1.createElement(WalletListItem, {
            key: gt.adapter.name,
            handleClick: At => ht(At, gt.adapter.name),
            tabIndex: et ? 0 : -1,
            wallet: gt
        }))) : null), ft.length ? React$1.createElement("button", {
            className: "wallet-adapter-modal-list-more",
            onClick: vt,
            tabIndex: 0
        }, React$1.createElement("span", null, et ? "Less " : "More ", "options"), React$1.createElement("svg", {
            width: "13",
            height: "7",
            viewBox: "0 0 13 7",
            xmlns: "http://www.w3.org/2000/svg",
            className: `${et?"wallet-adapter-modal-list-more-icon-rotate":""}`
        }, React$1.createElement("path", {
            d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
        }))) : null) : React$1.createElement(React$1.Fragment, null, React$1.createElement("h1", {
            className: "wallet-adapter-modal-title"
        }, "You'll need a wallet on Solana to continue"), React$1.createElement("div", {
            className: "wallet-adapter-modal-middle"
        }, React$1.createElement(WalletSVG, null)), ft.length ? React$1.createElement(React$1.Fragment, null, React$1.createElement("button", {
            className: "wallet-adapter-modal-list-more",
            onClick: vt,
            tabIndex: 0
        }, React$1.createElement("span", null, et ? "Hide " : "Already have a wallet? View ", "options"), React$1.createElement("svg", {
            width: "13",
            height: "7",
            viewBox: "0 0 13 7",
            xmlns: "http://www.w3.org/2000/svg",
            className: `${et?"wallet-adapter-modal-list-more-icon-rotate":""}`
        }, React$1.createElement("path", {
            d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
        }))), React$1.createElement(Collapse, {
            expanded: et,
            id: "wallet-adapter-modal-collapse"
        }, React$1.createElement("ul", {
            className: "wallet-adapter-modal-list"
        }, ft.map(gt => React$1.createElement(WalletListItem, {
            key: gt.adapter.name,
            handleClick: At => ht(At, gt.adapter.name),
            tabIndex: et ? 0 : -1,
            wallet: gt
        }))))) : null))), React$1.createElement("div", {
            className: "wallet-adapter-modal-overlay",
            onMouseDown: bt
        })), ot)
    },
    WalletModalProvider = ({
        children: s,
        ...o
    }) => {
        const [a, $] = reactExports.useState(!1);
        return React$1.createElement(WalletModalContext.Provider, {
            value: {
                visible: a,
                setVisible: $
            }
        }, s, a && React$1.createElement(WalletModal, { ...o
        }))
    },
    LABELS = {
        "change-wallet": "Change wallet",
        connecting: "Connecting ...",
        "copy-address": "Copy address",
        copied: "Copied",
        disconnect: "Disconnect",
        "has-wallet": "Connect",
        "no-wallet": "Select Wallet"
    };

function WalletMultiButton(s) {
    return React$1.createElement(BaseWalletMultiButton, { ...s,
        labels: LABELS
    })
}
const version$1 = "0.1.0",
    name = "thirtymint",
    instructions = [{
        name: "initialize",
        accounts: [{
            name: "admin",
            isMut: !0,
            isSigner: !0
        }, {
            name: "state",
            isMut: !0,
            isSigner: !1
        }, {
            name: "systemProgram",
            isMut: !1,
            isSigner: !1
        }],
        args: []
    }, {
        name: "startRound",
        accounts: [{
            name: "admin",
            isMut: !0,
            isSigner: !0
        }, {
            name: "state",
            isMut: !0,
            isSigner: !1
        }, {
            name: "round",
            isMut: !0,
            isSigner: !1
        }, {
            name: "systemProgram",
            isMut: !1,
            isSigner: !1
        }],
        args: []
    }, {
        name: "participate",
        accounts: [{
            name: "admin",
            isMut: !0,
            isSigner: !1
        }, {
            name: "participant",
            isMut: !0,
            isSigner: !0
        }, {
            name: "state",
            isMut: !0,
            isSigner: !1
        }, {
            name: "round",
            isMut: !0,
            isSigner: !1
        }, {
            name: "systemProgram",
            isMut: !1,
            isSigner: !1
        }],
        args: [{
            name: "amount",
            type: "u64"
        }]
    }, {
        name: "distributePrizes",
        accounts: [{
            name: "admin",
            isMut: !0,
            isSigner: !0
        }, {
            name: "state",
            isMut: !0,
            isSigner: !1
        }, {
            name: "round",
            isMut: !0,
            isSigner: !1
        }, {
            name: "systemProgram",
            isMut: !1,
            isSigner: !1
        }],
        args: [{
            name: "randomness",
            type: {
                array: ["u8", 32]
            }
        }]
    }],
    accounts = [{
        name: "State",
        type: {
            kind: "struct",
            fields: [{
                name: "admin",
                type: "publicKey"
            }, {
                name: "currentRound",
                type: "u64"
            }, {
                name: "bump",
                type: "u8"
            }, {
                name: "totalParticipantsAllTime",
                type: "u64"
            }]
        }
    }, {
        name: "Round",
        type: {
            kind: "struct",
            fields: [{
                name: "id",
                type: "u64"
            }, {
                name: "startTime",
                type: "i64"
            }, {
                name: "endTime",
                type: "i64"
            }, {
                name: "totalCollected",
                type: "u64"
            }, {
                name: "totalParticipants",
                type: "u64"
            }, {
                name: "participants",
                type: {
                    vec: "publicKey"
                }
            }, {
                name: "participationTimes",
                type: {
                    vec: "i64"
                }
            }, {
                name: "previousParticipants",
                type: {
                    vec: "publicKey"
                }
            }, {
                name: "winners",
                type: {
                    vec: "publicKey"
                }
            }, {
                name: "totalDistributed",
                type: "u64"
            }, {
                name: "isActive",
                type: "bool"
            }, {
                name: "bump",
                type: "u8"
            }]
        }
    }],
    errors$1 = [{
        code: 6e3,
        name: "Unauthorized",
        msg: "Unauthorized"
    }, {
        code: 6001,
        name: "RoundNotActive",
        msg: "Round is not active"
    }, {
        code: 6002,
        name: "NoActiveRound",
        msg: "No active round"
    }, {
        code: 6003,
        name: "RoundNotEnded",
        msg: "Round has not ended yet"
    }, {
        code: 6004,
        name: "RoundAlreadyActive",
        msg: "Round is already active"
    }, {
        code: 6005,
        name: "Overflow",
        msg: "Overflow"
    }, {
        code: 6006,
        name: "WinnerAccountNotProvided",
        msg: "Winner account not provided"
    }, {
        code: 6007,
        name: "NotEnoughParticipants",
        msg: "Not enough participants"
    }, {
        code: 6008,
        name: "InvalidNumberOfWinnerAccounts",
        msg: "Not enough participants to distribute prizes"
    }],
    metadata = {
        address: "8e8LEZDqxTtGgmAV7MaAH5jThNj5GyhtguvCT6CtwxDc"
    },
    idl = {
        version: version$1,
        name,
        instructions,
        accounts,
        errors: errors$1,
        metadata
    };
var buffer = {},
    base64Js = {};
base64Js.byteLength = byteLength;
var toByteArray_1 = base64Js.toByteArray = toByteArray,
    fromByteArray_1 = base64Js.fromByteArray = fromByteArray,
    lookup = [],
    revLookup = [],
    Arr = typeof Uint8Array < "u" ? Uint8Array : Array,
    code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;

function getLens(s) {
    var o = s.length;
    if (o % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var a = s.indexOf("=");
    a === -1 && (a = o);
    var $ = a === o ? 0 : 4 - a % 4;
    return [a, $]
}

function byteLength(s) {
    var o = getLens(s),
        a = o[0],
        $ = o[1];
    return (a + $) * 3 / 4 - $
}

function _byteLength(s, o, a) {
    return (o + a) * 3 / 4 - a
}

function toByteArray(s) {
    var o, a = getLens(s),
        $ = a[0],
        j = a[1],
        _e = new Arr(_byteLength(s, $, j)),
        et = 0,
        tt = j > 0 ? $ - 4 : $,
        nt;
    for (nt = 0; nt < tt; nt += 4) o = revLookup[s.charCodeAt(nt)] << 18 | revLookup[s.charCodeAt(nt + 1)] << 12 | revLookup[s.charCodeAt(nt + 2)] << 6 | revLookup[s.charCodeAt(nt + 3)], _e[et++] = o >> 16 & 255, _e[et++] = o >> 8 & 255, _e[et++] = o & 255;
    return j === 2 && (o = revLookup[s.charCodeAt(nt)] << 2 | revLookup[s.charCodeAt(nt + 1)] >> 4, _e[et++] = o & 255), j === 1 && (o = revLookup[s.charCodeAt(nt)] << 10 | revLookup[s.charCodeAt(nt + 1)] << 4 | revLookup[s.charCodeAt(nt + 2)] >> 2, _e[et++] = o >> 8 & 255, _e[et++] = o & 255), _e
}

function tripletToBase64(s) {
    return lookup[s >> 18 & 63] + lookup[s >> 12 & 63] + lookup[s >> 6 & 63] + lookup[s & 63]
}

function encodeChunk(s, o, a) {
    for (var $, j = [], _e = o; _e < a; _e += 3) $ = (s[_e] << 16 & 16711680) + (s[_e + 1] << 8 & 65280) + (s[_e + 2] & 255), j.push(tripletToBase64($));
    return j.join("")
}

function fromByteArray(s) {
    for (var o, a = s.length, $ = a % 3, j = [], _e = 16383, et = 0, tt = a - $; et < tt; et += _e) j.push(encodeChunk(s, et, et + _e > tt ? tt : et + _e));
    return $ === 1 ? (o = s[a - 1], j.push(lookup[o >> 2] + lookup[o << 4 & 63] + "==")) : $ === 2 && (o = (s[a - 2] << 8) + s[a - 1], j.push(lookup[o >> 10] + lookup[o >> 4 & 63] + lookup[o << 2 & 63] + "=")), j.join("")
}
var ieee754 = {}; /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(s, o, a, $, j) {
    var _e, et, tt = j * 8 - $ - 1,
        nt = (1 << tt) - 1,
        rt = nt >> 1,
        ot = -7,
        st = a ? j - 1 : 0,
        lt = a ? -1 : 1,
        ft = s[o + st];
    for (st += lt, _e = ft & (1 << -ot) - 1, ft >>= -ot, ot += tt; ot > 0; _e = _e * 256 + s[o + st], st += lt, ot -= 8);
    for (et = _e & (1 << -ot) - 1, _e >>= -ot, ot += $; ot > 0; et = et * 256 + s[o + st], st += lt, ot -= 8);
    if (_e === 0) _e = 1 - rt;
    else {
        if (_e === nt) return et ? NaN : (ft ? -1 : 1) * (1 / 0);
        et = et + Math.pow(2, $), _e = _e - rt
    }
    return (ft ? -1 : 1) * et * Math.pow(2, _e - $)
};
ieee754.write = function(s, o, a, $, j, _e) {
    var et, tt, nt, rt = _e * 8 - j - 1,
        ot = (1 << rt) - 1,
        st = ot >> 1,
        lt = j === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        ft = $ ? 0 : _e - 1,
        yt = $ ? 1 : -1,
        bt = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
    for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (tt = isNaN(o) ? 1 : 0, et = ot) : (et = Math.floor(Math.log(o) / Math.LN2), o * (nt = Math.pow(2, -et)) < 1 && (et--, nt *= 2), et + st >= 1 ? o += lt / nt : o += lt * Math.pow(2, 1 - st), o * nt >= 2 && (et++, nt /= 2), et + st >= ot ? (tt = 0, et = ot) : et + st >= 1 ? (tt = (o * nt - 1) * Math.pow(2, j), et = et + st) : (tt = o * Math.pow(2, st - 1) * Math.pow(2, j), et = 0)); j >= 8; s[a + ft] = tt & 255, ft += yt, tt /= 256, j -= 8);
    for (et = et << j | tt, rt += j; rt > 0; s[a + ft] = et & 255, ft += yt, et /= 256, rt -= 8);
    s[a + ft - yt] |= bt * 128
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(s) {
    const o = base64Js,
        a = ieee754,
        $ = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    s.Buffer = tt, s.SlowBuffer = wt, s.INSPECT_MAX_BYTES = 50;
    const j = 2147483647;
    s.kMaxLength = j, tt.TYPED_ARRAY_SUPPORT = _e(), !tt.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

    function _e() {
        try {
            const St = new Uint8Array(1),
                ct = {
                    foo: function() {
                        return 42
                    }
                };
            return Object.setPrototypeOf(ct, Uint8Array.prototype), Object.setPrototypeOf(St, ct), St.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(tt.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (tt.isBuffer(this)) return this.buffer
        }
    }), Object.defineProperty(tt.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (tt.isBuffer(this)) return this.byteOffset
        }
    });

    function et(St) {
        if (St > j) throw new RangeError('The value "' + St + '" is invalid for option "size"');
        const ct = new Uint8Array(St);
        return Object.setPrototypeOf(ct, tt.prototype), ct
    }

    function tt(St, ct, pt) {
        if (typeof St == "number") {
            if (typeof ct == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return st(St)
        }
        return nt(St, ct, pt)
    }
    tt.poolSize = 8192;

    function nt(St, ct, pt) {
        if (typeof St == "string") return lt(St, ct);
        if (ArrayBuffer.isView(St)) return yt(St);
        if (St == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof St);
        if (vn(St, ArrayBuffer) || St && vn(St.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (vn(St, SharedArrayBuffer) || St && vn(St.buffer, SharedArrayBuffer))) return bt(St, ct, pt);
        if (typeof St == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const kt = St.valueOf && St.valueOf();
        if (kt != null && kt !== St) return tt.from(kt, ct, pt);
        const Dt = ht(St);
        if (Dt) return Dt;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof St[Symbol.toPrimitive] == "function") return tt.from(St[Symbol.toPrimitive]("string"), ct, pt);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof St)
    }
    tt.from = function(St, ct, pt) {
        return nt(St, ct, pt)
    }, Object.setPrototypeOf(tt.prototype, Uint8Array.prototype), Object.setPrototypeOf(tt, Uint8Array);

    function rt(St) {
        if (typeof St != "number") throw new TypeError('"size" argument must be of type number');
        if (St < 0) throw new RangeError('The value "' + St + '" is invalid for option "size"')
    }

    function ot(St, ct, pt) {
        return rt(St), St <= 0 ? et(St) : ct !== void 0 ? typeof pt == "string" ? et(St).fill(ct, pt) : et(St).fill(ct) : et(St)
    }
    tt.alloc = function(St, ct, pt) {
        return ot(St, ct, pt)
    };

    function st(St) {
        return rt(St), et(St < 0 ? 0 : vt(St) | 0)
    }
    tt.allocUnsafe = function(St) {
        return st(St)
    }, tt.allocUnsafeSlow = function(St) {
        return st(St)
    };

    function lt(St, ct) {
        if ((typeof ct != "string" || ct === "") && (ct = "utf8"), !tt.isEncoding(ct)) throw new TypeError("Unknown encoding: " + ct);
        const pt = gt(St, ct) | 0;
        let kt = et(pt);
        const Dt = kt.write(St, ct);
        return Dt !== pt && (kt = kt.slice(0, Dt)), kt
    }

    function ft(St) {
        const ct = St.length < 0 ? 0 : vt(St.length) | 0,
            pt = et(ct);
        for (let kt = 0; kt < ct; kt += 1) pt[kt] = St[kt] & 255;
        return pt
    }

    function yt(St) {
        if (vn(St, Uint8Array)) {
            const ct = new Uint8Array(St);
            return bt(ct.buffer, ct.byteOffset, ct.byteLength)
        }
        return ft(St)
    }

    function bt(St, ct, pt) {
        if (ct < 0 || St.byteLength < ct) throw new RangeError('"offset" is outside of buffer bounds');
        if (St.byteLength < ct + (pt || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let kt;
        return ct === void 0 && pt === void 0 ? kt = new Uint8Array(St) : pt === void 0 ? kt = new Uint8Array(St, ct) : kt = new Uint8Array(St, ct, pt), Object.setPrototypeOf(kt, tt.prototype), kt
    }

    function ht(St) {
        if (tt.isBuffer(St)) {
            const ct = vt(St.length) | 0,
                pt = et(ct);
            return pt.length === 0 || St.copy(pt, 0, 0, ct), pt
        }
        if (St.length !== void 0) return typeof St.length != "number" || gn(St.length) ? et(0) : ft(St);
        if (St.type === "Buffer" && Array.isArray(St.data)) return ft(St.data)
    }

    function vt(St) {
        if (St >= j) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + j.toString(16) + " bytes");
        return St | 0
    }

    function wt(St) {
        return +St != St && (St = 0), tt.alloc(+St)
    }
    tt.isBuffer = function(ct) {
        return ct != null && ct._isBuffer === !0 && ct !== tt.prototype
    }, tt.compare = function(ct, pt) {
        if (vn(ct, Uint8Array) && (ct = tt.from(ct, ct.offset, ct.byteLength)), vn(pt, Uint8Array) && (pt = tt.from(pt, pt.offset, pt.byteLength)), !tt.isBuffer(ct) || !tt.isBuffer(pt)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (ct === pt) return 0;
        let kt = ct.length,
            Dt = pt.length;
        for (let zt = 0, Ht = Math.min(kt, Dt); zt < Ht; ++zt)
            if (ct[zt] !== pt[zt]) {
                kt = ct[zt], Dt = pt[zt];
                break
            }
        return kt < Dt ? -1 : Dt < kt ? 1 : 0
    }, tt.isEncoding = function(ct) {
        switch (String(ct).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, tt.concat = function(ct, pt) {
        if (!Array.isArray(ct)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (ct.length === 0) return tt.alloc(0);
        let kt;
        if (pt === void 0)
            for (pt = 0, kt = 0; kt < ct.length; ++kt) pt += ct[kt].length;
        const Dt = tt.allocUnsafe(pt);
        let zt = 0;
        for (kt = 0; kt < ct.length; ++kt) {
            let Ht = ct[kt];
            if (vn(Ht, Uint8Array)) zt + Ht.length > Dt.length ? (tt.isBuffer(Ht) || (Ht = tt.from(Ht)), Ht.copy(Dt, zt)) : Uint8Array.prototype.set.call(Dt, Ht, zt);
            else if (tt.isBuffer(Ht)) Ht.copy(Dt, zt);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            zt += Ht.length
        }
        return Dt
    };

    function gt(St, ct) {
        if (tt.isBuffer(St)) return St.length;
        if (ArrayBuffer.isView(St) || vn(St, ArrayBuffer)) return St.byteLength;
        if (typeof St != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof St);
        const pt = St.length,
            kt = arguments.length > 2 && arguments[2] === !0;
        if (!kt && pt === 0) return 0;
        let Dt = !1;
        for (;;) switch (ct) {
            case "ascii":
            case "latin1":
            case "binary":
                return pt;
            case "utf8":
            case "utf-8":
                return hn(St).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return pt * 2;
            case "hex":
                return pt >>> 1;
            case "base64":
                return mn(St).length;
            default:
                if (Dt) return kt ? -1 : hn(St).length;
                ct = ("" + ct).toLowerCase(), Dt = !0
        }
    }
    tt.byteLength = gt;

    function At(St, ct, pt) {
        let kt = !1;
        if ((ct === void 0 || ct < 0) && (ct = 0), ct > this.length || ((pt === void 0 || pt > this.length) && (pt = this.length), pt <= 0) || (pt >>>= 0, ct >>>= 0, pt <= ct)) return "";
        for (St || (St = "utf8");;) switch (St) {
            case "hex":
                return Rt(this, ct, pt);
            case "utf8":
            case "utf-8":
                return it(this, ct, pt);
            case "ascii":
                return xt(this, ct, pt);
            case "latin1":
            case "binary":
                return $t(this, ct, pt);
            case "base64":
                return Ct(this, ct, pt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return It(this, ct, pt);
            default:
                if (kt) throw new TypeError("Unknown encoding: " + St);
                St = (St + "").toLowerCase(), kt = !0
        }
    }
    tt.prototype._isBuffer = !0;

    function Pt(St, ct, pt) {
        const kt = St[ct];
        St[ct] = St[pt], St[pt] = kt
    }
    tt.prototype.swap16 = function() {
        const ct = this.length;
        if (ct % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let pt = 0; pt < ct; pt += 2) Pt(this, pt, pt + 1);
        return this
    }, tt.prototype.swap32 = function() {
        const ct = this.length;
        if (ct % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let pt = 0; pt < ct; pt += 4) Pt(this, pt, pt + 3), Pt(this, pt + 1, pt + 2);
        return this
    }, tt.prototype.swap64 = function() {
        const ct = this.length;
        if (ct % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let pt = 0; pt < ct; pt += 8) Pt(this, pt, pt + 7), Pt(this, pt + 1, pt + 6), Pt(this, pt + 2, pt + 5), Pt(this, pt + 3, pt + 4);
        return this
    }, tt.prototype.toString = function() {
        const ct = this.length;
        return ct === 0 ? "" : arguments.length === 0 ? it(this, 0, ct) : At.apply(this, arguments)
    }, tt.prototype.toLocaleString = tt.prototype.toString, tt.prototype.equals = function(ct) {
        if (!tt.isBuffer(ct)) throw new TypeError("Argument must be a Buffer");
        return this === ct ? !0 : tt.compare(this, ct) === 0
    }, tt.prototype.inspect = function() {
        let ct = "";
        const pt = s.INSPECT_MAX_BYTES;
        return ct = this.toString("hex", 0, pt).replace(/(.{2})/g, "$1 ").trim(), this.length > pt && (ct += " ... "), "<Buffer " + ct + ">"
    }, $ && (tt.prototype[$] = tt.prototype.inspect), tt.prototype.compare = function(ct, pt, kt, Dt, zt) {
        if (vn(ct, Uint8Array) && (ct = tt.from(ct, ct.offset, ct.byteLength)), !tt.isBuffer(ct)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ct);
        if (pt === void 0 && (pt = 0), kt === void 0 && (kt = ct ? ct.length : 0), Dt === void 0 && (Dt = 0), zt === void 0 && (zt = this.length), pt < 0 || kt > ct.length || Dt < 0 || zt > this.length) throw new RangeError("out of range index");
        if (Dt >= zt && pt >= kt) return 0;
        if (Dt >= zt) return -1;
        if (pt >= kt) return 1;
        if (pt >>>= 0, kt >>>= 0, Dt >>>= 0, zt >>>= 0, this === ct) return 0;
        let Ht = zt - Dt,
            an = kt - pt;
        const Xt = Math.min(Ht, an),
            tn = this.slice(Dt, zt),
            pn = ct.slice(pt, kt);
        for (let sn = 0; sn < Xt; ++sn)
            if (tn[sn] !== pn[sn]) {
                Ht = tn[sn], an = pn[sn];
                break
            }
        return Ht < an ? -1 : an < Ht ? 1 : 0
    };

    function Bt(St, ct, pt, kt, Dt) {
        if (St.length === 0) return -1;
        if (typeof pt == "string" ? (kt = pt, pt = 0) : pt > 2147483647 ? pt = 2147483647 : pt < -2147483648 && (pt = -2147483648), pt = +pt, gn(pt) && (pt = Dt ? 0 : St.length - 1), pt < 0 && (pt = St.length + pt), pt >= St.length) {
            if (Dt) return -1;
            pt = St.length - 1
        } else if (pt < 0)
            if (Dt) pt = 0;
            else return -1;
        if (typeof ct == "string" && (ct = tt.from(ct, kt)), tt.isBuffer(ct)) return ct.length === 0 ? -1 : Lt(St, ct, pt, kt, Dt);
        if (typeof ct == "number") return ct = ct & 255, typeof Uint8Array.prototype.indexOf == "function" ? Dt ? Uint8Array.prototype.indexOf.call(St, ct, pt) : Uint8Array.prototype.lastIndexOf.call(St, ct, pt) : Lt(St, [ct], pt, kt, Dt);
        throw new TypeError("val must be string, number or Buffer")
    }

    function Lt(St, ct, pt, kt, Dt) {
        let zt = 1,
            Ht = St.length,
            an = ct.length;
        if (kt !== void 0 && (kt = String(kt).toLowerCase(), kt === "ucs2" || kt === "ucs-2" || kt === "utf16le" || kt === "utf-16le")) {
            if (St.length < 2 || ct.length < 2) return -1;
            zt = 2, Ht /= 2, an /= 2, pt /= 2
        }

        function Xt(pn, sn) {
            return zt === 1 ? pn[sn] : pn.readUInt16BE(sn * zt)
        }
        let tn;
        if (Dt) {
            let pn = -1;
            for (tn = pt; tn < Ht; tn++)
                if (Xt(St, tn) === Xt(ct, pn === -1 ? 0 : tn - pn)) {
                    if (pn === -1 && (pn = tn), tn - pn + 1 === an) return pn * zt
                } else pn !== -1 && (tn -= tn - pn), pn = -1
        } else
            for (pt + an > Ht && (pt = Ht - an), tn = pt; tn >= 0; tn--) {
                let pn = !0;
                for (let sn = 0; sn < an; sn++)
                    if (Xt(St, tn + sn) !== Xt(ct, sn)) {
                        pn = !1;
                        break
                    }
                if (pn) return tn
            }
        return -1
    }
    tt.prototype.includes = function(ct, pt, kt) {
        return this.indexOf(ct, pt, kt) !== -1
    }, tt.prototype.indexOf = function(ct, pt, kt) {
        return Bt(this, ct, pt, kt, !0)
    }, tt.prototype.lastIndexOf = function(ct, pt, kt) {
        return Bt(this, ct, pt, kt, !1)
    };

    function Nt(St, ct, pt, kt) {
        pt = Number(pt) || 0;
        const Dt = St.length - pt;
        kt ? (kt = Number(kt), kt > Dt && (kt = Dt)) : kt = Dt;
        const zt = ct.length;
        kt > zt / 2 && (kt = zt / 2);
        let Ht;
        for (Ht = 0; Ht < kt; ++Ht) {
            const an = parseInt(ct.substr(Ht * 2, 2), 16);
            if (gn(an)) return Ht;
            St[pt + Ht] = an
        }
        return Ht
    }

    function Ut(St, ct, pt, kt) {
        return dn(hn(ct, St.length - pt), St, pt, kt)
    }

    function Vt(St, ct, pt, kt) {
        return dn(fn(ct), St, pt, kt)
    }

    function Ft(St, ct, pt, kt) {
        return dn(mn(ct), St, pt, kt)
    }

    function Wt(St, ct, pt, kt) {
        return dn(rn(ct, St.length - pt), St, pt, kt)
    }
    tt.prototype.write = function(ct, pt, kt, Dt) {
        if (pt === void 0) Dt = "utf8", kt = this.length, pt = 0;
        else if (kt === void 0 && typeof pt == "string") Dt = pt, kt = this.length, pt = 0;
        else if (isFinite(pt)) pt = pt >>> 0, isFinite(kt) ? (kt = kt >>> 0, Dt === void 0 && (Dt = "utf8")) : (Dt = kt, kt = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const zt = this.length - pt;
        if ((kt === void 0 || kt > zt) && (kt = zt), ct.length > 0 && (kt < 0 || pt < 0) || pt > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        Dt || (Dt = "utf8");
        let Ht = !1;
        for (;;) switch (Dt) {
            case "hex":
                return Nt(this, ct, pt, kt);
            case "utf8":
            case "utf-8":
                return Ut(this, ct, pt, kt);
            case "ascii":
            case "latin1":
            case "binary":
                return Vt(this, ct, pt, kt);
            case "base64":
                return Ft(this, ct, pt, kt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Wt(this, ct, pt, kt);
            default:
                if (Ht) throw new TypeError("Unknown encoding: " + Dt);
                Dt = ("" + Dt).toLowerCase(), Ht = !0
        }
    }, tt.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    };

    function Ct(St, ct, pt) {
        return ct === 0 && pt === St.length ? o.fromByteArray(St) : o.fromByteArray(St.slice(ct, pt))
    }

    function it(St, ct, pt) {
        pt = Math.min(St.length, pt);
        const kt = [];
        let Dt = ct;
        for (; Dt < pt;) {
            const zt = St[Dt];
            let Ht = null,
                an = zt > 239 ? 4 : zt > 223 ? 3 : zt > 191 ? 2 : 1;
            if (Dt + an <= pt) {
                let Xt, tn, pn, sn;
                switch (an) {
                    case 1:
                        zt < 128 && (Ht = zt);
                        break;
                    case 2:
                        Xt = St[Dt + 1], (Xt & 192) === 128 && (sn = (zt & 31) << 6 | Xt & 63, sn > 127 && (Ht = sn));
                        break;
                    case 3:
                        Xt = St[Dt + 1], tn = St[Dt + 2], (Xt & 192) === 128 && (tn & 192) === 128 && (sn = (zt & 15) << 12 | (Xt & 63) << 6 | tn & 63, sn > 2047 && (sn < 55296 || sn > 57343) && (Ht = sn));
                        break;
                    case 4:
                        Xt = St[Dt + 1], tn = St[Dt + 2], pn = St[Dt + 3], (Xt & 192) === 128 && (tn & 192) === 128 && (pn & 192) === 128 && (sn = (zt & 15) << 18 | (Xt & 63) << 12 | (tn & 63) << 6 | pn & 63, sn > 65535 && sn < 1114112 && (Ht = sn))
                }
            }
            Ht === null ? (Ht = 65533, an = 1) : Ht > 65535 && (Ht -= 65536, kt.push(Ht >>> 10 & 1023 | 55296), Ht = 56320 | Ht & 1023), kt.push(Ht), Dt += an
        }
        return mt(kt)
    }
    const at = 4096;

    function mt(St) {
        const ct = St.length;
        if (ct <= at) return String.fromCharCode.apply(String, St);
        let pt = "",
            kt = 0;
        for (; kt < ct;) pt += String.fromCharCode.apply(String, St.slice(kt, kt += at));
        return pt
    }

    function xt(St, ct, pt) {
        let kt = "";
        pt = Math.min(St.length, pt);
        for (let Dt = ct; Dt < pt; ++Dt) kt += String.fromCharCode(St[Dt] & 127);
        return kt
    }

    function $t(St, ct, pt) {
        let kt = "";
        pt = Math.min(St.length, pt);
        for (let Dt = ct; Dt < pt; ++Dt) kt += String.fromCharCode(St[Dt]);
        return kt
    }

    function Rt(St, ct, pt) {
        const kt = St.length;
        (!ct || ct < 0) && (ct = 0), (!pt || pt < 0 || pt > kt) && (pt = kt);
        let Dt = "";
        for (let zt = ct; zt < pt; ++zt) Dt += Gt[St[zt]];
        return Dt
    }

    function It(St, ct, pt) {
        const kt = St.slice(ct, pt);
        let Dt = "";
        for (let zt = 0; zt < kt.length - 1; zt += 2) Dt += String.fromCharCode(kt[zt] + kt[zt + 1] * 256);
        return Dt
    }
    tt.prototype.slice = function(ct, pt) {
        const kt = this.length;
        ct = ~~ct, pt = pt === void 0 ? kt : ~~pt, ct < 0 ? (ct += kt, ct < 0 && (ct = 0)) : ct > kt && (ct = kt), pt < 0 ? (pt += kt, pt < 0 && (pt = 0)) : pt > kt && (pt = kt), pt < ct && (pt = ct);
        const Dt = this.subarray(ct, pt);
        return Object.setPrototypeOf(Dt, tt.prototype), Dt
    };

    function Tt(St, ct, pt) {
        if (St % 1 !== 0 || St < 0) throw new RangeError("offset is not uint");
        if (St + ct > pt) throw new RangeError("Trying to access beyond buffer length")
    }
    tt.prototype.readUintLE = tt.prototype.readUIntLE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = this[ct],
            zt = 1,
            Ht = 0;
        for (; ++Ht < pt && (zt *= 256);) Dt += this[ct + Ht] * zt;
        return Dt
    }, tt.prototype.readUintBE = tt.prototype.readUIntBE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = this[ct + --pt],
            zt = 1;
        for (; pt > 0 && (zt *= 256);) Dt += this[ct + --pt] * zt;
        return Dt
    }, tt.prototype.readUint8 = tt.prototype.readUInt8 = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 1, this.length), this[ct]
    }, tt.prototype.readUint16LE = tt.prototype.readUInt16LE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 2, this.length), this[ct] | this[ct + 1] << 8
    }, tt.prototype.readUint16BE = tt.prototype.readUInt16BE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 2, this.length), this[ct] << 8 | this[ct + 1]
    }, tt.prototype.readUint32LE = tt.prototype.readUInt32LE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), (this[ct] | this[ct + 1] << 8 | this[ct + 2] << 16) + this[ct + 3] * 16777216
    }, tt.prototype.readUint32BE = tt.prototype.readUInt32BE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), this[ct] * 16777216 + (this[ct + 1] << 16 | this[ct + 2] << 8 | this[ct + 3])
    }, tt.prototype.readBigUInt64LE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = pt + this[++ct] * 2 ** 8 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 24,
            zt = this[++ct] + this[++ct] * 2 ** 8 + this[++ct] * 2 ** 16 + kt * 2 ** 24;
        return BigInt(Dt) + (BigInt(zt) << BigInt(32))
    }), tt.prototype.readBigUInt64BE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = pt * 2 ** 24 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + this[++ct],
            zt = this[++ct] * 2 ** 24 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + kt;
        return (BigInt(Dt) << BigInt(32)) + BigInt(zt)
    }), tt.prototype.readIntLE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = this[ct],
            zt = 1,
            Ht = 0;
        for (; ++Ht < pt && (zt *= 256);) Dt += this[ct + Ht] * zt;
        return zt *= 128, Dt >= zt && (Dt -= Math.pow(2, 8 * pt)), Dt
    }, tt.prototype.readIntBE = function(ct, pt, kt) {
        ct = ct >>> 0, pt = pt >>> 0, kt || Tt(ct, pt, this.length);
        let Dt = pt,
            zt = 1,
            Ht = this[ct + --Dt];
        for (; Dt > 0 && (zt *= 256);) Ht += this[ct + --Dt] * zt;
        return zt *= 128, Ht >= zt && (Ht -= Math.pow(2, 8 * pt)), Ht
    }, tt.prototype.readInt8 = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 1, this.length), this[ct] & 128 ? (255 - this[ct] + 1) * -1 : this[ct]
    }, tt.prototype.readInt16LE = function(ct, pt) {
        ct = ct >>> 0, pt || Tt(ct, 2, this.length);
        const kt = this[ct] | this[ct + 1] << 8;
        return kt & 32768 ? kt | 4294901760 : kt
    }, tt.prototype.readInt16BE = function(ct, pt) {
        ct = ct >>> 0, pt || Tt(ct, 2, this.length);
        const kt = this[ct + 1] | this[ct] << 8;
        return kt & 32768 ? kt | 4294901760 : kt
    }, tt.prototype.readInt32LE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), this[ct] | this[ct + 1] << 8 | this[ct + 2] << 16 | this[ct + 3] << 24
    }, tt.prototype.readInt32BE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), this[ct] << 24 | this[ct + 1] << 16 | this[ct + 2] << 8 | this[ct + 3]
    }, tt.prototype.readBigInt64LE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = this[ct + 4] + this[ct + 5] * 2 ** 8 + this[ct + 6] * 2 ** 16 + (kt << 24);
        return (BigInt(Dt) << BigInt(32)) + BigInt(pt + this[++ct] * 2 ** 8 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 24)
    }), tt.prototype.readBigInt64BE = Yt(function(ct) {
        ct = ct >>> 0, ln(ct, "offset");
        const pt = this[ct],
            kt = this[ct + 7];
        (pt === void 0 || kt === void 0) && cn(ct, this.length - 8);
        const Dt = (pt << 24) + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + this[++ct];
        return (BigInt(Dt) << BigInt(32)) + BigInt(this[++ct] * 2 ** 24 + this[++ct] * 2 ** 16 + this[++ct] * 2 ** 8 + kt)
    }), tt.prototype.readFloatLE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), a.read(this, ct, !0, 23, 4)
    }, tt.prototype.readFloatBE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 4, this.length), a.read(this, ct, !1, 23, 4)
    }, tt.prototype.readDoubleLE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 8, this.length), a.read(this, ct, !0, 52, 8)
    }, tt.prototype.readDoubleBE = function(ct, pt) {
        return ct = ct >>> 0, pt || Tt(ct, 8, this.length), a.read(this, ct, !1, 52, 8)
    };

    function dt(St, ct, pt, kt, Dt, zt) {
        if (!tt.isBuffer(St)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (ct > Dt || ct < zt) throw new RangeError('"value" argument is out of bounds');
        if (pt + kt > St.length) throw new RangeError("Index out of range")
    }
    tt.prototype.writeUintLE = tt.prototype.writeUIntLE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, kt = kt >>> 0, !Dt) {
            const an = Math.pow(2, 8 * kt) - 1;
            dt(this, ct, pt, kt, an, 0)
        }
        let zt = 1,
            Ht = 0;
        for (this[pt] = ct & 255; ++Ht < kt && (zt *= 256);) this[pt + Ht] = ct / zt & 255;
        return pt + kt
    }, tt.prototype.writeUintBE = tt.prototype.writeUIntBE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, kt = kt >>> 0, !Dt) {
            const an = Math.pow(2, 8 * kt) - 1;
            dt(this, ct, pt, kt, an, 0)
        }
        let zt = kt - 1,
            Ht = 1;
        for (this[pt + zt] = ct & 255; --zt >= 0 && (Ht *= 256);) this[pt + zt] = ct / Ht & 255;
        return pt + kt
    }, tt.prototype.writeUint8 = tt.prototype.writeUInt8 = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 1, 255, 0), this[pt] = ct & 255, pt + 1
    }, tt.prototype.writeUint16LE = tt.prototype.writeUInt16LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 65535, 0), this[pt] = ct & 255, this[pt + 1] = ct >>> 8, pt + 2
    }, tt.prototype.writeUint16BE = tt.prototype.writeUInt16BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 65535, 0), this[pt] = ct >>> 8, this[pt + 1] = ct & 255, pt + 2
    }, tt.prototype.writeUint32LE = tt.prototype.writeUInt32LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 4294967295, 0), this[pt + 3] = ct >>> 24, this[pt + 2] = ct >>> 16, this[pt + 1] = ct >>> 8, this[pt] = ct & 255, pt + 4
    }, tt.prototype.writeUint32BE = tt.prototype.writeUInt32BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 4294967295, 0), this[pt] = ct >>> 24, this[pt + 1] = ct >>> 16, this[pt + 2] = ct >>> 8, this[pt + 3] = ct & 255, pt + 4
    };

    function Et(St, ct, pt, kt, Dt) {
        en(ct, kt, Dt, St, pt, 7);
        let zt = Number(ct & BigInt(4294967295));
        St[pt++] = zt, zt = zt >> 8, St[pt++] = zt, zt = zt >> 8, St[pt++] = zt, zt = zt >> 8, St[pt++] = zt;
        let Ht = Number(ct >> BigInt(32) & BigInt(4294967295));
        return St[pt++] = Ht, Ht = Ht >> 8, St[pt++] = Ht, Ht = Ht >> 8, St[pt++] = Ht, Ht = Ht >> 8, St[pt++] = Ht, pt
    }

    function Ot(St, ct, pt, kt, Dt) {
        en(ct, kt, Dt, St, pt, 7);
        let zt = Number(ct & BigInt(4294967295));
        St[pt + 7] = zt, zt = zt >> 8, St[pt + 6] = zt, zt = zt >> 8, St[pt + 5] = zt, zt = zt >> 8, St[pt + 4] = zt;
        let Ht = Number(ct >> BigInt(32) & BigInt(4294967295));
        return St[pt + 3] = Ht, Ht = Ht >> 8, St[pt + 2] = Ht, Ht = Ht >> 8, St[pt + 1] = Ht, Ht = Ht >> 8, St[pt] = Ht, pt + 8
    }
    tt.prototype.writeBigUInt64LE = Yt(function(ct, pt = 0) {
        return Et(this, ct, pt, BigInt(0), BigInt("0xffffffffffffffff"))
    }), tt.prototype.writeBigUInt64BE = Yt(function(ct, pt = 0) {
        return Ot(this, ct, pt, BigInt(0), BigInt("0xffffffffffffffff"))
    }), tt.prototype.writeIntLE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, !Dt) {
            const Xt = Math.pow(2, 8 * kt - 1);
            dt(this, ct, pt, kt, Xt - 1, -Xt)
        }
        let zt = 0,
            Ht = 1,
            an = 0;
        for (this[pt] = ct & 255; ++zt < kt && (Ht *= 256);) ct < 0 && an === 0 && this[pt + zt - 1] !== 0 && (an = 1), this[pt + zt] = (ct / Ht >> 0) - an & 255;
        return pt + kt
    }, tt.prototype.writeIntBE = function(ct, pt, kt, Dt) {
        if (ct = +ct, pt = pt >>> 0, !Dt) {
            const Xt = Math.pow(2, 8 * kt - 1);
            dt(this, ct, pt, kt, Xt - 1, -Xt)
        }
        let zt = kt - 1,
            Ht = 1,
            an = 0;
        for (this[pt + zt] = ct & 255; --zt >= 0 && (Ht *= 256);) ct < 0 && an === 0 && this[pt + zt + 1] !== 0 && (an = 1), this[pt + zt] = (ct / Ht >> 0) - an & 255;
        return pt + kt
    }, tt.prototype.writeInt8 = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 1, 127, -128), ct < 0 && (ct = 255 + ct + 1), this[pt] = ct & 255, pt + 1
    }, tt.prototype.writeInt16LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 32767, -32768), this[pt] = ct & 255, this[pt + 1] = ct >>> 8, pt + 2
    }, tt.prototype.writeInt16BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 2, 32767, -32768), this[pt] = ct >>> 8, this[pt + 1] = ct & 255, pt + 2
    }, tt.prototype.writeInt32LE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 2147483647, -2147483648), this[pt] = ct & 255, this[pt + 1] = ct >>> 8, this[pt + 2] = ct >>> 16, this[pt + 3] = ct >>> 24, pt + 4
    }, tt.prototype.writeInt32BE = function(ct, pt, kt) {
        return ct = +ct, pt = pt >>> 0, kt || dt(this, ct, pt, 4, 2147483647, -2147483648), ct < 0 && (ct = 4294967295 + ct + 1), this[pt] = ct >>> 24, this[pt + 1] = ct >>> 16, this[pt + 2] = ct >>> 8, this[pt + 3] = ct & 255, pt + 4
    }, tt.prototype.writeBigInt64LE = Yt(function(ct, pt = 0) {
        return Et(this, ct, pt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }), tt.prototype.writeBigInt64BE = Yt(function(ct, pt = 0) {
        return Ot(this, ct, pt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });

    function Mt(St, ct, pt, kt, Dt, zt) {
        if (pt + kt > St.length) throw new RangeError("Index out of range");
        if (pt < 0) throw new RangeError("Index out of range")
    }

    function jt(St, ct, pt, kt, Dt) {
        return ct = +ct, pt = pt >>> 0, Dt || Mt(St, ct, pt, 4), a.write(St, ct, pt, kt, 23, 4), pt + 4
    }
    tt.prototype.writeFloatLE = function(ct, pt, kt) {
        return jt(this, ct, pt, !0, kt)
    }, tt.prototype.writeFloatBE = function(ct, pt, kt) {
        return jt(this, ct, pt, !1, kt)
    };

    function Qt(St, ct, pt, kt, Dt) {
        return ct = +ct, pt = pt >>> 0, Dt || Mt(St, ct, pt, 8), a.write(St, ct, pt, kt, 52, 8), pt + 8
    }
    tt.prototype.writeDoubleLE = function(ct, pt, kt) {
        return Qt(this, ct, pt, !0, kt)
    }, tt.prototype.writeDoubleBE = function(ct, pt, kt) {
        return Qt(this, ct, pt, !1, kt)
    }, tt.prototype.copy = function(ct, pt, kt, Dt) {
        if (!tt.isBuffer(ct)) throw new TypeError("argument should be a Buffer");
        if (kt || (kt = 0), !Dt && Dt !== 0 && (Dt = this.length), pt >= ct.length && (pt = ct.length), pt || (pt = 0), Dt > 0 && Dt < kt && (Dt = kt), Dt === kt || ct.length === 0 || this.length === 0) return 0;
        if (pt < 0) throw new RangeError("targetStart out of bounds");
        if (kt < 0 || kt >= this.length) throw new RangeError("Index out of range");
        if (Dt < 0) throw new RangeError("sourceEnd out of bounds");
        Dt > this.length && (Dt = this.length), ct.length - pt < Dt - kt && (Dt = ct.length - pt + kt);
        const zt = Dt - kt;
        return this === ct && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(pt, kt, Dt) : Uint8Array.prototype.set.call(ct, this.subarray(kt, Dt), pt), zt
    }, tt.prototype.fill = function(ct, pt, kt, Dt) {
        if (typeof ct == "string") {
            if (typeof pt == "string" ? (Dt = pt, pt = 0, kt = this.length) : typeof kt == "string" && (Dt = kt, kt = this.length), Dt !== void 0 && typeof Dt != "string") throw new TypeError("encoding must be a string");
            if (typeof Dt == "string" && !tt.isEncoding(Dt)) throw new TypeError("Unknown encoding: " + Dt);
            if (ct.length === 1) {
                const Ht = ct.charCodeAt(0);
                (Dt === "utf8" && Ht < 128 || Dt === "latin1") && (ct = Ht)
            }
        } else typeof ct == "number" ? ct = ct & 255 : typeof ct == "boolean" && (ct = Number(ct));
        if (pt < 0 || this.length < pt || this.length < kt) throw new RangeError("Out of range index");
        if (kt <= pt) return this;
        pt = pt >>> 0, kt = kt === void 0 ? this.length : kt >>> 0, ct || (ct = 0);
        let zt;
        if (typeof ct == "number")
            for (zt = pt; zt < kt; ++zt) this[zt] = ct;
        else {
            const Ht = tt.isBuffer(ct) ? ct : tt.from(ct, Dt),
                an = Ht.length;
            if (an === 0) throw new TypeError('The value "' + ct + '" is invalid for argument "value"');
            for (zt = 0; zt < kt - pt; ++zt) this[zt + pt] = Ht[zt % an]
        }
        return this
    };
    const Kt = {};

    function qt(St, ct, pt) {
        Kt[St] = class extends pt {
            constructor() {
                super(), Object.defineProperty(this, "message", {
                    value: ct.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${St}]`, this.stack, delete this.name
            }
            get code() {
                return St
            }
            set code(Dt) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: Dt,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${St}]: ${this.message}`
            }
        }
    }
    qt("ERR_BUFFER_OUT_OF_BOUNDS", function(St) {
        return St ? `${St} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError), qt("ERR_INVALID_ARG_TYPE", function(St, ct) {
        return `The "${St}" argument must be of type number. Received type ${typeof ct}`
    }, TypeError), qt("ERR_OUT_OF_RANGE", function(St, ct, pt) {
        let kt = `The value of "${St}" is out of range.`,
            Dt = pt;
        return Number.isInteger(pt) && Math.abs(pt) > 2 ** 32 ? Dt = Jt(String(pt)) : typeof pt == "bigint" && (Dt = String(pt), (pt > BigInt(2) ** BigInt(32) || pt < -(BigInt(2) ** BigInt(32))) && (Dt = Jt(Dt)), Dt += "n"), kt += ` It must be ${ct}. Received ${Dt}`, kt
    }, RangeError);

    function Jt(St) {
        let ct = "",
            pt = St.length;
        const kt = St[0] === "-" ? 1 : 0;
        for (; pt >= kt + 4; pt -= 3) ct = `_${St.slice(pt-3,pt)}${ct}`;
        return `${St.slice(0,pt)}${ct}`
    }

    function Zt(St, ct, pt) {
        ln(ct, "offset"), (St[ct] === void 0 || St[ct + pt] === void 0) && cn(ct, St.length - (pt + 1))
    }

    function en(St, ct, pt, kt, Dt, zt) {
        if (St > pt || St < ct) {
            const Ht = typeof ct == "bigint" ? "n" : "";
            let an;
            throw ct === 0 || ct === BigInt(0) ? an = `>= 0${Ht} and < 2${Ht} ** ${(zt+1)*8}${Ht}` : an = `>= -(2${Ht} ** ${(zt+1)*8-1}${Ht}) and < 2 ** ${(zt+1)*8-1}${Ht}`, new Kt.ERR_OUT_OF_RANGE("value", an, St)
        }
        Zt(kt, Dt, zt)
    }

    function ln(St, ct) {
        if (typeof St != "number") throw new Kt.ERR_INVALID_ARG_TYPE(ct, "number", St)
    }

    function cn(St, ct, pt) {
        throw Math.floor(St) !== St ? (ln(St, pt), new Kt.ERR_OUT_OF_RANGE("offset", "an integer", St)) : ct < 0 ? new Kt.ERR_BUFFER_OUT_OF_BOUNDS : new Kt.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${ct}`, St)
    }
    const un = /[^+/0-9A-Za-z-_]/g;

    function Nn(St) {
        if (St = St.split("=")[0], St = St.trim().replace(un, ""), St.length < 2) return "";
        for (; St.length % 4 !== 0;) St = St + "=";
        return St
    }

    function hn(St, ct) {
        ct = ct || 1 / 0;
        let pt;
        const kt = St.length;
        let Dt = null;
        const zt = [];
        for (let Ht = 0; Ht < kt; ++Ht) {
            if (pt = St.charCodeAt(Ht), pt > 55295 && pt < 57344) {
                if (!Dt) {
                    if (pt > 56319) {
                        (ct -= 3) > -1 && zt.push(239, 191, 189);
                        continue
                    } else if (Ht + 1 === kt) {
                        (ct -= 3) > -1 && zt.push(239, 191, 189);
                        continue
                    }
                    Dt = pt;
                    continue
                }
                if (pt < 56320) {
                    (ct -= 3) > -1 && zt.push(239, 191, 189), Dt = pt;
                    continue
                }
                pt = (Dt - 55296 << 10 | pt - 56320) + 65536
            } else Dt && (ct -= 3) > -1 && zt.push(239, 191, 189);
            if (Dt = null, pt < 128) {
                if ((ct -= 1) < 0) break;
                zt.push(pt)
            } else if (pt < 2048) {
                if ((ct -= 2) < 0) break;
                zt.push(pt >> 6 | 192, pt & 63 | 128)
            } else if (pt < 65536) {
                if ((ct -= 3) < 0) break;
                zt.push(pt >> 12 | 224, pt >> 6 & 63 | 128, pt & 63 | 128)
            } else if (pt < 1114112) {
                if ((ct -= 4) < 0) break;
                zt.push(pt >> 18 | 240, pt >> 12 & 63 | 128, pt >> 6 & 63 | 128, pt & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return zt
    }

    function fn(St) {
        const ct = [];
        for (let pt = 0; pt < St.length; ++pt) ct.push(St.charCodeAt(pt) & 255);
        return ct
    }

    function rn(St, ct) {
        let pt, kt, Dt;
        const zt = [];
        for (let Ht = 0; Ht < St.length && !((ct -= 2) < 0); ++Ht) pt = St.charCodeAt(Ht), kt = pt >> 8, Dt = pt % 256, zt.push(Dt), zt.push(kt);
        return zt
    }

    function mn(St) {
        return o.toByteArray(Nn(St))
    }

    function dn(St, ct, pt, kt) {
        let Dt;
        for (Dt = 0; Dt < kt && !(Dt + pt >= ct.length || Dt >= St.length); ++Dt) ct[Dt + pt] = St[Dt];
        return Dt
    }

    function vn(St, ct) {
        return St instanceof ct || St != null && St.constructor != null && St.constructor.name != null && St.constructor.name === ct.name
    }

    function gn(St) {
        return St !== St
    }
    const Gt = function() {
        const St = "0123456789abcdef",
            ct = new Array(256);
        for (let pt = 0; pt < 16; ++pt) {
            const kt = pt * 16;
            for (let Dt = 0; Dt < 16; ++Dt) ct[kt + Dt] = St[pt] + St[Dt]
        }
        return ct
    }();

    function Yt(St) {
        return typeof BigInt > "u" ? nn : St
    }

    function nn() {
        throw new Error("BigInt not supported")
    }
})(buffer);

function number$2(s) {
    if (!Number.isSafeInteger(s) || s < 0) throw new Error(`positive integer expected, not ${s}`)
}

function isBytes$1(s) {
    return s instanceof Uint8Array || s != null && typeof s == "object" && s.constructor.name === "Uint8Array"
}

function bytes(s, ...o) {
    if (!isBytes$1(s)) throw new Error("Uint8Array expected");
    if (o.length > 0 && !o.includes(s.length)) throw new Error(`Uint8Array expected of length ${o}, not of length=${s.length}`)
}

function hash$1(s) {
    if (typeof s != "function" || typeof s.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number$2(s.outputLen), number$2(s.blockLen)
}

function exists(s, o = !0) {
    if (s.destroyed) throw new Error("Hash instance has been destroyed");
    if (o && s.finished) throw new Error("Hash#digest() has already been called")
}

function output(s, o) {
    bytes(s);
    const a = o.outputLen;
    if (s.length < a) throw new Error(`digestInto() expects output buffer of length at least ${a}`)
}
const crypto$1 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$2 = s => new Uint32Array(s.buffer, s.byteOffset, Math.floor(s.byteLength / 4)),
    createView = s => new DataView(s.buffer, s.byteOffset, s.byteLength),
    rotr = (s, o) => s << 32 - o | s >>> o,
    isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
    byteSwap = s => s << 24 & 4278190080 | s << 8 & 16711680 | s >>> 8 & 65280 | s >>> 24 & 255;

function byteSwap32(s) {
    for (let o = 0; o < s.length; o++) s[o] = byteSwap(s[o])
}

function utf8ToBytes$1(s) {
    if (typeof s != "string") throw new Error(`utf8ToBytes expected string, got ${typeof s}`);
    return new Uint8Array(new TextEncoder().encode(s))
}

function toBytes(s) {
    return typeof s == "string" && (s = utf8ToBytes$1(s)), bytes(s), s
}

function concatBytes$1(...s) {
    let o = 0;
    for (let $ = 0; $ < s.length; $++) {
        const j = s[$];
        bytes(j), o += j.length
    }
    const a = new Uint8Array(o);
    for (let $ = 0, j = 0; $ < s.length; $++) {
        const _e = s[$];
        a.set(_e, j), j += _e.length
    }
    return a
}
class Hash {
    clone() {
        return this._cloneInto()
    }
}

function wrapConstructor(s) {
    const o = $ => s().update(toBytes($)).digest(),
        a = s();
    return o.outputLen = a.outputLen, o.blockLen = a.blockLen, o.create = () => s(), o
}

function randomBytes(s = 32) {
    if (crypto$1 && typeof crypto$1.getRandomValues == "function") return crypto$1.getRandomValues(new Uint8Array(s));
    if (crypto$1 && typeof crypto$1.randomBytes == "function") return crypto$1.randomBytes(s);
    throw new Error("crypto.getRandomValues must be defined")
}

function setBigUint64(s, o, a, $) {
    if (typeof s.setBigUint64 == "function") return s.setBigUint64(o, a, $);
    const j = BigInt(32),
        _e = BigInt(4294967295),
        et = Number(a >> j & _e),
        tt = Number(a & _e),
        nt = $ ? 4 : 0,
        rt = $ ? 0 : 4;
    s.setUint32(o + nt, et, $), s.setUint32(o + rt, tt, $)
}
const Chi = (s, o, a) => s & o ^ ~s & a,
    Maj = (s, o, a) => s & o ^ s & a ^ o & a;
class HashMD extends Hash {
    constructor(o, a, $, j) {
        super(), this.blockLen = o, this.outputLen = a, this.padOffset = $, this.isLE = j, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(o), this.view = createView(this.buffer)
    }
    update(o) {
        exists(this);
        const {
            view: a,
            buffer: $,
            blockLen: j
        } = this;
        o = toBytes(o);
        const _e = o.length;
        for (let et = 0; et < _e;) {
            const tt = Math.min(j - this.pos, _e - et);
            if (tt === j) {
                const nt = createView(o);
                for (; j <= _e - et; et += j) this.process(nt, et);
                continue
            }
            $.set(o.subarray(et, et + tt), this.pos), this.pos += tt, et += tt, this.pos === j && (this.process(a, 0), this.pos = 0)
        }
        return this.length += o.length, this.roundClean(), this
    }
    digestInto(o) {
        exists(this), output(o, this), this.finished = !0;
        const {
            buffer: a,
            view: $,
            blockLen: j,
            isLE: _e
        } = this;
        let {
            pos: et
        } = this;
        a[et++] = 128, this.buffer.subarray(et).fill(0), this.padOffset > j - et && (this.process($, 0), et = 0);
        for (let st = et; st < j; st++) a[st] = 0;
        setBigUint64($, j - 8, BigInt(this.length * 8), _e), this.process($, 0);
        const tt = createView(o),
            nt = this.outputLen;
        if (nt % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const rt = nt / 4,
            ot = this.get();
        if (rt > ot.length) throw new Error("_sha2: outputLen bigger than state");
        for (let st = 0; st < rt; st++) tt.setUint32(4 * st, ot[st], _e)
    }
    digest() {
        const {
            buffer: o,
            outputLen: a
        } = this;
        this.digestInto(o);
        const $ = o.slice(0, a);
        return this.destroy(), $
    }
    _cloneInto(o) {
        o || (o = new this.constructor), o.set(...this.get());
        const {
            blockLen: a,
            buffer: $,
            length: j,
            finished: _e,
            destroyed: et,
            pos: tt
        } = this;
        return o.length = j, o.pos = tt, o.finished = _e, o.destroyed = et, j % a && o.buffer.set($), o
    }
}
const U32_MASK64 = BigInt(2 ** 32 - 1),
    _32n = BigInt(32);

function fromBig(s, o = !1) {
    return o ? {
        h: Number(s & U32_MASK64),
        l: Number(s >> _32n & U32_MASK64)
    } : {
        h: Number(s >> _32n & U32_MASK64) | 0,
        l: Number(s & U32_MASK64) | 0
    }
}

function split(s, o = !1) {
    let a = new Uint32Array(s.length),
        $ = new Uint32Array(s.length);
    for (let j = 0; j < s.length; j++) {
        const {
            h: _e,
            l: et
        } = fromBig(s[j], o);
        [a[j], $[j]] = [_e, et]
    }
    return [a, $]
}
const toBig = (s, o) => BigInt(s >>> 0) << _32n | BigInt(o >>> 0),
    shrSH = (s, o, a) => s >>> a,
    shrSL = (s, o, a) => s << 32 - a | o >>> a,
    rotrSH = (s, o, a) => s >>> a | o << 32 - a,
    rotrSL = (s, o, a) => s << 32 - a | o >>> a,
    rotrBH = (s, o, a) => s << 64 - a | o >>> a - 32,
    rotrBL = (s, o, a) => s >>> a - 32 | o << 64 - a,
    rotr32H = (s, o) => o,
    rotr32L = (s, o) => s,
    rotlSH = (s, o, a) => s << a | o >>> 32 - a,
    rotlSL = (s, o, a) => o << a | s >>> 32 - a,
    rotlBH = (s, o, a) => o << a - 32 | s >>> 64 - a,
    rotlBL = (s, o, a) => s << a - 32 | o >>> 64 - a;

function add(s, o, a, $) {
    const j = (o >>> 0) + ($ >>> 0);
    return {
        h: s + a + (j / 2 ** 32 | 0) | 0,
        l: j | 0
    }
}
const add3L = (s, o, a) => (s >>> 0) + (o >>> 0) + (a >>> 0),
    add3H = (s, o, a, $) => o + a + $ + (s / 2 ** 32 | 0) | 0,
    add4L = (s, o, a, $) => (s >>> 0) + (o >>> 0) + (a >>> 0) + ($ >>> 0),
    add4H = (s, o, a, $, j) => o + a + $ + j + (s / 2 ** 32 | 0) | 0,
    add5L = (s, o, a, $, j) => (s >>> 0) + (o >>> 0) + (a >>> 0) + ($ >>> 0) + (j >>> 0),
    add5H = (s, o, a, $, j, _e) => o + a + $ + j + _e + (s / 2 ** 32 | 0) | 0,
    u64$2 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
    },
    [SHA512_Kh, SHA512_Kl] = u64$2.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(s => BigInt(s))),
    SHA512_W_H = new Uint32Array(80),
    SHA512_W_L = new Uint32Array(80);
class SHA512 extends HashMD {
    constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
    }
    get() {
        const {
            Ah: o,
            Al: a,
            Bh: $,
            Bl: j,
            Ch: _e,
            Cl: et,
            Dh: tt,
            Dl: nt,
            Eh: rt,
            El: ot,
            Fh: st,
            Fl: lt,
            Gh: ft,
            Gl: yt,
            Hh: bt,
            Hl: ht
        } = this;
        return [o, a, $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht]
    }
    set(o, a, $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht) {
        this.Ah = o | 0, this.Al = a | 0, this.Bh = $ | 0, this.Bl = j | 0, this.Ch = _e | 0, this.Cl = et | 0, this.Dh = tt | 0, this.Dl = nt | 0, this.Eh = rt | 0, this.El = ot | 0, this.Fh = st | 0, this.Fl = lt | 0, this.Gh = ft | 0, this.Gl = yt | 0, this.Hh = bt | 0, this.Hl = ht | 0
    }
    process(o, a) {
        for (let gt = 0; gt < 16; gt++, a += 4) SHA512_W_H[gt] = o.getUint32(a), SHA512_W_L[gt] = o.getUint32(a += 4);
        for (let gt = 16; gt < 80; gt++) {
            const At = SHA512_W_H[gt - 15] | 0,
                Pt = SHA512_W_L[gt - 15] | 0,
                Bt = u64$2.rotrSH(At, Pt, 1) ^ u64$2.rotrSH(At, Pt, 8) ^ u64$2.shrSH(At, Pt, 7),
                Lt = u64$2.rotrSL(At, Pt, 1) ^ u64$2.rotrSL(At, Pt, 8) ^ u64$2.shrSL(At, Pt, 7),
                Nt = SHA512_W_H[gt - 2] | 0,
                Ut = SHA512_W_L[gt - 2] | 0,
                Vt = u64$2.rotrSH(Nt, Ut, 19) ^ u64$2.rotrBH(Nt, Ut, 61) ^ u64$2.shrSH(Nt, Ut, 6),
                Ft = u64$2.rotrSL(Nt, Ut, 19) ^ u64$2.rotrBL(Nt, Ut, 61) ^ u64$2.shrSL(Nt, Ut, 6),
                Wt = u64$2.add4L(Lt, Ft, SHA512_W_L[gt - 7], SHA512_W_L[gt - 16]),
                Ct = u64$2.add4H(Wt, Bt, Vt, SHA512_W_H[gt - 7], SHA512_W_H[gt - 16]);
            SHA512_W_H[gt] = Ct | 0, SHA512_W_L[gt] = Wt | 0
        }
        let {
            Ah: $,
            Al: j,
            Bh: _e,
            Bl: et,
            Ch: tt,
            Cl: nt,
            Dh: rt,
            Dl: ot,
            Eh: st,
            El: lt,
            Fh: ft,
            Fl: yt,
            Gh: bt,
            Gl: ht,
            Hh: vt,
            Hl: wt
        } = this;
        for (let gt = 0; gt < 80; gt++) {
            const At = u64$2.rotrSH(st, lt, 14) ^ u64$2.rotrSH(st, lt, 18) ^ u64$2.rotrBH(st, lt, 41),
                Pt = u64$2.rotrSL(st, lt, 14) ^ u64$2.rotrSL(st, lt, 18) ^ u64$2.rotrBL(st, lt, 41),
                Bt = st & ft ^ ~st & bt,
                Lt = lt & yt ^ ~lt & ht,
                Nt = u64$2.add5L(wt, Pt, Lt, SHA512_Kl[gt], SHA512_W_L[gt]),
                Ut = u64$2.add5H(Nt, vt, At, Bt, SHA512_Kh[gt], SHA512_W_H[gt]),
                Vt = Nt | 0,
                Ft = u64$2.rotrSH($, j, 28) ^ u64$2.rotrBH($, j, 34) ^ u64$2.rotrBH($, j, 39),
                Wt = u64$2.rotrSL($, j, 28) ^ u64$2.rotrBL($, j, 34) ^ u64$2.rotrBL($, j, 39),
                Ct = $ & _e ^ $ & tt ^ _e & tt,
                it = j & et ^ j & nt ^ et & nt;
            vt = bt | 0, wt = ht | 0, bt = ft | 0, ht = yt | 0, ft = st | 0, yt = lt | 0, {
                h: st,
                l: lt
            } = u64$2.add(rt | 0, ot | 0, Ut | 0, Vt | 0), rt = tt | 0, ot = nt | 0, tt = _e | 0, nt = et | 0, _e = $ | 0, et = j | 0;
            const at = u64$2.add3L(Vt, Wt, it);
            $ = u64$2.add3H(at, Ut, Ft, Ct), j = at | 0
        }({
            h: $,
            l: j
        } = u64$2.add(this.Ah | 0, this.Al | 0, $ | 0, j | 0)), {
            h: _e,
            l: et
        } = u64$2.add(this.Bh | 0, this.Bl | 0, _e | 0, et | 0), {
            h: tt,
            l: nt
        } = u64$2.add(this.Ch | 0, this.Cl | 0, tt | 0, nt | 0), {
            h: rt,
            l: ot
        } = u64$2.add(this.Dh | 0, this.Dl | 0, rt | 0, ot | 0), {
            h: st,
            l: lt
        } = u64$2.add(this.Eh | 0, this.El | 0, st | 0, lt | 0), {
            h: ft,
            l: yt
        } = u64$2.add(this.Fh | 0, this.Fl | 0, ft | 0, yt | 0), {
            h: bt,
            l: ht
        } = u64$2.add(this.Gh | 0, this.Gl | 0, bt | 0, ht | 0), {
            h: vt,
            l: wt
        } = u64$2.add(this.Hh | 0, this.Hl | 0, vt | 0, wt | 0), this.set($, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht, vt, wt)
    }
    roundClean() {
        SHA512_W_H.fill(0), SHA512_W_L.fill(0)
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
const sha512 = wrapConstructor(() => new SHA512); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = BigInt(0),
    _1n$7 = BigInt(1),
    _2n$5 = BigInt(2);

function isBytes(s) {
    return s instanceof Uint8Array || s != null && typeof s == "object" && s.constructor.name === "Uint8Array"
}

function abytes(s) {
    if (!isBytes(s)) throw new Error("Uint8Array expected")
}

function abool(s, o) {
    if (typeof o != "boolean") throw new Error(`${s} must be valid boolean, got "${o}".`)
}
const hexes = Array.from({
    length: 256
}, (s, o) => o.toString(16).padStart(2, "0"));

function bytesToHex(s) {
    abytes(s);
    let o = "";
    for (let a = 0; a < s.length; a++) o += hexes[s[a]];
    return o
}

function numberToHexUnpadded(s) {
    const o = s.toString(16);
    return o.length & 1 ? `0${o}` : o
}

function hexToNumber(s) {
    if (typeof s != "string") throw new Error("hex string expected, got " + typeof s);
    return BigInt(s === "" ? "0" : `0x${s}`)
}
const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};

function asciiToBase16(s) {
    if (s >= asciis._0 && s <= asciis._9) return s - asciis._0;
    if (s >= asciis._A && s <= asciis._F) return s - (asciis._A - 10);
    if (s >= asciis._a && s <= asciis._f) return s - (asciis._a - 10)
}

function hexToBytes(s) {
    if (typeof s != "string") throw new Error("hex string expected, got " + typeof s);
    const o = s.length,
        a = o / 2;
    if (o % 2) throw new Error("padded hex string expected, got unpadded hex of length " + o);
    const $ = new Uint8Array(a);
    for (let j = 0, _e = 0; j < a; j++, _e += 2) {
        const et = asciiToBase16(s.charCodeAt(_e)),
            tt = asciiToBase16(s.charCodeAt(_e + 1));
        if (et === void 0 || tt === void 0) {
            const nt = s[_e] + s[_e + 1];
            throw new Error('hex string expected, got non-hex character "' + nt + '" at index ' + _e)
        }
        $[j] = et * 16 + tt
    }
    return $
}

function bytesToNumberBE(s) {
    return hexToNumber(bytesToHex(s))
}

function bytesToNumberLE(s) {
    return abytes(s), hexToNumber(bytesToHex(Uint8Array.from(s).reverse()))
}

function numberToBytesBE(s, o) {
    return hexToBytes(s.toString(16).padStart(o * 2, "0"))
}

function numberToBytesLE(s, o) {
    return numberToBytesBE(s, o).reverse()
}

function numberToVarBytesBE(s) {
    return hexToBytes(numberToHexUnpadded(s))
}

function ensureBytes(s, o, a) {
    let $;
    if (typeof o == "string") try {
            $ = hexToBytes(o)
        } catch (_e) {
            throw new Error(`${s} must be valid hex string, got "${o}". Cause: ${_e}`)
        } else if (isBytes(o)) $ = Uint8Array.from(o);
        else throw new Error(`${s} must be hex string or Uint8Array`);
    const j = $.length;
    if (typeof a == "number" && j !== a) throw new Error(`${s} expected ${a} bytes, got ${j}`);
    return $
}

function concatBytes(...s) {
    let o = 0;
    for (let $ = 0; $ < s.length; $++) {
        const j = s[$];
        abytes(j), o += j.length
    }
    const a = new Uint8Array(o);
    for (let $ = 0, j = 0; $ < s.length; $++) {
        const _e = s[$];
        a.set(_e, j), j += _e.length
    }
    return a
}

function equalBytes(s, o) {
    if (s.length !== o.length) return !1;
    let a = 0;
    for (let $ = 0; $ < s.length; $++) a |= s[$] ^ o[$];
    return a === 0
}

function utf8ToBytes(s) {
    if (typeof s != "string") throw new Error(`utf8ToBytes expected string, got ${typeof s}`);
    return new Uint8Array(new TextEncoder().encode(s))
}
const isPosBig = s => typeof s == "bigint" && _0n$5 <= s;

function inRange$1(s, o, a) {
    return isPosBig(s) && isPosBig(o) && isPosBig(a) && o <= s && s < a
}

function aInRange(s, o, a, $) {
    if (!inRange$1(o, a, $)) throw new Error(`expected valid ${s}: ${a} <= n < ${$}, got ${typeof o} ${o}`)
}

function bitLen(s) {
    let o;
    for (o = 0; s > _0n$5; s >>= _1n$7, o += 1);
    return o
}

function bitGet(s, o) {
    return s >> BigInt(o) & _1n$7
}

function bitSet(s, o, a) {
    return s | (a ? _1n$7 : _0n$5) << BigInt(o)
}
const bitMask = s => (_2n$5 << BigInt(s - 1)) - _1n$7,
    u8n = s => new Uint8Array(s),
    u8fr = s => Uint8Array.from(s);

function createHmacDrbg(s, o, a) {
    if (typeof s != "number" || s < 2) throw new Error("hashLen must be a number");
    if (typeof o != "number" || o < 2) throw new Error("qByteLen must be a number");
    if (typeof a != "function") throw new Error("hmacFn must be a function");
    let $ = u8n(s),
        j = u8n(s),
        _e = 0;
    const et = () => {
            $.fill(1), j.fill(0), _e = 0
        },
        tt = (...st) => a(j, $, ...st),
        nt = (st = u8n()) => {
            j = tt(u8fr([0]), st), $ = tt(), st.length !== 0 && (j = tt(u8fr([1]), st), $ = tt())
        },
        rt = () => {
            if (_e++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let st = 0;
            const lt = [];
            for (; st < o;) {
                $ = tt();
                const ft = $.slice();
                lt.push(ft), st += $.length
            }
            return concatBytes(...lt)
        };
    return (st, lt) => {
        et(), nt(st);
        let ft;
        for (; !(ft = lt(rt()));) nt();
        return et(), ft
    }
}
const validatorFns = {
    bigint: s => typeof s == "bigint",
    function: s => typeof s == "function",
    boolean: s => typeof s == "boolean",
    string: s => typeof s == "string",
    stringOrUint8Array: s => typeof s == "string" || isBytes(s),
    isSafeInteger: s => Number.isSafeInteger(s),
    array: s => Array.isArray(s),
    field: (s, o) => o.Fp.isValid(s),
    hash: s => typeof s == "function" && Number.isSafeInteger(s.outputLen)
};

function validateObject(s, o, a = {}) {
    const $ = (j, _e, et) => {
        const tt = validatorFns[_e];
        if (typeof tt != "function") throw new Error(`Invalid validator "${_e}", expected function`);
        const nt = s[j];
        if (!(et && nt === void 0) && !tt(nt, s)) throw new Error(`Invalid param ${String(j)}=${nt} (${typeof nt}), expected ${_e}`)
    };
    for (const [j, _e] of Object.entries(o)) $(j, _e, !1);
    for (const [j, _e] of Object.entries(a)) $(j, _e, !0);
    return s
}
const notImplemented = () => {
    throw new Error("not implemented")
};

function memoized(s) {
    const o = new WeakMap;
    return (a, ...$) => {
        const j = o.get(a);
        if (j !== void 0) return j;
        const _e = s(a, ...$);
        return o.set(a, _e), _e
    }
}
const ut = Object.freeze(Object.defineProperty({
    __proto__: null,
    aInRange,
    abool,
    abytes,
    bitGet,
    bitLen,
    bitMask,
    bitSet,
    bytesToHex,
    bytesToNumberBE,
    bytesToNumberLE,
    concatBytes,
    createHmacDrbg,
    ensureBytes,
    equalBytes,
    hexToBytes,
    hexToNumber,
    inRange: inRange$1,
    isBytes,
    memoized,
    notImplemented,
    numberToBytesBE,
    numberToBytesLE,
    numberToHexUnpadded,
    numberToVarBytesBE,
    utf8ToBytes,
    validateObject
}, Symbol.toStringTag, {
    value: "Module"
})); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0),
    _1n$6 = BigInt(1),
    _2n$4 = BigInt(2),
    _3n$1 = BigInt(3),
    _4n = BigInt(4),
    _5n$1 = BigInt(5),
    _8n$2 = BigInt(8);
BigInt(9);
BigInt(16);

function mod(s, o) {
    const a = s % o;
    return a >= _0n$4 ? a : o + a
}

function pow(s, o, a) {
    if (a <= _0n$4 || o < _0n$4) throw new Error("Expected power/modulo > 0");
    if (a === _1n$6) return _0n$4;
    let $ = _1n$6;
    for (; o > _0n$4;) o & _1n$6 && ($ = $ * s % a), s = s * s % a, o >>= _1n$6;
    return $
}

function pow2(s, o, a) {
    let $ = s;
    for (; o-- > _0n$4;) $ *= $, $ %= a;
    return $
}

function invert(s, o) {
    if (s === _0n$4 || o <= _0n$4) throw new Error(`invert: expected positive integers, got n=${s} mod=${o}`);
    let a = mod(s, o),
        $ = o,
        j = _0n$4,
        _e = _1n$6;
    for (; a !== _0n$4;) {
        const tt = $ / a,
            nt = $ % a,
            rt = j - _e * tt;
        $ = a, a = nt, j = _e, _e = rt
    }
    if ($ !== _1n$6) throw new Error("invert: does not exist");
    return mod(j, o)
}

function tonelliShanks(s) {
    const o = (s - _1n$6) / _2n$4;
    let a, $, j;
    for (a = s - _1n$6, $ = 0; a % _2n$4 === _0n$4; a /= _2n$4, $++);
    for (j = _2n$4; j < s && pow(j, o, s) !== s - _1n$6; j++);
    if ($ === 1) {
        const et = (s + _1n$6) / _4n;
        return function(nt, rt) {
            const ot = nt.pow(rt, et);
            if (!nt.eql(nt.sqr(ot), rt)) throw new Error("Cannot find square root");
            return ot
        }
    }
    const _e = (a + _1n$6) / _2n$4;
    return function(tt, nt) {
        if (tt.pow(nt, o) === tt.neg(tt.ONE)) throw new Error("Cannot find square root");
        let rt = $,
            ot = tt.pow(tt.mul(tt.ONE, j), a),
            st = tt.pow(nt, _e),
            lt = tt.pow(nt, a);
        for (; !tt.eql(lt, tt.ONE);) {
            if (tt.eql(lt, tt.ZERO)) return tt.ZERO;
            let ft = 1;
            for (let bt = tt.sqr(lt); ft < rt && !tt.eql(bt, tt.ONE); ft++) bt = tt.sqr(bt);
            const yt = tt.pow(ot, _1n$6 << BigInt(rt - ft - 1));
            ot = tt.sqr(yt), st = tt.mul(st, yt), lt = tt.mul(lt, ot), rt = ft
        }
        return st
    }
}

function FpSqrt(s) {
    if (s % _4n === _3n$1) {
        const o = (s + _1n$6) / _4n;
        return function($, j) {
            const _e = $.pow(j, o);
            if (!$.eql($.sqr(_e), j)) throw new Error("Cannot find square root");
            return _e
        }
    }
    if (s % _8n$2 === _5n$1) {
        const o = (s - _5n$1) / _8n$2;
        return function($, j) {
            const _e = $.mul(j, _2n$4),
                et = $.pow(_e, o),
                tt = $.mul(j, et),
                nt = $.mul($.mul(tt, _2n$4), et),
                rt = $.mul(tt, $.sub(nt, $.ONE));
            if (!$.eql($.sqr(rt), j)) throw new Error("Cannot find square root");
            return rt
        }
    }
    return tonelliShanks(s)
}
const isNegativeLE = (s, o) => (mod(s, o) & _1n$6) === _1n$6,
    FIELD_FIELDS = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function validateField(s) {
    const o = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        },
        a = FIELD_FIELDS.reduce(($, j) => ($[j] = "function", $), o);
    return validateObject(s, a)
}

function FpPow(s, o, a) {
    if (a < _0n$4) throw new Error("Expected power > 0");
    if (a === _0n$4) return s.ONE;
    if (a === _1n$6) return o;
    let $ = s.ONE,
        j = o;
    for (; a > _0n$4;) a & _1n$6 && ($ = s.mul($, j)), j = s.sqr(j), a >>= _1n$6;
    return $
}

function FpInvertBatch(s, o) {
    const a = new Array(o.length),
        $ = o.reduce((_e, et, tt) => s.is0(et) ? _e : (a[tt] = _e, s.mul(_e, et)), s.ONE),
        j = s.inv($);
    return o.reduceRight((_e, et, tt) => s.is0(et) ? _e : (a[tt] = s.mul(_e, a[tt]), s.mul(_e, et)), j), a
}

function nLength(s, o) {
    const a = o !== void 0 ? o : s.toString(2).length,
        $ = Math.ceil(a / 8);
    return {
        nBitLength: a,
        nByteLength: $
    }
}

function Field(s, o, a = !1, $ = {}) {
    if (s <= _0n$4) throw new Error(`Expected Field ORDER > 0, got ${s}`);
    const {
        nBitLength: j,
        nByteLength: _e
    } = nLength(s, o);
    if (_e > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const et = FpSqrt(s),
        tt = Object.freeze({
            ORDER: s,
            BITS: j,
            BYTES: _e,
            MASK: bitMask(j),
            ZERO: _0n$4,
            ONE: _1n$6,
            create: nt => mod(nt, s),
            isValid: nt => {
                if (typeof nt != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof nt}`);
                return _0n$4 <= nt && nt < s
            },
            is0: nt => nt === _0n$4,
            isOdd: nt => (nt & _1n$6) === _1n$6,
            neg: nt => mod(-nt, s),
            eql: (nt, rt) => nt === rt,
            sqr: nt => mod(nt * nt, s),
            add: (nt, rt) => mod(nt + rt, s),
            sub: (nt, rt) => mod(nt - rt, s),
            mul: (nt, rt) => mod(nt * rt, s),
            pow: (nt, rt) => FpPow(tt, nt, rt),
            div: (nt, rt) => mod(nt * invert(rt, s), s),
            sqrN: nt => nt * nt,
            addN: (nt, rt) => nt + rt,
            subN: (nt, rt) => nt - rt,
            mulN: (nt, rt) => nt * rt,
            inv: nt => invert(nt, s),
            sqrt: $.sqrt || (nt => et(tt, nt)),
            invertBatch: nt => FpInvertBatch(tt, nt),
            cmov: (nt, rt, ot) => ot ? rt : nt,
            toBytes: nt => a ? numberToBytesLE(nt, _e) : numberToBytesBE(nt, _e),
            fromBytes: nt => {
                if (nt.length !== _e) throw new Error(`Fp.fromBytes: expected ${_e}, got ${nt.length}`);
                return a ? bytesToNumberLE(nt) : bytesToNumberBE(nt)
            }
        });
    return Object.freeze(tt)
}

function getFieldBytesLength(s) {
    if (typeof s != "bigint") throw new Error("field order must be bigint");
    const o = s.toString(2).length;
    return Math.ceil(o / 8)
}

function getMinHashLength(s) {
    const o = getFieldBytesLength(s);
    return o + Math.ceil(o / 2)
}

function mapHashToField(s, o, a = !1) {
    const $ = s.length,
        j = getFieldBytesLength(o),
        _e = getMinHashLength(o);
    if ($ < 16 || $ < _e || $ > 1024) throw new Error(`expected ${_e}-1024 bytes of input, got ${$}`);
    const et = a ? bytesToNumberBE(s) : bytesToNumberLE(s),
        tt = mod(et, o - _1n$6) + _1n$6;
    return a ? numberToBytesLE(tt, j) : numberToBytesBE(tt, j)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0),
    _1n$5 = BigInt(1),
    pointPrecomputes = new WeakMap,
    pointWindowSizes = new WeakMap;

function wNAF(s, o) {
    const a = (_e, et) => {
            const tt = et.negate();
            return _e ? tt : et
        },
        $ = _e => {
            if (!Number.isSafeInteger(_e) || _e <= 0 || _e > o) throw new Error(`Wrong window size=${_e}, should be [1..${o}]`)
        },
        j = _e => {
            $(_e);
            const et = Math.ceil(o / _e) + 1,
                tt = 2 ** (_e - 1);
            return {
                windows: et,
                windowSize: tt
            }
        };
    return {
        constTimeNegate: a,
        unsafeLadder(_e, et) {
            let tt = s.ZERO,
                nt = _e;
            for (; et > _0n$3;) et & _1n$5 && (tt = tt.add(nt)), nt = nt.double(), et >>= _1n$5;
            return tt
        },
        precomputeWindow(_e, et) {
            const {
                windows: tt,
                windowSize: nt
            } = j(et), rt = [];
            let ot = _e,
                st = ot;
            for (let lt = 0; lt < tt; lt++) {
                st = ot, rt.push(st);
                for (let ft = 1; ft < nt; ft++) st = st.add(ot), rt.push(st);
                ot = st.double()
            }
            return rt
        },
        wNAF(_e, et, tt) {
            const {
                windows: nt,
                windowSize: rt
            } = j(_e);
            let ot = s.ZERO,
                st = s.BASE;
            const lt = BigInt(2 ** _e - 1),
                ft = 2 ** _e,
                yt = BigInt(_e);
            for (let bt = 0; bt < nt; bt++) {
                const ht = bt * rt;
                let vt = Number(tt & lt);
                tt >>= yt, vt > rt && (vt -= ft, tt += _1n$5);
                const wt = ht,
                    gt = ht + Math.abs(vt) - 1,
                    At = bt % 2 !== 0,
                    Pt = vt < 0;
                vt === 0 ? st = st.add(a(At, et[wt])) : ot = ot.add(a(Pt, et[gt]))
            }
            return {
                p: ot,
                f: st
            }
        },
        wNAFCached(_e, et, tt) {
            const nt = pointWindowSizes.get(_e) || 1;
            let rt = pointPrecomputes.get(_e);
            return rt || (rt = this.precomputeWindow(_e, nt), nt !== 1 && pointPrecomputes.set(_e, tt(rt))), this.wNAF(nt, rt, et)
        },
        setWindowSize(_e, et) {
            $(et), pointWindowSizes.set(_e, et), pointPrecomputes.delete(_e)
        }
    }
}

function pippenger(s, o, a, $) {
    if (!Array.isArray(a) || !Array.isArray($) || $.length !== a.length) throw new Error("arrays of points and scalars must have equal length");
    $.forEach((ot, st) => {
        if (!o.isValid(ot)) throw new Error(`wrong scalar at index ${st}`)
    }), a.forEach((ot, st) => {
        if (!(ot instanceof s)) throw new Error(`wrong point at index ${st}`)
    });
    const j = bitLen(BigInt(a.length)),
        _e = j > 12 ? j - 3 : j > 4 ? j - 2 : j ? 2 : 1,
        et = (1 << _e) - 1,
        tt = new Array(et + 1).fill(s.ZERO),
        nt = Math.floor((o.BITS - 1) / _e) * _e;
    let rt = s.ZERO;
    for (let ot = nt; ot >= 0; ot -= _e) {
        tt.fill(s.ZERO);
        for (let lt = 0; lt < $.length; lt++) {
            const ft = $[lt],
                yt = Number(ft >> BigInt(ot) & BigInt(et));
            tt[yt] = tt[yt].add(a[lt])
        }
        let st = s.ZERO;
        for (let lt = tt.length - 1, ft = s.ZERO; lt > 0; lt--) ft = ft.add(tt[lt]), st = st.add(ft);
        if (rt = rt.add(st), ot !== 0)
            for (let lt = 0; lt < _e; lt++) rt = rt.double()
    }
    return rt
}

function validateBasic(s) {
    return validateField(s.Fp), validateObject(s, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({ ...nLength(s.n, s.nBitLength),
        ...s,
        p: s.Fp.ORDER
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0),
    _1n$4 = BigInt(1),
    _2n$3 = BigInt(2),
    _8n$1 = BigInt(8),
    VERIFY_DEFAULT = {
        zip215: !0
    };

function validateOpts$1(s) {
    const o = validateBasic(s);
    return validateObject(s, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }), Object.freeze({ ...o
    })
}

function twistedEdwards(s) {
    const o = validateOpts$1(s),
        {
            Fp: a,
            n: $,
            prehash: j,
            hash: _e,
            randomBytes: et,
            nByteLength: tt,
            h: nt
        } = o,
        rt = _2n$3 << BigInt(tt * 8) - _1n$4,
        ot = a.create,
        st = Field(o.n, o.nBitLength),
        lt = o.uvRatio || ((mt, xt) => {
            try {
                return {
                    isValid: !0,
                    value: a.sqrt(mt * a.inv(xt))
                }
            } catch {
                return {
                    isValid: !1,
                    value: _0n$2
                }
            }
        }),
        ft = o.adjustScalarBytes || (mt => mt),
        yt = o.domain || ((mt, xt, $t) => {
            if (abool("phflag", $t), xt.length || $t) throw new Error("Contexts/pre-hash are not supported");
            return mt
        });

    function bt(mt, xt) {
        aInRange("coordinate " + mt, xt, _0n$2, rt)
    }

    function ht(mt) {
        if (!(mt instanceof gt)) throw new Error("ExtendedPoint expected")
    }
    const vt = memoized((mt, xt) => {
            const {
                ex: $t,
                ey: Rt,
                ez: It
            } = mt, Tt = mt.is0();
            xt == null && (xt = Tt ? _8n$1 : a.inv(It));
            const dt = ot($t * xt),
                Et = ot(Rt * xt),
                Ot = ot(It * xt);
            if (Tt) return {
                x: _0n$2,
                y: _1n$4
            };
            if (Ot !== _1n$4) throw new Error("invZ was invalid");
            return {
                x: dt,
                y: Et
            }
        }),
        wt = memoized(mt => {
            const {
                a: xt,
                d: $t
            } = o;
            if (mt.is0()) throw new Error("bad point: ZERO");
            const {
                ex: Rt,
                ey: It,
                ez: Tt,
                et: dt
            } = mt, Et = ot(Rt * Rt), Ot = ot(It * It), Mt = ot(Tt * Tt), jt = ot(Mt * Mt), Qt = ot(Et * xt), Kt = ot(Mt * ot(Qt + Ot)), qt = ot(jt + ot($t * ot(Et * Ot)));
            if (Kt !== qt) throw new Error("bad point: equation left != right (1)");
            const Jt = ot(Rt * It),
                Zt = ot(Tt * dt);
            if (Jt !== Zt) throw new Error("bad point: equation left != right (2)");
            return !0
        });
    class gt {
        constructor(xt, $t, Rt, It) {
            this.ex = xt, this.ey = $t, this.ez = Rt, this.et = It, bt("x", xt), bt("y", $t), bt("z", Rt), bt("t", It), Object.freeze(this)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(xt) {
            if (xt instanceof gt) throw new Error("extended point not allowed");
            const {
                x: $t,
                y: Rt
            } = xt || {};
            return bt("x", $t), bt("y", Rt), new gt($t, Rt, _1n$4, ot($t * Rt))
        }
        static normalizeZ(xt) {
            const $t = a.invertBatch(xt.map(Rt => Rt.ez));
            return xt.map((Rt, It) => Rt.toAffine($t[It])).map(gt.fromAffine)
        }
        static msm(xt, $t) {
            return pippenger(gt, st, xt, $t)
        }
        _setWindowSize(xt) {
            Bt.setWindowSize(this, xt)
        }
        assertValidity() {
            wt(this)
        }
        equals(xt) {
            ht(xt);
            const {
                ex: $t,
                ey: Rt,
                ez: It
            } = this, {
                ex: Tt,
                ey: dt,
                ez: Et
            } = xt, Ot = ot($t * Et), Mt = ot(Tt * It), jt = ot(Rt * Et), Qt = ot(dt * It);
            return Ot === Mt && jt === Qt
        }
        is0() {
            return this.equals(gt.ZERO)
        }
        negate() {
            return new gt(ot(-this.ex), this.ey, this.ez, ot(-this.et))
        }
        double() {
            const {
                a: xt
            } = o, {
                ex: $t,
                ey: Rt,
                ez: It
            } = this, Tt = ot($t * $t), dt = ot(Rt * Rt), Et = ot(_2n$3 * ot(It * It)), Ot = ot(xt * Tt), Mt = $t + Rt, jt = ot(ot(Mt * Mt) - Tt - dt), Qt = Ot + dt, Kt = Qt - Et, qt = Ot - dt, Jt = ot(jt * Kt), Zt = ot(Qt * qt), en = ot(jt * qt), ln = ot(Kt * Qt);
            return new gt(Jt, Zt, ln, en)
        }
        add(xt) {
            ht(xt);
            const {
                a: $t,
                d: Rt
            } = o, {
                ex: It,
                ey: Tt,
                ez: dt,
                et: Et
            } = this, {
                ex: Ot,
                ey: Mt,
                ez: jt,
                et: Qt
            } = xt;
            if ($t === BigInt(-1)) {
                const mn = ot((Tt - It) * (Mt + Ot)),
                    dn = ot((Tt + It) * (Mt - Ot)),
                    vn = ot(dn - mn);
                if (vn === _0n$2) return this.double();
                const gn = ot(dt * _2n$3 * Qt),
                    Gt = ot(Et * _2n$3 * jt),
                    Yt = Gt + gn,
                    nn = dn + mn,
                    St = Gt - gn,
                    ct = ot(Yt * vn),
                    pt = ot(nn * St),
                    kt = ot(Yt * St),
                    Dt = ot(vn * nn);
                return new gt(ct, pt, Dt, kt)
            }
            const Kt = ot(It * Ot),
                qt = ot(Tt * Mt),
                Jt = ot(Et * Rt * Qt),
                Zt = ot(dt * jt),
                en = ot((It + Tt) * (Ot + Mt) - Kt - qt),
                ln = Zt - Jt,
                cn = Zt + Jt,
                un = ot(qt - $t * Kt),
                Nn = ot(en * ln),
                hn = ot(cn * un),
                fn = ot(en * un),
                rn = ot(ln * cn);
            return new gt(Nn, hn, rn, fn)
        }
        subtract(xt) {
            return this.add(xt.negate())
        }
        wNAF(xt) {
            return Bt.wNAFCached(this, xt, gt.normalizeZ)
        }
        multiply(xt) {
            const $t = xt;
            aInRange("scalar", $t, _1n$4, $);
            const {
                p: Rt,
                f: It
            } = this.wNAF($t);
            return gt.normalizeZ([Rt, It])[0]
        }
        multiplyUnsafe(xt) {
            const $t = xt;
            return aInRange("scalar", $t, _0n$2, $), $t === _0n$2 ? Pt : this.equals(Pt) || $t === _1n$4 ? this : this.equals(At) ? this.wNAF($t).p : Bt.unsafeLadder(this, $t)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(nt).is0()
        }
        isTorsionFree() {
            return Bt.unsafeLadder(this, $).is0()
        }
        toAffine(xt) {
            return vt(this, xt)
        }
        clearCofactor() {
            const {
                h: xt
            } = o;
            return xt === _1n$4 ? this : this.multiplyUnsafe(xt)
        }
        static fromHex(xt, $t = !1) {
            const {
                d: Rt,
                a: It
            } = o, Tt = a.BYTES;
            xt = ensureBytes("pointHex", xt, Tt), abool("zip215", $t);
            const dt = xt.slice(),
                Et = xt[Tt - 1];
            dt[Tt - 1] = Et & -129;
            const Ot = bytesToNumberLE(dt),
                Mt = $t ? rt : a.ORDER;
            aInRange("pointHex.y", Ot, _0n$2, Mt);
            const jt = ot(Ot * Ot),
                Qt = ot(jt - _1n$4),
                Kt = ot(Rt * jt - It);
            let {
                isValid: qt,
                value: Jt
            } = lt(Qt, Kt);
            if (!qt) throw new Error("Point.fromHex: invalid y coordinate");
            const Zt = (Jt & _1n$4) === _1n$4,
                en = (Et & 128) !== 0;
            if (!$t && Jt === _0n$2 && en) throw new Error("Point.fromHex: x=0 and x_0=1");
            return en !== Zt && (Jt = ot(-Jt)), gt.fromAffine({
                x: Jt,
                y: Ot
            })
        }
        static fromPrivateKey(xt) {
            return Ut(xt).point
        }
        toRawBytes() {
            const {
                x: xt,
                y: $t
            } = this.toAffine(), Rt = numberToBytesLE($t, a.BYTES);
            return Rt[Rt.length - 1] |= xt & _1n$4 ? 128 : 0, Rt
        }
        toHex() {
            return bytesToHex(this.toRawBytes())
        }
    }
    gt.BASE = new gt(o.Gx, o.Gy, _1n$4, ot(o.Gx * o.Gy)), gt.ZERO = new gt(_0n$2, _1n$4, _1n$4, _0n$2);
    const {
        BASE: At,
        ZERO: Pt
    } = gt, Bt = wNAF(gt, tt * 8);

    function Lt(mt) {
        return mod(mt, $)
    }

    function Nt(mt) {
        return Lt(bytesToNumberLE(mt))
    }

    function Ut(mt) {
        const xt = tt;
        mt = ensureBytes("private key", mt, xt);
        const $t = ensureBytes("hashed private key", _e(mt), 2 * xt),
            Rt = ft($t.slice(0, xt)),
            It = $t.slice(xt, 2 * xt),
            Tt = Nt(Rt),
            dt = At.multiply(Tt),
            Et = dt.toRawBytes();
        return {
            head: Rt,
            prefix: It,
            scalar: Tt,
            point: dt,
            pointBytes: Et
        }
    }

    function Vt(mt) {
        return Ut(mt).pointBytes
    }

    function Ft(mt = new Uint8Array, ...xt) {
        const $t = concatBytes(...xt);
        return Nt(_e(yt($t, ensureBytes("context", mt), !!j)))
    }

    function Wt(mt, xt, $t = {}) {
        mt = ensureBytes("message", mt), j && (mt = j(mt));
        const {
            prefix: Rt,
            scalar: It,
            pointBytes: Tt
        } = Ut(xt), dt = Ft($t.context, Rt, mt), Et = At.multiply(dt).toRawBytes(), Ot = Ft($t.context, Et, Tt, mt), Mt = Lt(dt + Ot * It);
        aInRange("signature.s", Mt, _0n$2, $);
        const jt = concatBytes(Et, numberToBytesLE(Mt, a.BYTES));
        return ensureBytes("result", jt, tt * 2)
    }
    const Ct = VERIFY_DEFAULT;

    function it(mt, xt, $t, Rt = Ct) {
        const {
            context: It,
            zip215: Tt
        } = Rt, dt = a.BYTES;
        mt = ensureBytes("signature", mt, 2 * dt), xt = ensureBytes("message", xt), Tt !== void 0 && abool("zip215", Tt), j && (xt = j(xt));
        const Et = bytesToNumberLE(mt.slice(dt, 2 * dt));
        let Ot, Mt, jt;
        try {
            Ot = gt.fromHex($t, Tt), Mt = gt.fromHex(mt.slice(0, dt), Tt), jt = At.multiplyUnsafe(Et)
        } catch {
            return !1
        }
        if (!Tt && Ot.isSmallOrder()) return !1;
        const Qt = Ft(It, Mt.toRawBytes(), Ot.toRawBytes(), xt);
        return Mt.add(Ot.multiplyUnsafe(Qt)).subtract(jt).clearCofactor().equals(gt.ZERO)
    }
    return At._setWindowSize(8), {
        CURVE: o,
        getPublicKey: Vt,
        sign: Wt,
        verify: it,
        ExtendedPoint: gt,
        utils: {
            getExtendedPublicKey: Ut,
            randomPrivateKey: () => et(a.BYTES),
            precompute(mt = 8, xt = gt.BASE) {
                return xt._setWindowSize(mt), xt.multiply(BigInt(3)), xt
            }
        }
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
    ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$3 = BigInt(1),
    _2n$2 = BigInt(2);
BigInt(3);
const _5n = BigInt(5),
    _8n = BigInt(8);

function ed25519_pow_2_252_3(s) {
    const o = BigInt(10),
        a = BigInt(20),
        $ = BigInt(40),
        j = BigInt(80),
        _e = ED25519_P,
        tt = s * s % _e * s % _e,
        nt = pow2(tt, _2n$2, _e) * tt % _e,
        rt = pow2(nt, _1n$3, _e) * s % _e,
        ot = pow2(rt, _5n, _e) * rt % _e,
        st = pow2(ot, o, _e) * ot % _e,
        lt = pow2(st, a, _e) * st % _e,
        ft = pow2(lt, $, _e) * lt % _e,
        yt = pow2(ft, j, _e) * ft % _e,
        bt = pow2(yt, j, _e) * ft % _e,
        ht = pow2(bt, o, _e) * ot % _e;
    return {
        pow_p_5_8: pow2(ht, _2n$2, _e) * s % _e,
        b2: tt
    }
}

function adjustScalarBytes(s) {
    return s[0] &= 248, s[31] &= 127, s[31] |= 64, s
}

function uvRatio(s, o) {
    const a = ED25519_P,
        $ = mod(o * o * o, a),
        j = mod($ * $ * o, a),
        _e = ed25519_pow_2_252_3(s * j).pow_p_5_8;
    let et = mod(s * $ * _e, a);
    const tt = mod(o * et * et, a),
        nt = et,
        rt = mod(et * ED25519_SQRT_M1, a),
        ot = tt === s,
        st = tt === mod(-s, a),
        lt = tt === mod(-s * ED25519_SQRT_M1, a);
    return ot && (et = nt), (st || lt) && (et = rt), isNegativeLE(et, a) && (et = mod(-et, a)), {
        isValid: ot || st,
        value: et
    }
}
const Fp$1 = Field(ED25519_P, void 0, !0),
    ed25519Defaults = {
        a: BigInt(-1),
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        Fp: Fp$1,
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        h: _8n,
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512,
        randomBytes,
        adjustScalarBytes,
        uvRatio
    },
    ed25519 = twistedEdwards(ed25519Defaults);
var bn = {
    exports: {}
};
bn.exports;
(function(s) {
    (function(o, a) {
        function $(Ct, it) {
            if (!Ct) throw new Error(it || "Assertion failed")
        }

        function j(Ct, it) {
            Ct.super_ = it;
            var at = function() {};
            at.prototype = it.prototype, Ct.prototype = new at, Ct.prototype.constructor = Ct
        }

        function _e(Ct, it, at) {
            if (_e.isBN(Ct)) return Ct;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, Ct !== null && ((it === "le" || it === "be") && (at = it, it = 10), this._init(Ct || 0, it || 10, at || "be"))
        }
        typeof o == "object" ? o.exports = _e : a.BN = _e, _e.BN = _e, _e.wordSize = 26;
        var et;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? et = window.Buffer : et = require$$1$1.Buffer
        } catch {}
        _e.isBN = function(it) {
            return it instanceof _e ? !0 : it !== null && typeof it == "object" && it.constructor.wordSize === _e.wordSize && Array.isArray(it.words)
        }, _e.max = function(it, at) {
            return it.cmp(at) > 0 ? it : at
        }, _e.min = function(it, at) {
            return it.cmp(at) < 0 ? it : at
        }, _e.prototype._init = function(it, at, mt) {
            if (typeof it == "number") return this._initNumber(it, at, mt);
            if (typeof it == "object") return this._initArray(it, at, mt);
            at === "hex" && (at = 16), $(at === (at | 0) && at >= 2 && at <= 36), it = it.toString().replace(/\s+/g, "");
            var xt = 0;
            it[0] === "-" && (xt++, this.negative = 1), xt < it.length && (at === 16 ? this._parseHex(it, xt, mt) : (this._parseBase(it, at, xt), mt === "le" && this._initArray(this.toArray(), at, mt)))
        }, _e.prototype._initNumber = function(it, at, mt) {
            it < 0 && (this.negative = 1, it = -it), it < 67108864 ? (this.words = [it & 67108863], this.length = 1) : it < 4503599627370496 ? (this.words = [it & 67108863, it / 67108864 & 67108863], this.length = 2) : ($(it < 9007199254740992), this.words = [it & 67108863, it / 67108864 & 67108863, 1], this.length = 3), mt === "le" && this._initArray(this.toArray(), at, mt)
        }, _e.prototype._initArray = function(it, at, mt) {
            if ($(typeof it.length == "number"), it.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(it.length / 3), this.words = new Array(this.length);
            for (var xt = 0; xt < this.length; xt++) this.words[xt] = 0;
            var $t, Rt, It = 0;
            if (mt === "be")
                for (xt = it.length - 1, $t = 0; xt >= 0; xt -= 3) Rt = it[xt] | it[xt - 1] << 8 | it[xt - 2] << 16, this.words[$t] |= Rt << It & 67108863, this.words[$t + 1] = Rt >>> 26 - It & 67108863, It += 24, It >= 26 && (It -= 26, $t++);
            else if (mt === "le")
                for (xt = 0, $t = 0; xt < it.length; xt += 3) Rt = it[xt] | it[xt + 1] << 8 | it[xt + 2] << 16, this.words[$t] |= Rt << It & 67108863, this.words[$t + 1] = Rt >>> 26 - It & 67108863, It += 24, It >= 26 && (It -= 26, $t++);
            return this._strip()
        };

        function tt(Ct, it) {
            var at = Ct.charCodeAt(it);
            if (at >= 48 && at <= 57) return at - 48;
            if (at >= 65 && at <= 70) return at - 55;
            if (at >= 97 && at <= 102) return at - 87;
            $(!1, "Invalid character in " + Ct)
        }

        function nt(Ct, it, at) {
            var mt = tt(Ct, at);
            return at - 1 >= it && (mt |= tt(Ct, at - 1) << 4), mt
        }
        _e.prototype._parseHex = function(it, at, mt) {
            this.length = Math.ceil((it.length - at) / 6), this.words = new Array(this.length);
            for (var xt = 0; xt < this.length; xt++) this.words[xt] = 0;
            var $t = 0,
                Rt = 0,
                It;
            if (mt === "be")
                for (xt = it.length - 1; xt >= at; xt -= 2) It = nt(it, at, xt) << $t, this.words[Rt] |= It & 67108863, $t >= 18 ? ($t -= 18, Rt += 1, this.words[Rt] |= It >>> 26) : $t += 8;
            else {
                var Tt = it.length - at;
                for (xt = Tt % 2 === 0 ? at + 1 : at; xt < it.length; xt += 2) It = nt(it, at, xt) << $t, this.words[Rt] |= It & 67108863, $t >= 18 ? ($t -= 18, Rt += 1, this.words[Rt] |= It >>> 26) : $t += 8
            }
            this._strip()
        };

        function rt(Ct, it, at, mt) {
            for (var xt = 0, $t = 0, Rt = Math.min(Ct.length, at), It = it; It < Rt; It++) {
                var Tt = Ct.charCodeAt(It) - 48;
                xt *= mt, Tt >= 49 ? $t = Tt - 49 + 10 : Tt >= 17 ? $t = Tt - 17 + 10 : $t = Tt, $(Tt >= 0 && $t < mt, "Invalid character"), xt += $t
            }
            return xt
        }
        _e.prototype._parseBase = function(it, at, mt) {
            this.words = [0], this.length = 1;
            for (var xt = 0, $t = 1; $t <= 67108863; $t *= at) xt++;
            xt--, $t = $t / at | 0;
            for (var Rt = it.length - mt, It = Rt % xt, Tt = Math.min(Rt, Rt - It) + mt, dt = 0, Et = mt; Et < Tt; Et += xt) dt = rt(it, Et, Et + xt, at), this.imuln($t), this.words[0] + dt < 67108864 ? this.words[0] += dt : this._iaddn(dt);
            if (It !== 0) {
                var Ot = 1;
                for (dt = rt(it, Et, it.length, at), Et = 0; Et < It; Et++) Ot *= at;
                this.imuln(Ot), this.words[0] + dt < 67108864 ? this.words[0] += dt : this._iaddn(dt)
            }
            this._strip()
        }, _e.prototype.copy = function(it) {
            it.words = new Array(this.length);
            for (var at = 0; at < this.length; at++) it.words[at] = this.words[at];
            it.length = this.length, it.negative = this.negative, it.red = this.red
        };

        function ot(Ct, it) {
            Ct.words = it.words, Ct.length = it.length, Ct.negative = it.negative, Ct.red = it.red
        }
        if (_e.prototype._move = function(it) {
                ot(it, this)
            }, _e.prototype.clone = function() {
                var it = new _e(null);
                return this.copy(it), it
            }, _e.prototype._expand = function(it) {
                for (; this.length < it;) this.words[this.length++] = 0;
                return this
            }, _e.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                return this._normSign()
            }, _e.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
            _e.prototype[Symbol.for("nodejs.util.inspect.custom")] = st
        } catch {
            _e.prototype.inspect = st
        } else _e.prototype.inspect = st;

        function st() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            ft = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            yt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        _e.prototype.toString = function(it, at) {
            it = it || 10, at = at | 0 || 1;
            var mt;
            if (it === 16 || it === "hex") {
                mt = "";
                for (var xt = 0, $t = 0, Rt = 0; Rt < this.length; Rt++) {
                    var It = this.words[Rt],
                        Tt = ((It << xt | $t) & 16777215).toString(16);
                    $t = It >>> 24 - xt & 16777215, xt += 2, xt >= 26 && (xt -= 26, Rt--), $t !== 0 || Rt !== this.length - 1 ? mt = lt[6 - Tt.length] + Tt + mt : mt = Tt + mt
                }
                for ($t !== 0 && (mt = $t.toString(16) + mt); mt.length % at !== 0;) mt = "0" + mt;
                return this.negative !== 0 && (mt = "-" + mt), mt
            }
            if (it === (it | 0) && it >= 2 && it <= 36) {
                var dt = ft[it],
                    Et = yt[it];
                mt = "";
                var Ot = this.clone();
                for (Ot.negative = 0; !Ot.isZero();) {
                    var Mt = Ot.modrn(Et).toString(it);
                    Ot = Ot.idivn(Et), Ot.isZero() ? mt = Mt + mt : mt = lt[dt - Mt.length] + Mt + mt
                }
                for (this.isZero() && (mt = "0" + mt); mt.length % at !== 0;) mt = "0" + mt;
                return this.negative !== 0 && (mt = "-" + mt), mt
            }
            $(!1, "Base should be between 2 and 36")
        }, _e.prototype.toNumber = function() {
            var it = this.words[0];
            return this.length === 2 ? it += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? it += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -it : it
        }, _e.prototype.toJSON = function() {
            return this.toString(16, 2)
        }, et && (_e.prototype.toBuffer = function(it, at) {
            return this.toArrayLike(et, it, at)
        }), _e.prototype.toArray = function(it, at) {
            return this.toArrayLike(Array, it, at)
        };
        var bt = function(it, at) {
            return it.allocUnsafe ? it.allocUnsafe(at) : new it(at)
        };
        _e.prototype.toArrayLike = function(it, at, mt) {
            this._strip();
            var xt = this.byteLength(),
                $t = mt || Math.max(1, xt);
            $(xt <= $t, "byte array longer than desired length"), $($t > 0, "Requested array length <= 0");
            var Rt = bt(it, $t),
                It = at === "le" ? "LE" : "BE";
            return this["_toArrayLike" + It](Rt, xt), Rt
        }, _e.prototype._toArrayLikeLE = function(it, at) {
            for (var mt = 0, xt = 0, $t = 0, Rt = 0; $t < this.length; $t++) {
                var It = this.words[$t] << Rt | xt;
                it[mt++] = It & 255, mt < it.length && (it[mt++] = It >> 8 & 255), mt < it.length && (it[mt++] = It >> 16 & 255), Rt === 6 ? (mt < it.length && (it[mt++] = It >> 24 & 255), xt = 0, Rt = 0) : (xt = It >>> 24, Rt += 2)
            }
            if (mt < it.length)
                for (it[mt++] = xt; mt < it.length;) it[mt++] = 0
        }, _e.prototype._toArrayLikeBE = function(it, at) {
            for (var mt = it.length - 1, xt = 0, $t = 0, Rt = 0; $t < this.length; $t++) {
                var It = this.words[$t] << Rt | xt;
                it[mt--] = It & 255, mt >= 0 && (it[mt--] = It >> 8 & 255), mt >= 0 && (it[mt--] = It >> 16 & 255), Rt === 6 ? (mt >= 0 && (it[mt--] = It >> 24 & 255), xt = 0, Rt = 0) : (xt = It >>> 24, Rt += 2)
            }
            if (mt >= 0)
                for (it[mt--] = xt; mt >= 0;) it[mt--] = 0
        }, Math.clz32 ? _e.prototype._countBits = function(it) {
            return 32 - Math.clz32(it)
        } : _e.prototype._countBits = function(it) {
            var at = it,
                mt = 0;
            return at >= 4096 && (mt += 13, at >>>= 13), at >= 64 && (mt += 7, at >>>= 7), at >= 8 && (mt += 4, at >>>= 4), at >= 2 && (mt += 2, at >>>= 2), mt + at
        }, _e.prototype._zeroBits = function(it) {
            if (it === 0) return 26;
            var at = it,
                mt = 0;
            return at & 8191 || (mt += 13, at >>>= 13), at & 127 || (mt += 7, at >>>= 7), at & 15 || (mt += 4, at >>>= 4), at & 3 || (mt += 2, at >>>= 2), at & 1 || mt++, mt
        }, _e.prototype.bitLength = function() {
            var it = this.words[this.length - 1],
                at = this._countBits(it);
            return (this.length - 1) * 26 + at
        };

        function ht(Ct) {
            for (var it = new Array(Ct.bitLength()), at = 0; at < it.length; at++) {
                var mt = at / 26 | 0,
                    xt = at % 26;
                it[at] = Ct.words[mt] >>> xt & 1
            }
            return it
        }
        _e.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var it = 0, at = 0; at < this.length; at++) {
                var mt = this._zeroBits(this.words[at]);
                if (it += mt, mt !== 26) break
            }
            return it
        }, _e.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, _e.prototype.toTwos = function(it) {
            return this.negative !== 0 ? this.abs().inotn(it).iaddn(1) : this.clone()
        }, _e.prototype.fromTwos = function(it) {
            return this.testn(it - 1) ? this.notn(it).iaddn(1).ineg() : this.clone()
        }, _e.prototype.isNeg = function() {
            return this.negative !== 0
        }, _e.prototype.neg = function() {
            return this.clone().ineg()
        }, _e.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, _e.prototype.iuor = function(it) {
            for (; this.length < it.length;) this.words[this.length++] = 0;
            for (var at = 0; at < it.length; at++) this.words[at] = this.words[at] | it.words[at];
            return this._strip()
        }, _e.prototype.ior = function(it) {
            return $((this.negative | it.negative) === 0), this.iuor(it)
        }, _e.prototype.or = function(it) {
            return this.length > it.length ? this.clone().ior(it) : it.clone().ior(this)
        }, _e.prototype.uor = function(it) {
            return this.length > it.length ? this.clone().iuor(it) : it.clone().iuor(this)
        }, _e.prototype.iuand = function(it) {
            var at;
            this.length > it.length ? at = it : at = this;
            for (var mt = 0; mt < at.length; mt++) this.words[mt] = this.words[mt] & it.words[mt];
            return this.length = at.length, this._strip()
        }, _e.prototype.iand = function(it) {
            return $((this.negative | it.negative) === 0), this.iuand(it)
        }, _e.prototype.and = function(it) {
            return this.length > it.length ? this.clone().iand(it) : it.clone().iand(this)
        }, _e.prototype.uand = function(it) {
            return this.length > it.length ? this.clone().iuand(it) : it.clone().iuand(this)
        }, _e.prototype.iuxor = function(it) {
            var at, mt;
            this.length > it.length ? (at = this, mt = it) : (at = it, mt = this);
            for (var xt = 0; xt < mt.length; xt++) this.words[xt] = at.words[xt] ^ mt.words[xt];
            if (this !== at)
                for (; xt < at.length; xt++) this.words[xt] = at.words[xt];
            return this.length = at.length, this._strip()
        }, _e.prototype.ixor = function(it) {
            return $((this.negative | it.negative) === 0), this.iuxor(it)
        }, _e.prototype.xor = function(it) {
            return this.length > it.length ? this.clone().ixor(it) : it.clone().ixor(this)
        }, _e.prototype.uxor = function(it) {
            return this.length > it.length ? this.clone().iuxor(it) : it.clone().iuxor(this)
        }, _e.prototype.inotn = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = Math.ceil(it / 26) | 0,
                mt = it % 26;
            this._expand(at), mt > 0 && at--;
            for (var xt = 0; xt < at; xt++) this.words[xt] = ~this.words[xt] & 67108863;
            return mt > 0 && (this.words[xt] = ~this.words[xt] & 67108863 >> 26 - mt), this._strip()
        }, _e.prototype.notn = function(it) {
            return this.clone().inotn(it)
        }, _e.prototype.setn = function(it, at) {
            $(typeof it == "number" && it >= 0);
            var mt = it / 26 | 0,
                xt = it % 26;
            return this._expand(mt + 1), at ? this.words[mt] = this.words[mt] | 1 << xt : this.words[mt] = this.words[mt] & ~(1 << xt), this._strip()
        }, _e.prototype.iadd = function(it) {
            var at;
            if (this.negative !== 0 && it.negative === 0) return this.negative = 0, at = this.isub(it), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && it.negative !== 0) return it.negative = 0, at = this.isub(it), it.negative = 1, at._normSign();
            var mt, xt;
            this.length > it.length ? (mt = this, xt = it) : (mt = it, xt = this);
            for (var $t = 0, Rt = 0; Rt < xt.length; Rt++) at = (mt.words[Rt] | 0) + (xt.words[Rt] | 0) + $t, this.words[Rt] = at & 67108863, $t = at >>> 26;
            for (; $t !== 0 && Rt < mt.length; Rt++) at = (mt.words[Rt] | 0) + $t, this.words[Rt] = at & 67108863, $t = at >>> 26;
            if (this.length = mt.length, $t !== 0) this.words[this.length] = $t, this.length++;
            else if (mt !== this)
                for (; Rt < mt.length; Rt++) this.words[Rt] = mt.words[Rt];
            return this
        }, _e.prototype.add = function(it) {
            var at;
            return it.negative !== 0 && this.negative === 0 ? (it.negative = 0, at = this.sub(it), it.negative ^= 1, at) : it.negative === 0 && this.negative !== 0 ? (this.negative = 0, at = it.sub(this), this.negative = 1, at) : this.length > it.length ? this.clone().iadd(it) : it.clone().iadd(this)
        }, _e.prototype.isub = function(it) {
            if (it.negative !== 0) {
                it.negative = 0;
                var at = this.iadd(it);
                return it.negative = 1, at._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(it), this.negative = 1, this._normSign();
            var mt = this.cmp(it);
            if (mt === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var xt, $t;
            mt > 0 ? (xt = this, $t = it) : (xt = it, $t = this);
            for (var Rt = 0, It = 0; It < $t.length; It++) at = (xt.words[It] | 0) - ($t.words[It] | 0) + Rt, Rt = at >> 26, this.words[It] = at & 67108863;
            for (; Rt !== 0 && It < xt.length; It++) at = (xt.words[It] | 0) + Rt, Rt = at >> 26, this.words[It] = at & 67108863;
            if (Rt === 0 && It < xt.length && xt !== this)
                for (; It < xt.length; It++) this.words[It] = xt.words[It];
            return this.length = Math.max(this.length, It), xt !== this && (this.negative = 1), this._strip()
        }, _e.prototype.sub = function(it) {
            return this.clone().isub(it)
        };

        function vt(Ct, it, at) {
            at.negative = it.negative ^ Ct.negative;
            var mt = Ct.length + it.length | 0;
            at.length = mt, mt = mt - 1 | 0;
            var xt = Ct.words[0] | 0,
                $t = it.words[0] | 0,
                Rt = xt * $t,
                It = Rt & 67108863,
                Tt = Rt / 67108864 | 0;
            at.words[0] = It;
            for (var dt = 1; dt < mt; dt++) {
                for (var Et = Tt >>> 26, Ot = Tt & 67108863, Mt = Math.min(dt, it.length - 1), jt = Math.max(0, dt - Ct.length + 1); jt <= Mt; jt++) {
                    var Qt = dt - jt | 0;
                    xt = Ct.words[Qt] | 0, $t = it.words[jt] | 0, Rt = xt * $t + Ot, Et += Rt / 67108864 | 0, Ot = Rt & 67108863
                }
                at.words[dt] = Ot | 0, Tt = Et | 0
            }
            return Tt !== 0 ? at.words[dt] = Tt | 0 : at.length--, at._strip()
        }
        var wt = function(it, at, mt) {
            var xt = it.words,
                $t = at.words,
                Rt = mt.words,
                It = 0,
                Tt, dt, Et, Ot = xt[0] | 0,
                Mt = Ot & 8191,
                jt = Ot >>> 13,
                Qt = xt[1] | 0,
                Kt = Qt & 8191,
                qt = Qt >>> 13,
                Jt = xt[2] | 0,
                Zt = Jt & 8191,
                en = Jt >>> 13,
                ln = xt[3] | 0,
                cn = ln & 8191,
                un = ln >>> 13,
                Nn = xt[4] | 0,
                hn = Nn & 8191,
                fn = Nn >>> 13,
                rn = xt[5] | 0,
                mn = rn & 8191,
                dn = rn >>> 13,
                vn = xt[6] | 0,
                gn = vn & 8191,
                Gt = vn >>> 13,
                Yt = xt[7] | 0,
                nn = Yt & 8191,
                St = Yt >>> 13,
                ct = xt[8] | 0,
                pt = ct & 8191,
                kt = ct >>> 13,
                Dt = xt[9] | 0,
                zt = Dt & 8191,
                Ht = Dt >>> 13,
                an = $t[0] | 0,
                Xt = an & 8191,
                tn = an >>> 13,
                pn = $t[1] | 0,
                sn = pn & 8191,
                yn = pn >>> 13,
                Dn = $t[2] | 0,
                wn = Dn & 8191,
                _n = Dn >>> 13,
                Un = $t[3] | 0,
                $n = Un & 8191,
                An = Un >>> 13,
                Gn = $t[4] | 0,
                Pn = Gn & 8191,
                Bn = Gn >>> 13,
                zn = $t[5] | 0,
                Ln = zn & 8191,
                En = zn >>> 13,
                Wn = $t[6] | 0,
                xn = Wn & 8191,
                Sn = Wn >>> 13,
                Qn = $t[7] | 0,
                Tn = Qn & 8191,
                Rn = Qn >>> 13,
                Kn = $t[8] | 0,
                Cn = Kn & 8191,
                kn = Kn >>> 13,
                qn = $t[9] | 0,
                On = qn & 8191,
                Mn = qn >>> 13;
            mt.negative = it.negative ^ at.negative, mt.length = 19, Tt = Math.imul(Mt, Xt), dt = Math.imul(Mt, tn), dt = dt + Math.imul(jt, Xt) | 0, Et = Math.imul(jt, tn);
            var Hn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Hn >>> 26) | 0, Hn &= 67108863, Tt = Math.imul(Kt, Xt), dt = Math.imul(Kt, tn), dt = dt + Math.imul(qt, Xt) | 0, Et = Math.imul(qt, tn), Tt = Tt + Math.imul(Mt, sn) | 0, dt = dt + Math.imul(Mt, yn) | 0, dt = dt + Math.imul(jt, sn) | 0, Et = Et + Math.imul(jt, yn) | 0;
            var Vn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Vn >>> 26) | 0, Vn &= 67108863, Tt = Math.imul(Zt, Xt), dt = Math.imul(Zt, tn), dt = dt + Math.imul(en, Xt) | 0, Et = Math.imul(en, tn), Tt = Tt + Math.imul(Kt, sn) | 0, dt = dt + Math.imul(Kt, yn) | 0, dt = dt + Math.imul(qt, sn) | 0, Et = Et + Math.imul(qt, yn) | 0, Tt = Tt + Math.imul(Mt, wn) | 0, dt = dt + Math.imul(Mt, _n) | 0, dt = dt + Math.imul(jt, wn) | 0, Et = Et + Math.imul(jt, _n) | 0;
            var In = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, Tt = Math.imul(cn, Xt), dt = Math.imul(cn, tn), dt = dt + Math.imul(un, Xt) | 0, Et = Math.imul(un, tn), Tt = Tt + Math.imul(Zt, sn) | 0, dt = dt + Math.imul(Zt, yn) | 0, dt = dt + Math.imul(en, sn) | 0, Et = Et + Math.imul(en, yn) | 0, Tt = Tt + Math.imul(Kt, wn) | 0, dt = dt + Math.imul(Kt, _n) | 0, dt = dt + Math.imul(qt, wn) | 0, Et = Et + Math.imul(qt, _n) | 0, Tt = Tt + Math.imul(Mt, $n) | 0, dt = dt + Math.imul(Mt, An) | 0, dt = dt + Math.imul(jt, $n) | 0, Et = Et + Math.imul(jt, An) | 0;
            var Fn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Fn >>> 26) | 0, Fn &= 67108863, Tt = Math.imul(hn, Xt), dt = Math.imul(hn, tn), dt = dt + Math.imul(fn, Xt) | 0, Et = Math.imul(fn, tn), Tt = Tt + Math.imul(cn, sn) | 0, dt = dt + Math.imul(cn, yn) | 0, dt = dt + Math.imul(un, sn) | 0, Et = Et + Math.imul(un, yn) | 0, Tt = Tt + Math.imul(Zt, wn) | 0, dt = dt + Math.imul(Zt, _n) | 0, dt = dt + Math.imul(en, wn) | 0, Et = Et + Math.imul(en, _n) | 0, Tt = Tt + Math.imul(Kt, $n) | 0, dt = dt + Math.imul(Kt, An) | 0, dt = dt + Math.imul(qt, $n) | 0, Et = Et + Math.imul(qt, An) | 0, Tt = Tt + Math.imul(Mt, Pn) | 0, dt = dt + Math.imul(Mt, Bn) | 0, dt = dt + Math.imul(jt, Pn) | 0, Et = Et + Math.imul(jt, Bn) | 0;
            var Yn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Yn >>> 26) | 0, Yn &= 67108863, Tt = Math.imul(mn, Xt), dt = Math.imul(mn, tn), dt = dt + Math.imul(dn, Xt) | 0, Et = Math.imul(dn, tn), Tt = Tt + Math.imul(hn, sn) | 0, dt = dt + Math.imul(hn, yn) | 0, dt = dt + Math.imul(fn, sn) | 0, Et = Et + Math.imul(fn, yn) | 0, Tt = Tt + Math.imul(cn, wn) | 0, dt = dt + Math.imul(cn, _n) | 0, dt = dt + Math.imul(un, wn) | 0, Et = Et + Math.imul(un, _n) | 0, Tt = Tt + Math.imul(Zt, $n) | 0, dt = dt + Math.imul(Zt, An) | 0, dt = dt + Math.imul(en, $n) | 0, Et = Et + Math.imul(en, An) | 0, Tt = Tt + Math.imul(Kt, Pn) | 0, dt = dt + Math.imul(Kt, Bn) | 0, dt = dt + Math.imul(qt, Pn) | 0, Et = Et + Math.imul(qt, Bn) | 0, Tt = Tt + Math.imul(Mt, Ln) | 0, dt = dt + Math.imul(Mt, En) | 0, dt = dt + Math.imul(jt, Ln) | 0, Et = Et + Math.imul(jt, En) | 0;
            var Zn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Zn >>> 26) | 0, Zn &= 67108863, Tt = Math.imul(gn, Xt), dt = Math.imul(gn, tn), dt = dt + Math.imul(Gt, Xt) | 0, Et = Math.imul(Gt, tn), Tt = Tt + Math.imul(mn, sn) | 0, dt = dt + Math.imul(mn, yn) | 0, dt = dt + Math.imul(dn, sn) | 0, Et = Et + Math.imul(dn, yn) | 0, Tt = Tt + Math.imul(hn, wn) | 0, dt = dt + Math.imul(hn, _n) | 0, dt = dt + Math.imul(fn, wn) | 0, Et = Et + Math.imul(fn, _n) | 0, Tt = Tt + Math.imul(cn, $n) | 0, dt = dt + Math.imul(cn, An) | 0, dt = dt + Math.imul(un, $n) | 0, Et = Et + Math.imul(un, An) | 0, Tt = Tt + Math.imul(Zt, Pn) | 0, dt = dt + Math.imul(Zt, Bn) | 0, dt = dt + Math.imul(en, Pn) | 0, Et = Et + Math.imul(en, Bn) | 0, Tt = Tt + Math.imul(Kt, Ln) | 0, dt = dt + Math.imul(Kt, En) | 0, dt = dt + Math.imul(qt, Ln) | 0, Et = Et + Math.imul(qt, En) | 0, Tt = Tt + Math.imul(Mt, xn) | 0, dt = dt + Math.imul(Mt, Sn) | 0, dt = dt + Math.imul(jt, xn) | 0, Et = Et + Math.imul(jt, Sn) | 0;
            var Xn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Xn >>> 26) | 0, Xn &= 67108863, Tt = Math.imul(nn, Xt), dt = Math.imul(nn, tn), dt = dt + Math.imul(St, Xt) | 0, Et = Math.imul(St, tn), Tt = Tt + Math.imul(gn, sn) | 0, dt = dt + Math.imul(gn, yn) | 0, dt = dt + Math.imul(Gt, sn) | 0, Et = Et + Math.imul(Gt, yn) | 0, Tt = Tt + Math.imul(mn, wn) | 0, dt = dt + Math.imul(mn, _n) | 0, dt = dt + Math.imul(dn, wn) | 0, Et = Et + Math.imul(dn, _n) | 0, Tt = Tt + Math.imul(hn, $n) | 0, dt = dt + Math.imul(hn, An) | 0, dt = dt + Math.imul(fn, $n) | 0, Et = Et + Math.imul(fn, An) | 0, Tt = Tt + Math.imul(cn, Pn) | 0, dt = dt + Math.imul(cn, Bn) | 0, dt = dt + Math.imul(un, Pn) | 0, Et = Et + Math.imul(un, Bn) | 0, Tt = Tt + Math.imul(Zt, Ln) | 0, dt = dt + Math.imul(Zt, En) | 0, dt = dt + Math.imul(en, Ln) | 0, Et = Et + Math.imul(en, En) | 0, Tt = Tt + Math.imul(Kt, xn) | 0, dt = dt + Math.imul(Kt, Sn) | 0, dt = dt + Math.imul(qt, xn) | 0, Et = Et + Math.imul(qt, Sn) | 0, Tt = Tt + Math.imul(Mt, Tn) | 0, dt = dt + Math.imul(Mt, Rn) | 0, dt = dt + Math.imul(jt, Tn) | 0, Et = Et + Math.imul(jt, Rn) | 0;
            var Jn = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (Jn >>> 26) | 0, Jn &= 67108863, Tt = Math.imul(pt, Xt), dt = Math.imul(pt, tn), dt = dt + Math.imul(kt, Xt) | 0, Et = Math.imul(kt, tn), Tt = Tt + Math.imul(nn, sn) | 0, dt = dt + Math.imul(nn, yn) | 0, dt = dt + Math.imul(St, sn) | 0, Et = Et + Math.imul(St, yn) | 0, Tt = Tt + Math.imul(gn, wn) | 0, dt = dt + Math.imul(gn, _n) | 0, dt = dt + Math.imul(Gt, wn) | 0, Et = Et + Math.imul(Gt, _n) | 0, Tt = Tt + Math.imul(mn, $n) | 0, dt = dt + Math.imul(mn, An) | 0, dt = dt + Math.imul(dn, $n) | 0, Et = Et + Math.imul(dn, An) | 0, Tt = Tt + Math.imul(hn, Pn) | 0, dt = dt + Math.imul(hn, Bn) | 0, dt = dt + Math.imul(fn, Pn) | 0, Et = Et + Math.imul(fn, Bn) | 0, Tt = Tt + Math.imul(cn, Ln) | 0, dt = dt + Math.imul(cn, En) | 0, dt = dt + Math.imul(un, Ln) | 0, Et = Et + Math.imul(un, En) | 0, Tt = Tt + Math.imul(Zt, xn) | 0, dt = dt + Math.imul(Zt, Sn) | 0, dt = dt + Math.imul(en, xn) | 0, Et = Et + Math.imul(en, Sn) | 0, Tt = Tt + Math.imul(Kt, Tn) | 0, dt = dt + Math.imul(Kt, Rn) | 0, dt = dt + Math.imul(qt, Tn) | 0, Et = Et + Math.imul(qt, Rn) | 0, Tt = Tt + Math.imul(Mt, Cn) | 0, dt = dt + Math.imul(Mt, kn) | 0, dt = dt + Math.imul(jt, Cn) | 0, Et = Et + Math.imul(jt, kn) | 0;
            var er = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, Tt = Math.imul(zt, Xt), dt = Math.imul(zt, tn), dt = dt + Math.imul(Ht, Xt) | 0, Et = Math.imul(Ht, tn), Tt = Tt + Math.imul(pt, sn) | 0, dt = dt + Math.imul(pt, yn) | 0, dt = dt + Math.imul(kt, sn) | 0, Et = Et + Math.imul(kt, yn) | 0, Tt = Tt + Math.imul(nn, wn) | 0, dt = dt + Math.imul(nn, _n) | 0, dt = dt + Math.imul(St, wn) | 0, Et = Et + Math.imul(St, _n) | 0, Tt = Tt + Math.imul(gn, $n) | 0, dt = dt + Math.imul(gn, An) | 0, dt = dt + Math.imul(Gt, $n) | 0, Et = Et + Math.imul(Gt, An) | 0, Tt = Tt + Math.imul(mn, Pn) | 0, dt = dt + Math.imul(mn, Bn) | 0, dt = dt + Math.imul(dn, Pn) | 0, Et = Et + Math.imul(dn, Bn) | 0, Tt = Tt + Math.imul(hn, Ln) | 0, dt = dt + Math.imul(hn, En) | 0, dt = dt + Math.imul(fn, Ln) | 0, Et = Et + Math.imul(fn, En) | 0, Tt = Tt + Math.imul(cn, xn) | 0, dt = dt + Math.imul(cn, Sn) | 0, dt = dt + Math.imul(un, xn) | 0, Et = Et + Math.imul(un, Sn) | 0, Tt = Tt + Math.imul(Zt, Tn) | 0, dt = dt + Math.imul(Zt, Rn) | 0, dt = dt + Math.imul(en, Tn) | 0, Et = Et + Math.imul(en, Rn) | 0, Tt = Tt + Math.imul(Kt, Cn) | 0, dt = dt + Math.imul(Kt, kn) | 0, dt = dt + Math.imul(qt, Cn) | 0, Et = Et + Math.imul(qt, kn) | 0, Tt = Tt + Math.imul(Mt, On) | 0, dt = dt + Math.imul(Mt, Mn) | 0, dt = dt + Math.imul(jt, On) | 0, Et = Et + Math.imul(jt, Mn) | 0;
            var tr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, Tt = Math.imul(zt, sn), dt = Math.imul(zt, yn), dt = dt + Math.imul(Ht, sn) | 0, Et = Math.imul(Ht, yn), Tt = Tt + Math.imul(pt, wn) | 0, dt = dt + Math.imul(pt, _n) | 0, dt = dt + Math.imul(kt, wn) | 0, Et = Et + Math.imul(kt, _n) | 0, Tt = Tt + Math.imul(nn, $n) | 0, dt = dt + Math.imul(nn, An) | 0, dt = dt + Math.imul(St, $n) | 0, Et = Et + Math.imul(St, An) | 0, Tt = Tt + Math.imul(gn, Pn) | 0, dt = dt + Math.imul(gn, Bn) | 0, dt = dt + Math.imul(Gt, Pn) | 0, Et = Et + Math.imul(Gt, Bn) | 0, Tt = Tt + Math.imul(mn, Ln) | 0, dt = dt + Math.imul(mn, En) | 0, dt = dt + Math.imul(dn, Ln) | 0, Et = Et + Math.imul(dn, En) | 0, Tt = Tt + Math.imul(hn, xn) | 0, dt = dt + Math.imul(hn, Sn) | 0, dt = dt + Math.imul(fn, xn) | 0, Et = Et + Math.imul(fn, Sn) | 0, Tt = Tt + Math.imul(cn, Tn) | 0, dt = dt + Math.imul(cn, Rn) | 0, dt = dt + Math.imul(un, Tn) | 0, Et = Et + Math.imul(un, Rn) | 0, Tt = Tt + Math.imul(Zt, Cn) | 0, dt = dt + Math.imul(Zt, kn) | 0, dt = dt + Math.imul(en, Cn) | 0, Et = Et + Math.imul(en, kn) | 0, Tt = Tt + Math.imul(Kt, On) | 0, dt = dt + Math.imul(Kt, Mn) | 0, dt = dt + Math.imul(qt, On) | 0, Et = Et + Math.imul(qt, Mn) | 0;
            var nr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, Tt = Math.imul(zt, wn), dt = Math.imul(zt, _n), dt = dt + Math.imul(Ht, wn) | 0, Et = Math.imul(Ht, _n), Tt = Tt + Math.imul(pt, $n) | 0, dt = dt + Math.imul(pt, An) | 0, dt = dt + Math.imul(kt, $n) | 0, Et = Et + Math.imul(kt, An) | 0, Tt = Tt + Math.imul(nn, Pn) | 0, dt = dt + Math.imul(nn, Bn) | 0, dt = dt + Math.imul(St, Pn) | 0, Et = Et + Math.imul(St, Bn) | 0, Tt = Tt + Math.imul(gn, Ln) | 0, dt = dt + Math.imul(gn, En) | 0, dt = dt + Math.imul(Gt, Ln) | 0, Et = Et + Math.imul(Gt, En) | 0, Tt = Tt + Math.imul(mn, xn) | 0, dt = dt + Math.imul(mn, Sn) | 0, dt = dt + Math.imul(dn, xn) | 0, Et = Et + Math.imul(dn, Sn) | 0, Tt = Tt + Math.imul(hn, Tn) | 0, dt = dt + Math.imul(hn, Rn) | 0, dt = dt + Math.imul(fn, Tn) | 0, Et = Et + Math.imul(fn, Rn) | 0, Tt = Tt + Math.imul(cn, Cn) | 0, dt = dt + Math.imul(cn, kn) | 0, dt = dt + Math.imul(un, Cn) | 0, Et = Et + Math.imul(un, kn) | 0, Tt = Tt + Math.imul(Zt, On) | 0, dt = dt + Math.imul(Zt, Mn) | 0, dt = dt + Math.imul(en, On) | 0, Et = Et + Math.imul(en, Mn) | 0;
            var rr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, Tt = Math.imul(zt, $n), dt = Math.imul(zt, An), dt = dt + Math.imul(Ht, $n) | 0, Et = Math.imul(Ht, An), Tt = Tt + Math.imul(pt, Pn) | 0, dt = dt + Math.imul(pt, Bn) | 0, dt = dt + Math.imul(kt, Pn) | 0, Et = Et + Math.imul(kt, Bn) | 0, Tt = Tt + Math.imul(nn, Ln) | 0, dt = dt + Math.imul(nn, En) | 0, dt = dt + Math.imul(St, Ln) | 0, Et = Et + Math.imul(St, En) | 0, Tt = Tt + Math.imul(gn, xn) | 0, dt = dt + Math.imul(gn, Sn) | 0, dt = dt + Math.imul(Gt, xn) | 0, Et = Et + Math.imul(Gt, Sn) | 0, Tt = Tt + Math.imul(mn, Tn) | 0, dt = dt + Math.imul(mn, Rn) | 0, dt = dt + Math.imul(dn, Tn) | 0, Et = Et + Math.imul(dn, Rn) | 0, Tt = Tt + Math.imul(hn, Cn) | 0, dt = dt + Math.imul(hn, kn) | 0, dt = dt + Math.imul(fn, Cn) | 0, Et = Et + Math.imul(fn, kn) | 0, Tt = Tt + Math.imul(cn, On) | 0, dt = dt + Math.imul(cn, Mn) | 0, dt = dt + Math.imul(un, On) | 0, Et = Et + Math.imul(un, Mn) | 0;
            var or = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, Tt = Math.imul(zt, Pn), dt = Math.imul(zt, Bn), dt = dt + Math.imul(Ht, Pn) | 0, Et = Math.imul(Ht, Bn), Tt = Tt + Math.imul(pt, Ln) | 0, dt = dt + Math.imul(pt, En) | 0, dt = dt + Math.imul(kt, Ln) | 0, Et = Et + Math.imul(kt, En) | 0, Tt = Tt + Math.imul(nn, xn) | 0, dt = dt + Math.imul(nn, Sn) | 0, dt = dt + Math.imul(St, xn) | 0, Et = Et + Math.imul(St, Sn) | 0, Tt = Tt + Math.imul(gn, Tn) | 0, dt = dt + Math.imul(gn, Rn) | 0, dt = dt + Math.imul(Gt, Tn) | 0, Et = Et + Math.imul(Gt, Rn) | 0, Tt = Tt + Math.imul(mn, Cn) | 0, dt = dt + Math.imul(mn, kn) | 0, dt = dt + Math.imul(dn, Cn) | 0, Et = Et + Math.imul(dn, kn) | 0, Tt = Tt + Math.imul(hn, On) | 0, dt = dt + Math.imul(hn, Mn) | 0, dt = dt + Math.imul(fn, On) | 0, Et = Et + Math.imul(fn, Mn) | 0;
            var ir = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, Tt = Math.imul(zt, Ln), dt = Math.imul(zt, En), dt = dt + Math.imul(Ht, Ln) | 0, Et = Math.imul(Ht, En), Tt = Tt + Math.imul(pt, xn) | 0, dt = dt + Math.imul(pt, Sn) | 0, dt = dt + Math.imul(kt, xn) | 0, Et = Et + Math.imul(kt, Sn) | 0, Tt = Tt + Math.imul(nn, Tn) | 0, dt = dt + Math.imul(nn, Rn) | 0, dt = dt + Math.imul(St, Tn) | 0, Et = Et + Math.imul(St, Rn) | 0, Tt = Tt + Math.imul(gn, Cn) | 0, dt = dt + Math.imul(gn, kn) | 0, dt = dt + Math.imul(Gt, Cn) | 0, Et = Et + Math.imul(Gt, kn) | 0, Tt = Tt + Math.imul(mn, On) | 0, dt = dt + Math.imul(mn, Mn) | 0, dt = dt + Math.imul(dn, On) | 0, Et = Et + Math.imul(dn, Mn) | 0;
            var sr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, Tt = Math.imul(zt, xn), dt = Math.imul(zt, Sn), dt = dt + Math.imul(Ht, xn) | 0, Et = Math.imul(Ht, Sn), Tt = Tt + Math.imul(pt, Tn) | 0, dt = dt + Math.imul(pt, Rn) | 0, dt = dt + Math.imul(kt, Tn) | 0, Et = Et + Math.imul(kt, Rn) | 0, Tt = Tt + Math.imul(nn, Cn) | 0, dt = dt + Math.imul(nn, kn) | 0, dt = dt + Math.imul(St, Cn) | 0, Et = Et + Math.imul(St, kn) | 0, Tt = Tt + Math.imul(gn, On) | 0, dt = dt + Math.imul(gn, Mn) | 0, dt = dt + Math.imul(Gt, On) | 0, Et = Et + Math.imul(Gt, Mn) | 0;
            var ar = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, Tt = Math.imul(zt, Tn), dt = Math.imul(zt, Rn), dt = dt + Math.imul(Ht, Tn) | 0, Et = Math.imul(Ht, Rn), Tt = Tt + Math.imul(pt, Cn) | 0, dt = dt + Math.imul(pt, kn) | 0, dt = dt + Math.imul(kt, Cn) | 0, Et = Et + Math.imul(kt, kn) | 0, Tt = Tt + Math.imul(nn, On) | 0, dt = dt + Math.imul(nn, Mn) | 0, dt = dt + Math.imul(St, On) | 0, Et = Et + Math.imul(St, Mn) | 0;
            var lr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, Tt = Math.imul(zt, Cn), dt = Math.imul(zt, kn), dt = dt + Math.imul(Ht, Cn) | 0, Et = Math.imul(Ht, kn), Tt = Tt + Math.imul(pt, On) | 0, dt = dt + Math.imul(pt, Mn) | 0, dt = dt + Math.imul(kt, On) | 0, Et = Et + Math.imul(kt, Mn) | 0;
            var cr = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            It = (Et + (dt >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, Tt = Math.imul(zt, On), dt = Math.imul(zt, Mn), dt = dt + Math.imul(Ht, On) | 0, Et = Math.imul(Ht, Mn);
            var ur = (It + Tt | 0) + ((dt & 8191) << 13) | 0;
            return It = (Et + (dt >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, Rt[0] = Hn, Rt[1] = Vn, Rt[2] = In, Rt[3] = Fn, Rt[4] = Yn, Rt[5] = Zn, Rt[6] = Xn, Rt[7] = Jn, Rt[8] = er, Rt[9] = tr, Rt[10] = nr, Rt[11] = rr, Rt[12] = or, Rt[13] = ir, Rt[14] = sr, Rt[15] = ar, Rt[16] = lr, Rt[17] = cr, Rt[18] = ur, It !== 0 && (Rt[19] = It, mt.length++), mt
        };
        Math.imul || (wt = vt);

        function gt(Ct, it, at) {
            at.negative = it.negative ^ Ct.negative, at.length = Ct.length + it.length;
            for (var mt = 0, xt = 0, $t = 0; $t < at.length - 1; $t++) {
                var Rt = xt;
                xt = 0;
                for (var It = mt & 67108863, Tt = Math.min($t, it.length - 1), dt = Math.max(0, $t - Ct.length + 1); dt <= Tt; dt++) {
                    var Et = $t - dt,
                        Ot = Ct.words[Et] | 0,
                        Mt = it.words[dt] | 0,
                        jt = Ot * Mt,
                        Qt = jt & 67108863;
                    Rt = Rt + (jt / 67108864 | 0) | 0, Qt = Qt + It | 0, It = Qt & 67108863, Rt = Rt + (Qt >>> 26) | 0, xt += Rt >>> 26, Rt &= 67108863
                }
                at.words[$t] = It, mt = Rt, Rt = xt
            }
            return mt !== 0 ? at.words[$t] = mt : at.length--, at._strip()
        }

        function At(Ct, it, at) {
            return gt(Ct, it, at)
        }
        _e.prototype.mulTo = function(it, at) {
            var mt, xt = this.length + it.length;
            return this.length === 10 && it.length === 10 ? mt = wt(this, it, at) : xt < 63 ? mt = vt(this, it, at) : xt < 1024 ? mt = gt(this, it, at) : mt = At(this, it, at), mt
        }, _e.prototype.mul = function(it) {
            var at = new _e(null);
            return at.words = new Array(this.length + it.length), this.mulTo(it, at)
        }, _e.prototype.mulf = function(it) {
            var at = new _e(null);
            return at.words = new Array(this.length + it.length), At(this, it, at)
        }, _e.prototype.imul = function(it) {
            return this.clone().mulTo(it, this)
        }, _e.prototype.imuln = function(it) {
            var at = it < 0;
            at && (it = -it), $(typeof it == "number"), $(it < 67108864);
            for (var mt = 0, xt = 0; xt < this.length; xt++) {
                var $t = (this.words[xt] | 0) * it,
                    Rt = ($t & 67108863) + (mt & 67108863);
                mt >>= 26, mt += $t / 67108864 | 0, mt += Rt >>> 26, this.words[xt] = Rt & 67108863
            }
            return mt !== 0 && (this.words[xt] = mt, this.length++), at ? this.ineg() : this
        }, _e.prototype.muln = function(it) {
            return this.clone().imuln(it)
        }, _e.prototype.sqr = function() {
            return this.mul(this)
        }, _e.prototype.isqr = function() {
            return this.imul(this.clone())
        }, _e.prototype.pow = function(it) {
            var at = ht(it);
            if (at.length === 0) return new _e(1);
            for (var mt = this, xt = 0; xt < at.length && at[xt] === 0; xt++, mt = mt.sqr());
            if (++xt < at.length)
                for (var $t = mt.sqr(); xt < at.length; xt++, $t = $t.sqr()) at[xt] !== 0 && (mt = mt.mul($t));
            return mt
        }, _e.prototype.iushln = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = it % 26,
                mt = (it - at) / 26,
                xt = 67108863 >>> 26 - at << 26 - at,
                $t;
            if (at !== 0) {
                var Rt = 0;
                for ($t = 0; $t < this.length; $t++) {
                    var It = this.words[$t] & xt,
                        Tt = (this.words[$t] | 0) - It << at;
                    this.words[$t] = Tt | Rt, Rt = It >>> 26 - at
                }
                Rt && (this.words[$t] = Rt, this.length++)
            }
            if (mt !== 0) {
                for ($t = this.length - 1; $t >= 0; $t--) this.words[$t + mt] = this.words[$t];
                for ($t = 0; $t < mt; $t++) this.words[$t] = 0;
                this.length += mt
            }
            return this._strip()
        }, _e.prototype.ishln = function(it) {
            return $(this.negative === 0), this.iushln(it)
        }, _e.prototype.iushrn = function(it, at, mt) {
            $(typeof it == "number" && it >= 0);
            var xt;
            at ? xt = (at - at % 26) / 26 : xt = 0;
            var $t = it % 26,
                Rt = Math.min((it - $t) / 26, this.length),
                It = 67108863 ^ 67108863 >>> $t << $t,
                Tt = mt;
            if (xt -= Rt, xt = Math.max(0, xt), Tt) {
                for (var dt = 0; dt < Rt; dt++) Tt.words[dt] = this.words[dt];
                Tt.length = Rt
            }
            if (Rt !== 0)
                if (this.length > Rt)
                    for (this.length -= Rt, dt = 0; dt < this.length; dt++) this.words[dt] = this.words[dt + Rt];
                else this.words[0] = 0, this.length = 1;
            var Et = 0;
            for (dt = this.length - 1; dt >= 0 && (Et !== 0 || dt >= xt); dt--) {
                var Ot = this.words[dt] | 0;
                this.words[dt] = Et << 26 - $t | Ot >>> $t, Et = Ot & It
            }
            return Tt && Et !== 0 && (Tt.words[Tt.length++] = Et), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
        }, _e.prototype.ishrn = function(it, at, mt) {
            return $(this.negative === 0), this.iushrn(it, at, mt)
        }, _e.prototype.shln = function(it) {
            return this.clone().ishln(it)
        }, _e.prototype.ushln = function(it) {
            return this.clone().iushln(it)
        }, _e.prototype.shrn = function(it) {
            return this.clone().ishrn(it)
        }, _e.prototype.ushrn = function(it) {
            return this.clone().iushrn(it)
        }, _e.prototype.testn = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = it % 26,
                mt = (it - at) / 26,
                xt = 1 << at;
            if (this.length <= mt) return !1;
            var $t = this.words[mt];
            return !!($t & xt)
        }, _e.prototype.imaskn = function(it) {
            $(typeof it == "number" && it >= 0);
            var at = it % 26,
                mt = (it - at) / 26;
            if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= mt) return this;
            if (at !== 0 && mt++, this.length = Math.min(mt, this.length), at !== 0) {
                var xt = 67108863 ^ 67108863 >>> at << at;
                this.words[this.length - 1] &= xt
            }
            return this._strip()
        }, _e.prototype.maskn = function(it) {
            return this.clone().imaskn(it)
        }, _e.prototype.iaddn = function(it) {
            return $(typeof it == "number"), $(it < 67108864), it < 0 ? this.isubn(-it) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= it ? (this.words[0] = it - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(it), this.negative = 1, this) : this._iaddn(it)
        }, _e.prototype._iaddn = function(it) {
            this.words[0] += it;
            for (var at = 0; at < this.length && this.words[at] >= 67108864; at++) this.words[at] -= 67108864, at === this.length - 1 ? this.words[at + 1] = 1 : this.words[at + 1]++;
            return this.length = Math.max(this.length, at + 1), this
        }, _e.prototype.isubn = function(it) {
            if ($(typeof it == "number"), $(it < 67108864), it < 0) return this.iaddn(-it);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(it), this.negative = 1, this;
            if (this.words[0] -= it, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var at = 0; at < this.length && this.words[at] < 0; at++) this.words[at] += 67108864, this.words[at + 1] -= 1;
            return this._strip()
        }, _e.prototype.addn = function(it) {
            return this.clone().iaddn(it)
        }, _e.prototype.subn = function(it) {
            return this.clone().isubn(it)
        }, _e.prototype.iabs = function() {
            return this.negative = 0, this
        }, _e.prototype.abs = function() {
            return this.clone().iabs()
        }, _e.prototype._ishlnsubmul = function(it, at, mt) {
            var xt = it.length + mt,
                $t;
            this._expand(xt);
            var Rt, It = 0;
            for ($t = 0; $t < it.length; $t++) {
                Rt = (this.words[$t + mt] | 0) + It;
                var Tt = (it.words[$t] | 0) * at;
                Rt -= Tt & 67108863, It = (Rt >> 26) - (Tt / 67108864 | 0), this.words[$t + mt] = Rt & 67108863
            }
            for (; $t < this.length - mt; $t++) Rt = (this.words[$t + mt] | 0) + It, It = Rt >> 26, this.words[$t + mt] = Rt & 67108863;
            if (It === 0) return this._strip();
            for ($(It === -1), It = 0, $t = 0; $t < this.length; $t++) Rt = -(this.words[$t] | 0) + It, It = Rt >> 26, this.words[$t] = Rt & 67108863;
            return this.negative = 1, this._strip()
        }, _e.prototype._wordDiv = function(it, at) {
            var mt = this.length - it.length,
                xt = this.clone(),
                $t = it,
                Rt = $t.words[$t.length - 1] | 0,
                It = this._countBits(Rt);
            mt = 26 - It, mt !== 0 && ($t = $t.ushln(mt), xt.iushln(mt), Rt = $t.words[$t.length - 1] | 0);
            var Tt = xt.length - $t.length,
                dt;
            if (at !== "mod") {
                dt = new _e(null), dt.length = Tt + 1, dt.words = new Array(dt.length);
                for (var Et = 0; Et < dt.length; Et++) dt.words[Et] = 0
            }
            var Ot = xt.clone()._ishlnsubmul($t, 1, Tt);
            Ot.negative === 0 && (xt = Ot, dt && (dt.words[Tt] = 1));
            for (var Mt = Tt - 1; Mt >= 0; Mt--) {
                var jt = (xt.words[$t.length + Mt] | 0) * 67108864 + (xt.words[$t.length + Mt - 1] | 0);
                for (jt = Math.min(jt / Rt | 0, 67108863), xt._ishlnsubmul($t, jt, Mt); xt.negative !== 0;) jt--, xt.negative = 0, xt._ishlnsubmul($t, 1, Mt), xt.isZero() || (xt.negative ^= 1);
                dt && (dt.words[Mt] = jt)
            }
            return dt && dt._strip(), xt._strip(), at !== "div" && mt !== 0 && xt.iushrn(mt), {
                div: dt || null,
                mod: xt
            }
        }, _e.prototype.divmod = function(it, at, mt) {
            if ($(!it.isZero()), this.isZero()) return {
                div: new _e(0),
                mod: new _e(0)
            };
            var xt, $t, Rt;
            return this.negative !== 0 && it.negative === 0 ? (Rt = this.neg().divmod(it, at), at !== "mod" && (xt = Rt.div.neg()), at !== "div" && ($t = Rt.mod.neg(), mt && $t.negative !== 0 && $t.iadd(it)), {
                div: xt,
                mod: $t
            }) : this.negative === 0 && it.negative !== 0 ? (Rt = this.divmod(it.neg(), at), at !== "mod" && (xt = Rt.div.neg()), {
                div: xt,
                mod: Rt.mod
            }) : this.negative & it.negative ? (Rt = this.neg().divmod(it.neg(), at), at !== "div" && ($t = Rt.mod.neg(), mt && $t.negative !== 0 && $t.isub(it)), {
                div: Rt.div,
                mod: $t
            }) : it.length > this.length || this.cmp(it) < 0 ? {
                div: new _e(0),
                mod: this
            } : it.length === 1 ? at === "div" ? {
                div: this.divn(it.words[0]),
                mod: null
            } : at === "mod" ? {
                div: null,
                mod: new _e(this.modrn(it.words[0]))
            } : {
                div: this.divn(it.words[0]),
                mod: new _e(this.modrn(it.words[0]))
            } : this._wordDiv(it, at)
        }, _e.prototype.div = function(it) {
            return this.divmod(it, "div", !1).div
        }, _e.prototype.mod = function(it) {
            return this.divmod(it, "mod", !1).mod
        }, _e.prototype.umod = function(it) {
            return this.divmod(it, "mod", !0).mod
        }, _e.prototype.divRound = function(it) {
            var at = this.divmod(it);
            if (at.mod.isZero()) return at.div;
            var mt = at.div.negative !== 0 ? at.mod.isub(it) : at.mod,
                xt = it.ushrn(1),
                $t = it.andln(1),
                Rt = mt.cmp(xt);
            return Rt < 0 || $t === 1 && Rt === 0 ? at.div : at.div.negative !== 0 ? at.div.isubn(1) : at.div.iaddn(1)
        }, _e.prototype.modrn = function(it) {
            var at = it < 0;
            at && (it = -it), $(it <= 67108863);
            for (var mt = (1 << 26) % it, xt = 0, $t = this.length - 1; $t >= 0; $t--) xt = (mt * xt + (this.words[$t] | 0)) % it;
            return at ? -xt : xt
        }, _e.prototype.modn = function(it) {
            return this.modrn(it)
        }, _e.prototype.idivn = function(it) {
            var at = it < 0;
            at && (it = -it), $(it <= 67108863);
            for (var mt = 0, xt = this.length - 1; xt >= 0; xt--) {
                var $t = (this.words[xt] | 0) + mt * 67108864;
                this.words[xt] = $t / it | 0, mt = $t % it
            }
            return this._strip(), at ? this.ineg() : this
        }, _e.prototype.divn = function(it) {
            return this.clone().idivn(it)
        }, _e.prototype.egcd = function(it) {
            $(it.negative === 0), $(!it.isZero());
            var at = this,
                mt = it.clone();
            at.negative !== 0 ? at = at.umod(it) : at = at.clone();
            for (var xt = new _e(1), $t = new _e(0), Rt = new _e(0), It = new _e(1), Tt = 0; at.isEven() && mt.isEven();) at.iushrn(1), mt.iushrn(1), ++Tt;
            for (var dt = mt.clone(), Et = at.clone(); !at.isZero();) {
                for (var Ot = 0, Mt = 1; !(at.words[0] & Mt) && Ot < 26; ++Ot, Mt <<= 1);
                if (Ot > 0)
                    for (at.iushrn(Ot); Ot-- > 0;)(xt.isOdd() || $t.isOdd()) && (xt.iadd(dt), $t.isub(Et)), xt.iushrn(1), $t.iushrn(1);
                for (var jt = 0, Qt = 1; !(mt.words[0] & Qt) && jt < 26; ++jt, Qt <<= 1);
                if (jt > 0)
                    for (mt.iushrn(jt); jt-- > 0;)(Rt.isOdd() || It.isOdd()) && (Rt.iadd(dt), It.isub(Et)), Rt.iushrn(1), It.iushrn(1);
                at.cmp(mt) >= 0 ? (at.isub(mt), xt.isub(Rt), $t.isub(It)) : (mt.isub(at), Rt.isub(xt), It.isub($t))
            }
            return {
                a: Rt,
                b: It,
                gcd: mt.iushln(Tt)
            }
        }, _e.prototype._invmp = function(it) {
            $(it.negative === 0), $(!it.isZero());
            var at = this,
                mt = it.clone();
            at.negative !== 0 ? at = at.umod(it) : at = at.clone();
            for (var xt = new _e(1), $t = new _e(0), Rt = mt.clone(); at.cmpn(1) > 0 && mt.cmpn(1) > 0;) {
                for (var It = 0, Tt = 1; !(at.words[0] & Tt) && It < 26; ++It, Tt <<= 1);
                if (It > 0)
                    for (at.iushrn(It); It-- > 0;) xt.isOdd() && xt.iadd(Rt), xt.iushrn(1);
                for (var dt = 0, Et = 1; !(mt.words[0] & Et) && dt < 26; ++dt, Et <<= 1);
                if (dt > 0)
                    for (mt.iushrn(dt); dt-- > 0;) $t.isOdd() && $t.iadd(Rt), $t.iushrn(1);
                at.cmp(mt) >= 0 ? (at.isub(mt), xt.isub($t)) : (mt.isub(at), $t.isub(xt))
            }
            var Ot;
            return at.cmpn(1) === 0 ? Ot = xt : Ot = $t, Ot.cmpn(0) < 0 && Ot.iadd(it), Ot
        }, _e.prototype.gcd = function(it) {
            if (this.isZero()) return it.abs();
            if (it.isZero()) return this.abs();
            var at = this.clone(),
                mt = it.clone();
            at.negative = 0, mt.negative = 0;
            for (var xt = 0; at.isEven() && mt.isEven(); xt++) at.iushrn(1), mt.iushrn(1);
            do {
                for (; at.isEven();) at.iushrn(1);
                for (; mt.isEven();) mt.iushrn(1);
                var $t = at.cmp(mt);
                if ($t < 0) {
                    var Rt = at;
                    at = mt, mt = Rt
                } else if ($t === 0 || mt.cmpn(1) === 0) break;
                at.isub(mt)
            } while (!0);
            return mt.iushln(xt)
        }, _e.prototype.invm = function(it) {
            return this.egcd(it).a.umod(it)
        }, _e.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }, _e.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }, _e.prototype.andln = function(it) {
            return this.words[0] & it
        }, _e.prototype.bincn = function(it) {
            $(typeof it == "number");
            var at = it % 26,
                mt = (it - at) / 26,
                xt = 1 << at;
            if (this.length <= mt) return this._expand(mt + 1), this.words[mt] |= xt, this;
            for (var $t = xt, Rt = mt; $t !== 0 && Rt < this.length; Rt++) {
                var It = this.words[Rt] | 0;
                It += $t, $t = It >>> 26, It &= 67108863, this.words[Rt] = It
            }
            return $t !== 0 && (this.words[Rt] = $t, this.length++), this
        }, _e.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, _e.prototype.cmpn = function(it) {
            var at = it < 0;
            if (this.negative !== 0 && !at) return -1;
            if (this.negative === 0 && at) return 1;
            this._strip();
            var mt;
            if (this.length > 1) mt = 1;
            else {
                at && (it = -it), $(it <= 67108863, "Number is too big");
                var xt = this.words[0] | 0;
                mt = xt === it ? 0 : xt < it ? -1 : 1
            }
            return this.negative !== 0 ? -mt | 0 : mt
        }, _e.prototype.cmp = function(it) {
            if (this.negative !== 0 && it.negative === 0) return -1;
            if (this.negative === 0 && it.negative !== 0) return 1;
            var at = this.ucmp(it);
            return this.negative !== 0 ? -at | 0 : at
        }, _e.prototype.ucmp = function(it) {
            if (this.length > it.length) return 1;
            if (this.length < it.length) return -1;
            for (var at = 0, mt = this.length - 1; mt >= 0; mt--) {
                var xt = this.words[mt] | 0,
                    $t = it.words[mt] | 0;
                if (xt !== $t) {
                    xt < $t ? at = -1 : xt > $t && (at = 1);
                    break
                }
            }
            return at
        }, _e.prototype.gtn = function(it) {
            return this.cmpn(it) === 1
        }, _e.prototype.gt = function(it) {
            return this.cmp(it) === 1
        }, _e.prototype.gten = function(it) {
            return this.cmpn(it) >= 0
        }, _e.prototype.gte = function(it) {
            return this.cmp(it) >= 0
        }, _e.prototype.ltn = function(it) {
            return this.cmpn(it) === -1
        }, _e.prototype.lt = function(it) {
            return this.cmp(it) === -1
        }, _e.prototype.lten = function(it) {
            return this.cmpn(it) <= 0
        }, _e.prototype.lte = function(it) {
            return this.cmp(it) <= 0
        }, _e.prototype.eqn = function(it) {
            return this.cmpn(it) === 0
        }, _e.prototype.eq = function(it) {
            return this.cmp(it) === 0
        }, _e.red = function(it) {
            return new Ft(it)
        }, _e.prototype.toRed = function(it) {
            return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), it.convertTo(this)._forceRed(it)
        }, _e.prototype.fromRed = function() {
            return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, _e.prototype._forceRed = function(it) {
            return this.red = it, this
        }, _e.prototype.forceRed = function(it) {
            return $(!this.red, "Already a number in reduction context"), this._forceRed(it)
        }, _e.prototype.redAdd = function(it) {
            return $(this.red, "redAdd works only with red numbers"), this.red.add(this, it)
        }, _e.prototype.redIAdd = function(it) {
            return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, it)
        }, _e.prototype.redSub = function(it) {
            return $(this.red, "redSub works only with red numbers"), this.red.sub(this, it)
        }, _e.prototype.redISub = function(it) {
            return $(this.red, "redISub works only with red numbers"), this.red.isub(this, it)
        }, _e.prototype.redShl = function(it) {
            return $(this.red, "redShl works only with red numbers"), this.red.shl(this, it)
        }, _e.prototype.redMul = function(it) {
            return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, it), this.red.mul(this, it)
        }, _e.prototype.redIMul = function(it) {
            return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, it), this.red.imul(this, it)
        }, _e.prototype.redSqr = function() {
            return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, _e.prototype.redISqr = function() {
            return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, _e.prototype.redSqrt = function() {
            return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, _e.prototype.redInvm = function() {
            return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, _e.prototype.redNeg = function() {
            return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, _e.prototype.redPow = function(it) {
            return $(this.red && !it.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, it)
        };
        var Pt = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function Bt(Ct, it) {
            this.name = Ct, this.p = new _e(it, 16), this.n = this.p.bitLength(), this.k = new _e(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        Bt.prototype._tmp = function() {
            var it = new _e(null);
            return it.words = new Array(Math.ceil(this.n / 13)), it
        }, Bt.prototype.ireduce = function(it) {
            var at = it,
                mt;
            do this.split(at, this.tmp), at = this.imulK(at), at = at.iadd(this.tmp), mt = at.bitLength(); while (mt > this.n);
            var xt = mt < this.n ? -1 : at.ucmp(this.p);
            return xt === 0 ? (at.words[0] = 0, at.length = 1) : xt > 0 ? at.isub(this.p) : at.strip !== void 0 ? at.strip() : at._strip(), at
        }, Bt.prototype.split = function(it, at) {
            it.iushrn(this.n, 0, at)
        }, Bt.prototype.imulK = function(it) {
            return it.imul(this.k)
        };

        function Lt() {
            Bt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        j(Lt, Bt), Lt.prototype.split = function(it, at) {
            for (var mt = 4194303, xt = Math.min(it.length, 9), $t = 0; $t < xt; $t++) at.words[$t] = it.words[$t];
            if (at.length = xt, it.length <= 9) {
                it.words[0] = 0, it.length = 1;
                return
            }
            var Rt = it.words[9];
            for (at.words[at.length++] = Rt & mt, $t = 10; $t < it.length; $t++) {
                var It = it.words[$t] | 0;
                it.words[$t - 10] = (It & mt) << 4 | Rt >>> 22, Rt = It
            }
            Rt >>>= 22, it.words[$t - 10] = Rt, Rt === 0 && it.length > 10 ? it.length -= 10 : it.length -= 9
        }, Lt.prototype.imulK = function(it) {
            it.words[it.length] = 0, it.words[it.length + 1] = 0, it.length += 2;
            for (var at = 0, mt = 0; mt < it.length; mt++) {
                var xt = it.words[mt] | 0;
                at += xt * 977, it.words[mt] = at & 67108863, at = xt * 64 + (at / 67108864 | 0)
            }
            return it.words[it.length - 1] === 0 && (it.length--, it.words[it.length - 1] === 0 && it.length--), it
        };

        function Nt() {
            Bt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        j(Nt, Bt);

        function Ut() {
            Bt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        j(Ut, Bt);

        function Vt() {
            Bt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        j(Vt, Bt), Vt.prototype.imulK = function(it) {
            for (var at = 0, mt = 0; mt < it.length; mt++) {
                var xt = (it.words[mt] | 0) * 19 + at,
                    $t = xt & 67108863;
                xt >>>= 26, it.words[mt] = $t, at = xt
            }
            return at !== 0 && (it.words[it.length++] = at), it
        }, _e._prime = function(it) {
            if (Pt[it]) return Pt[it];
            var at;
            if (it === "k256") at = new Lt;
            else if (it === "p224") at = new Nt;
            else if (it === "p192") at = new Ut;
            else if (it === "p25519") at = new Vt;
            else throw new Error("Unknown prime " + it);
            return Pt[it] = at, at
        };

        function Ft(Ct) {
            if (typeof Ct == "string") {
                var it = _e._prime(Ct);
                this.m = it.p, this.prime = it
            } else $(Ct.gtn(1), "modulus must be greater than 1"), this.m = Ct, this.prime = null
        }
        Ft.prototype._verify1 = function(it) {
            $(it.negative === 0, "red works only with positives"), $(it.red, "red works only with red numbers")
        }, Ft.prototype._verify2 = function(it, at) {
            $((it.negative | at.negative) === 0, "red works only with positives"), $(it.red && it.red === at.red, "red works only with red numbers")
        }, Ft.prototype.imod = function(it) {
            return this.prime ? this.prime.ireduce(it)._forceRed(this) : (ot(it, it.umod(this.m)._forceRed(this)), it)
        }, Ft.prototype.neg = function(it) {
            return it.isZero() ? it.clone() : this.m.sub(it)._forceRed(this)
        }, Ft.prototype.add = function(it, at) {
            this._verify2(it, at);
            var mt = it.add(at);
            return mt.cmp(this.m) >= 0 && mt.isub(this.m), mt._forceRed(this)
        }, Ft.prototype.iadd = function(it, at) {
            this._verify2(it, at);
            var mt = it.iadd(at);
            return mt.cmp(this.m) >= 0 && mt.isub(this.m), mt
        }, Ft.prototype.sub = function(it, at) {
            this._verify2(it, at);
            var mt = it.sub(at);
            return mt.cmpn(0) < 0 && mt.iadd(this.m), mt._forceRed(this)
        }, Ft.prototype.isub = function(it, at) {
            this._verify2(it, at);
            var mt = it.isub(at);
            return mt.cmpn(0) < 0 && mt.iadd(this.m), mt
        }, Ft.prototype.shl = function(it, at) {
            return this._verify1(it), this.imod(it.ushln(at))
        }, Ft.prototype.imul = function(it, at) {
            return this._verify2(it, at), this.imod(it.imul(at))
        }, Ft.prototype.mul = function(it, at) {
            return this._verify2(it, at), this.imod(it.mul(at))
        }, Ft.prototype.isqr = function(it) {
            return this.imul(it, it.clone())
        }, Ft.prototype.sqr = function(it) {
            return this.mul(it, it)
        }, Ft.prototype.sqrt = function(it) {
            if (it.isZero()) return it.clone();
            var at = this.m.andln(3);
            if ($(at % 2 === 1), at === 3) {
                var mt = this.m.add(new _e(1)).iushrn(2);
                return this.pow(it, mt)
            }
            for (var xt = this.m.subn(1), $t = 0; !xt.isZero() && xt.andln(1) === 0;) $t++, xt.iushrn(1);
            $(!xt.isZero());
            var Rt = new _e(1).toRed(this),
                It = Rt.redNeg(),
                Tt = this.m.subn(1).iushrn(1),
                dt = this.m.bitLength();
            for (dt = new _e(2 * dt * dt).toRed(this); this.pow(dt, Tt).cmp(It) !== 0;) dt.redIAdd(It);
            for (var Et = this.pow(dt, xt), Ot = this.pow(it, xt.addn(1).iushrn(1)), Mt = this.pow(it, xt), jt = $t; Mt.cmp(Rt) !== 0;) {
                for (var Qt = Mt, Kt = 0; Qt.cmp(Rt) !== 0; Kt++) Qt = Qt.redSqr();
                $(Kt < jt);
                var qt = this.pow(Et, new _e(1).iushln(jt - Kt - 1));
                Ot = Ot.redMul(qt), Et = qt.redSqr(), Mt = Mt.redMul(Et), jt = Kt
            }
            return Ot
        }, Ft.prototype.invm = function(it) {
            var at = it._invmp(this.m);
            return at.negative !== 0 ? (at.negative = 0, this.imod(at).redNeg()) : this.imod(at)
        }, Ft.prototype.pow = function(it, at) {
            if (at.isZero()) return new _e(1).toRed(this);
            if (at.cmpn(1) === 0) return it.clone();
            var mt = 4,
                xt = new Array(1 << mt);
            xt[0] = new _e(1).toRed(this), xt[1] = it;
            for (var $t = 2; $t < xt.length; $t++) xt[$t] = this.mul(xt[$t - 1], it);
            var Rt = xt[0],
                It = 0,
                Tt = 0,
                dt = at.bitLength() % 26;
            for (dt === 0 && (dt = 26), $t = at.length - 1; $t >= 0; $t--) {
                for (var Et = at.words[$t], Ot = dt - 1; Ot >= 0; Ot--) {
                    var Mt = Et >> Ot & 1;
                    if (Rt !== xt[0] && (Rt = this.sqr(Rt)), Mt === 0 && It === 0) {
                        Tt = 0;
                        continue
                    }
                    It <<= 1, It |= Mt, Tt++, !(Tt !== mt && ($t !== 0 || Ot !== 0)) && (Rt = this.mul(Rt, xt[It]), Tt = 0, It = 0)
                }
                dt = 26
            }
            return Rt
        }, Ft.prototype.convertTo = function(it) {
            var at = it.umod(this.m);
            return at === it ? at.clone() : at
        }, Ft.prototype.convertFrom = function(it) {
            var at = it.clone();
            return at.red = null, at
        }, _e.mont = function(it) {
            return new Wt(it)
        };

        function Wt(Ct) {
            Ft.call(this, Ct), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new _e(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        j(Wt, Ft), Wt.prototype.convertTo = function(it) {
            return this.imod(it.ushln(this.shift))
        }, Wt.prototype.convertFrom = function(it) {
            var at = this.imod(it.mul(this.rinv));
            return at.red = null, at
        }, Wt.prototype.imul = function(it, at) {
            if (it.isZero() || at.isZero()) return it.words[0] = 0, it.length = 1, it;
            var mt = it.imul(at),
                xt = mt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                $t = mt.isub(xt).iushrn(this.shift),
                Rt = $t;
            return $t.cmp(this.m) >= 0 ? Rt = $t.isub(this.m) : $t.cmpn(0) < 0 && (Rt = $t.iadd(this.m)), Rt._forceRed(this)
        }, Wt.prototype.mul = function(it, at) {
            if (it.isZero() || at.isZero()) return new _e(0)._forceRed(this);
            var mt = it.mul(at),
                xt = mt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                $t = mt.isub(xt).iushrn(this.shift),
                Rt = $t;
            return $t.cmp(this.m) >= 0 ? Rt = $t.isub(this.m) : $t.cmpn(0) < 0 && (Rt = $t.iadd(this.m)), Rt._forceRed(this)
        }, Wt.prototype.invm = function(it) {
            var at = this.imod(it._invmp(this.m).mul(this.r2));
            return at._forceRed(this)
        }
    })(s, commonjsGlobal$1)
})(bn);
var bnExports = bn.exports;
const BN = getDefaultExportFromCjs$3(bnExports);
var safeBuffer = {
    exports: {}
}; /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(s, o) {
    var a = buffer,
        $ = a.Buffer;

    function j(et, tt) {
        for (var nt in et) tt[nt] = et[nt]
    }
    $.from && $.alloc && $.allocUnsafe && $.allocUnsafeSlow ? s.exports = a : (j(a, o), o.Buffer = _e);

    function _e(et, tt, nt) {
        return $(et, tt, nt)
    }
    _e.prototype = Object.create($.prototype), j($, _e), _e.from = function(et, tt, nt) {
        if (typeof et == "number") throw new TypeError("Argument must not be a number");
        return $(et, tt, nt)
    }, _e.alloc = function(et, tt, nt) {
        if (typeof et != "number") throw new TypeError("Argument must be a number");
        var rt = $(et);
        return tt !== void 0 ? typeof nt == "string" ? rt.fill(tt, nt) : rt.fill(tt) : rt.fill(0), rt
    }, _e.allocUnsafe = function(et) {
        if (typeof et != "number") throw new TypeError("Argument must be a number");
        return $(et)
    }, _e.allocUnsafeSlow = function(et) {
        if (typeof et != "number") throw new TypeError("Argument must be a number");
        return a.SlowBuffer(et)
    }
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports,
    _Buffer = safeBufferExports.Buffer;

function base(s) {
    if (s.length >= 255) throw new TypeError("Alphabet too long");
    for (var o = new Uint8Array(256), a = 0; a < o.length; a++) o[a] = 255;
    for (var $ = 0; $ < s.length; $++) {
        var j = s.charAt($),
            _e = j.charCodeAt(0);
        if (o[_e] !== 255) throw new TypeError(j + " is ambiguous");
        o[_e] = $
    }
    var et = s.length,
        tt = s.charAt(0),
        nt = Math.log(et) / Math.log(256),
        rt = Math.log(256) / Math.log(et);

    function ot(ft) {
        if ((Array.isArray(ft) || ft instanceof Uint8Array) && (ft = _Buffer.from(ft)), !_Buffer.isBuffer(ft)) throw new TypeError("Expected Buffer");
        if (ft.length === 0) return "";
        for (var yt = 0, bt = 0, ht = 0, vt = ft.length; ht !== vt && ft[ht] === 0;) ht++, yt++;
        for (var wt = (vt - ht) * rt + 1 >>> 0, gt = new Uint8Array(wt); ht !== vt;) {
            for (var At = ft[ht], Pt = 0, Bt = wt - 1;
                (At !== 0 || Pt < bt) && Bt !== -1; Bt--, Pt++) At += 256 * gt[Bt] >>> 0, gt[Bt] = At % et >>> 0, At = At / et >>> 0;
            if (At !== 0) throw new Error("Non-zero carry");
            bt = Pt, ht++
        }
        for (var Lt = wt - bt; Lt !== wt && gt[Lt] === 0;) Lt++;
        for (var Nt = tt.repeat(yt); Lt < wt; ++Lt) Nt += s.charAt(gt[Lt]);
        return Nt
    }

    function st(ft) {
        if (typeof ft != "string") throw new TypeError("Expected String");
        if (ft.length === 0) return _Buffer.alloc(0);
        for (var yt = 0, bt = 0, ht = 0; ft[yt] === tt;) bt++, yt++;
        for (var vt = (ft.length - yt) * nt + 1 >>> 0, wt = new Uint8Array(vt); yt < ft.length;) {
            var gt = o[ft.charCodeAt(yt)];
            if (gt === 255) return;
            for (var At = 0, Pt = vt - 1;
                (gt !== 0 || At < ht) && Pt !== -1; Pt--, At++) gt += et * wt[Pt] >>> 0, wt[Pt] = gt % 256 >>> 0, gt = gt / 256 >>> 0;
            if (gt !== 0) throw new Error("Non-zero carry");
            ht = At, yt++
        }
        for (var Bt = vt - ht; Bt !== vt && wt[Bt] === 0;) Bt++;
        var Lt = _Buffer.allocUnsafe(bt + (vt - Bt));
        Lt.fill(0, 0, bt);
        for (var Nt = bt; Bt !== vt;) Lt[Nt++] = wt[Bt++];
        return Lt
    }

    function lt(ft) {
        var yt = st(ft);
        if (yt) return yt;
        throw new Error("Non-base" + et + " character")
    }
    return {
        encode: ot,
        decodeUnsafe: st,
        decode: lt
    }
}
var src = base,
    basex = src,
    ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    bs58$1 = basex(ALPHABET);
const bs58$1$1 = getDefaultExportFromCjs$3(bs58$1),
    SHA256_K = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    SHA256_IV = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    SHA256_W = new Uint32Array(64);
class SHA256 extends HashMD {
    constructor() {
        super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0
    }
    get() {
        const {
            A: o,
            B: a,
            C: $,
            D: j,
            E: _e,
            F: et,
            G: tt,
            H: nt
        } = this;
        return [o, a, $, j, _e, et, tt, nt]
    }
    set(o, a, $, j, _e, et, tt, nt) {
        this.A = o | 0, this.B = a | 0, this.C = $ | 0, this.D = j | 0, this.E = _e | 0, this.F = et | 0, this.G = tt | 0, this.H = nt | 0
    }
    process(o, a) {
        for (let st = 0; st < 16; st++, a += 4) SHA256_W[st] = o.getUint32(a, !1);
        for (let st = 16; st < 64; st++) {
            const lt = SHA256_W[st - 15],
                ft = SHA256_W[st - 2],
                yt = rotr(lt, 7) ^ rotr(lt, 18) ^ lt >>> 3,
                bt = rotr(ft, 17) ^ rotr(ft, 19) ^ ft >>> 10;
            SHA256_W[st] = bt + SHA256_W[st - 7] + yt + SHA256_W[st - 16] | 0
        }
        let {
            A: $,
            B: j,
            C: _e,
            D: et,
            E: tt,
            F: nt,
            G: rt,
            H: ot
        } = this;
        for (let st = 0; st < 64; st++) {
            const lt = rotr(tt, 6) ^ rotr(tt, 11) ^ rotr(tt, 25),
                ft = ot + lt + Chi(tt, nt, rt) + SHA256_K[st] + SHA256_W[st] | 0,
                bt = (rotr($, 2) ^ rotr($, 13) ^ rotr($, 22)) + Maj($, j, _e) | 0;
            ot = rt, rt = nt, nt = tt, tt = et + ft | 0, et = _e, _e = j, j = $, $ = ft + bt | 0
        }
        $ = $ + this.A | 0, j = j + this.B | 0, _e = _e + this.C | 0, et = et + this.D | 0, tt = tt + this.E | 0, nt = nt + this.F | 0, rt = rt + this.G | 0, ot = ot + this.H | 0, this.set($, j, _e, et, tt, nt, rt, ot)
    }
    roundClean() {
        SHA256_W.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
    }
}
const sha256$2 = wrapConstructor(() => new SHA256);
var lib = {};

function inRange(s, o, a) {
    return o <= s && s <= a
}

function ToDictionary(s) {
    if (s === void 0) return {};
    if (s === Object(s)) return s;
    throw TypeError("Could not convert argument to dictionary")
}

function stringToCodePoints(s) {
    for (var o = String(s), a = o.length, $ = 0, j = []; $ < a;) {
        var _e = o.charCodeAt($);
        if (_e < 55296 || _e > 57343) j.push(_e);
        else if (56320 <= _e && _e <= 57343) j.push(65533);
        else if (55296 <= _e && _e <= 56319)
            if ($ === a - 1) j.push(65533);
            else {
                var et = s.charCodeAt($ + 1);
                if (56320 <= et && et <= 57343) {
                    var tt = _e & 1023,
                        nt = et & 1023;
                    j.push(65536 + (tt << 10) + nt), $ += 1
                } else j.push(65533)
            }
        $ += 1
    }
    return j
}

function codePointsToString(s) {
    for (var o = "", a = 0; a < s.length; ++a) {
        var $ = s[a];
        $ <= 65535 ? o += String.fromCharCode($) : ($ -= 65536, o += String.fromCharCode(($ >> 10) + 55296, ($ & 1023) + 56320))
    }
    return o
}
var end_of_stream = -1;

function Stream(s) {
    this.tokens = [].slice.call(s)
}
Stream.prototype = {
    endOfStream: function() {
        return !this.tokens.length
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : end_of_stream
    },
    prepend: function(s) {
        if (Array.isArray(s))
            for (var o = s; o.length;) this.tokens.unshift(o.pop());
        else this.tokens.unshift(s)
    },
    push: function(s) {
        if (Array.isArray(s))
            for (var o = s; o.length;) this.tokens.push(o.shift());
        else this.tokens.push(s)
    }
};
var finished = -1;

function decoderError(s, o) {
    if (s) throw TypeError("Decoder error");
    return o || 65533
}
var DEFAULT_ENCODING = "utf-8";

function TextDecoder$1(s, o) {
    if (!(this instanceof TextDecoder$1)) return new TextDecoder$1(s, o);
    if (s = s !== void 0 ? String(s).toLowerCase() : DEFAULT_ENCODING, s !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
    o = ToDictionary(o), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!o.fatal, this._ignoreBOM = !!o.ignoreBOM, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }), Object.defineProperty(this, "fatal", {
        value: this._fatal
    }), Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
TextDecoder$1.prototype = {
    decode: function s(o, a) {
        var $;
        typeof o == "object" && o instanceof ArrayBuffer ? $ = new Uint8Array(o) : typeof o == "object" && "buffer" in o && o.buffer instanceof ArrayBuffer ? $ = new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : $ = new Uint8Array(0), a = ToDictionary(a), this._streaming || (this._decoder = new UTF8Decoder({
            fatal: this._fatal
        }), this._BOMseen = !1), this._streaming = !!a.stream;
        for (var j = new Stream($), _e = [], et; !j.endOfStream() && (et = this._decoder.handler(j, j.read()), et !== finished);) et !== null && (Array.isArray(et) ? _e.push.apply(_e, et) : _e.push(et));
        if (!this._streaming) {
            do {
                if (et = this._decoder.handler(j, j.read()), et === finished) break;
                et !== null && (Array.isArray(et) ? _e.push.apply(_e, et) : _e.push(et))
            } while (!j.endOfStream());
            this._decoder = null
        }
        return _e.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (_e[0] === 65279 ? (this._BOMseen = !0, _e.shift()) : this._BOMseen = !0), codePointsToString(_e)
    }
};

function TextEncoder$1(s, o) {
    if (!(this instanceof TextEncoder$1)) return new TextEncoder$1(s, o);
    if (s = s !== void 0 ? String(s).toLowerCase() : DEFAULT_ENCODING, s !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
    o = ToDictionary(o), this._streaming = !1, this._encoder = null, this._options = {
        fatal: !!o.fatal
    }, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
TextEncoder$1.prototype = {
    encode: function s(o, a) {
        o = o ? String(o) : "", a = ToDictionary(a), this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = !!a.stream;
        for (var $ = [], j = new Stream(stringToCodePoints(o)), _e; !j.endOfStream() && (_e = this._encoder.handler(j, j.read()), _e !== finished);) Array.isArray(_e) ? $.push.apply($, _e) : $.push(_e);
        if (!this._streaming) {
            for (; _e = this._encoder.handler(j, j.read()), _e !== finished;) Array.isArray(_e) ? $.push.apply($, _e) : $.push(_e);
            this._encoder = null
        }
        return new Uint8Array($)
    }
};

function UTF8Decoder(s) {
    var o = s.fatal,
        a = 0,
        $ = 0,
        j = 0,
        _e = 128,
        et = 191;
    this.handler = function(tt, nt) {
        if (nt === end_of_stream && j !== 0) return j = 0, decoderError(o);
        if (nt === end_of_stream) return finished;
        if (j === 0) {
            if (inRange(nt, 0, 127)) return nt;
            if (inRange(nt, 194, 223)) j = 1, a = nt - 192;
            else if (inRange(nt, 224, 239)) nt === 224 && (_e = 160), nt === 237 && (et = 159), j = 2, a = nt - 224;
            else if (inRange(nt, 240, 244)) nt === 240 && (_e = 144), nt === 244 && (et = 143), j = 3, a = nt - 240;
            else return decoderError(o);
            return a = a << 6 * j, null
        }
        if (!inRange(nt, _e, et)) return a = j = $ = 0, _e = 128, et = 191, tt.prepend(nt), decoderError(o);
        if (_e = 128, et = 191, $ += 1, a += nt - 128 << 6 * (j - $), $ !== j) return null;
        var rt = a;
        return a = j = $ = 0, rt
    }
}

function UTF8Encoder(s) {
    s.fatal, this.handler = function(o, a) {
        if (a === end_of_stream) return finished;
        if (inRange(a, 0, 127)) return a;
        var $, j;
        inRange(a, 128, 2047) ? ($ = 1, j = 192) : inRange(a, 2048, 65535) ? ($ = 2, j = 224) : inRange(a, 65536, 1114111) && ($ = 3, j = 240);
        for (var _e = [(a >> 6 * $) + j]; $ > 0;) {
            var et = a >> 6 * ($ - 1);
            _e.push(128 | et & 63), $ -= 1
        }
        return _e
    }
}
const encoding$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        TextDecoder: TextDecoder$1,
        TextEncoder: TextEncoder$1
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    require$$2 = getAugmentedNamespace(encoding$1);
var __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(s, o, a, $) {
        $ === void 0 && ($ = a), Object.defineProperty(s, $, {
            enumerable: !0,
            get: function() {
                return o[a]
            }
        })
    } : function(s, o, a, $) {
        $ === void 0 && ($ = a), s[$] = o[a]
    }),
    __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(s, o) {
        Object.defineProperty(s, "default", {
            enumerable: !0,
            value: o
        })
    } : function(s, o) {
        s.default = o
    }),
    __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(s, o, a, $) {
        var j = arguments.length,
            _e = j < 3 ? o : $ === null ? $ = Object.getOwnPropertyDescriptor(o, a) : $,
            et;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") _e = Reflect.decorate(s, o, a, $);
        else
            for (var tt = s.length - 1; tt >= 0; tt--)(et = s[tt]) && (_e = (j < 3 ? et(_e) : j > 3 ? et(o, a, _e) : et(o, a)) || _e);
        return j > 3 && _e && Object.defineProperty(o, a, _e), _e
    },
    __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(s) {
        if (s && s.__esModule) return s;
        var o = {};
        if (s != null)
            for (var a in s) a !== "default" && Object.hasOwnProperty.call(s, a) && __createBinding(o, s, a);
        return __setModuleDefault(o, s), o
    },
    __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(s) {
        return s && s.__esModule ? s : {
            default: s
        }
    };
Object.defineProperty(lib, "__esModule", {
    value: !0
});
var deserializeUnchecked_1 = lib.deserializeUnchecked = deserialize_1 = lib.deserialize = serialize_1 = lib.serialize = lib.BinaryReader = lib.BinaryWriter = lib.BorshError = lib.baseDecode = lib.baseEncode = void 0;
const bn_js_1 = __importDefault(bnExports),
    bs58_1 = __importDefault(bs58$1),
    encoding = __importStar(require$$2),
    ResolvedTextDecoder = typeof TextDecoder != "function" ? encoding.TextDecoder : TextDecoder,
    textDecoder = new ResolvedTextDecoder("utf-8", {
        fatal: !0
    });

function baseEncode(s) {
    return typeof s == "string" && (s = Buffer.from(s, "utf8")), bs58_1.default.encode(Buffer.from(s))
}
lib.baseEncode = baseEncode;

function baseDecode(s) {
    return Buffer.from(bs58_1.default.decode(s))
}
lib.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
    constructor(o) {
        super(o), this.fieldPath = [], this.originalMessage = o
    }
    addToFieldPath(o) {
        this.fieldPath.splice(0, 0, o), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
    }
}
lib.BorshError = BorshError;
class BinaryWriter {
    constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH), this.length = 0
    }
    maybeResize() {
        this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]))
    }
    writeU8(o) {
        this.maybeResize(), this.buf.writeUInt8(o, this.length), this.length += 1
    }
    writeU16(o) {
        this.maybeResize(), this.buf.writeUInt16LE(o, this.length), this.length += 2
    }
    writeU32(o) {
        this.maybeResize(), this.buf.writeUInt32LE(o, this.length), this.length += 4
    }
    writeU64(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(o).toArray("le", 8)))
    }
    writeU128(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(o).toArray("le", 16)))
    }
    writeU256(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(o).toArray("le", 32)))
    }
    writeU512(o) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(o).toArray("le", 64)))
    }
    writeBuffer(o) {
        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), o, Buffer.alloc(INITIAL_LENGTH)]), this.length += o.length
    }
    writeString(o) {
        this.maybeResize();
        const a = Buffer.from(o, "utf8");
        this.writeU32(a.length), this.writeBuffer(a)
    }
    writeFixedArray(o) {
        this.writeBuffer(Buffer.from(o))
    }
    writeArray(o, a) {
        this.maybeResize(), this.writeU32(o.length);
        for (const $ of o) this.maybeResize(), a($)
    }
    toArray() {
        return this.buf.subarray(0, this.length)
    }
}
lib.BinaryWriter = BinaryWriter;

function handlingRangeError(s, o, a) {
    const $ = a.value;
    a.value = function(...j) {
        try {
            return $.apply(this, j)
        } catch (_e) {
            if (_e instanceof RangeError) {
                const et = _e.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(et) >= 0) throw new BorshError("Reached the end of buffer when deserializing")
            }
            throw _e
        }
    }
}
class BinaryReader {
    constructor(o) {
        this.buf = o, this.offset = 0
    }
    readU8() {
        const o = this.buf.readUInt8(this.offset);
        return this.offset += 1, o
    }
    readU16() {
        const o = this.buf.readUInt16LE(this.offset);
        return this.offset += 2, o
    }
    readU32() {
        const o = this.buf.readUInt32LE(this.offset);
        return this.offset += 4, o
    }
    readU64() {
        const o = this.readBuffer(8);
        return new bn_js_1.default(o, "le")
    }
    readU128() {
        const o = this.readBuffer(16);
        return new bn_js_1.default(o, "le")
    }
    readU256() {
        const o = this.readBuffer(32);
        return new bn_js_1.default(o, "le")
    }
    readU512() {
        const o = this.readBuffer(64);
        return new bn_js_1.default(o, "le")
    }
    readBuffer(o) {
        if (this.offset + o > this.buf.length) throw new BorshError(`Expected buffer length ${o} isn't within bounds`);
        const a = this.buf.slice(this.offset, this.offset + o);
        return this.offset += o, a
    }
    readString() {
        const o = this.readU32(),
            a = this.readBuffer(o);
        try {
            return textDecoder.decode(a)
        } catch ($) {
            throw new BorshError(`Error decoding UTF-8 string: ${$}`)
        }
    }
    readFixedArray(o) {
        return new Uint8Array(this.readBuffer(o))
    }
    readArray(o) {
        const a = this.readU32(),
            $ = Array();
        for (let j = 0; j < a; ++j) $.push(o());
        return $
    }
}
__decorate([handlingRangeError], BinaryReader.prototype, "readU8", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU16", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU32", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU64", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU128", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU256", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU512", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readString", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readFixedArray", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readArray", null);
lib.BinaryReader = BinaryReader;

function capitalizeFirstLetter(s) {
    return s.charAt(0).toUpperCase() + s.slice(1)
}

function serializeField(s, o, a, $, j) {
    try {
        if (typeof $ == "string") j[`write${capitalizeFirstLetter($)}`](a);
        else if ($ instanceof Array)
            if (typeof $[0] == "number") {
                if (a.length !== $[0]) throw new BorshError(`Expecting byte array of length ${$[0]}, but got ${a.length} bytes`);
                j.writeFixedArray(a)
            } else if ($.length === 2 && typeof $[1] == "number") {
            if (a.length !== $[1]) throw new BorshError(`Expecting byte array of length ${$[1]}, but got ${a.length} bytes`);
            for (let _e = 0; _e < $[1]; _e++) serializeField(s, null, a[_e], $[0], j)
        } else j.writeArray(a, _e => {
            serializeField(s, o, _e, $[0], j)
        });
        else if ($.kind !== void 0) switch ($.kind) {
            case "option":
                {
                    a == null ? j.writeU8(0) : (j.writeU8(1), serializeField(s, o, a, $.type, j));
                    break
                }
            case "map":
                {
                    j.writeU32(a.size),
                    a.forEach((_e, et) => {
                        serializeField(s, o, et, $.key, j), serializeField(s, o, _e, $.value, j)
                    });
                    break
                }
            default:
                throw new BorshError(`FieldType ${$} unrecognized`)
        } else serializeStruct(s, a, j)
    } catch (_e) {
        throw _e instanceof BorshError && _e.addToFieldPath(o), _e
    }
}

function serializeStruct(s, o, a) {
    if (typeof o.borshSerialize == "function") {
        o.borshSerialize(a);
        return
    }
    const $ = s.get(o.constructor);
    if (!$) throw new BorshError(`Class ${o.constructor.name} is missing in schema`);
    if ($.kind === "struct") $.fields.map(([j, _e]) => {
        serializeField(s, j, o[j], _e, a)
    });
    else if ($.kind === "enum") {
        const j = o[$.field];
        for (let _e = 0; _e < $.values.length; ++_e) {
            const [et, tt] = $.values[_e];
            if (et === j) {
                a.writeU8(_e), serializeField(s, et, o[et], tt, a);
                break
            }
        }
    } else throw new BorshError(`Unexpected schema kind: ${$.kind} for ${o.constructor.name}`)
}

function serialize(s, o, a = BinaryWriter) {
    const $ = new a;
    return serializeStruct(s, o, $), $.toArray()
}
var serialize_1 = lib.serialize = serialize;

function deserializeField(s, o, a, $) {
    try {
        if (typeof a == "string") return $[`read${capitalizeFirstLetter(a)}`]();
        if (a instanceof Array) {
            if (typeof a[0] == "number") return $.readFixedArray(a[0]);
            if (typeof a[1] == "number") {
                const j = [];
                for (let _e = 0; _e < a[1]; _e++) j.push(deserializeField(s, null, a[0], $));
                return j
            } else return $.readArray(() => deserializeField(s, o, a[0], $))
        }
        if (a.kind === "option") return $.readU8() ? deserializeField(s, o, a.type, $) : void 0;
        if (a.kind === "map") {
            let j = new Map;
            const _e = $.readU32();
            for (let et = 0; et < _e; et++) {
                const tt = deserializeField(s, o, a.key, $),
                    nt = deserializeField(s, o, a.value, $);
                j.set(tt, nt)
            }
            return j
        }
        return deserializeStruct(s, a, $)
    } catch (j) {
        throw j instanceof BorshError && j.addToFieldPath(o), j
    }
}

function deserializeStruct(s, o, a) {
    if (typeof o.borshDeserialize == "function") return o.borshDeserialize(a);
    const $ = s.get(o);
    if (!$) throw new BorshError(`Class ${o.name} is missing in schema`);
    if ($.kind === "struct") {
        const j = {};
        for (const [_e, et] of s.get(o).fields) j[_e] = deserializeField(s, _e, et, a);
        return new o(j)
    }
    if ($.kind === "enum") {
        const j = a.readU8();
        if (j >= $.values.length) throw new BorshError(`Enum index: ${j} is out of range`);
        const [_e, et] = $.values[j], tt = deserializeField(s, _e, et, a);
        return new o({
            [_e]: tt
        })
    }
    throw new BorshError(`Unexpected schema kind: ${$.kind} for ${o.constructor.name}`)
}

function deserialize(s, o, a, $ = BinaryReader) {
    const j = new $(a),
        _e = deserializeStruct(s, o, j);
    if (j.offset < a.length) throw new BorshError(`Unexpected ${a.length-j.offset} bytes after deserialized data`);
    return _e
}
var deserialize_1 = lib.deserialize = deserialize;

function deserializeUnchecked(s, o, a, $ = BinaryReader) {
    const j = new $(a);
    return deserializeStruct(s, o, j)
}
deserializeUnchecked_1 = lib.deserializeUnchecked = deserializeUnchecked;
var Layout$5 = {};
Object.defineProperty(Layout$5, "__esModule", {
    value: !0
});
Layout$5.s16 = Layout$5.s8 = Layout$5.nu64be = Layout$5.u48be = Layout$5.u40be = Layout$5.u32be = Layout$5.u24be = Layout$5.u16be = nu64$1 = Layout$5.nu64 = Layout$5.u48 = Layout$5.u40 = u32$1 = Layout$5.u32 = Layout$5.u24 = u16 = Layout$5.u16 = u8$1 = Layout$5.u8 = offset$1 = Layout$5.offset = Layout$5.greedy = Layout$5.Constant = Layout$5.UTF8 = Layout$5.CString = Layout$5.Blob = Layout$5.Boolean = Layout$5.BitField = Layout$5.BitStructure = Layout$5.VariantLayout = Layout$5.Union = Layout$5.UnionLayoutDiscriminator = Layout$5.UnionDiscriminator = Layout$5.Structure = Layout$5.Sequence = Layout$5.DoubleBE = Layout$5.Double = Layout$5.FloatBE = Layout$5.Float = Layout$5.NearInt64BE = Layout$5.NearInt64 = Layout$5.NearUInt64BE = Layout$5.NearUInt64 = Layout$5.IntBE = Layout$5.Int = Layout$5.UIntBE = Layout$5.UInt = Layout$5.OffsetLayout = Layout$5.GreedyCount = Layout$5.ExternalLayout = Layout$5.bindConstructorLayout = Layout$5.nameWithProperty = Layout$5.Layout = Layout$5.uint8ArrayToBuffer = Layout$5.checkUint8Array = void 0;
Layout$5.constant = Layout$5.utf8 = Layout$5.cstr = blob$1 = Layout$5.blob = Layout$5.unionLayoutDiscriminator = Layout$5.union = seq = Layout$5.seq = Layout$5.bits = struct$1 = Layout$5.struct = Layout$5.f64be = Layout$5.f64 = Layout$5.f32be = Layout$5.f32 = Layout$5.ns64be = Layout$5.s48be = Layout$5.s40be = Layout$5.s32be = Layout$5.s24be = Layout$5.s16be = ns64$1 = Layout$5.ns64 = Layout$5.s48 = Layout$5.s40 = Layout$5.s32 = Layout$5.s24 = void 0;
const buffer_1 = buffer;

function checkUint8Array(s) {
    if (!(s instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
}
Layout$5.checkUint8Array = checkUint8Array;

function uint8ArrayToBuffer(s) {
    return checkUint8Array(s), buffer_1.Buffer.from(s.buffer, s.byteOffset, s.length)
}
Layout$5.uint8ArrayToBuffer = uint8ArrayToBuffer;
let Layout$4 = class {
    constructor(o, a) {
        if (!Number.isInteger(o)) throw new TypeError("span must be an integer");
        this.span = o, this.property = a
    }
    makeDestinationObject() {
        return {}
    }
    getSpan(o, a) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(o) {
        const a = Object.create(this.constructor.prototype);
        return Object.assign(a, this), a.property = o, a
    }
    fromArray(o) {}
};
Layout$5.Layout = Layout$4;

function nameWithProperty$2(s, o) {
    return o.property ? s + "[" + o.property + "]" : s
}
Layout$5.nameWithProperty = nameWithProperty$2;

function bindConstructorLayout$1(s, o) {
    if (typeof s != "function") throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(s, "layout_")) throw new Error("Class is already bound to a layout");
    if (!(o && o instanceof Layout$4)) throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(o, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
    s.layout_ = o, o.boundConstructor_ = s, o.makeDestinationObject = () => new s, Object.defineProperty(s.prototype, "encode", {
        value(a, $) {
            return o.encode(this, a, $)
        },
        writable: !0
    }), Object.defineProperty(s, "decode", {
        value(a, $) {
            return o.decode(a, $)
        },
        writable: !0
    })
}
Layout$5.bindConstructorLayout = bindConstructorLayout$1;
let ExternalLayout$2 = class extends Layout$4 {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
};
Layout$5.ExternalLayout = ExternalLayout$2;
let GreedyCount$1 = class extends ExternalLayout$2 {
    constructor(o = 1, a) {
        if (!Number.isInteger(o) || 0 >= o) throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, a), this.elementSpan = o
    }
    isCount() {
        return !0
    }
    decode(o, a = 0) {
        checkUint8Array(o);
        const $ = o.length - a;
        return Math.floor($ / this.elementSpan)
    }
    encode(o, a, $) {
        return 0
    }
};
Layout$5.GreedyCount = GreedyCount$1;
let OffsetLayout$2 = class extends ExternalLayout$2 {
    constructor(o, a = 0, $) {
        if (!(o instanceof Layout$4)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(a)) throw new TypeError("offset must be integer or undefined");
        super(o.span, $ || o.property), this.layout = o, this.offset = a
    }
    isCount() {
        return this.layout instanceof UInt$2 || this.layout instanceof UIntBE$2
    }
    decode(o, a = 0) {
        return this.layout.decode(o, a + this.offset)
    }
    encode(o, a, $ = 0) {
        return this.layout.encode(o, a, $ + this.offset)
    }
};
Layout$5.OffsetLayout = OffsetLayout$2;
let UInt$2 = class extends Layout$4 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readUIntLE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeUIntLE(o, $, this.span), this.span
    }
};
Layout$5.UInt = UInt$2;
let UIntBE$2 = class extends Layout$4 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readUIntBE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeUIntBE(o, $, this.span), this.span
    }
};
Layout$5.UIntBE = UIntBE$2;
let Int$1 = class extends Layout$4 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readIntLE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeIntLE(o, $, this.span), this.span
    }
};
Layout$5.Int = Int$1;
let IntBE$1 = class extends Layout$4 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readIntBE(a, this.span)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeIntBE(o, $, this.span), this.span
    }
};
Layout$5.IntBE = IntBE$1;
const V2E32$2 = Math.pow(2, 32);

function divmodInt64$2(s) {
    const o = Math.floor(s / V2E32$2),
        a = s - o * V2E32$2;
    return {
        hi32: o,
        lo32: a
    }
}

function roundedInt64$2(s, o) {
    return s * V2E32$2 + o
}
let NearUInt64$2 = class extends Layout$4 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer(o),
            j = $.readUInt32LE(a),
            _e = $.readUInt32LE(a + 4);
        return roundedInt64$2(_e, j)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$2(o),
            _e = uint8ArrayToBuffer(a);
        return _e.writeUInt32LE(j.lo32, $), _e.writeUInt32LE(j.hi32, $ + 4), 8
    }
};
Layout$5.NearUInt64 = NearUInt64$2;
let NearUInt64BE$1 = class extends Layout$4 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer(o),
            j = $.readUInt32BE(a),
            _e = $.readUInt32BE(a + 4);
        return roundedInt64$2(j, _e)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$2(o),
            _e = uint8ArrayToBuffer(a);
        return _e.writeUInt32BE(j.hi32, $), _e.writeUInt32BE(j.lo32, $ + 4), 8
    }
};
Layout$5.NearUInt64BE = NearUInt64BE$1;
let NearInt64$2 = class extends Layout$4 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer(o),
            j = $.readUInt32LE(a),
            _e = $.readInt32LE(a + 4);
        return roundedInt64$2(_e, j)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$2(o),
            _e = uint8ArrayToBuffer(a);
        return _e.writeUInt32LE(j.lo32, $), _e.writeInt32LE(j.hi32, $ + 4), 8
    }
};
Layout$5.NearInt64 = NearInt64$2;
let NearInt64BE$1 = class extends Layout$4 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        const $ = uint8ArrayToBuffer(o),
            j = $.readInt32BE(a),
            _e = $.readUInt32BE(a + 4);
        return roundedInt64$2(j, _e)
    }
    encode(o, a, $ = 0) {
        const j = divmodInt64$2(o),
            _e = uint8ArrayToBuffer(a);
        return _e.writeInt32BE(j.hi32, $), _e.writeUInt32BE(j.lo32, $ + 4), 8
    }
};
Layout$5.NearInt64BE = NearInt64BE$1;
let Float$1 = class extends Layout$4 {
    constructor(o) {
        super(4, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readFloatLE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeFloatLE(o, $), 4
    }
};
Layout$5.Float = Float$1;
let FloatBE$1 = class extends Layout$4 {
    constructor(o) {
        super(4, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readFloatBE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeFloatBE(o, $), 4
    }
};
Layout$5.FloatBE = FloatBE$1;
let Double$1 = class extends Layout$4 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readDoubleLE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeDoubleLE(o, $), 8
    }
};
Layout$5.Double = Double$1;
let DoubleBE$1 = class extends Layout$4 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a = 0) {
        return uint8ArrayToBuffer(o).readDoubleBE(a)
    }
    encode(o, a, $ = 0) {
        return uint8ArrayToBuffer(a).writeDoubleBE(o, $), 8
    }
};
Layout$5.DoubleBE = DoubleBE$1;
let Sequence$1 = class extends Layout$4 {
    constructor(o, a, $) {
        if (!(o instanceof Layout$4)) throw new TypeError("elementLayout must be a Layout");
        if (!(a instanceof ExternalLayout$2 && a.isCount() || Number.isInteger(a) && 0 <= a)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let j = -1;
        !(a instanceof ExternalLayout$2) && 0 < o.span && (j = a * o.span), super(j, $), this.elementLayout = o, this.count = a
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        let $ = 0,
            j = this.count;
        if (j instanceof ExternalLayout$2 && (j = j.decode(o, a)), 0 < this.elementLayout.span) $ = j * this.elementLayout.span;
        else {
            let _e = 0;
            for (; _e < j;) $ += this.elementLayout.getSpan(o, a + $), ++_e
        }
        return $
    }
    decode(o, a = 0) {
        const $ = [];
        let j = 0,
            _e = this.count;
        for (_e instanceof ExternalLayout$2 && (_e = _e.decode(o, a)); j < _e;) $.push(this.elementLayout.decode(o, a)), a += this.elementLayout.getSpan(o, a), j += 1;
        return $
    }
    encode(o, a, $ = 0) {
        const j = this.elementLayout,
            _e = o.reduce((et, tt) => et + j.encode(tt, a, $ + et), 0);
        return this.count instanceof ExternalLayout$2 && this.count.encode(o.length, a, $), _e
    }
};
Layout$5.Sequence = Sequence$1;
let Structure$2 = class extends Layout$4 {
    constructor(o, a, $) {
        if (!(Array.isArray(o) && o.reduce((_e, et) => _e && et instanceof Layout$4, !0))) throw new TypeError("fields must be array of Layout instances");
        typeof a == "boolean" && $ === void 0 && ($ = a, a = void 0);
        for (const _e of o)
            if (0 > _e.span && _e.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
        let j = -1;
        try {
            j = o.reduce((_e, et) => _e + et.getSpan(), 0)
        } catch {}
        super(j, a), this.fields = o, this.decodePrefixes = !!$
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        let $ = 0;
        try {
            $ = this.fields.reduce((j, _e) => {
                const et = _e.getSpan(o, a);
                return a += et, j + et
            }, 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return $
    }
    decode(o, a = 0) {
        checkUint8Array(o);
        const $ = this.makeDestinationObject();
        for (const j of this.fields)
            if (j.property !== void 0 && ($[j.property] = j.decode(o, a)), a += j.getSpan(o, a), this.decodePrefixes && o.length === a) break;
        return $
    }
    encode(o, a, $ = 0) {
        const j = $;
        let _e = 0,
            et = 0;
        for (const tt of this.fields) {
            let nt = tt.span;
            if (et = 0 < nt ? nt : 0, tt.property !== void 0) {
                const rt = o[tt.property];
                rt !== void 0 && (et = tt.encode(rt, a, $), 0 > nt && (nt = tt.getSpan(a, $)))
            }
            _e = $, $ += nt
        }
        return _e + et - j
    }
    fromArray(o) {
        const a = this.makeDestinationObject();
        for (const $ of this.fields) $.property !== void 0 && 0 < o.length && (a[$.property] = o.shift());
        return a
    }
    layoutFor(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        for (const a of this.fields)
            if (a.property === o) return a
    }
    offsetOf(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        let a = 0;
        for (const $ of this.fields) {
            if ($.property === o) return a;
            0 > $.span ? a = -1 : 0 <= a && (a += $.span)
        }
    }
};
Layout$5.Structure = Structure$2;
let UnionDiscriminator$2 = class {
    constructor(o) {
        this.property = o
    }
    decode(o, a) {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode(o, a, $) {
        throw new Error("UnionDiscriminator is abstract")
    }
};
Layout$5.UnionDiscriminator = UnionDiscriminator$2;
let UnionLayoutDiscriminator$2 = class extends UnionDiscriminator$2 {
    constructor(o, a) {
        if (!(o instanceof ExternalLayout$2 && o.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(a || o.property || "variant"), this.layout = o
    }
    decode(o, a) {
        return this.layout.decode(o, a)
    }
    encode(o, a, $) {
        return this.layout.encode(o, a, $)
    }
};
Layout$5.UnionLayoutDiscriminator = UnionLayoutDiscriminator$2;
let Union$2 = class extends Layout$4 {
    constructor(o, a, $) {
        let j;
        if (o instanceof UInt$2 || o instanceof UIntBE$2) j = new UnionLayoutDiscriminator$2(new OffsetLayout$2(o));
        else if (o instanceof ExternalLayout$2 && o.isCount()) j = new UnionLayoutDiscriminator$2(o);
        else if (o instanceof UnionDiscriminator$2) j = o;
        else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (a === void 0 && (a = null), !(a === null || a instanceof Layout$4)) throw new TypeError("defaultLayout must be null or a Layout");
        if (a !== null) {
            if (0 > a.span) throw new Error("defaultLayout must have constant span");
            a.property === void 0 && (a = a.replicate("content"))
        }
        let _e = -1;
        a && (_e = a.span, 0 <= _e && (o instanceof UInt$2 || o instanceof UIntBE$2) && (_e += j.layout.span)), super(_e, $), this.discriminator = j, this.usesPrefixDiscriminator = o instanceof UInt$2 || o instanceof UIntBE$2, this.defaultLayout = a, this.registry = {};
        let et = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(tt) {
            return et(tt)
        }, this.configGetSourceVariant = function(tt) {
            et = tt.bind(this)
        }
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        const $ = this.getVariant(o, a);
        if (!$) throw new Error("unable to determine span for unrecognized variant");
        return $.getSpan(o, a)
    }
    defaultGetSourceVariant(o) {
        if (Object.prototype.hasOwnProperty.call(o, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(o, this.defaultLayout.property)) return;
            const a = this.registry[o[this.discriminator.property]];
            if (a && (!a.layout || a.property && Object.prototype.hasOwnProperty.call(o, a.property))) return a
        } else
            for (const a in this.registry) {
                const $ = this.registry[a];
                if ($.property && Object.prototype.hasOwnProperty.call(o, $.property)) return $
            }
        throw new Error("unable to infer src variant")
    }
    decode(o, a = 0) {
        let $;
        const j = this.discriminator,
            _e = j.decode(o, a),
            et = this.registry[_e];
        if (et === void 0) {
            const tt = this.defaultLayout;
            let nt = 0;
            this.usesPrefixDiscriminator && (nt = j.layout.span), $ = this.makeDestinationObject(), $[j.property] = _e, $[tt.property] = tt.decode(o, a + nt)
        } else $ = et.decode(o, a);
        return $
    }
    encode(o, a, $ = 0) {
        const j = this.getSourceVariant(o);
        if (j === void 0) {
            const _e = this.discriminator,
                et = this.defaultLayout;
            let tt = 0;
            return this.usesPrefixDiscriminator && (tt = _e.layout.span), _e.encode(o[_e.property], a, $), tt + et.encode(o[et.property], a, $ + tt)
        }
        return j.encode(o, a, $)
    }
    addVariant(o, a, $) {
        const j = new VariantLayout$2(this, o, a, $);
        return this.registry[o] = j, j
    }
    getVariant(o, a = 0) {
        let $;
        return o instanceof Uint8Array ? $ = this.discriminator.decode(o, a) : $ = o, this.registry[$]
    }
};
Layout$5.Union = Union$2;
let VariantLayout$2 = class extends Layout$4 {
    constructor(o, a, $, j) {
        if (!(o instanceof Union$2)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(a) || 0 > a) throw new TypeError("variant must be a (non-negative) integer");
        if (typeof $ == "string" && j === void 0 && (j = $, $ = null), $) {
            if (!($ instanceof Layout$4)) throw new TypeError("layout must be a Layout");
            if (o.defaultLayout !== null && 0 <= $.span && $.span > o.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
            if (typeof j != "string") throw new TypeError("variant must have a String property")
        }
        let _e = o.span;
        0 > o.span && (_e = $ ? $.span : 0, 0 <= _e && o.usesPrefixDiscriminator && (_e += o.discriminator.layout.span)), super(_e, j), this.union = o, this.variant = a, this.layout = $ || null
    }
    getSpan(o, a = 0) {
        if (0 <= this.span) return this.span;
        let $ = 0;
        this.union.usesPrefixDiscriminator && ($ = this.union.discriminator.layout.span);
        let j = 0;
        return this.layout && (j = this.layout.getSpan(o, a + $)), $ + j
    }
    decode(o, a = 0) {
        const $ = this.makeDestinationObject();
        if (this !== this.union.getVariant(o, a)) throw new Error("variant mismatch");
        let j = 0;
        return this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout ? $[this.property] = this.layout.decode(o, a + j) : this.property ? $[this.property] = !0 : this.union.usesPrefixDiscriminator && ($[this.union.discriminator.property] = this.variant), $
    }
    encode(o, a, $ = 0) {
        let j = 0;
        if (this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(o, this.property)) throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, a, $);
        let _e = j;
        if (this.layout && (this.layout.encode(o[this.property], a, $ + j), _e += this.layout.getSpan(a, $ + j), 0 <= this.union.span && _e > this.union.span)) throw new Error("encoded variant overruns containing union");
        return _e
    }
    fromArray(o) {
        if (this.layout) return this.layout.fromArray(o)
    }
};
Layout$5.VariantLayout = VariantLayout$2;

function fixBitwiseResult$1(s) {
    return 0 > s && (s += 4294967296), s
}
let BitStructure$1 = class extends Layout$4 {
    constructor(o, a, $) {
        if (!(o instanceof UInt$2 || o instanceof UIntBE$2)) throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof a == "string" && $ === void 0 && ($ = a, a = !1), 4 < o.span) throw new RangeError("word cannot exceed 32 bits");
        super(o.span, $), this.word = o, this.msb = !!a, this.fields = [];
        let j = 0;
        this._packedSetValue = function(_e) {
            return j = fixBitwiseResult$1(_e), this
        }, this._packedGetValue = function() {
            return j
        }
    }
    decode(o, a = 0) {
        const $ = this.makeDestinationObject(),
            j = this.word.decode(o, a);
        this._packedSetValue(j);
        for (const _e of this.fields) _e.property !== void 0 && ($[_e.property] = _e.decode(o));
        return $
    }
    encode(o, a, $ = 0) {
        const j = this.word.decode(a, $);
        this._packedSetValue(j);
        for (const _e of this.fields)
            if (_e.property !== void 0) {
                const et = o[_e.property];
                et !== void 0 && _e.encode(et)
            }
        return this.word.encode(this._packedGetValue(), a, $)
    }
    addField(o, a) {
        const $ = new BitField$1(this, o, a);
        return this.fields.push($), $
    }
    addBoolean(o) {
        const a = new Boolean$2(this, o);
        return this.fields.push(a), a
    }
    fieldFor(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        for (const a of this.fields)
            if (a.property === o) return a
    }
};
Layout$5.BitStructure = BitStructure$1;
let BitField$1 = class {
    constructor(o, a, $) {
        if (!(o instanceof BitStructure$1)) throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(a) || 0 >= a) throw new TypeError("bits must be positive integer");
        const j = 8 * o.span,
            _e = o.fields.reduce((et, tt) => et + tt.bits, 0);
        if (a + _e > j) throw new Error("bits too long for span remainder (" + (j - _e) + " of " + j + " remain)");
        this.container = o, this.bits = a, this.valueMask = (1 << a) - 1, a === 32 && (this.valueMask = 4294967295), this.start = _e, this.container.msb && (this.start = j - _e - a), this.wordMask = fixBitwiseResult$1(this.valueMask << this.start), this.property = $
    }
    decode(o, a) {
        const $ = this.container._packedGetValue();
        return fixBitwiseResult$1($ & this.wordMask) >>> this.start
    }
    encode(o) {
        if (typeof o != "number" || !Number.isInteger(o) || o !== fixBitwiseResult$1(o & this.valueMask)) throw new TypeError(nameWithProperty$2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const a = this.container._packedGetValue(),
            $ = fixBitwiseResult$1(o << this.start);
        this.container._packedSetValue(fixBitwiseResult$1(a & ~this.wordMask) | $)
    }
};
Layout$5.BitField = BitField$1;
let Boolean$2 = class extends BitField$1 {
    constructor(o, a) {
        super(o, 1, a)
    }
    decode(o, a) {
        return !!super.decode(o, a)
    }
    encode(o) {
        typeof o == "boolean" && (o = +o), super.encode(o)
    }
};
Layout$5.Boolean = Boolean$2;
let Blob$3 = class extends Layout$4 {
    constructor(o, a) {
        if (!(o instanceof ExternalLayout$2 && o.isCount() || Number.isInteger(o) && 0 <= o)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let $ = -1;
        o instanceof ExternalLayout$2 || ($ = o), super($, a), this.length = o
    }
    getSpan(o, a) {
        let $ = this.span;
        return 0 > $ && ($ = this.length.decode(o, a)), $
    }
    decode(o, a = 0) {
        let $ = this.span;
        return 0 > $ && ($ = this.length.decode(o, a)), uint8ArrayToBuffer(o).slice(a, a + $)
    }
    encode(o, a, $) {
        let j = this.length;
        if (this.length instanceof ExternalLayout$2 && (j = o.length), !(o instanceof Uint8Array && j === o.length)) throw new TypeError(nameWithProperty$2("Blob.encode", this) + " requires (length " + j + ") Uint8Array as src");
        if ($ + j > a.length) throw new RangeError("encoding overruns Uint8Array");
        const _e = uint8ArrayToBuffer(o);
        return uint8ArrayToBuffer(a).write(_e.toString("hex"), $, j, "hex"), this.length instanceof ExternalLayout$2 && this.length.encode(j, a, $), j
    }
};
Layout$5.Blob = Blob$3;
let CString$1 = class extends Layout$4 {
    constructor(o) {
        super(-1, o)
    }
    getSpan(o, a = 0) {
        checkUint8Array(o);
        let $ = a;
        for (; $ < o.length && o[$] !== 0;) $ += 1;
        return 1 + $ - a
    }
    decode(o, a = 0) {
        const $ = this.getSpan(o, a);
        return uint8ArrayToBuffer(o).slice(a, a + $ - 1).toString("utf-8")
    }
    encode(o, a, $ = 0) {
        typeof o != "string" && (o = String(o));
        const j = buffer_1.Buffer.from(o, "utf8"),
            _e = j.length;
        if ($ + _e > a.length) throw new RangeError("encoding overruns Buffer");
        const et = uint8ArrayToBuffer(a);
        return j.copy(et, $), et[$ + _e] = 0, _e + 1
    }
};
Layout$5.CString = CString$1;
let UTF8$1 = class extends Layout$4 {
    constructor(o, a) {
        if (typeof o == "string" && a === void 0 && (a = o, o = void 0), o === void 0) o = -1;
        else if (!Number.isInteger(o)) throw new TypeError("maxSpan must be an integer");
        super(-1, a), this.maxSpan = o
    }
    getSpan(o, a = 0) {
        return checkUint8Array(o), o.length - a
    }
    decode(o, a = 0) {
        const $ = this.getSpan(o, a);
        if (0 <= this.maxSpan && this.maxSpan < $) throw new RangeError("text length exceeds maxSpan");
        return uint8ArrayToBuffer(o).slice(a, a + $).toString("utf-8")
    }
    encode(o, a, $ = 0) {
        typeof o != "string" && (o = String(o));
        const j = buffer_1.Buffer.from(o, "utf8"),
            _e = j.length;
        if (0 <= this.maxSpan && this.maxSpan < _e) throw new RangeError("text length exceeds maxSpan");
        if ($ + _e > a.length) throw new RangeError("encoding overruns Buffer");
        return j.copy(uint8ArrayToBuffer(a), $), _e
    }
};
Layout$5.UTF8 = UTF8$1;
let Constant$1 = class extends Layout$4 {
    constructor(o, a) {
        super(0, a), this.value = o
    }
    decode(o, a) {
        return this.value
    }
    encode(o, a, $) {
        return 0
    }
};
Layout$5.Constant = Constant$1;
Layout$5.greedy = (s, o) => new GreedyCount$1(s, o);
var offset$1 = Layout$5.offset = (s, o, a) => new OffsetLayout$2(s, o, a),
    u8$1 = Layout$5.u8 = s => new UInt$2(1, s),
    u16 = Layout$5.u16 = s => new UInt$2(2, s);
Layout$5.u24 = s => new UInt$2(3, s);
var u32$1 = Layout$5.u32 = s => new UInt$2(4, s);
Layout$5.u40 = s => new UInt$2(5, s);
Layout$5.u48 = s => new UInt$2(6, s);
var nu64$1 = Layout$5.nu64 = s => new NearUInt64$2(s);
Layout$5.u16be = s => new UIntBE$2(2, s);
Layout$5.u24be = s => new UIntBE$2(3, s);
Layout$5.u32be = s => new UIntBE$2(4, s);
Layout$5.u40be = s => new UIntBE$2(5, s);
Layout$5.u48be = s => new UIntBE$2(6, s);
Layout$5.nu64be = s => new NearUInt64BE$1(s);
Layout$5.s8 = s => new Int$1(1, s);
Layout$5.s16 = s => new Int$1(2, s);
Layout$5.s24 = s => new Int$1(3, s);
Layout$5.s32 = s => new Int$1(4, s);
Layout$5.s40 = s => new Int$1(5, s);
Layout$5.s48 = s => new Int$1(6, s);
var ns64$1 = Layout$5.ns64 = s => new NearInt64$2(s);
Layout$5.s16be = s => new IntBE$1(2, s);
Layout$5.s24be = s => new IntBE$1(3, s);
Layout$5.s32be = s => new IntBE$1(4, s);
Layout$5.s40be = s => new IntBE$1(5, s);
Layout$5.s48be = s => new IntBE$1(6, s);
Layout$5.ns64be = s => new NearInt64BE$1(s);
Layout$5.f32 = s => new Float$1(s);
Layout$5.f32be = s => new FloatBE$1(s);
Layout$5.f64 = s => new Double$1(s);
Layout$5.f64be = s => new DoubleBE$1(s);
var struct$1 = Layout$5.struct = (s, o, a) => new Structure$2(s, o, a);
Layout$5.bits = (s, o, a) => new BitStructure$1(s, o, a);
var seq = Layout$5.seq = (s, o, a) => new Sequence$1(s, o, a);
Layout$5.union = (s, o, a) => new Union$2(s, o, a);
Layout$5.unionLayoutDiscriminator = (s, o) => new UnionLayoutDiscriminator$2(s, o);
var blob$1 = Layout$5.blob = (s, o) => new Blob$3(s, o);
Layout$5.cstr = s => new CString$1(s);
Layout$5.utf8 = (s, o) => new UTF8$1(s, o);
Layout$5.constant = (s, o) => new Constant$1(s, o);
var browser$2 = {};
Object.defineProperty(browser$2, "__esModule", {
    value: !0
});

function toBigIntLE(s) {
    {
        const o = Buffer.from(s);
        o.reverse();
        const a = o.toString("hex");
        return a.length === 0 ? BigInt(0) : BigInt(`0x${a}`)
    }
}
var toBigIntLE_1 = browser$2.toBigIntLE = toBigIntLE;

function toBigIntBE(s) {
    {
        const o = s.toString("hex");
        return o.length === 0 ? BigInt(0) : BigInt(`0x${o}`)
    }
}
browser$2.toBigIntBE = toBigIntBE;

function toBufferLE(s, o) {
    {
        const a = s.toString(16),
            $ = Buffer.from(a.padStart(o * 2, "0").slice(0, o * 2), "hex");
        return $.reverse(), $
    }
}
var toBufferLE_1 = browser$2.toBufferLE = toBufferLE;

function toBufferBE(s, o) {
    {
        const a = s.toString(16);
        return Buffer.from(a.padStart(o * 2, "0").slice(0, o * 2), "hex")
    }
}
browser$2.toBufferBE = toBufferBE;
let StructError$1 = class extends TypeError {
    constructor(o, a) {
        let $;
        const {
            message: j,
            explanation: _e,
            ...et
        } = o, {
            path: tt
        } = o, nt = tt.length === 0 ? j : `At path: ${tt.join(".")} -- ${j}`;
        super(_e ? ? nt), _e != null && (this.cause = nt), Object.assign(this, et), this.name = this.constructor.name, this.failures = () => $ ? ? ($ = [o, ...a()])
    }
};

function isIterable$1(s) {
    return isObject$1(s) && typeof s[Symbol.iterator] == "function"
}

function isObject$1(s) {
    return typeof s == "object" && s != null
}

function isNonArrayObject(s) {
    return isObject$1(s) && !Array.isArray(s)
}

function print$1(s) {
    return typeof s == "symbol" ? s.toString() : typeof s == "string" ? JSON.stringify(s) : `${s}`
}

function shiftIterator$1(s) {
    const {
        done: o,
        value: a
    } = s.next();
    return o ? void 0 : a
}

function toFailure$1(s, o, a, $) {
    if (s === !0) return;
    s === !1 ? s = {} : typeof s == "string" && (s = {
        message: s
    });
    const {
        path: j,
        branch: _e
    } = o, {
        type: et
    } = a, {
        refinement: tt,
        message: nt = `Expected a value of type \`${et}\`${tt?` with refinement \`${tt}\``:""}, but received: \`${print$1($)}\``
    } = s;
    return {
        value: $,
        type: et,
        refinement: tt,
        key: j[j.length - 1],
        path: j,
        branch: _e,
        ...s,
        message: nt
    }
}

function* toFailures$1(s, o, a, $) {
    isIterable$1(s) || (s = [s]);
    for (const j of s) {
        const _e = toFailure$1(j, o, a, $);
        _e && (yield _e)
    }
}

function* run$1(s, o, a = {}) {
    const {
        path: $ = [],
        branch: j = [s],
        coerce: _e = !1,
        mask: et = !1
    } = a, tt = {
        path: $,
        branch: j,
        mask: et
    };
    _e && (s = o.coercer(s, tt));
    let nt = "valid";
    for (const rt of o.validator(s, tt)) rt.explanation = a.message, nt = "not_valid", yield [rt, void 0];
    for (let [rt, ot, st] of o.entries(s, tt)) {
        const lt = run$1(ot, st, {
            path: rt === void 0 ? $ : [...$, rt],
            branch: rt === void 0 ? j : [...j, ot],
            coerce: _e,
            mask: et,
            message: a.message
        });
        for (const ft of lt) ft[0] ? (nt = ft[0].refinement != null ? "not_refined" : "not_valid", yield [ft[0], void 0]) : _e && (ot = ft[1], rt === void 0 ? s = ot : s instanceof Map ? s.set(rt, ot) : s instanceof Set ? s.add(ot) : isObject$1(s) && (ot !== void 0 || rt in s) && (s[rt] = ot))
    }
    if (nt !== "not_valid")
        for (const rt of o.refiner(s, tt)) rt.explanation = a.message, nt = "not_refined", yield [rt, void 0];
    nt === "valid" && (yield [void 0, s])
}
let Struct$2 = class {
    constructor(o) {
        const {
            type: a,
            schema: $,
            validator: j,
            refiner: _e,
            coercer: et = nt => nt,
            entries: tt = function*() {}
        } = o;
        this.type = a, this.schema = $, this.entries = tt, this.coercer = et, j ? this.validator = (nt, rt) => {
            const ot = j(nt, rt);
            return toFailures$1(ot, rt, this, nt)
        } : this.validator = () => [], _e ? this.refiner = (nt, rt) => {
            const ot = _e(nt, rt);
            return toFailures$1(ot, rt, this, nt)
        } : this.refiner = () => []
    }
    assert(o, a) {
        return assert$3(o, this, a)
    }
    create(o, a) {
        return create$1(o, this, a)
    }
    is(o) {
        return is$1(o, this)
    }
    mask(o, a) {
        return mask$1(o, this, a)
    }
    validate(o, a = {}) {
        return validate$2(o, this, a)
    }
};

function assert$3(s, o, a) {
    const $ = validate$2(s, o, {
        message: a
    });
    if ($[0]) throw $[0]
}

function create$1(s, o, a) {
    const $ = validate$2(s, o, {
        coerce: !0,
        message: a
    });
    if ($[0]) throw $[0];
    return $[1]
}

function mask$1(s, o, a) {
    const $ = validate$2(s, o, {
        coerce: !0,
        mask: !0,
        message: a
    });
    if ($[0]) throw $[0];
    return $[1]
}

function is$1(s, o) {
    return !validate$2(s, o)[0]
}

function validate$2(s, o, a = {}) {
    const $ = run$1(s, o, a),
        j = shiftIterator$1($);
    return j[0] ? [new StructError$1(j[0], function*() {
        for (const et of $) et[0] && (yield et[0])
    }), void 0] : [void 0, j[1]]
}

function define$2(s, o) {
    return new Struct$2({
        type: s,
        schema: null,
        validator: o
    })
}

function any$1() {
    return define$2("any", () => !0)
}

function array$1(s) {
    return new Struct$2({
        type: "array",
        schema: s,
        * entries(o) {
            if (s && Array.isArray(o))
                for (const [a, $] of o.entries()) yield [a, $, s]
        },
        coercer(o) {
            return Array.isArray(o) ? o.slice() : o
        },
        validator(o) {
            return Array.isArray(o) || `Expected an array value, but received: ${print$1(o)}`
        }
    })
}

function boolean$1() {
    return define$2("boolean", s => typeof s == "boolean")
}

function instance(s) {
    return define$2("instance", o => o instanceof s || `Expected a \`${s.name}\` instance, but received: ${print$1(o)}`)
}

function literal$1(s) {
    const o = print$1(s),
        a = typeof s;
    return new Struct$2({
        type: "literal",
        schema: a === "string" || a === "number" || a === "boolean" ? s : null,
        validator($) {
            return $ === s || `Expected the literal \`${o}\`, but received: ${print$1($)}`
        }
    })
}

function never() {
    return define$2("never", () => !1)
}

function nullable$1(s) {
    return new Struct$2({ ...s,
        validator: (o, a) => o === null || s.validator(o, a),
        refiner: (o, a) => o === null || s.refiner(o, a)
    })
}

function number$1() {
    return define$2("number", s => typeof s == "number" && !isNaN(s) || `Expected a number, but received: ${print$1(s)}`)
}

function optional$1(s) {
    return new Struct$2({ ...s,
        validator: (o, a) => o === void 0 || s.validator(o, a),
        refiner: (o, a) => o === void 0 || s.refiner(o, a)
    })
}

function record(s, o) {
    return new Struct$2({
        type: "record",
        schema: null,
        * entries(a) {
            if (isObject$1(a))
                for (const $ in a) {
                    const j = a[$];
                    yield [$, $, s], yield [$, j, o]
                }
        },
        validator(a) {
            return isNonArrayObject(a) || `Expected an object, but received: ${print$1(a)}`
        },
        coercer(a) {
            return isNonArrayObject(a) ? { ...a
            } : a
        }
    })
}

function string$1() {
    return define$2("string", s => typeof s == "string" || `Expected a string, but received: ${print$1(s)}`)
}

function tuple(s) {
    const o = never();
    return new Struct$2({
        type: "tuple",
        schema: null,
        * entries(a) {
            if (Array.isArray(a)) {
                const $ = Math.max(s.length, a.length);
                for (let j = 0; j < $; j++) yield [j, a[j], s[j] || o]
            }
        },
        validator(a) {
            return Array.isArray(a) || `Expected an array, but received: ${print$1(a)}`
        },
        coercer(a) {
            return Array.isArray(a) ? a.slice() : a
        }
    })
}

function type$2(s) {
    const o = Object.keys(s);
    return new Struct$2({
        type: "type",
        schema: s,
        * entries(a) {
            if (isObject$1(a))
                for (const $ of o) yield [$, a[$], s[$]]
        },
        validator(a) {
            return isNonArrayObject(a) || `Expected an object, but received: ${print$1(a)}`
        },
        coercer(a) {
            return isNonArrayObject(a) ? { ...a
            } : a
        }
    })
}

function union$2(s) {
    const o = s.map(a => a.type).join(" | ");
    return new Struct$2({
        type: "union",
        schema: null,
        coercer(a, $) {
            for (const j of s) {
                const [_e, et] = j.validate(a, {
                    coerce: !0,
                    mask: $.mask
                });
                if (!_e) return et
            }
            return a
        },
        validator(a, $) {
            const j = [];
            for (const _e of s) {
                const [...et] = run$1(a, _e, $), [tt] = et;
                if (tt[0])
                    for (const [nt] of et) nt && j.push(nt);
                else return []
            }
            return [`Expected the value to satisfy a union of \`${o}\`, but received: ${print$1(a)}`, ...j]
        }
    })
}

function unknown$1() {
    return define$2("unknown", () => !0)
}

function coerce$1(s, o, a) {
    return new Struct$2({ ...s,
        coercer: ($, j) => is$1($, o) ? s.coercer(a($, j), j) : s.coercer($, j)
    })
}
var getRandomValues, rnds8 = new Uint8Array(16);

function rng() {
    if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return getRandomValues(rnds8)
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate$1(s) {
    return typeof s == "string" && REGEX.test(s)
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));

function stringify$1(s) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        a = (byteToHex[s[o + 0]] + byteToHex[s[o + 1]] + byteToHex[s[o + 2]] + byteToHex[s[o + 3]] + "-" + byteToHex[s[o + 4]] + byteToHex[s[o + 5]] + "-" + byteToHex[s[o + 6]] + byteToHex[s[o + 7]] + "-" + byteToHex[s[o + 8]] + byteToHex[s[o + 9]] + "-" + byteToHex[s[o + 10]] + byteToHex[s[o + 11]] + byteToHex[s[o + 12]] + byteToHex[s[o + 13]] + byteToHex[s[o + 14]] + byteToHex[s[o + 15]]).toLowerCase();
    if (!validate$1(a)) throw TypeError("Stringified UUID is invalid");
    return a
}
var _nodeId, _clockseq, _lastMSecs = 0,
    _lastNSecs = 0;

function v1(s, o, a) {
    var $ = o && a || 0,
        j = o || new Array(16);
    s = s || {};
    var _e = s.node || _nodeId,
        et = s.clockseq !== void 0 ? s.clockseq : _clockseq;
    if (_e == null || et == null) {
        var tt = s.random || (s.rng || rng)();
        _e == null && (_e = _nodeId = [tt[0] | 1, tt[1], tt[2], tt[3], tt[4], tt[5]]), et == null && (et = _clockseq = (tt[6] << 8 | tt[7]) & 16383)
    }
    var nt = s.msecs !== void 0 ? s.msecs : Date.now(),
        rt = s.nsecs !== void 0 ? s.nsecs : _lastNSecs + 1,
        ot = nt - _lastMSecs + (rt - _lastNSecs) / 1e4;
    if (ot < 0 && s.clockseq === void 0 && (et = et + 1 & 16383), (ot < 0 || nt > _lastMSecs) && s.nsecs === void 0 && (rt = 0), rt >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = nt, _lastNSecs = rt, _clockseq = et, nt += 122192928e5;
    var st = ((nt & 268435455) * 1e4 + rt) % 4294967296;
    j[$++] = st >>> 24 & 255, j[$++] = st >>> 16 & 255, j[$++] = st >>> 8 & 255, j[$++] = st & 255;
    var lt = nt / 4294967296 * 1e4 & 268435455;
    j[$++] = lt >>> 8 & 255, j[$++] = lt & 255, j[$++] = lt >>> 24 & 15 | 16, j[$++] = lt >>> 16 & 255, j[$++] = et >>> 8 | 128, j[$++] = et & 255;
    for (var ft = 0; ft < 6; ++ft) j[$ + ft] = _e[ft];
    return o || stringify$1(j)
}

function parse(s) {
    if (!validate$1(s)) throw TypeError("Invalid UUID");
    var o, a = new Uint8Array(16);
    return a[0] = (o = parseInt(s.slice(0, 8), 16)) >>> 24, a[1] = o >>> 16 & 255, a[2] = o >>> 8 & 255, a[3] = o & 255, a[4] = (o = parseInt(s.slice(9, 13), 16)) >>> 8, a[5] = o & 255, a[6] = (o = parseInt(s.slice(14, 18), 16)) >>> 8, a[7] = o & 255, a[8] = (o = parseInt(s.slice(19, 23), 16)) >>> 8, a[9] = o & 255, a[10] = (o = parseInt(s.slice(24, 36), 16)) / 1099511627776 & 255, a[11] = o / 4294967296 & 255, a[12] = o >>> 24 & 255, a[13] = o >>> 16 & 255, a[14] = o >>> 8 & 255, a[15] = o & 255, a
}

function stringToBytes(s) {
    s = unescape(encodeURIComponent(s));
    for (var o = [], a = 0; a < s.length; ++a) o.push(s.charCodeAt(a));
    return o
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";

function v35(s, o, a) {
    function $(j, _e, et, tt) {
        if (typeof j == "string" && (j = stringToBytes(j)), typeof _e == "string" && (_e = parse(_e)), _e.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var nt = new Uint8Array(16 + j.length);
        if (nt.set(_e), nt.set(j, _e.length), nt = a(nt), nt[6] = nt[6] & 15 | o, nt[8] = nt[8] & 63 | 128, et) {
            tt = tt || 0;
            for (var rt = 0; rt < 16; ++rt) et[tt + rt] = nt[rt];
            return et
        }
        return stringify$1(nt)
    }
    try {
        $.name = s
    } catch {}
    return $.DNS = DNS, $.URL = URL$1, $
}

function md5(s) {
    if (typeof s == "string") {
        var o = unescape(encodeURIComponent(s));
        s = new Uint8Array(o.length);
        for (var a = 0; a < o.length; ++a) s[a] = o.charCodeAt(a)
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(s), s.length * 8))
}

function md5ToHexEncodedArray(s) {
    for (var o = [], a = s.length * 32, $ = "0123456789abcdef", j = 0; j < a; j += 8) {
        var _e = s[j >> 5] >>> j % 32 & 255,
            et = parseInt($.charAt(_e >>> 4 & 15) + $.charAt(_e & 15), 16);
        o.push(et)
    }
    return o
}

function getOutputLength(s) {
    return (s + 64 >>> 9 << 4) + 14 + 1
}

function wordsToMd5(s, o) {
    s[o >> 5] |= 128 << o % 32, s[getOutputLength(o) - 1] = o;
    for (var a = 1732584193, $ = -271733879, j = -1732584194, _e = 271733878, et = 0; et < s.length; et += 16) {
        var tt = a,
            nt = $,
            rt = j,
            ot = _e;
        a = md5ff(a, $, j, _e, s[et], 7, -680876936), _e = md5ff(_e, a, $, j, s[et + 1], 12, -389564586), j = md5ff(j, _e, a, $, s[et + 2], 17, 606105819), $ = md5ff($, j, _e, a, s[et + 3], 22, -1044525330), a = md5ff(a, $, j, _e, s[et + 4], 7, -176418897), _e = md5ff(_e, a, $, j, s[et + 5], 12, 1200080426), j = md5ff(j, _e, a, $, s[et + 6], 17, -1473231341), $ = md5ff($, j, _e, a, s[et + 7], 22, -45705983), a = md5ff(a, $, j, _e, s[et + 8], 7, 1770035416), _e = md5ff(_e, a, $, j, s[et + 9], 12, -1958414417), j = md5ff(j, _e, a, $, s[et + 10], 17, -42063), $ = md5ff($, j, _e, a, s[et + 11], 22, -1990404162), a = md5ff(a, $, j, _e, s[et + 12], 7, 1804603682), _e = md5ff(_e, a, $, j, s[et + 13], 12, -40341101), j = md5ff(j, _e, a, $, s[et + 14], 17, -1502002290), $ = md5ff($, j, _e, a, s[et + 15], 22, 1236535329), a = md5gg(a, $, j, _e, s[et + 1], 5, -165796510), _e = md5gg(_e, a, $, j, s[et + 6], 9, -1069501632), j = md5gg(j, _e, a, $, s[et + 11], 14, 643717713), $ = md5gg($, j, _e, a, s[et], 20, -373897302), a = md5gg(a, $, j, _e, s[et + 5], 5, -701558691), _e = md5gg(_e, a, $, j, s[et + 10], 9, 38016083), j = md5gg(j, _e, a, $, s[et + 15], 14, -660478335), $ = md5gg($, j, _e, a, s[et + 4], 20, -405537848), a = md5gg(a, $, j, _e, s[et + 9], 5, 568446438), _e = md5gg(_e, a, $, j, s[et + 14], 9, -1019803690), j = md5gg(j, _e, a, $, s[et + 3], 14, -187363961), $ = md5gg($, j, _e, a, s[et + 8], 20, 1163531501), a = md5gg(a, $, j, _e, s[et + 13], 5, -1444681467), _e = md5gg(_e, a, $, j, s[et + 2], 9, -51403784), j = md5gg(j, _e, a, $, s[et + 7], 14, 1735328473), $ = md5gg($, j, _e, a, s[et + 12], 20, -1926607734), a = md5hh(a, $, j, _e, s[et + 5], 4, -378558), _e = md5hh(_e, a, $, j, s[et + 8], 11, -2022574463), j = md5hh(j, _e, a, $, s[et + 11], 16, 1839030562), $ = md5hh($, j, _e, a, s[et + 14], 23, -35309556), a = md5hh(a, $, j, _e, s[et + 1], 4, -1530992060), _e = md5hh(_e, a, $, j, s[et + 4], 11, 1272893353), j = md5hh(j, _e, a, $, s[et + 7], 16, -155497632), $ = md5hh($, j, _e, a, s[et + 10], 23, -1094730640), a = md5hh(a, $, j, _e, s[et + 13], 4, 681279174), _e = md5hh(_e, a, $, j, s[et], 11, -358537222), j = md5hh(j, _e, a, $, s[et + 3], 16, -722521979), $ = md5hh($, j, _e, a, s[et + 6], 23, 76029189), a = md5hh(a, $, j, _e, s[et + 9], 4, -640364487), _e = md5hh(_e, a, $, j, s[et + 12], 11, -421815835), j = md5hh(j, _e, a, $, s[et + 15], 16, 530742520), $ = md5hh($, j, _e, a, s[et + 2], 23, -995338651), a = md5ii(a, $, j, _e, s[et], 6, -198630844), _e = md5ii(_e, a, $, j, s[et + 7], 10, 1126891415), j = md5ii(j, _e, a, $, s[et + 14], 15, -1416354905), $ = md5ii($, j, _e, a, s[et + 5], 21, -57434055), a = md5ii(a, $, j, _e, s[et + 12], 6, 1700485571), _e = md5ii(_e, a, $, j, s[et + 3], 10, -1894986606), j = md5ii(j, _e, a, $, s[et + 10], 15, -1051523), $ = md5ii($, j, _e, a, s[et + 1], 21, -2054922799), a = md5ii(a, $, j, _e, s[et + 8], 6, 1873313359), _e = md5ii(_e, a, $, j, s[et + 15], 10, -30611744), j = md5ii(j, _e, a, $, s[et + 6], 15, -1560198380), $ = md5ii($, j, _e, a, s[et + 13], 21, 1309151649), a = md5ii(a, $, j, _e, s[et + 4], 6, -145523070), _e = md5ii(_e, a, $, j, s[et + 11], 10, -1120210379), j = md5ii(j, _e, a, $, s[et + 2], 15, 718787259), $ = md5ii($, j, _e, a, s[et + 9], 21, -343485551), a = safeAdd(a, tt), $ = safeAdd($, nt), j = safeAdd(j, rt), _e = safeAdd(_e, ot)
    }
    return [a, $, j, _e]
}

function bytesToWords(s) {
    if (s.length === 0) return [];
    for (var o = s.length * 8, a = new Uint32Array(getOutputLength(o)), $ = 0; $ < o; $ += 8) a[$ >> 5] |= (s[$ / 8] & 255) << $ % 32;
    return a
}

function safeAdd(s, o) {
    var a = (s & 65535) + (o & 65535),
        $ = (s >> 16) + (o >> 16) + (a >> 16);
    return $ << 16 | a & 65535
}

function bitRotateLeft(s, o) {
    return s << o | s >>> 32 - o
}

function md5cmn(s, o, a, $, j, _e) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(o, s), safeAdd($, _e)), j), a)
}

function md5ff(s, o, a, $, j, _e, et) {
    return md5cmn(o & a | ~o & $, s, o, j, _e, et)
}

function md5gg(s, o, a, $, j, _e, et) {
    return md5cmn(o & $ | a & ~$, s, o, j, _e, et)
}

function md5hh(s, o, a, $, j, _e, et) {
    return md5cmn(o ^ a ^ $, s, o, j, _e, et)
}

function md5ii(s, o, a, $, j, _e, et) {
    return md5cmn(a ^ (o | ~$), s, o, j, _e, et)
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;

function v4(s, o, a) {
    s = s || {};
    var $ = s.random || (s.rng || rng)();
    if ($[6] = $[6] & 15 | 64, $[8] = $[8] & 63 | 128, o) {
        a = a || 0;
        for (var j = 0; j < 16; ++j) o[a + j] = $[j];
        return o
    }
    return stringify$1($)
}

function f(s, o, a, $) {
    switch (s) {
        case 0:
            return o & a ^ ~o & $;
        case 1:
            return o ^ a ^ $;
        case 2:
            return o & a ^ o & $ ^ a & $;
        case 3:
            return o ^ a ^ $
    }
}

function ROTL(s, o) {
    return s << o | s >>> 32 - o
}

function sha1(s) {
    var o = [1518500249, 1859775393, 2400959708, 3395469782],
        a = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof s == "string") {
        var $ = unescape(encodeURIComponent(s));
        s = [];
        for (var j = 0; j < $.length; ++j) s.push($.charCodeAt(j))
    } else Array.isArray(s) || (s = Array.prototype.slice.call(s));
    s.push(128);
    for (var _e = s.length / 4 + 2, et = Math.ceil(_e / 16), tt = new Array(et), nt = 0; nt < et; ++nt) {
        for (var rt = new Uint32Array(16), ot = 0; ot < 16; ++ot) rt[ot] = s[nt * 64 + ot * 4] << 24 | s[nt * 64 + ot * 4 + 1] << 16 | s[nt * 64 + ot * 4 + 2] << 8 | s[nt * 64 + ot * 4 + 3];
        tt[nt] = rt
    }
    tt[et - 1][14] = (s.length - 1) * 8 / Math.pow(2, 32), tt[et - 1][14] = Math.floor(tt[et - 1][14]), tt[et - 1][15] = (s.length - 1) * 8 & 4294967295;
    for (var st = 0; st < et; ++st) {
        for (var lt = new Uint32Array(80), ft = 0; ft < 16; ++ft) lt[ft] = tt[st][ft];
        for (var yt = 16; yt < 80; ++yt) lt[yt] = ROTL(lt[yt - 3] ^ lt[yt - 8] ^ lt[yt - 14] ^ lt[yt - 16], 1);
        for (var bt = a[0], ht = a[1], vt = a[2], wt = a[3], gt = a[4], At = 0; At < 80; ++At) {
            var Pt = Math.floor(At / 20),
                Bt = ROTL(bt, 5) + f(Pt, ht, vt, wt) + gt + o[Pt] + lt[At] >>> 0;
            gt = wt, wt = vt, vt = ROTL(ht, 30) >>> 0, ht = bt, bt = Bt
        }
        a[0] = a[0] + bt >>> 0, a[1] = a[1] + ht >>> 0, a[2] = a[2] + vt >>> 0, a[3] = a[3] + wt >>> 0, a[4] = a[4] + gt >>> 0
    }
    return [a[0] >> 24 & 255, a[0] >> 16 & 255, a[0] >> 8 & 255, a[0] & 255, a[1] >> 24 & 255, a[1] >> 16 & 255, a[1] >> 8 & 255, a[1] & 255, a[2] >> 24 & 255, a[2] >> 16 & 255, a[2] >> 8 & 255, a[2] & 255, a[3] >> 24 & 255, a[3] >> 16 & 255, a[3] >> 8 & 255, a[3] & 255, a[4] >> 24 & 255, a[4] >> 16 & 255, a[4] >> 8 & 255, a[4] & 255]
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5,
    nil = "00000000-0000-0000-0000-000000000000";

function version(s) {
    if (!validate$1(s)) throw TypeError("Invalid UUID");
    return parseInt(s.substr(14, 1), 16)
}
const esmBrowser = Object.freeze(Object.defineProperty({
        __proto__: null,
        NIL: nil,
        parse,
        stringify: stringify$1,
        v1,
        v3: v3$1,
        v4,
        v5: v5$1,
        validate: validate$1,
        version
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    require$$0 = getAugmentedNamespace(esmBrowser),
    uuid$1 = require$$0.v4,
    generateRequest$1 = function(s, o, a, $) {
        if (typeof s != "string") throw new TypeError(s + " must be a string");
        $ = $ || {};
        const j = typeof $.version == "number" ? $.version : 2;
        if (j !== 1 && j !== 2) throw new TypeError(j + " must be 1 or 2");
        const _e = {
            method: s
        };
        if (j === 2 && (_e.jsonrpc = "2.0"), o) {
            if (typeof o != "object" && !Array.isArray(o)) throw new TypeError(o + " must be an object, array or omitted");
            _e.params = o
        }
        if (typeof a > "u") {
            const et = typeof $.generator == "function" ? $.generator : function() {
                return uuid$1()
            };
            _e.id = et(_e, $)
        } else j === 2 && a === null ? $.notificationIdNull && (_e.id = null) : _e.id = a;
        return _e
    };
var generateRequest_1 = generateRequest$1;
const uuid = require$$0.v4,
    generateRequest = generateRequest_1,
    ClientBrowser = function(s, o) {
        if (!(this instanceof ClientBrowser)) return new ClientBrowser(s, o);
        o || (o = {}), this.options = {
            reviver: typeof o.reviver < "u" ? o.reviver : null,
            replacer: typeof o.replacer < "u" ? o.replacer : null,
            generator: typeof o.generator < "u" ? o.generator : function() {
                return uuid()
            },
            version: typeof o.version < "u" ? o.version : 2,
            notificationIdNull: typeof o.notificationIdNull == "boolean" ? o.notificationIdNull : !1
        }, this.callServer = s
    };
var browser$1 = ClientBrowser;
ClientBrowser.prototype.request = function(s, o, a, $) {
    const j = this;
    let _e = null;
    const et = Array.isArray(s) && typeof o == "function";
    if (this.options.version === 1 && et) throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (et || !et && s && typeof s == "object" && typeof o == "function") $ = o, _e = s;
    else {
        typeof a == "function" && ($ = a, a = void 0);
        const rt = typeof $ == "function";
        try {
            _e = generateRequest(s, o, a, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            })
        } catch (ot) {
            if (rt) return $(ot);
            throw ot
        }
        if (!rt) return _e
    }
    let nt;
    try {
        nt = JSON.stringify(_e, this.options.replacer)
    } catch (rt) {
        return $(rt)
    }
    return this.callServer(nt, function(rt, ot) {
        j._parseResponse(rt, ot, $)
    }), _e
};
ClientBrowser.prototype._parseResponse = function(s, o, a) {
    if (s) {
        a(s);
        return
    }
    if (!o) return a();
    let $;
    try {
        $ = JSON.parse(o, this.options.reviver)
    } catch (j) {
        return a(j)
    }
    if (a.length === 3)
        if (Array.isArray($)) {
            const j = function(et) {
                    return typeof et.error < "u"
                },
                _e = function(et) {
                    return !j(et)
                };
            return a(null, $.filter(j), $.filter(_e))
        } else return a(null, $.error, $.result);
    a(null, $)
};
const RpcClient = getDefaultExportFromCjs$3(browser$1);
var eventemitter3$1 = {
    exports: {}
};
(function(s) {
    var o = Object.prototype.hasOwnProperty,
        a = "~";

    function $() {}
    Object.create && ($.prototype = Object.create(null), new $().__proto__ || (a = !1));

    function j(nt, rt, ot) {
        this.fn = nt, this.context = rt, this.once = ot || !1
    }

    function _e(nt, rt, ot, st, lt) {
        if (typeof ot != "function") throw new TypeError("The listener must be a function");
        var ft = new j(ot, st || nt, lt),
            yt = a ? a + rt : rt;
        return nt._events[yt] ? nt._events[yt].fn ? nt._events[yt] = [nt._events[yt], ft] : nt._events[yt].push(ft) : (nt._events[yt] = ft, nt._eventsCount++), nt
    }

    function et(nt, rt) {
        --nt._eventsCount === 0 ? nt._events = new $ : delete nt._events[rt]
    }

    function tt() {
        this._events = new $, this._eventsCount = 0
    }
    tt.prototype.eventNames = function() {
        var rt = [],
            ot, st;
        if (this._eventsCount === 0) return rt;
        for (st in ot = this._events) o.call(ot, st) && rt.push(a ? st.slice(1) : st);
        return Object.getOwnPropertySymbols ? rt.concat(Object.getOwnPropertySymbols(ot)) : rt
    }, tt.prototype.listeners = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        if (!st) return [];
        if (st.fn) return [st.fn];
        for (var lt = 0, ft = st.length, yt = new Array(ft); lt < ft; lt++) yt[lt] = st[lt].fn;
        return yt
    }, tt.prototype.listenerCount = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        return st ? st.fn ? 1 : st.length : 0
    }, tt.prototype.emit = function(rt, ot, st, lt, ft, yt) {
        var bt = a ? a + rt : rt;
        if (!this._events[bt]) return !1;
        var ht = this._events[bt],
            vt = arguments.length,
            wt, gt;
        if (ht.fn) {
            switch (ht.once && this.removeListener(rt, ht.fn, void 0, !0), vt) {
                case 1:
                    return ht.fn.call(ht.context), !0;
                case 2:
                    return ht.fn.call(ht.context, ot), !0;
                case 3:
                    return ht.fn.call(ht.context, ot, st), !0;
                case 4:
                    return ht.fn.call(ht.context, ot, st, lt), !0;
                case 5:
                    return ht.fn.call(ht.context, ot, st, lt, ft), !0;
                case 6:
                    return ht.fn.call(ht.context, ot, st, lt, ft, yt), !0
            }
            for (gt = 1, wt = new Array(vt - 1); gt < vt; gt++) wt[gt - 1] = arguments[gt];
            ht.fn.apply(ht.context, wt)
        } else {
            var At = ht.length,
                Pt;
            for (gt = 0; gt < At; gt++) switch (ht[gt].once && this.removeListener(rt, ht[gt].fn, void 0, !0), vt) {
                case 1:
                    ht[gt].fn.call(ht[gt].context);
                    break;
                case 2:
                    ht[gt].fn.call(ht[gt].context, ot);
                    break;
                case 3:
                    ht[gt].fn.call(ht[gt].context, ot, st);
                    break;
                case 4:
                    ht[gt].fn.call(ht[gt].context, ot, st, lt);
                    break;
                default:
                    if (!wt)
                        for (Pt = 1, wt = new Array(vt - 1); Pt < vt; Pt++) wt[Pt - 1] = arguments[Pt];
                    ht[gt].fn.apply(ht[gt].context, wt)
            }
        }
        return !0
    }, tt.prototype.on = function(rt, ot, st) {
        return _e(this, rt, ot, st, !1)
    }, tt.prototype.once = function(rt, ot, st) {
        return _e(this, rt, ot, st, !0)
    }, tt.prototype.removeListener = function(rt, ot, st, lt) {
        var ft = a ? a + rt : rt;
        if (!this._events[ft]) return this;
        if (!ot) return et(this, ft), this;
        var yt = this._events[ft];
        if (yt.fn) yt.fn === ot && (!lt || yt.once) && (!st || yt.context === st) && et(this, ft);
        else {
            for (var bt = 0, ht = [], vt = yt.length; bt < vt; bt++)(yt[bt].fn !== ot || lt && !yt[bt].once || st && yt[bt].context !== st) && ht.push(yt[bt]);
            ht.length ? this._events[ft] = ht.length === 1 ? ht[0] : ht : et(this, ft)
        }
        return this
    }, tt.prototype.removeAllListeners = function(rt) {
        var ot;
        return rt ? (ot = a ? a + rt : rt, this._events[ot] && et(this, ot)) : (this._events = new $, this._eventsCount = 0), this
    }, tt.prototype.off = tt.prototype.removeListener, tt.prototype.addListener = tt.prototype.on, tt.prefixed = a, tt.EventEmitter = tt, s.exports = tt
})(eventemitter3$1);
var eventemitter3Exports$1 = eventemitter3$1.exports;
const EventEmitter$1 = getDefaultExportFromCjs$3(eventemitter3Exports$1);
var WebSocketBrowserImpl = class extends EventEmitter$1 {
    constructor(o, a, $) {
        super();
        jn(this, "socket");
        this.socket = new window.WebSocket(o, $), this.socket.onopen = () => this.emit("open"), this.socket.onmessage = j => this.emit("message", j.data), this.socket.onerror = j => this.emit("error", j), this.socket.onclose = j => {
            this.emit("close", j.code, j.reason)
        }
    }
    send(o, a, $) {
        const j = $ || a;
        try {
            this.socket.send(o), j()
        } catch (_e) {
            j(_e)
        }
    }
    close(o, a) {
        this.socket.close(o, a)
    }
    addEventListener(o, a, $) {
        this.socket.addEventListener(o, a, $)
    }
};

function WebSocket$1(s, o) {
    return new WebSocketBrowserImpl(s, o)
}
var DefaultDataPack = class {
        encode(s) {
            return JSON.stringify(s)
        }
        decode(s) {
            return JSON.parse(s)
        }
    },
    CommonClient = class extends EventEmitter$1 {
        constructor(o, a = "ws://localhost:8080", {
            autoconnect: $ = !0,
            reconnect: j = !0,
            reconnect_interval: _e = 1e3,
            max_reconnects: et = 5,
            ...tt
        } = {}, nt, rt) {
            super();
            jn(this, "address");
            jn(this, "rpc_id");
            jn(this, "queue");
            jn(this, "options");
            jn(this, "autoconnect");
            jn(this, "ready");
            jn(this, "reconnect");
            jn(this, "reconnect_timer_id");
            jn(this, "reconnect_interval");
            jn(this, "max_reconnects");
            jn(this, "rest_options");
            jn(this, "current_reconnects");
            jn(this, "generate_request_id");
            jn(this, "socket");
            jn(this, "webSocketFactory");
            jn(this, "dataPack");
            this.webSocketFactory = o, this.queue = {}, this.rpc_id = 0, this.address = a, this.autoconnect = $, this.ready = !1, this.reconnect = j, this.reconnect_timer_id = void 0, this.reconnect_interval = _e, this.max_reconnects = et, this.rest_options = tt, this.current_reconnects = 0, this.generate_request_id = nt || (() => ++this.rpc_id), rt ? this.dataPack = rt : this.dataPack = new DefaultDataPack, this.autoconnect && this._connect(this.address, {
                autoconnect: this.autoconnect,
                reconnect: this.reconnect,
                reconnect_interval: this.reconnect_interval,
                max_reconnects: this.max_reconnects,
                ...this.rest_options
            })
        }
        connect() {
            this.socket || this._connect(this.address, {
                autoconnect: this.autoconnect,
                reconnect: this.reconnect,
                reconnect_interval: this.reconnect_interval,
                max_reconnects: this.max_reconnects,
                ...this.rest_options
            })
        }
        call(o, a, $, j) {
            return !j && typeof $ == "object" && (j = $, $ = null), new Promise((_e, et) => {
                if (!this.ready) return et(new Error("socket not ready"));
                const tt = this.generate_request_id(o, a),
                    nt = {
                        jsonrpc: "2.0",
                        method: o,
                        params: a || void 0,
                        id: tt
                    };
                this.socket.send(this.dataPack.encode(nt), j, rt => {
                    if (rt) return et(rt);
                    this.queue[tt] = {
                        promise: [_e, et]
                    }, $ && (this.queue[tt].timeout = setTimeout(() => {
                        delete this.queue[tt], et(new Error("reply timeout"))
                    }, $))
                })
            })
        }
        async login(o) {
            const a = await this.call("rpc.login", o);
            if (!a) throw new Error("authentication failed");
            return a
        }
        async listMethods() {
            return await this.call("__listMethods")
        }
        notify(o, a) {
            return new Promise(($, j) => {
                if (!this.ready) return j(new Error("socket not ready"));
                const _e = {
                    jsonrpc: "2.0",
                    method: o,
                    params: a
                };
                this.socket.send(this.dataPack.encode(_e), et => {
                    if (et) return j(et);
                    $()
                })
            })
        }
        async subscribe(o) {
            typeof o == "string" && (o = [o]);
            const a = await this.call("rpc.on", o);
            if (typeof o == "string" && a[o] !== "ok") throw new Error("Failed subscribing to an event '" + o + "' with: " + a[o]);
            return a
        }
        async unsubscribe(o) {
            typeof o == "string" && (o = [o]);
            const a = await this.call("rpc.off", o);
            if (typeof o == "string" && a[o] !== "ok") throw new Error("Failed unsubscribing from an event with: " + a);
            return a
        }
        close(o, a) {
            this.socket.close(o || 1e3, a)
        }
        setAutoReconnect(o) {
            this.reconnect = o
        }
        setReconnectInterval(o) {
            this.reconnect_interval = o
        }
        setMaxReconnects(o) {
            this.max_reconnects = o
        }
        _connect(o, a) {
            clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(o, a), this.socket.addEventListener("open", () => {
                this.ready = !0, this.emit("open"), this.current_reconnects = 0
            }), this.socket.addEventListener("message", ({
                data: $
            }) => {
                $ instanceof ArrayBuffer && ($ = buffer.Buffer.from($).toString());
                try {
                    $ = this.dataPack.decode($)
                } catch {
                    return
                }
                if ($.notification && this.listeners($.notification).length) {
                    if (!Object.keys($.params).length) return this.emit($.notification);
                    const j = [$.notification];
                    if ($.params.constructor === Object) j.push($.params);
                    else
                        for (let _e = 0; _e < $.params.length; _e++) j.push($.params[_e]);
                    return Promise.resolve().then(() => {
                        this.emit.apply(this, j)
                    })
                }
                if (!this.queue[$.id]) return $.method ? Promise.resolve().then(() => {
                    this.emit($.method, $ == null ? void 0 : $.params)
                }) : void 0;
                "error" in $ == "result" in $ && this.queue[$.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), this.queue[$.id].timeout && clearTimeout(this.queue[$.id].timeout), $.error ? this.queue[$.id].promise[1]($.error) : this.queue[$.id].promise[0]($.result), delete this.queue[$.id]
            }), this.socket.addEventListener("error", $ => this.emit("error", $)), this.socket.addEventListener("close", ({
                code: $,
                reason: j
            }) => {
                this.ready && setTimeout(() => this.emit("close", $, j), 0), this.ready = !1, this.socket = void 0, $ !== 1e3 && (this.current_reconnects++, this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout(() => this._connect(o, a), this.reconnect_interval)))
            })
        }
    };
const SHA3_PI = [],
    SHA3_ROTL = [],
    _SHA3_IOTA = [],
    _0n$1 = BigInt(0),
    _1n$2 = BigInt(1),
    _2n$1 = BigInt(2),
    _7n = BigInt(7),
    _256n = BigInt(256),
    _0x71n = BigInt(113);
for (let s = 0, o = _1n$2, a = 1, $ = 0; s < 24; s++) {
    [a, $] = [$, (2 * a + 3 * $) % 5], SHA3_PI.push(2 * (5 * $ + a)), SHA3_ROTL.push((s + 1) * (s + 2) / 2 % 64);
    let j = _0n$1;
    for (let _e = 0; _e < 7; _e++) o = (o << _1n$2 ^ (o >> _7n) * _0x71n) % _256n, o & _2n$1 && (j ^= _1n$2 << (_1n$2 << BigInt(_e)) - _1n$2);
    _SHA3_IOTA.push(j)
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, !0), rotlH = (s, o, a) => a > 32 ? rotlBH(s, o, a) : rotlSH(s, o, a), rotlL = (s, o, a) => a > 32 ? rotlBL(s, o, a) : rotlSL(s, o, a);

function keccakP(s, o = 24) {
    const a = new Uint32Array(10);
    for (let $ = 24 - o; $ < 24; $++) {
        for (let et = 0; et < 10; et++) a[et] = s[et] ^ s[et + 10] ^ s[et + 20] ^ s[et + 30] ^ s[et + 40];
        for (let et = 0; et < 10; et += 2) {
            const tt = (et + 8) % 10,
                nt = (et + 2) % 10,
                rt = a[nt],
                ot = a[nt + 1],
                st = rotlH(rt, ot, 1) ^ a[tt],
                lt = rotlL(rt, ot, 1) ^ a[tt + 1];
            for (let ft = 0; ft < 50; ft += 10) s[et + ft] ^= st, s[et + ft + 1] ^= lt
        }
        let j = s[2],
            _e = s[3];
        for (let et = 0; et < 24; et++) {
            const tt = SHA3_ROTL[et],
                nt = rotlH(j, _e, tt),
                rt = rotlL(j, _e, tt),
                ot = SHA3_PI[et];
            j = s[ot], _e = s[ot + 1], s[ot] = nt, s[ot + 1] = rt
        }
        for (let et = 0; et < 50; et += 10) {
            for (let tt = 0; tt < 10; tt++) a[tt] = s[et + tt];
            for (let tt = 0; tt < 10; tt++) s[et + tt] ^= ~a[(tt + 2) % 10] & a[(tt + 4) % 10]
        }
        s[0] ^= SHA3_IOTA_H[$], s[1] ^= SHA3_IOTA_L[$]
    }
    a.fill(0)
}
class Keccak extends Hash {
    constructor(o, a, $, j = !1, _e = 24) {
        if (super(), this.blockLen = o, this.suffix = a, this.outputLen = $, this.enableXOF = j, this.rounds = _e, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number$2($), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200), this.state32 = u32$2(this.state)
    }
    keccak() {
        isLE || byteSwap32(this.state32), keccakP(this.state32, this.rounds), isLE || byteSwap32(this.state32), this.posOut = 0, this.pos = 0
    }
    update(o) {
        exists(this);
        const {
            blockLen: a,
            state: $
        } = this;
        o = toBytes(o);
        const j = o.length;
        for (let _e = 0; _e < j;) {
            const et = Math.min(a - this.pos, j - _e);
            for (let tt = 0; tt < et; tt++) $[this.pos++] ^= o[_e++];
            this.pos === a && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
            state: o,
            suffix: a,
            pos: $,
            blockLen: j
        } = this;
        o[$] ^= a, a & 128 && $ === j - 1 && this.keccak(), o[j - 1] ^= 128, this.keccak()
    }
    writeInto(o) {
        exists(this, !1), bytes(o), this.finish();
        const a = this.state,
            {
                blockLen: $
            } = this;
        for (let j = 0, _e = o.length; j < _e;) {
            this.posOut >= $ && this.keccak();
            const et = Math.min($ - this.posOut, _e - j);
            o.set(a.subarray(this.posOut, this.posOut + et), j), this.posOut += et, j += et
        }
        return o
    }
    xofInto(o) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(o)
    }
    xof(o) {
        return number$2(o), this.xofInto(new Uint8Array(o))
    }
    digestInto(o) {
        if (output(o, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(o), this.destroy(), o
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0, this.state.fill(0)
    }
    _cloneInto(o) {
        const {
            blockLen: a,
            suffix: $,
            outputLen: j,
            rounds: _e,
            enableXOF: et
        } = this;
        return o || (o = new Keccak(a, $, j, et, _e)), o.state32.set(this.state32), o.pos = this.pos, o.posOut = this.posOut, o.finished = this.finished, o.rounds = _e, o.suffix = $, o.outputLen = j, o.enableXOF = et, o.destroyed = this.destroyed, o
    }
}
const gen = (s, o, a) => wrapConstructor(() => new Keccak(o, s, a)),
    keccak_256 = gen(1, 136, 256 / 8);
class HMAC extends Hash {
    constructor(o, a) {
        super(), this.finished = !1, this.destroyed = !1, hash$1(o);
        const $ = toBytes(a);
        if (this.iHash = o.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const j = this.blockLen,
            _e = new Uint8Array(j);
        _e.set($.length > j ? o.create().update($).digest() : $);
        for (let et = 0; et < _e.length; et++) _e[et] ^= 54;
        this.iHash.update(_e), this.oHash = o.create();
        for (let et = 0; et < _e.length; et++) _e[et] ^= 106;
        this.oHash.update(_e), _e.fill(0)
    }
    update(o) {
        return exists(this), this.iHash.update(o), this
    }
    digestInto(o) {
        exists(this), bytes(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy()
    }
    digest() {
        const o = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(o), o
    }
    _cloneInto(o) {
        o || (o = Object.create(Object.getPrototypeOf(this), {}));
        const {
            oHash: a,
            iHash: $,
            finished: j,
            destroyed: _e,
            blockLen: et,
            outputLen: tt
        } = this;
        return o = o, o.finished = j, o.destroyed = _e, o.blockLen = et, o.outputLen = tt, o.oHash = a._cloneInto(o.oHash), o.iHash = $._cloneInto(o.iHash), o
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
    }
}
const hmac = (s, o, a) => new HMAC(s, o).update(a).digest();
hmac.create = (s, o) => new HMAC(s, o); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(s) {
    s.lowS !== void 0 && abool("lowS", s.lowS), s.prehash !== void 0 && abool("prehash", s.prehash)
}

function validatePointOpts(s) {
    const o = validateBasic(s);
    validateObject(o, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {
        endo: a,
        Fp: $,
        a: j
    } = o;
    if (a) {
        if (!$.eql(j, $.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof a != "object" || typeof a.beta != "bigint" || typeof a.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({ ...o
    })
}
const {
    bytesToNumberBE: b2n,
    hexToBytes: h2b
} = ut, DER = {
    Err: class extends Error {
        constructor(o = "") {
            super(o)
        }
    },
    _tlv: {
        encode: (s, o) => {
            const {
                Err: a
            } = DER;
            if (s < 0 || s > 256) throw new a("tlv.encode: wrong tag");
            if (o.length & 1) throw new a("tlv.encode: unpadded data");
            const $ = o.length / 2,
                j = numberToHexUnpadded($);
            if (j.length / 2 & 128) throw new a("tlv.encode: long form length too big");
            const _e = $ > 127 ? numberToHexUnpadded(j.length / 2 | 128) : "";
            return `${numberToHexUnpadded(s)}${_e}${j}${o}`
        },
        decode(s, o) {
            const {
                Err: a
            } = DER;
            let $ = 0;
            if (s < 0 || s > 256) throw new a("tlv.encode: wrong tag");
            if (o.length < 2 || o[$++] !== s) throw new a("tlv.decode: wrong tlv");
            const j = o[$++],
                _e = !!(j & 128);
            let et = 0;
            if (!_e) et = j;
            else {
                const nt = j & 127;
                if (!nt) throw new a("tlv.decode(long): indefinite length not supported");
                if (nt > 4) throw new a("tlv.decode(long): byte length is too big");
                const rt = o.subarray($, $ + nt);
                if (rt.length !== nt) throw new a("tlv.decode: length bytes not complete");
                if (rt[0] === 0) throw new a("tlv.decode(long): zero leftmost byte");
                for (const ot of rt) et = et << 8 | ot;
                if ($ += nt, et < 128) throw new a("tlv.decode(long): not minimal encoding")
            }
            const tt = o.subarray($, $ + et);
            if (tt.length !== et) throw new a("tlv.decode: wrong value length");
            return {
                v: tt,
                l: o.subarray($ + et)
            }
        }
    },
    _int: {
        encode(s) {
            const {
                Err: o
            } = DER;
            if (s < _0n) throw new o("integer: negative integers are not allowed");
            let a = numberToHexUnpadded(s);
            if (Number.parseInt(a[0], 16) & 8 && (a = "00" + a), a.length & 1) throw new o("unexpected assertion");
            return a
        },
        decode(s) {
            const {
                Err: o
            } = DER;
            if (s[0] & 128) throw new o("Invalid signature integer: negative");
            if (s[0] === 0 && !(s[1] & 128)) throw new o("Invalid signature integer: unnecessary leading zero");
            return b2n(s)
        }
    },
    toSig(s) {
        const {
            Err: o,
            _int: a,
            _tlv: $
        } = DER, j = typeof s == "string" ? h2b(s) : s;
        abytes(j);
        const {
            v: _e,
            l: et
        } = $.decode(48, j);
        if (et.length) throw new o("Invalid signature: left bytes after parsing");
        const {
            v: tt,
            l: nt
        } = $.decode(2, _e), {
            v: rt,
            l: ot
        } = $.decode(2, nt);
        if (ot.length) throw new o("Invalid signature: left bytes after parsing");
        return {
            r: a.decode(tt),
            s: a.decode(rt)
        }
    },
    hexFromSig(s) {
        const {
            _tlv: o,
            _int: a
        } = DER, $ = `${o.encode(2,a.encode(s.r))}${o.encode(2,a.encode(s.s))}`;
        return o.encode(48, $)
    }
}, _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);

function weierstrassPoints(s) {
    const o = validatePointOpts(s),
        {
            Fp: a
        } = o,
        $ = Field(o.n, o.nBitLength),
        j = o.toBytes || ((bt, ht, vt) => {
            const wt = ht.toAffine();
            return concatBytes(Uint8Array.from([4]), a.toBytes(wt.x), a.toBytes(wt.y))
        }),
        _e = o.fromBytes || (bt => {
            const ht = bt.subarray(1),
                vt = a.fromBytes(ht.subarray(0, a.BYTES)),
                wt = a.fromBytes(ht.subarray(a.BYTES, 2 * a.BYTES));
            return {
                x: vt,
                y: wt
            }
        });

    function et(bt) {
        const {
            a: ht,
            b: vt
        } = o, wt = a.sqr(bt), gt = a.mul(wt, bt);
        return a.add(a.add(gt, a.mul(bt, ht)), vt)
    }
    if (!a.eql(a.sqr(o.Gy), et(o.Gx))) throw new Error("bad generator point: equation left != right");

    function tt(bt) {
        return inRange$1(bt, _1n$1, o.n)
    }

    function nt(bt) {
        const {
            allowedPrivateKeyLengths: ht,
            nByteLength: vt,
            wrapPrivateKey: wt,
            n: gt
        } = o;
        if (ht && typeof bt != "bigint") {
            if (isBytes(bt) && (bt = bytesToHex(bt)), typeof bt != "string" || !ht.includes(bt.length)) throw new Error("Invalid key");
            bt = bt.padStart(vt * 2, "0")
        }
        let At;
        try {
            At = typeof bt == "bigint" ? bt : bytesToNumberBE(ensureBytes("private key", bt, vt))
        } catch {
            throw new Error(`private key must be ${vt} bytes, hex or bigint, not ${typeof bt}`)
        }
        return wt && (At = mod(At, gt)), aInRange("private key", At, _1n$1, gt), At
    }

    function rt(bt) {
        if (!(bt instanceof lt)) throw new Error("ProjectivePoint expected")
    }
    const ot = memoized((bt, ht) => {
            const {
                px: vt,
                py: wt,
                pz: gt
            } = bt;
            if (a.eql(gt, a.ONE)) return {
                x: vt,
                y: wt
            };
            const At = bt.is0();
            ht == null && (ht = At ? a.ONE : a.inv(gt));
            const Pt = a.mul(vt, ht),
                Bt = a.mul(wt, ht),
                Lt = a.mul(gt, ht);
            if (At) return {
                x: a.ZERO,
                y: a.ZERO
            };
            if (!a.eql(Lt, a.ONE)) throw new Error("invZ was invalid");
            return {
                x: Pt,
                y: Bt
            }
        }),
        st = memoized(bt => {
            if (bt.is0()) {
                if (o.allowInfinityPoint && !a.is0(bt.py)) return;
                throw new Error("bad point: ZERO")
            }
            const {
                x: ht,
                y: vt
            } = bt.toAffine();
            if (!a.isValid(ht) || !a.isValid(vt)) throw new Error("bad point: x or y not FE");
            const wt = a.sqr(vt),
                gt = et(ht);
            if (!a.eql(wt, gt)) throw new Error("bad point: equation left != right");
            if (!bt.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0
        });
    class lt {
        constructor(ht, vt, wt) {
            if (this.px = ht, this.py = vt, this.pz = wt, ht == null || !a.isValid(ht)) throw new Error("x required");
            if (vt == null || !a.isValid(vt)) throw new Error("y required");
            if (wt == null || !a.isValid(wt)) throw new Error("z required");
            Object.freeze(this)
        }
        static fromAffine(ht) {
            const {
                x: vt,
                y: wt
            } = ht || {};
            if (!ht || !a.isValid(vt) || !a.isValid(wt)) throw new Error("invalid affine point");
            if (ht instanceof lt) throw new Error("projective point not allowed");
            const gt = At => a.eql(At, a.ZERO);
            return gt(vt) && gt(wt) ? lt.ZERO : new lt(vt, wt, a.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(ht) {
            const vt = a.invertBatch(ht.map(wt => wt.pz));
            return ht.map((wt, gt) => wt.toAffine(vt[gt])).map(lt.fromAffine)
        }
        static fromHex(ht) {
            const vt = lt.fromAffine(_e(ensureBytes("pointHex", ht)));
            return vt.assertValidity(), vt
        }
        static fromPrivateKey(ht) {
            return lt.BASE.multiply(nt(ht))
        }
        static msm(ht, vt) {
            return pippenger(lt, $, ht, vt)
        }
        _setWindowSize(ht) {
            yt.setWindowSize(this, ht)
        }
        assertValidity() {
            st(this)
        }
        hasEvenY() {
            const {
                y: ht
            } = this.toAffine();
            if (a.isOdd) return !a.isOdd(ht);
            throw new Error("Field doesn't support isOdd")
        }
        equals(ht) {
            rt(ht);
            const {
                px: vt,
                py: wt,
                pz: gt
            } = this, {
                px: At,
                py: Pt,
                pz: Bt
            } = ht, Lt = a.eql(a.mul(vt, Bt), a.mul(At, gt)), Nt = a.eql(a.mul(wt, Bt), a.mul(Pt, gt));
            return Lt && Nt
        }
        negate() {
            return new lt(this.px, a.neg(this.py), this.pz)
        }
        double() {
            const {
                a: ht,
                b: vt
            } = o, wt = a.mul(vt, _3n), {
                px: gt,
                py: At,
                pz: Pt
            } = this;
            let Bt = a.ZERO,
                Lt = a.ZERO,
                Nt = a.ZERO,
                Ut = a.mul(gt, gt),
                Vt = a.mul(At, At),
                Ft = a.mul(Pt, Pt),
                Wt = a.mul(gt, At);
            return Wt = a.add(Wt, Wt), Nt = a.mul(gt, Pt), Nt = a.add(Nt, Nt), Bt = a.mul(ht, Nt), Lt = a.mul(wt, Ft), Lt = a.add(Bt, Lt), Bt = a.sub(Vt, Lt), Lt = a.add(Vt, Lt), Lt = a.mul(Bt, Lt), Bt = a.mul(Wt, Bt), Nt = a.mul(wt, Nt), Ft = a.mul(ht, Ft), Wt = a.sub(Ut, Ft), Wt = a.mul(ht, Wt), Wt = a.add(Wt, Nt), Nt = a.add(Ut, Ut), Ut = a.add(Nt, Ut), Ut = a.add(Ut, Ft), Ut = a.mul(Ut, Wt), Lt = a.add(Lt, Ut), Ft = a.mul(At, Pt), Ft = a.add(Ft, Ft), Ut = a.mul(Ft, Wt), Bt = a.sub(Bt, Ut), Nt = a.mul(Ft, Vt), Nt = a.add(Nt, Nt), Nt = a.add(Nt, Nt), new lt(Bt, Lt, Nt)
        }
        add(ht) {
            rt(ht);
            const {
                px: vt,
                py: wt,
                pz: gt
            } = this, {
                px: At,
                py: Pt,
                pz: Bt
            } = ht;
            let Lt = a.ZERO,
                Nt = a.ZERO,
                Ut = a.ZERO;
            const Vt = o.a,
                Ft = a.mul(o.b, _3n);
            let Wt = a.mul(vt, At),
                Ct = a.mul(wt, Pt),
                it = a.mul(gt, Bt),
                at = a.add(vt, wt),
                mt = a.add(At, Pt);
            at = a.mul(at, mt), mt = a.add(Wt, Ct), at = a.sub(at, mt), mt = a.add(vt, gt);
            let xt = a.add(At, Bt);
            return mt = a.mul(mt, xt), xt = a.add(Wt, it), mt = a.sub(mt, xt), xt = a.add(wt, gt), Lt = a.add(Pt, Bt), xt = a.mul(xt, Lt), Lt = a.add(Ct, it), xt = a.sub(xt, Lt), Ut = a.mul(Vt, mt), Lt = a.mul(Ft, it), Ut = a.add(Lt, Ut), Lt = a.sub(Ct, Ut), Ut = a.add(Ct, Ut), Nt = a.mul(Lt, Ut), Ct = a.add(Wt, Wt), Ct = a.add(Ct, Wt), it = a.mul(Vt, it), mt = a.mul(Ft, mt), Ct = a.add(Ct, it), it = a.sub(Wt, it), it = a.mul(Vt, it), mt = a.add(mt, it), Wt = a.mul(Ct, mt), Nt = a.add(Nt, Wt), Wt = a.mul(xt, mt), Lt = a.mul(at, Lt), Lt = a.sub(Lt, Wt), Wt = a.mul(at, Ct), Ut = a.mul(xt, Ut), Ut = a.add(Ut, Wt), new lt(Lt, Nt, Ut)
        }
        subtract(ht) {
            return this.add(ht.negate())
        }
        is0() {
            return this.equals(lt.ZERO)
        }
        wNAF(ht) {
            return yt.wNAFCached(this, ht, lt.normalizeZ)
        }
        multiplyUnsafe(ht) {
            aInRange("scalar", ht, _0n, o.n);
            const vt = lt.ZERO;
            if (ht === _0n) return vt;
            if (ht === _1n$1) return this;
            const {
                endo: wt
            } = o;
            if (!wt) return yt.unsafeLadder(this, ht);
            let {
                k1neg: gt,
                k1: At,
                k2neg: Pt,
                k2: Bt
            } = wt.splitScalar(ht), Lt = vt, Nt = vt, Ut = this;
            for (; At > _0n || Bt > _0n;) At & _1n$1 && (Lt = Lt.add(Ut)), Bt & _1n$1 && (Nt = Nt.add(Ut)), Ut = Ut.double(), At >>= _1n$1, Bt >>= _1n$1;
            return gt && (Lt = Lt.negate()), Pt && (Nt = Nt.negate()), Nt = new lt(a.mul(Nt.px, wt.beta), Nt.py, Nt.pz), Lt.add(Nt)
        }
        multiply(ht) {
            const {
                endo: vt,
                n: wt
            } = o;
            aInRange("scalar", ht, _1n$1, wt);
            let gt, At;
            if (vt) {
                const {
                    k1neg: Pt,
                    k1: Bt,
                    k2neg: Lt,
                    k2: Nt
                } = vt.splitScalar(ht);
                let {
                    p: Ut,
                    f: Vt
                } = this.wNAF(Bt), {
                    p: Ft,
                    f: Wt
                } = this.wNAF(Nt);
                Ut = yt.constTimeNegate(Pt, Ut), Ft = yt.constTimeNegate(Lt, Ft), Ft = new lt(a.mul(Ft.px, vt.beta), Ft.py, Ft.pz), gt = Ut.add(Ft), At = Vt.add(Wt)
            } else {
                const {
                    p: Pt,
                    f: Bt
                } = this.wNAF(ht);
                gt = Pt, At = Bt
            }
            return lt.normalizeZ([gt, At])[0]
        }
        multiplyAndAddUnsafe(ht, vt, wt) {
            const gt = lt.BASE,
                At = (Bt, Lt) => Lt === _0n || Lt === _1n$1 || !Bt.equals(gt) ? Bt.multiplyUnsafe(Lt) : Bt.multiply(Lt),
                Pt = At(this, vt).add(At(ht, wt));
            return Pt.is0() ? void 0 : Pt
        }
        toAffine(ht) {
            return ot(this, ht)
        }
        isTorsionFree() {
            const {
                h: ht,
                isTorsionFree: vt
            } = o;
            if (ht === _1n$1) return !0;
            if (vt) return vt(lt, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {
                h: ht,
                clearCofactor: vt
            } = o;
            return ht === _1n$1 ? this : vt ? vt(lt, this) : this.multiplyUnsafe(o.h)
        }
        toRawBytes(ht = !0) {
            return abool("isCompressed", ht), this.assertValidity(), j(lt, this, ht)
        }
        toHex(ht = !0) {
            return abool("isCompressed", ht), bytesToHex(this.toRawBytes(ht))
        }
    }
    lt.BASE = new lt(o.Gx, o.Gy, a.ONE), lt.ZERO = new lt(a.ZERO, a.ONE, a.ZERO);
    const ft = o.nBitLength,
        yt = wNAF(lt, o.endo ? Math.ceil(ft / 2) : ft);
    return {
        CURVE: o,
        ProjectivePoint: lt,
        normPrivateKeyToScalar: nt,
        weierstrassEquation: et,
        isWithinCurveOrder: tt
    }
}

function validateOpts(s) {
    const o = validateBasic(s);
    return validateObject(o, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...o
    })
}

function weierstrass(s) {
    const o = validateOpts(s),
        {
            Fp: a,
            n: $
        } = o,
        j = a.BYTES + 1,
        _e = 2 * a.BYTES + 1;

    function et(it) {
        return mod(it, $)
    }

    function tt(it) {
        return invert(it, $)
    }
    const {
        ProjectivePoint: nt,
        normPrivateKeyToScalar: rt,
        weierstrassEquation: ot,
        isWithinCurveOrder: st
    } = weierstrassPoints({ ...o,
        toBytes(it, at, mt) {
            const xt = at.toAffine(),
                $t = a.toBytes(xt.x),
                Rt = concatBytes;
            return abool("isCompressed", mt), mt ? Rt(Uint8Array.from([at.hasEvenY() ? 2 : 3]), $t) : Rt(Uint8Array.from([4]), $t, a.toBytes(xt.y))
        },
        fromBytes(it) {
            const at = it.length,
                mt = it[0],
                xt = it.subarray(1);
            if (at === j && (mt === 2 || mt === 3)) {
                const $t = bytesToNumberBE(xt);
                if (!inRange$1($t, _1n$1, a.ORDER)) throw new Error("Point is not on curve");
                const Rt = ot($t);
                let It;
                try {
                    It = a.sqrt(Rt)
                } catch (Et) {
                    const Ot = Et instanceof Error ? ": " + Et.message : "";
                    throw new Error("Point is not on curve" + Ot)
                }
                const Tt = (It & _1n$1) === _1n$1;
                return (mt & 1) === 1 !== Tt && (It = a.neg(It)), {
                    x: $t,
                    y: It
                }
            } else if (at === _e && mt === 4) {
                const $t = a.fromBytes(xt.subarray(0, a.BYTES)),
                    Rt = a.fromBytes(xt.subarray(a.BYTES, 2 * a.BYTES));
                return {
                    x: $t,
                    y: Rt
                }
            } else throw new Error(`Point of length ${at} was invalid. Expected ${j} compressed bytes or ${_e} uncompressed bytes`)
        }
    }), lt = it => bytesToHex(numberToBytesBE(it, o.nByteLength));

    function ft(it) {
        const at = $ >> _1n$1;
        return it > at
    }

    function yt(it) {
        return ft(it) ? et(-it) : it
    }
    const bt = (it, at, mt) => bytesToNumberBE(it.slice(at, mt));
    class ht {
        constructor(at, mt, xt) {
            this.r = at, this.s = mt, this.recovery = xt, this.assertValidity()
        }
        static fromCompact(at) {
            const mt = o.nByteLength;
            return at = ensureBytes("compactSignature", at, mt * 2), new ht(bt(at, 0, mt), bt(at, mt, 2 * mt))
        }
        static fromDER(at) {
            const {
                r: mt,
                s: xt
            } = DER.toSig(ensureBytes("DER", at));
            return new ht(mt, xt)
        }
        assertValidity() {
            aInRange("r", this.r, _1n$1, $), aInRange("s", this.s, _1n$1, $)
        }
        addRecoveryBit(at) {
            return new ht(this.r, this.s, at)
        }
        recoverPublicKey(at) {
            const {
                r: mt,
                s: xt,
                recovery: $t
            } = this, Rt = Bt(ensureBytes("msgHash", at));
            if ($t == null || ![0, 1, 2, 3].includes($t)) throw new Error("recovery id invalid");
            const It = $t === 2 || $t === 3 ? mt + o.n : mt;
            if (It >= a.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const Tt = $t & 1 ? "03" : "02",
                dt = nt.fromHex(Tt + lt(It)),
                Et = tt(It),
                Ot = et(-Rt * Et),
                Mt = et(xt * Et),
                jt = nt.BASE.multiplyAndAddUnsafe(dt, Ot, Mt);
            if (!jt) throw new Error("point at infinify");
            return jt.assertValidity(), jt
        }
        hasHighS() {
            return ft(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new ht(this.r, et(-this.s), this.recovery) : this
        }
        toDERRawBytes() {
            return hexToBytes(this.toDERHex())
        }
        toDERHex() {
            return DER.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return hexToBytes(this.toCompactHex())
        }
        toCompactHex() {
            return lt(this.r) + lt(this.s)
        }
    }
    const vt = {
        isValidPrivateKey(it) {
            try {
                return rt(it), !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: rt,
        randomPrivateKey: () => {
            const it = getMinHashLength(o.n);
            return mapHashToField(o.randomBytes(it), o.n)
        },
        precompute(it = 8, at = nt.BASE) {
            return at._setWindowSize(it), at.multiply(BigInt(3)), at
        }
    };

    function wt(it, at = !0) {
        return nt.fromPrivateKey(it).toRawBytes(at)
    }

    function gt(it) {
        const at = isBytes(it),
            mt = typeof it == "string",
            xt = (at || mt) && it.length;
        return at ? xt === j || xt === _e : mt ? xt === 2 * j || xt === 2 * _e : it instanceof nt
    }

    function At(it, at, mt = !0) {
        if (gt(it)) throw new Error("first arg must be private key");
        if (!gt(at)) throw new Error("second arg must be public key");
        return nt.fromHex(at).multiply(rt(it)).toRawBytes(mt)
    }
    const Pt = o.bits2int || function(it) {
            const at = bytesToNumberBE(it),
                mt = it.length * 8 - o.nBitLength;
            return mt > 0 ? at >> BigInt(mt) : at
        },
        Bt = o.bits2int_modN || function(it) {
            return et(Pt(it))
        },
        Lt = bitMask(o.nBitLength);

    function Nt(it) {
        return aInRange(`num < 2^${o.nBitLength}`, it, _0n, Lt), numberToBytesBE(it, o.nByteLength)
    }

    function Ut(it, at, mt = Vt) {
        if (["recovered", "canonical"].some(Kt => Kt in mt)) throw new Error("sign() legacy options not supported");
        const {
            hash: xt,
            randomBytes: $t
        } = o;
        let {
            lowS: Rt,
            prehash: It,
            extraEntropy: Tt
        } = mt;
        Rt == null && (Rt = !0), it = ensureBytes("msgHash", it), validateSigVerOpts(mt), It && (it = ensureBytes("prehashed msgHash", xt(it)));
        const dt = Bt(it),
            Et = rt(at),
            Ot = [Nt(Et), Nt(dt)];
        if (Tt != null && Tt !== !1) {
            const Kt = Tt === !0 ? $t(a.BYTES) : Tt;
            Ot.push(ensureBytes("extraEntropy", Kt))
        }
        const Mt = concatBytes(...Ot),
            jt = dt;

        function Qt(Kt) {
            const qt = Pt(Kt);
            if (!st(qt)) return;
            const Jt = tt(qt),
                Zt = nt.BASE.multiply(qt).toAffine(),
                en = et(Zt.x);
            if (en === _0n) return;
            const ln = et(Jt * et(jt + en * Et));
            if (ln === _0n) return;
            let cn = (Zt.x === en ? 0 : 2) | Number(Zt.y & _1n$1),
                un = ln;
            return Rt && ft(ln) && (un = yt(ln), cn ^= 1), new ht(en, un, cn)
        }
        return {
            seed: Mt,
            k2sig: Qt
        }
    }
    const Vt = {
            lowS: o.lowS,
            prehash: !1
        },
        Ft = {
            lowS: o.lowS,
            prehash: !1
        };

    function Wt(it, at, mt = Vt) {
        const {
            seed: xt,
            k2sig: $t
        } = Ut(it, at, mt), Rt = o;
        return createHmacDrbg(Rt.hash.outputLen, Rt.nByteLength, Rt.hmac)(xt, $t)
    }
    nt.BASE._setWindowSize(8);

    function Ct(it, at, mt, xt = Ft) {
        var Zt;
        const $t = it;
        if (at = ensureBytes("msgHash", at), mt = ensureBytes("publicKey", mt), "strict" in xt) throw new Error("options.strict was renamed to lowS");
        validateSigVerOpts(xt);
        const {
            lowS: Rt,
            prehash: It
        } = xt;
        let Tt, dt;
        try {
            if (typeof $t == "string" || isBytes($t)) try {
                Tt = ht.fromDER($t)
            } catch (en) {
                if (!(en instanceof DER.Err)) throw en;
                Tt = ht.fromCompact($t)
            } else if (typeof $t == "object" && typeof $t.r == "bigint" && typeof $t.s == "bigint") {
                const {
                    r: en,
                    s: ln
                } = $t;
                Tt = new ht(en, ln)
            } else throw new Error("PARSE");
            dt = nt.fromHex(mt)
        } catch (en) {
            if (en.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (Rt && Tt.hasHighS()) return !1;
        It && (at = o.hash(at));
        const {
            r: Et,
            s: Ot
        } = Tt, Mt = Bt(at), jt = tt(Ot), Qt = et(Mt * jt), Kt = et(Et * jt), qt = (Zt = nt.BASE.multiplyAndAddUnsafe(dt, Qt, Kt)) == null ? void 0 : Zt.toAffine();
        return qt ? et(qt.x) === Et : !1
    }
    return {
        CURVE: o,
        getPublicKey: wt,
        getSharedSecret: At,
        sign: Wt,
        verify: Ct,
        ProjectivePoint: nt,
        Signature: ht,
        utils: vt
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(s) {
    return {
        hash: s,
        hmac: (o, ...a) => hmac(s, o, concatBytes$1(...a)),
        randomBytes
    }
}

function createCurve(s, o) {
    const a = $ => weierstrass({ ...s,
        ...getHash($)
    });
    return Object.freeze({ ...a(o),
        create: a
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    _1n = BigInt(1),
    _2n = BigInt(2),
    divNearest = (s, o) => (s + o / _2n) / o;

function sqrtMod(s) {
    const o = secp256k1P,
        a = BigInt(3),
        $ = BigInt(6),
        j = BigInt(11),
        _e = BigInt(22),
        et = BigInt(23),
        tt = BigInt(44),
        nt = BigInt(88),
        rt = s * s * s % o,
        ot = rt * rt * s % o,
        st = pow2(ot, a, o) * ot % o,
        lt = pow2(st, a, o) * ot % o,
        ft = pow2(lt, _2n, o) * rt % o,
        yt = pow2(ft, j, o) * ft % o,
        bt = pow2(yt, _e, o) * yt % o,
        ht = pow2(bt, tt, o) * bt % o,
        vt = pow2(ht, nt, o) * ht % o,
        wt = pow2(vt, tt, o) * bt % o,
        gt = pow2(wt, a, o) * ot % o,
        At = pow2(gt, et, o) * yt % o,
        Pt = pow2(At, $, o) * rt % o,
        Bt = pow2(Pt, _2n, o);
    if (!Fp.eql(Fp.sqr(Bt), s)) throw new Error("Cannot find square root");
    return Bt
}
const Fp = Field(secp256k1P, void 0, void 0, {
        sqrt: sqrtMod
    }),
    secp256k1 = createCurve({
        a: BigInt(0),
        b: BigInt(7),
        Fp,
        n: secp256k1N,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: s => {
                const o = secp256k1N,
                    a = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    $ = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    j = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                    _e = a,
                    et = BigInt("0x100000000000000000000000000000000"),
                    tt = divNearest(_e * s, o),
                    nt = divNearest(-$ * s, o);
                let rt = mod(s - tt * a - nt * j, o),
                    ot = mod(-tt * $ - nt * _e, o);
                const st = rt > et,
                    lt = ot > et;
                if (st && (rt = o - rt), lt && (ot = o - ot), rt > et || ot > et) throw new Error("splitScalar: Endomorphism failed, k=" + s);
                return {
                    k1neg: st,
                    k1: rt,
                    k2neg: lt,
                    k2: ot
                }
            }
        }
    }, sha256$2);
BigInt(0);
secp256k1.ProjectivePoint;
const generatePrivateKey = ed25519.utils.randomPrivateKey,
    generateKeypair = () => {
        const s = ed25519.utils.randomPrivateKey(),
            o = getPublicKey(s),
            a = new Uint8Array(64);
        return a.set(s), a.set(o, 32), {
            publicKey: o,
            secretKey: a
        }
    },
    getPublicKey = ed25519.getPublicKey;

function isOnCurve(s) {
    try {
        return ed25519.ExtendedPoint.fromHex(s), !0
    } catch {
        return !1
    }
}
const sign = (s, o) => ed25519.sign(s, o.slice(0, 32)),
    verify = ed25519.verify,
    toBuffer$1 = s => buffer.Buffer.isBuffer(s) ? s : s instanceof Uint8Array ? buffer.Buffer.from(s.buffer, s.byteOffset, s.byteLength) : buffer.Buffer.from(s);
let Struct$1 = class {
    constructor(o) {
        Object.assign(this, o)
    }
    encode() {
        return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA, this))
    }
    static decode(o) {
        return deserialize_1(SOLANA_SCHEMA, this, o)
    }
    static decodeUnchecked(o) {
        return deserializeUnchecked_1(SOLANA_SCHEMA, this, o)
    }
};
class Enum extends Struct$1 {
    constructor(o) {
        if (super(o), this.enum = "", Object.keys(o).length !== 1) throw new Error("Enum can only take single value");
        Object.keys(o).map(a => {
            this.enum = a
        })
    }
}
const SOLANA_SCHEMA = new Map;
var _PublicKey;
const MAX_SEED_LENGTH = 32,
    PUBLIC_KEY_LENGTH = 32;

function isPublicKeyData(s) {
    return s._bn !== void 0
}
let uniquePublicKeyCounter = 1;
class PublicKey extends Struct$1 {
    constructor(o) {
        if (super({}), this._bn = void 0, isPublicKeyData(o)) this._bn = o._bn;
        else {
            if (typeof o == "string") {
                const a = bs58$1$1.decode(o);
                if (a.length != PUBLIC_KEY_LENGTH) throw new Error("Invalid public key input");
                this._bn = new BN(a)
            } else this._bn = new BN(o);
            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) throw new Error("Invalid public key input")
        }
    }
    static unique() {
        const o = new PublicKey(uniquePublicKeyCounter);
        return uniquePublicKeyCounter += 1, new PublicKey(o.toBuffer())
    }
    equals(o) {
        return this._bn.eq(o._bn)
    }
    toBase58() {
        return bs58$1$1.encode(this.toBytes())
    }
    toJSON() {
        return this.toBase58()
    }
    toBytes() {
        const o = this.toBuffer();
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
    }
    toBuffer() {
        const o = this._bn.toArrayLike(buffer.Buffer);
        if (o.length === PUBLIC_KEY_LENGTH) return o;
        const a = buffer.Buffer.alloc(32);
        return o.copy(a, 32 - o.length), a
    }
    get[Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`
    }
    toString() {
        return this.toBase58()
    }
    static async createWithSeed(o, a, $) {
        const j = buffer.Buffer.concat([o.toBuffer(), buffer.Buffer.from(a), $.toBuffer()]),
            _e = sha256$2(j);
        return new PublicKey(_e)
    }
    static createProgramAddressSync(o, a) {
        let $ = buffer.Buffer.alloc(0);
        o.forEach(function(_e) {
            if (_e.length > MAX_SEED_LENGTH) throw new TypeError("Max seed length exceeded");
            $ = buffer.Buffer.concat([$, toBuffer$1(_e)])
        }), $ = buffer.Buffer.concat([$, a.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
        const j = sha256$2($);
        if (isOnCurve(j)) throw new Error("Invalid seeds, address must fall off the curve");
        return new PublicKey(j)
    }
    static async createProgramAddress(o, a) {
        return this.createProgramAddressSync(o, a)
    }
    static findProgramAddressSync(o, a) {
        let $ = 255,
            j;
        for (; $ != 0;) {
            try {
                const _e = o.concat(buffer.Buffer.from([$]));
                j = this.createProgramAddressSync(_e, a)
            } catch (_e) {
                if (_e instanceof TypeError) throw _e;
                $--;
                continue
            }
            return [j, $]
        }
        throw new Error("Unable to find a viable program address nonce")
    }
    static async findProgramAddress(o, a) {
        return this.findProgramAddressSync(o, a)
    }
    static isOnCurve(o) {
        const a = new PublicKey(o);
        return isOnCurve(a.toBytes())
    }
}
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
    kind: "struct",
    fields: [
        ["_bn", "u256"]
    ]
});
class Account {
    constructor(o) {
        if (this._publicKey = void 0, this._secretKey = void 0, o) {
            const a = toBuffer$1(o);
            if (o.length !== 64) throw new Error("bad secret key size");
            this._publicKey = a.slice(32, 64), this._secretKey = a.slice(0, 32)
        } else this._secretKey = toBuffer$1(generatePrivateKey()), this._publicKey = toBuffer$1(getPublicKey(this._secretKey))
    }
    get publicKey() {
        return new PublicKey(this._publicKey)
    }
    get secretKey() {
        return buffer.Buffer.concat([this._secretKey, this._publicKey], 64)
    }
}
const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111"),
    PACKET_DATA_SIZE = 1232,
    VERSION_PREFIX_MASK = 127,
    SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
    constructor(o) {
        super(`Signature ${o} has expired: block height exceeded.`), this.signature = void 0, this.signature = o
    }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
    constructor(o, a) {
        super(`Transaction was not confirmed in ${a.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${o} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = o
    }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
    constructor(o) {
        super(`Signature ${o} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = o
    }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
    constructor(o, a) {
        this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = o, this.accountKeysFromLookups = a
    }
    keySegments() {
        const o = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (o.push(this.accountKeysFromLookups.writable), o.push(this.accountKeysFromLookups.readonly)), o
    }
    get(o) {
        for (const a of this.keySegments()) {
            if (o < a.length) return a[o];
            o -= a.length
        }
    }
    get length() {
        return this.keySegments().flat().length
    }
    compileInstructions(o) {
        if (this.length > 256) throw new Error("Account index overflow encountered during compilation");
        const $ = new Map;
        this.keySegments().flat().forEach((_e, et) => {
            $.set(_e.toBase58(), et)
        });
        const j = _e => {
            const et = $.get(_e.toBase58());
            if (et === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
            return et
        };
        return o.map(_e => ({
            programIdIndex: j(_e.programId),
            accountKeyIndexes: _e.keys.map(et => j(et.pubkey)),
            data: _e.data
        }))
    }
}
const publicKey$3 = (s = "publicKey") => blob$1(32, s),
    signature = (s = "signature") => blob$1(64, s),
    rustString = (s = "string") => {
        const o = struct$1([u32$1("length"), u32$1("lengthPadding"), blob$1(offset$1(u32$1(), -8), "chars")], s),
            a = o.decode.bind(o),
            $ = o.encode.bind(o),
            j = o;
        return j.decode = (_e, et) => a(_e, et).chars.toString(), j.encode = (_e, et, tt) => {
            const nt = {
                chars: buffer.Buffer.from(_e, "utf8")
            };
            return $(nt, et, tt)
        }, j.alloc = _e => u32$1().span + u32$1().span + buffer.Buffer.from(_e, "utf8").length, j
    },
    authorized = (s = "authorized") => struct$1([publicKey$3("staker"), publicKey$3("withdrawer")], s),
    lockup = (s = "lockup") => struct$1([ns64$1("unixTimestamp"), ns64$1("epoch"), publicKey$3("custodian")], s),
    voteInit = (s = "voteInit") => struct$1([publicKey$3("nodePubkey"), publicKey$3("authorizedVoter"), publicKey$3("authorizedWithdrawer"), u8$1("commission")], s),
    voteAuthorizeWithSeedArgs = (s = "voteAuthorizeWithSeedArgs") => struct$1([u32$1("voteAuthorizationType"), publicKey$3("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey$3("newAuthorized")], s);

function getAlloc(s, o) {
    const a = j => {
        if (j.span >= 0) return j.span;
        if (typeof j.alloc == "function") return j.alloc(o[j.property]);
        if ("count" in j && "elementLayout" in j) {
            const _e = o[j.property];
            if (Array.isArray(_e)) return _e.length * a(j.elementLayout)
        } else if ("fields" in j) return getAlloc({
            layout: j
        }, o[j.property]);
        return 0
    };
    let $ = 0;
    return s.layout.fields.forEach(j => {
        $ += a(j)
    }), $
}

function decodeLength(s) {
    let o = 0,
        a = 0;
    for (;;) {
        let $ = s.shift();
        if (o |= ($ & 127) << a * 7, a += 1, !($ & 128)) break
    }
    return o
}

function encodeLength(s, o) {
    let a = o;
    for (;;) {
        let $ = a & 127;
        if (a >>= 7, a == 0) {
            s.push($);
            break
        } else $ |= 128, s.push($)
    }
}

function assert$2(s, o) {
    if (!s) throw new Error(o || "Assertion failed")
}
class CompiledKeys {
    constructor(o, a) {
        this.payer = void 0, this.keyMetaMap = void 0, this.payer = o, this.keyMetaMap = a
    }
    static compile(o, a) {
        const $ = new Map,
            j = et => {
                const tt = et.toBase58();
                let nt = $.get(tt);
                return nt === void 0 && (nt = {
                    isSigner: !1,
                    isWritable: !1,
                    isInvoked: !1
                }, $.set(tt, nt)), nt
            },
            _e = j(a);
        _e.isSigner = !0, _e.isWritable = !0;
        for (const et of o) {
            j(et.programId).isInvoked = !0;
            for (const tt of et.keys) {
                const nt = j(tt.pubkey);
                nt.isSigner || (nt.isSigner = tt.isSigner), nt.isWritable || (nt.isWritable = tt.isWritable)
            }
        }
        return new CompiledKeys(a, $)
    }
    getMessageComponents() {
        const o = [...this.keyMetaMap.entries()];
        assert$2(o.length <= 256, "Max static account keys length exceeded");
        const a = o.filter(([, nt]) => nt.isSigner && nt.isWritable),
            $ = o.filter(([, nt]) => nt.isSigner && !nt.isWritable),
            j = o.filter(([, nt]) => !nt.isSigner && nt.isWritable),
            _e = o.filter(([, nt]) => !nt.isSigner && !nt.isWritable),
            et = {
                numRequiredSignatures: a.length + $.length,
                numReadonlySignedAccounts: $.length,
                numReadonlyUnsignedAccounts: _e.length
            }; {
            assert$2(a.length > 0, "Expected at least one writable signer key");
            const [nt] = a[0];
            assert$2(nt === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        const tt = [...a.map(([nt]) => new PublicKey(nt)), ...$.map(([nt]) => new PublicKey(nt)), ...j.map(([nt]) => new PublicKey(nt)), ..._e.map(([nt]) => new PublicKey(nt))];
        return [et, tt]
    }
    extractTableLookup(o) {
        const [a, $] = this.drainKeysFoundInLookupTable(o.state.addresses, et => !et.isSigner && !et.isInvoked && et.isWritable), [j, _e] = this.drainKeysFoundInLookupTable(o.state.addresses, et => !et.isSigner && !et.isInvoked && !et.isWritable);
        if (!(a.length === 0 && j.length === 0)) return [{
            accountKey: o.key,
            writableIndexes: a,
            readonlyIndexes: j
        }, {
            writable: $,
            readonly: _e
        }]
    }
    drainKeysFoundInLookupTable(o, a) {
        const $ = new Array,
            j = new Array;
        for (const [_e, et] of this.keyMetaMap.entries())
            if (a(et)) {
                const tt = new PublicKey(_e),
                    nt = o.findIndex(rt => rt.equals(tt));
                nt >= 0 && (assert$2(nt < 256, "Max lookup table index exceeded"), $.push(nt), j.push(tt), this.keyMetaMap.delete(_e))
            }
        return [$, j]
    }
}
const END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";

function guardedShift(s) {
    if (s.length === 0) throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    return s.shift()
}

function guardedSplice(s, ...o) {
    const [a] = o;
    if (o.length === 2 ? a + (o[1] ? ? 0) > s.length : a >= s.length) throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    return s.splice(...o)
}
class Message {
    constructor(o) {
        this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = o.header, this.accountKeys = o.accountKeys.map(a => new PublicKey(a)), this.recentBlockhash = o.recentBlockhash, this.instructions = o.instructions, this.instructions.forEach(a => this.indexToProgramIds.set(a.programIdIndex, this.accountKeys[a.programIdIndex]))
    }
    get version() {
        return "legacy"
    }
    get staticAccountKeys() {
        return this.accountKeys
    }
    get compiledInstructions() {
        return this.instructions.map(o => ({
            programIdIndex: o.programIdIndex,
            accountKeyIndexes: o.accounts,
            data: bs58$1$1.decode(o.data)
        }))
    }
    get addressTableLookups() {
        return []
    }
    getAccountKeys() {
        return new MessageAccountKeys(this.staticAccountKeys)
    }
    static compile(o) {
        const a = CompiledKeys.compile(o.instructions, o.payerKey),
            [$, j] = a.getMessageComponents(),
            et = new MessageAccountKeys(j).compileInstructions(o.instructions).map(tt => ({
                programIdIndex: tt.programIdIndex,
                accounts: tt.accountKeyIndexes,
                data: bs58$1$1.encode(tt.data)
            }));
        return new Message({
            header: $,
            accountKeys: j,
            recentBlockhash: o.recentBlockhash,
            instructions: et
        })
    }
    isAccountSigner(o) {
        return o < this.header.numRequiredSignatures
    }
    isAccountWritable(o) {
        const a = this.header.numRequiredSignatures;
        if (o >= this.header.numRequiredSignatures) {
            const $ = o - a,
                _e = this.accountKeys.length - a - this.header.numReadonlyUnsignedAccounts;
            return $ < _e
        } else {
            const $ = a - this.header.numReadonlySignedAccounts;
            return o < $
        }
    }
    isProgramId(o) {
        return this.indexToProgramIds.has(o)
    }
    programIds() {
        return [...this.indexToProgramIds.values()]
    }
    nonProgramIds() {
        return this.accountKeys.filter((o, a) => !this.isProgramId(a))
    }
    serialize() {
        const o = this.accountKeys.length;
        let a = [];
        encodeLength(a, o);
        const $ = this.instructions.map(st => {
            const {
                accounts: lt,
                programIdIndex: ft
            } = st, yt = Array.from(bs58$1$1.decode(st.data));
            let bt = [];
            encodeLength(bt, lt.length);
            let ht = [];
            return encodeLength(ht, yt.length), {
                programIdIndex: ft,
                keyIndicesCount: buffer.Buffer.from(bt),
                keyIndices: lt,
                dataLength: buffer.Buffer.from(ht),
                data: yt
            }
        });
        let j = [];
        encodeLength(j, $.length);
        let _e = buffer.Buffer.alloc(PACKET_DATA_SIZE);
        buffer.Buffer.from(j).copy(_e);
        let et = j.length;
        $.forEach(st => {
            const ft = struct$1([u8$1("programIdIndex"), blob$1(st.keyIndicesCount.length, "keyIndicesCount"), seq(u8$1("keyIndex"), st.keyIndices.length, "keyIndices"), blob$1(st.dataLength.length, "dataLength"), seq(u8$1("userdatum"), st.data.length, "data")]).encode(st, _e, et);
            et += ft
        }), _e = _e.slice(0, et);
        const tt = struct$1([blob$1(1, "numRequiredSignatures"), blob$1(1, "numReadonlySignedAccounts"), blob$1(1, "numReadonlyUnsignedAccounts"), blob$1(a.length, "keyCount"), seq(publicKey$3("key"), o, "keys"), publicKey$3("recentBlockhash")]),
            nt = {
                numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
                numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
                numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                keyCount: buffer.Buffer.from(a),
                keys: this.accountKeys.map(st => toBuffer$1(st.toBytes())),
                recentBlockhash: bs58$1$1.decode(this.recentBlockhash)
            };
        let rt = buffer.Buffer.alloc(2048);
        const ot = tt.encode(nt, rt);
        return _e.copy(rt, ot), rt.slice(0, ot + _e.length)
    }
    static from(o) {
        let a = [...o];
        const $ = guardedShift(a);
        if ($ !== ($ & VERSION_PREFIX_MASK)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const j = guardedShift(a),
            _e = guardedShift(a),
            et = decodeLength(a);
        let tt = [];
        for (let lt = 0; lt < et; lt++) {
            const ft = guardedSplice(a, 0, PUBLIC_KEY_LENGTH);
            tt.push(new PublicKey(buffer.Buffer.from(ft)))
        }
        const nt = guardedSplice(a, 0, PUBLIC_KEY_LENGTH),
            rt = decodeLength(a);
        let ot = [];
        for (let lt = 0; lt < rt; lt++) {
            const ft = guardedShift(a),
                yt = decodeLength(a),
                bt = guardedSplice(a, 0, yt),
                ht = decodeLength(a),
                vt = guardedSplice(a, 0, ht),
                wt = bs58$1$1.encode(buffer.Buffer.from(vt));
            ot.push({
                programIdIndex: ft,
                accounts: bt,
                data: wt
            })
        }
        const st = {
            header: {
                numRequiredSignatures: $,
                numReadonlySignedAccounts: j,
                numReadonlyUnsignedAccounts: _e
            },
            recentBlockhash: bs58$1$1.encode(buffer.Buffer.from(nt)),
            accountKeys: tt,
            instructions: ot
        };
        return new Message(st)
    }
}
class MessageV0 {
    constructor(o) {
        this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = o.header, this.staticAccountKeys = o.staticAccountKeys, this.recentBlockhash = o.recentBlockhash, this.compiledInstructions = o.compiledInstructions, this.addressTableLookups = o.addressTableLookups
    }
    get version() {
        return 0
    }
    get numAccountKeysFromLookups() {
        let o = 0;
        for (const a of this.addressTableLookups) o += a.readonlyIndexes.length + a.writableIndexes.length;
        return o
    }
    getAccountKeys(o) {
        let a;
        if (o && "accountKeysFromLookups" in o && o.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != o.accountKeysFromLookups.writable.length + o.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            a = o.accountKeysFromLookups
        } else if (o && "addressLookupTableAccounts" in o && o.addressLookupTableAccounts) a = this.resolveAddressTableLookups(o.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new MessageAccountKeys(this.staticAccountKeys, a)
    }
    isAccountSigner(o) {
        return o < this.header.numRequiredSignatures
    }
    isAccountWritable(o) {
        const a = this.header.numRequiredSignatures,
            $ = this.staticAccountKeys.length;
        if (o >= $) {
            const j = o - $,
                _e = this.addressTableLookups.reduce((et, tt) => et + tt.writableIndexes.length, 0);
            return j < _e
        } else if (o >= this.header.numRequiredSignatures) {
            const j = o - a,
                et = $ - a - this.header.numReadonlyUnsignedAccounts;
            return j < et
        } else {
            const j = a - this.header.numReadonlySignedAccounts;
            return o < j
        }
    }
    resolveAddressTableLookups(o) {
        const a = {
            writable: [],
            readonly: []
        };
        for (const $ of this.addressTableLookups) {
            const j = o.find(_e => _e.key.equals($.accountKey));
            if (!j) throw new Error(`Failed to find address lookup table account for table key ${$.accountKey.toBase58()}`);
            for (const _e of $.writableIndexes)
                if (_e < j.state.addresses.length) a.writable.push(j.state.addresses[_e]);
                else throw new Error(`Failed to find address for index ${_e} in address lookup table ${$.accountKey.toBase58()}`);
            for (const _e of $.readonlyIndexes)
                if (_e < j.state.addresses.length) a.readonly.push(j.state.addresses[_e]);
                else throw new Error(`Failed to find address for index ${_e} in address lookup table ${$.accountKey.toBase58()}`)
        }
        return a
    }
    static compile(o) {
        const a = CompiledKeys.compile(o.instructions, o.payerKey),
            $ = new Array,
            j = {
                writable: new Array,
                readonly: new Array
            },
            _e = o.addressLookupTableAccounts || [];
        for (const ot of _e) {
            const st = a.extractTableLookup(ot);
            if (st !== void 0) {
                const [lt, {
                    writable: ft,
                    readonly: yt
                }] = st;
                $.push(lt), j.writable.push(...ft), j.readonly.push(...yt)
            }
        }
        const [et, tt] = a.getMessageComponents(), rt = new MessageAccountKeys(tt, j).compileInstructions(o.instructions);
        return new MessageV0({
            header: et,
            staticAccountKeys: tt,
            recentBlockhash: o.recentBlockhash,
            compiledInstructions: rt,
            addressTableLookups: $
        })
    }
    serialize() {
        const o = Array();
        encodeLength(o, this.staticAccountKeys.length);
        const a = this.serializeInstructions(),
            $ = Array();
        encodeLength($, this.compiledInstructions.length);
        const j = this.serializeAddressTableLookups(),
            _e = Array();
        encodeLength(_e, this.addressTableLookups.length);
        const et = struct$1([u8$1("prefix"), struct$1([u8$1("numRequiredSignatures"), u8$1("numReadonlySignedAccounts"), u8$1("numReadonlyUnsignedAccounts")], "header"), blob$1(o.length, "staticAccountKeysLength"), seq(publicKey$3(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey$3("recentBlockhash"), blob$1($.length, "instructionsLength"), blob$1(a.length, "serializedInstructions"), blob$1(_e.length, "addressTableLookupsLength"), blob$1(j.length, "serializedAddressTableLookups")]),
            tt = new Uint8Array(PACKET_DATA_SIZE),
            rt = et.encode({
                prefix: 128,
                header: this.header,
                staticAccountKeysLength: new Uint8Array(o),
                staticAccountKeys: this.staticAccountKeys.map(ot => ot.toBytes()),
                recentBlockhash: bs58$1$1.decode(this.recentBlockhash),
                instructionsLength: new Uint8Array($),
                serializedInstructions: a,
                addressTableLookupsLength: new Uint8Array(_e),
                serializedAddressTableLookups: j
            }, tt);
        return tt.slice(0, rt)
    }
    serializeInstructions() {
        let o = 0;
        const a = new Uint8Array(PACKET_DATA_SIZE);
        for (const $ of this.compiledInstructions) {
            const j = Array();
            encodeLength(j, $.accountKeyIndexes.length);
            const _e = Array();
            encodeLength(_e, $.data.length);
            const et = struct$1([u8$1("programIdIndex"), blob$1(j.length, "encodedAccountKeyIndexesLength"), seq(u8$1(), $.accountKeyIndexes.length, "accountKeyIndexes"), blob$1(_e.length, "encodedDataLength"), blob$1($.data.length, "data")]);
            o += et.encode({
                programIdIndex: $.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(j),
                accountKeyIndexes: $.accountKeyIndexes,
                encodedDataLength: new Uint8Array(_e),
                data: $.data
            }, a, o)
        }
        return a.slice(0, o)
    }
    serializeAddressTableLookups() {
        let o = 0;
        const a = new Uint8Array(PACKET_DATA_SIZE);
        for (const $ of this.addressTableLookups) {
            const j = Array();
            encodeLength(j, $.writableIndexes.length);
            const _e = Array();
            encodeLength(_e, $.readonlyIndexes.length);
            const et = struct$1([publicKey$3("accountKey"), blob$1(j.length, "encodedWritableIndexesLength"), seq(u8$1(), $.writableIndexes.length, "writableIndexes"), blob$1(_e.length, "encodedReadonlyIndexesLength"), seq(u8$1(), $.readonlyIndexes.length, "readonlyIndexes")]);
            o += et.encode({
                accountKey: $.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(j),
                writableIndexes: $.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(_e),
                readonlyIndexes: $.readonlyIndexes
            }, a, o)
        }
        return a.slice(0, o)
    }
    static deserialize(o) {
        let a = [...o];
        const $ = guardedShift(a),
            j = $ & VERSION_PREFIX_MASK;
        assert$2($ !== j, "Expected versioned message but received legacy message");
        const _e = j;
        assert$2(_e === 0, `Expected versioned message with version 0 but found version ${_e}`);
        const et = {
                numRequiredSignatures: guardedShift(a),
                numReadonlySignedAccounts: guardedShift(a),
                numReadonlyUnsignedAccounts: guardedShift(a)
            },
            tt = [],
            nt = decodeLength(a);
        for (let yt = 0; yt < nt; yt++) tt.push(new PublicKey(guardedSplice(a, 0, PUBLIC_KEY_LENGTH)));
        const rt = bs58$1$1.encode(guardedSplice(a, 0, PUBLIC_KEY_LENGTH)),
            ot = decodeLength(a),
            st = [];
        for (let yt = 0; yt < ot; yt++) {
            const bt = guardedShift(a),
                ht = decodeLength(a),
                vt = guardedSplice(a, 0, ht),
                wt = decodeLength(a),
                gt = new Uint8Array(guardedSplice(a, 0, wt));
            st.push({
                programIdIndex: bt,
                accountKeyIndexes: vt,
                data: gt
            })
        }
        const lt = decodeLength(a),
            ft = [];
        for (let yt = 0; yt < lt; yt++) {
            const bt = new PublicKey(guardedSplice(a, 0, PUBLIC_KEY_LENGTH)),
                ht = decodeLength(a),
                vt = guardedSplice(a, 0, ht),
                wt = decodeLength(a),
                gt = guardedSplice(a, 0, wt);
            ft.push({
                accountKey: bt,
                writableIndexes: vt,
                readonlyIndexes: gt
            })
        }
        return new MessageV0({
            header: et,
            staticAccountKeys: tt,
            recentBlockhash: rt,
            compiledInstructions: st,
            addressTableLookups: ft
        })
    }
}
const VersionedMessage = {
    deserializeMessageVersion(s) {
        const o = s[0],
            a = o & VERSION_PREFIX_MASK;
        return a === o ? "legacy" : a
    },
    deserialize: s => {
        const o = VersionedMessage.deserializeMessageVersion(s);
        if (o === "legacy") return Message.from(s);
        if (o === 0) return MessageV0.deserialize(s);
        throw new Error(`Transaction message version ${o} deserialization is not supported`)
    }
};
let TransactionStatus = function(s) {
    return s[s.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", s[s.PROCESSED = 1] = "PROCESSED", s[s.TIMED_OUT = 2] = "TIMED_OUT", s[s.NONCE_INVALID = 3] = "NONCE_INVALID", s
}({});
const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
    constructor(o) {
        this.keys = void 0, this.programId = void 0, this.data = buffer.Buffer.alloc(0), this.programId = o.programId, this.keys = o.keys, o.data && (this.data = o.data)
    }
    toJSON() {
        return {
            keys: this.keys.map(({
                pubkey: o,
                isSigner: a,
                isWritable: $
            }) => ({
                pubkey: o.toJSON(),
                isSigner: a,
                isWritable: $
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
        }
    }
}
class Transaction {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }
    constructor(o) {
        if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!o)
            if (o.feePayer && (this.feePayer = o.feePayer), o.signatures && (this.signatures = o.signatures), Object.prototype.hasOwnProperty.call(o, "nonceInfo")) {
                const {
                    minContextSlot: a,
                    nonceInfo: $
                } = o;
                this.minNonceContextSlot = a, this.nonceInfo = $
            } else if (Object.prototype.hasOwnProperty.call(o, "lastValidBlockHeight")) {
            const {
                blockhash: a,
                lastValidBlockHeight: $
            } = o;
            this.recentBlockhash = a, this.lastValidBlockHeight = $
        } else {
            const {
                recentBlockhash: a,
                nonceInfo: $
            } = o;
            $ && (this.nonceInfo = $), this.recentBlockhash = a
        }
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map(o => o.toJSON()),
            signers: this.signatures.map(({
                publicKey: o
            }) => o.toJSON())
        }
    }
    add(...o) {
        if (o.length === 0) throw new Error("No instructions");
        return o.forEach(a => {
            "instructions" in a ? this.instructions = this.instructions.concat(a.instructions) : "data" in a && "programId" in a && "keys" in a ? this.instructions.push(a) : this.instructions.push(new TransactionInstruction(a))
        }), this
    }
    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
        let o, a;
        if (this.nonceInfo ? (o = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? a = [this.nonceInfo.nonceInstruction, ...this.instructions] : a = this.instructions) : (o = this.recentBlockhash, a = this.instructions), !o) throw new Error("Transaction recentBlockhash required");
        a.length < 1 && console.warn("No instructions provided");
        let $;
        if (this.feePayer) $ = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey) $ = this.signatures[0].publicKey;
        else throw new Error("Transaction fee payer required");
        for (let bt = 0; bt < a.length; bt++)
            if (a[bt].programId === void 0) throw new Error(`Transaction instruction index ${bt} has undefined program id`);
        const j = [],
            _e = [];
        a.forEach(bt => {
            bt.keys.forEach(vt => {
                _e.push({ ...vt
                })
            });
            const ht = bt.programId.toString();
            j.includes(ht) || j.push(ht)
        }), j.forEach(bt => {
            _e.push({
                pubkey: new PublicKey(bt),
                isSigner: !1,
                isWritable: !1
            })
        });
        const et = [];
        _e.forEach(bt => {
            const ht = bt.pubkey.toString(),
                vt = et.findIndex(wt => wt.pubkey.toString() === ht);
            vt > -1 ? (et[vt].isWritable = et[vt].isWritable || bt.isWritable, et[vt].isSigner = et[vt].isSigner || bt.isSigner) : et.push(bt)
        }), et.sort(function(bt, ht) {
            if (bt.isSigner !== ht.isSigner) return bt.isSigner ? -1 : 1;
            if (bt.isWritable !== ht.isWritable) return bt.isWritable ? -1 : 1;
            const vt = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return bt.pubkey.toBase58().localeCompare(ht.pubkey.toBase58(), "en", vt)
        });
        const tt = et.findIndex(bt => bt.pubkey.equals($));
        if (tt > -1) {
            const [bt] = et.splice(tt, 1);
            bt.isSigner = !0, bt.isWritable = !0, et.unshift(bt)
        } else et.unshift({
            pubkey: $,
            isSigner: !0,
            isWritable: !0
        });
        for (const bt of this.signatures) {
            const ht = et.findIndex(vt => vt.pubkey.equals(bt.publicKey));
            if (ht > -1) et[ht].isSigner || (et[ht].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
            else throw new Error(`unknown signer: ${bt.publicKey.toString()}`)
        }
        let nt = 0,
            rt = 0,
            ot = 0;
        const st = [],
            lt = [];
        et.forEach(({
            pubkey: bt,
            isSigner: ht,
            isWritable: vt
        }) => {
            ht ? (st.push(bt.toString()), nt += 1, vt || (rt += 1)) : (lt.push(bt.toString()), vt || (ot += 1))
        });
        const ft = st.concat(lt),
            yt = a.map(bt => {
                const {
                    data: ht,
                    programId: vt
                } = bt;
                return {
                    programIdIndex: ft.indexOf(vt.toString()),
                    accounts: bt.keys.map(wt => ft.indexOf(wt.pubkey.toString())),
                    data: bs58$1$1.encode(ht)
                }
            });
        return yt.forEach(bt => {
            assert$2(bt.programIdIndex >= 0), bt.accounts.forEach(ht => assert$2(ht >= 0))
        }), new Message({
            header: {
                numRequiredSignatures: nt,
                numReadonlySignedAccounts: rt,
                numReadonlyUnsignedAccounts: ot
            },
            accountKeys: ft,
            recentBlockhash: o,
            instructions: yt
        })
    }
    _compile() {
        const o = this.compileMessage(),
            a = o.accountKeys.slice(0, o.header.numRequiredSignatures);
        return this.signatures.length === a.length && this.signatures.every((j, _e) => a[_e].equals(j.publicKey)) || (this.signatures = a.map($ => ({
            signature: null,
            publicKey: $
        }))), o
    }
    serializeMessage() {
        return this._compile().serialize()
    }
    async getEstimatedFee(o) {
        return (await o.getFeeForMessage(this.compileMessage())).value
    }
    setSigners(...o) {
        if (o.length === 0) throw new Error("No signers");
        const a = new Set;
        this.signatures = o.filter($ => {
            const j = $.toString();
            return a.has(j) ? !1 : (a.add(j), !0)
        }).map($ => ({
            signature: null,
            publicKey: $
        }))
    }
    sign(...o) {
        if (o.length === 0) throw new Error("No signers");
        const a = new Set,
            $ = [];
        for (const _e of o) {
            const et = _e.publicKey.toString();
            a.has(et) || (a.add(et), $.push(_e))
        }
        this.signatures = $.map(_e => ({
            signature: null,
            publicKey: _e.publicKey
        }));
        const j = this._compile();
        this._partialSign(j, ...$)
    }
    partialSign(...o) {
        if (o.length === 0) throw new Error("No signers");
        const a = new Set,
            $ = [];
        for (const _e of o) {
            const et = _e.publicKey.toString();
            a.has(et) || (a.add(et), $.push(_e))
        }
        const j = this._compile();
        this._partialSign(j, ...$)
    }
    _partialSign(o, ...a) {
        const $ = o.serialize();
        a.forEach(j => {
            const _e = sign($, j.secretKey);
            this._addSignature(j.publicKey, toBuffer$1(_e))
        })
    }
    addSignature(o, a) {
        this._compile(), this._addSignature(o, a)
    }
    _addSignature(o, a) {
        assert$2(a.length === 64);
        const $ = this.signatures.findIndex(j => o.equals(j.publicKey));
        if ($ < 0) throw new Error(`unknown signer: ${o.toString()}`);
        this.signatures[$].signature = buffer.Buffer.from(a)
    }
    verifySignatures(o = !0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), o)
    }
    _getMessageSignednessErrors(o, a) {
        const $ = {};
        for (const {
                signature: j,
                publicKey: _e
            } of this.signatures) j === null ? a && ($.missing || ($.missing = [])).push(_e) : verify(j, o, _e.toBytes()) || ($.invalid || ($.invalid = [])).push(_e);
        return $.invalid || $.missing ? $ : void 0
    }
    serialize(o) {
        const {
            requireAllSignatures: a,
            verifySignatures: $
        } = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, o), j = this.serializeMessage();
        if ($) {
            const _e = this._getMessageSignednessErrors(j, a);
            if (_e) {
                let et = "Signature verification failed.";
                throw _e.invalid && (et += `
Invalid signature for public key${_e.invalid.length===1?"":"(s)"} [\`${_e.invalid.map(tt=>tt.toBase58()).join("`, `")}\`].`), _e.missing && (et += `
Missing signature for public key${_e.missing.length===1?"":"(s)"} [\`${_e.missing.map(tt=>tt.toBase58()).join("`, `")}\`].`), new Error(et)
            }
        }
        return this._serialize(j)
    }
    _serialize(o) {
        const {
            signatures: a
        } = this, $ = [];
        encodeLength($, a.length);
        const j = $.length + a.length * 64 + o.length,
            _e = buffer.Buffer.alloc(j);
        return assert$2(a.length < 256), buffer.Buffer.from($).copy(_e, 0), a.forEach(({
            signature: et
        }, tt) => {
            et !== null && (assert$2(et.length === 64, "signature has invalid length"), buffer.Buffer.from(et).copy(_e, $.length + tt * 64))
        }), o.copy(_e, $.length + a.length * 64), assert$2(_e.length <= PACKET_DATA_SIZE, `Transaction too large: ${_e.length} > ${PACKET_DATA_SIZE}`), _e
    }
    get keys() {
        return assert$2(this.instructions.length === 1), this.instructions[0].keys.map(o => o.pubkey)
    }
    get programId() {
        return assert$2(this.instructions.length === 1), this.instructions[0].programId
    }
    get data() {
        return assert$2(this.instructions.length === 1), this.instructions[0].data
    }
    static from(o) {
        let a = [...o];
        const $ = decodeLength(a);
        let j = [];
        for (let _e = 0; _e < $; _e++) {
            const et = guardedSplice(a, 0, SIGNATURE_LENGTH_IN_BYTES);
            j.push(bs58$1$1.encode(buffer.Buffer.from(et)))
        }
        return Transaction.populate(Message.from(a), j)
    }
    static populate(o, a = []) {
        const $ = new Transaction;
        return $.recentBlockhash = o.recentBlockhash, o.header.numRequiredSignatures > 0 && ($.feePayer = o.accountKeys[0]), a.forEach((j, _e) => {
            const et = {
                signature: j == bs58$1$1.encode(DEFAULT_SIGNATURE) ? null : bs58$1$1.decode(j),
                publicKey: o.accountKeys[_e]
            };
            $.signatures.push(et)
        }), o.instructions.forEach(j => {
            const _e = j.accounts.map(et => {
                const tt = o.accountKeys[et];
                return {
                    pubkey: tt,
                    isSigner: $.signatures.some(nt => nt.publicKey.toString() === tt.toString()) || o.isAccountSigner(et),
                    isWritable: o.isAccountWritable(et)
                }
            });
            $.instructions.push(new TransactionInstruction({
                keys: _e,
                programId: o.accountKeys[j.programIdIndex],
                data: bs58$1$1.decode(j.data)
            }))
        }), $._message = o, $._json = $.toJSON(), $
    }
}
class TransactionMessage {
    constructor(o) {
        this.payerKey = void 0, this.instructions = void 0, this.recentBlockhash = void 0, this.payerKey = o.payerKey, this.instructions = o.instructions, this.recentBlockhash = o.recentBlockhash
    }
    static decompile(o, a) {
        const {
            header: $,
            compiledInstructions: j,
            recentBlockhash: _e
        } = o, {
            numRequiredSignatures: et,
            numReadonlySignedAccounts: tt,
            numReadonlyUnsignedAccounts: nt
        } = $, rt = et - tt;
        assert$2(rt > 0, "Message header is invalid");
        const ot = o.staticAccountKeys.length - et - nt;
        assert$2(ot >= 0, "Message header is invalid");
        const st = o.getAccountKeys(a),
            lt = st.get(0);
        if (lt === void 0) throw new Error("Failed to decompile message because no account keys were found");
        const ft = [];
        for (const yt of j) {
            const bt = [];
            for (const vt of yt.accountKeyIndexes) {
                const wt = st.get(vt);
                if (wt === void 0) throw new Error(`Failed to find key for account key index ${vt}`);
                const gt = vt < et;
                let At;
                gt ? At = vt < rt : vt < st.staticAccountKeys.length ? At = vt - et < ot : At = vt - st.staticAccountKeys.length < st.accountKeysFromLookups.writable.length, bt.push({
                    pubkey: wt,
                    isSigner: vt < $.numRequiredSignatures,
                    isWritable: At
                })
            }
            const ht = st.get(yt.programIdIndex);
            if (ht === void 0) throw new Error(`Failed to find program id for program id index ${yt.programIdIndex}`);
            ft.push(new TransactionInstruction({
                programId: ht,
                data: toBuffer$1(yt.data),
                keys: bt
            }))
        }
        return new TransactionMessage({
            payerKey: lt,
            instructions: ft,
            recentBlockhash: _e
        })
    }
    compileToLegacyMessage() {
        return Message.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions
        })
    }
    compileToV0Message(o) {
        return MessageV0.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts: o
        })
    }
}
class VersionedTransaction {
    get version() {
        return this.message.version
    }
    constructor(o, a) {
        if (this.signatures = void 0, this.message = void 0, a !== void 0) assert$2(a.length === o.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = a;
        else {
            const $ = [];
            for (let j = 0; j < o.header.numRequiredSignatures; j++) $.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
            this.signatures = $
        }
        this.message = o
    }
    serialize() {
        const o = this.message.serialize(),
            a = Array();
        encodeLength(a, this.signatures.length);
        const $ = struct$1([blob$1(a.length, "encodedSignaturesLength"), seq(signature(), this.signatures.length, "signatures"), blob$1(o.length, "serializedMessage")]),
            j = new Uint8Array(2048),
            _e = $.encode({
                encodedSignaturesLength: new Uint8Array(a),
                signatures: this.signatures,
                serializedMessage: o
            }, j);
        return j.slice(0, _e)
    }
    static deserialize(o) {
        let a = [...o];
        const $ = [],
            j = decodeLength(a);
        for (let et = 0; et < j; et++) $.push(new Uint8Array(guardedSplice(a, 0, SIGNATURE_LENGTH_IN_BYTES)));
        const _e = VersionedMessage.deserialize(new Uint8Array(a));
        return new VersionedTransaction(_e, $)
    }
    sign(o) {
        const a = this.message.serialize(),
            $ = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const j of o) {
            const _e = $.findIndex(et => et.equals(j.publicKey));
            assert$2(_e >= 0, `Cannot sign with non signer key ${j.publicKey.toBase58()}`), this.signatures[_e] = sign(a, j.secretKey)
        }
    }
    addSignature(o, a) {
        assert$2(a.byteLength === 64, "Signature must be 64 bytes long");
        const j = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(_e => _e.equals(o));
        assert$2(j >= 0, `Can not add signature; \`${o.toBase58()}\` is not required to sign this transaction`), this.signatures[j] = a
    }
}
const NUM_TICKS_PER_SECOND = 160,
    DEFAULT_TICKS_PER_SLOT = 64,
    NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT,
    MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND,
    SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111"),
    SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),
    SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111"),
    SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),
    SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111"),
    SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111"),
    SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111"),
    SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111"),
    SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
class SendTransactionError extends Error {
    constructor({
        action: o,
        signature: a,
        transactionMessage: $,
        logs: j
    }) {
        const _e = j ? `Logs: 
${JSON.stringify(j.slice(-10),null,2)}. ` : "",
            et = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
        let tt;
        switch (o) {
            case "send":
                tt = `Transaction ${a} resulted in an error. 
${$}. ` + _e + et;
                break;
            case "simulate":
                tt = `Simulation failed. 
Message: ${$}. 
` + _e + et;
                break;
            default:
                tt = `Unknown action '${(nt=>nt)(o)}'`
        }
        super(tt), this.signature = void 0, this.transactionMessage = void 0, this.transactionLogs = void 0, this.signature = a, this.transactionMessage = $, this.transactionLogs = j || void 0
    }
    get transactionError() {
        return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
        }
    }
    get logs() {
        const o = this.transactionLogs;
        if (!(o != null && typeof o == "object" && "then" in o)) return o
    }
    async getLogs(o) {
        return Array.isArray(this.transactionLogs) || (this.transactionLogs = new Promise((a, $) => {
            o.getTransaction(this.signature).then(j => {
                if (j && j.meta && j.meta.logMessages) {
                    const _e = j.meta.logMessages;
                    this.transactionLogs = _e, a(_e)
                } else $(new Error("Log messages not found"))
            }).catch($)
        })), await this.transactionLogs
    }
}
const SolanaJSONRPCErrorCode = {
    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
    JSON_RPC_SCAN_ERROR: -32012,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class SolanaJSONRPCError extends Error {
    constructor({
        code: o,
        message: a,
        data: $
    }, j) {
        super(j != null ? `${j}: ${a}` : a), this.code = void 0, this.data = void 0, this.code = o, this.data = $, this.name = "SolanaJSONRPCError"
    }
}
async function sendAndConfirmTransaction(s, o, a, $) {
    const j = $ && {
            skipPreflight: $.skipPreflight,
            preflightCommitment: $.preflightCommitment || $.commitment,
            maxRetries: $.maxRetries,
            minContextSlot: $.minContextSlot
        },
        _e = await s.sendTransaction(o, a, j);
    let et;
    if (o.recentBlockhash != null && o.lastValidBlockHeight != null) et = (await s.confirmTransaction({
        abortSignal: $ == null ? void 0 : $.abortSignal,
        signature: _e,
        blockhash: o.recentBlockhash,
        lastValidBlockHeight: o.lastValidBlockHeight
    }, $ && $.commitment)).value;
    else if (o.minNonceContextSlot != null && o.nonceInfo != null) {
        const {
            nonceInstruction: tt
        } = o.nonceInfo, nt = tt.keys[0].pubkey;
        et = (await s.confirmTransaction({
            abortSignal: $ == null ? void 0 : $.abortSignal,
            minContextSlot: o.minNonceContextSlot,
            nonceAccountPubkey: nt,
            nonceValue: o.nonceInfo.nonce,
            signature: _e
        }, $ && $.commitment)).value
    } else($ == null ? void 0 : $.abortSignal) != null && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."), et = (await s.confirmTransaction(_e, $ && $.commitment)).value;
    if (et.err) throw _e != null ? new SendTransactionError({
        action: "send",
        signature: _e,
        transactionMessage: `Status: (${JSON.stringify(et)})`
    }) : new Error(`Transaction ${_e} failed (${JSON.stringify(et)})`);
    return _e
}

function sleep(s) {
    return new Promise(o => setTimeout(o, s))
}

function encodeData(s, o) {
    const a = s.layout.span >= 0 ? s.layout.span : getAlloc(s, o),
        $ = buffer.Buffer.alloc(a),
        j = Object.assign({
            instruction: s.index
        }, o);
    return s.layout.encode(j, $), $
}

function decodeData$1(s, o) {
    let a;
    try {
        a = s.layout.decode(o)
    } catch ($) {
        throw new Error("invalid instruction; " + $)
    }
    if (a.instruction !== s.index) throw new Error(`invalid instruction; instruction index mismatch ${a.instruction} != ${s.index}`);
    return a
}
const FeeCalculatorLayout = nu64$1("lamportsPerSignature"),
    NonceAccountLayout = struct$1([u32$1("version"), u32$1("state"), publicKey$3("authorizedPubkey"), publicKey$3("nonce"), struct$1([FeeCalculatorLayout], "feeCalculator")]),
    NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
class NonceAccount {
    constructor(o) {
        this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = o.authorizedPubkey, this.nonce = o.nonce, this.feeCalculator = o.feeCalculator
    }
    static fromAccountData(o) {
        const a = NonceAccountLayout.decode(toBuffer$1(o), 0);
        return new NonceAccount({
            authorizedPubkey: new PublicKey(a.authorizedPubkey),
            nonce: new PublicKey(a.nonce).toString(),
            feeCalculator: a.feeCalculator
        })
    }
}
const encodeDecode = s => {
        const o = s.decode.bind(s),
            a = s.encode.bind(s);
        return {
            decode: o,
            encode: a
        }
    },
    bigInt = s => o => {
        const a = blob$1(s, o),
            {
                encode: $,
                decode: j
            } = encodeDecode(a),
            _e = a;
        return _e.decode = (et, tt) => {
            const nt = j(et, tt);
            return toBigIntLE_1(buffer.Buffer.from(nt))
        }, _e.encode = (et, tt, nt) => {
            const rt = toBufferLE_1(et, s);
            return $(rt, tt, nt)
        }, _e
    },
    u64$1 = bigInt(8);
class SystemInstruction {
    constructor() {}
    static decodeInstructionType(o) {
        this.checkProgramId(o.programId);
        const $ = u32$1("instruction").decode(o.data);
        let j;
        for (const [_e, et] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS))
            if (et.index == $) {
                j = _e;
                break
            }
        if (!j) throw new Error("Instruction type incorrect; not a SystemInstruction");
        return j
    }
    static decodeCreateAccount(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 2);
        const {
            lamports: a,
            space: $,
            programId: j
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, o.data);
        return {
            fromPubkey: o.keys[0].pubkey,
            newAccountPubkey: o.keys[1].pubkey,
            lamports: a,
            space: $,
            programId: new PublicKey(j)
        }
    }
    static decodeTransfer(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 2);
        const {
            lamports: a
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, o.data);
        return {
            fromPubkey: o.keys[0].pubkey,
            toPubkey: o.keys[1].pubkey,
            lamports: a
        }
    }
    static decodeTransferWithSeed(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3);
        const {
            lamports: a,
            seed: $,
            programId: j
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, o.data);
        return {
            fromPubkey: o.keys[0].pubkey,
            basePubkey: o.keys[1].pubkey,
            toPubkey: o.keys[2].pubkey,
            lamports: a,
            seed: $,
            programId: new PublicKey(j)
        }
    }
    static decodeAllocate(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 1);
        const {
            space: a
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, o.data);
        return {
            accountPubkey: o.keys[0].pubkey,
            space: a
        }
    }
    static decodeAllocateWithSeed(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 1);
        const {
            base: a,
            seed: $,
            space: j,
            programId: _e
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, o.data);
        return {
            accountPubkey: o.keys[0].pubkey,
            basePubkey: new PublicKey(a),
            seed: $,
            space: j,
            programId: new PublicKey(_e)
        }
    }
    static decodeAssign(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 1);
        const {
            programId: a
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, o.data);
        return {
            accountPubkey: o.keys[0].pubkey,
            programId: new PublicKey(a)
        }
    }
    static decodeAssignWithSeed(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 1);
        const {
            base: a,
            seed: $,
            programId: j
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, o.data);
        return {
            accountPubkey: o.keys[0].pubkey,
            basePubkey: new PublicKey(a),
            seed: $,
            programId: new PublicKey(j)
        }
    }
    static decodeCreateWithSeed(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 2);
        const {
            base: a,
            seed: $,
            lamports: j,
            space: _e,
            programId: et
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, o.data);
        return {
            fromPubkey: o.keys[0].pubkey,
            newAccountPubkey: o.keys[1].pubkey,
            basePubkey: new PublicKey(a),
            seed: $,
            lamports: j,
            space: _e,
            programId: new PublicKey(et)
        }
    }
    static decodeNonceInitialize(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3);
        const {
            authorized: a
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, o.data);
        return {
            noncePubkey: o.keys[0].pubkey,
            authorizedPubkey: new PublicKey(a)
        }
    }
    static decodeNonceAdvance(o) {
        return this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3), decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, o.data), {
            noncePubkey: o.keys[0].pubkey,
            authorizedPubkey: o.keys[2].pubkey
        }
    }
    static decodeNonceWithdraw(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 5);
        const {
            lamports: a
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, o.data);
        return {
            noncePubkey: o.keys[0].pubkey,
            toPubkey: o.keys[1].pubkey,
            authorizedPubkey: o.keys[4].pubkey,
            lamports: a
        }
    }
    static decodeNonceAuthorize(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 2);
        const {
            authorized: a
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, o.data);
        return {
            noncePubkey: o.keys[0].pubkey,
            authorizedPubkey: o.keys[1].pubkey,
            newAuthorizedPubkey: new PublicKey(a)
        }
    }
    static checkProgramId(o) {
        if (!o.equals(SystemProgram.programId)) throw new Error("invalid instruction; programId is not SystemProgram")
    }
    static checkKeyLength(o, a) {
        if (o.length < a) throw new Error(`invalid instruction; found ${o.length} keys, expected at least ${a}`)
    }
}
const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
    Create: {
        index: 0,
        layout: struct$1([u32$1("instruction"), ns64$1("lamports"), ns64$1("space"), publicKey$3("programId")])
    },
    Assign: {
        index: 1,
        layout: struct$1([u32$1("instruction"), publicKey$3("programId")])
    },
    Transfer: {
        index: 2,
        layout: struct$1([u32$1("instruction"), u64$1("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: struct$1([u32$1("instruction"), publicKey$3("base"), rustString("seed"), ns64$1("lamports"), ns64$1("space"), publicKey$3("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: struct$1([u32$1("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: struct$1([u32$1("instruction"), publicKey$3("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: struct$1([u32$1("instruction"), publicKey$3("authorized")])
    },
    Allocate: {
        index: 8,
        layout: struct$1([u32$1("instruction"), ns64$1("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: struct$1([u32$1("instruction"), publicKey$3("base"), rustString("seed"), ns64$1("space"), publicKey$3("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: struct$1([u32$1("instruction"), publicKey$3("base"), rustString("seed"), publicKey$3("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: struct$1([u32$1("instruction"), u64$1("lamports"), rustString("seed"), publicKey$3("programId")])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: struct$1([u32$1("instruction")])
    }
});
class SystemProgram {
    constructor() {}
    static createAccount(o) {
        const a = SYSTEM_INSTRUCTION_LAYOUTS.Create,
            $ = encodeData(a, {
                lamports: o.lamports,
                space: o.space,
                programId: toBuffer$1(o.programId.toBuffer())
            });
        return new TransactionInstruction({
            keys: [{
                pubkey: o.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: o.newAccountPubkey,
                isSigner: !0,
                isWritable: !0
            }],
            programId: this.programId,
            data: $
        })
    }
    static transfer(o) {
        let a, $;
        if ("basePubkey" in o) {
            const j = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
            a = encodeData(j, {
                lamports: BigInt(o.lamports),
                seed: o.seed,
                programId: toBuffer$1(o.programId.toBuffer())
            }), $ = [{
                pubkey: o.fromPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.basePubkey,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: o.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        } else {
            const j = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
            a = encodeData(j, {
                lamports: BigInt(o.lamports)
            }), $ = [{
                pubkey: o.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: o.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        }
        return new TransactionInstruction({
            keys: $,
            programId: this.programId,
            data: a
        })
    }
    static assign(o) {
        let a, $;
        if ("basePubkey" in o) {
            const j = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
            a = encodeData(j, {
                base: toBuffer$1(o.basePubkey.toBuffer()),
                seed: o.seed,
                programId: toBuffer$1(o.programId.toBuffer())
            }), $ = [{
                pubkey: o.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const j = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
            a = encodeData(j, {
                programId: toBuffer$1(o.programId.toBuffer())
            }), $ = [{
                pubkey: o.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new TransactionInstruction({
            keys: $,
            programId: this.programId,
            data: a
        })
    }
    static createAccountWithSeed(o) {
        const a = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed,
            $ = encodeData(a, {
                base: toBuffer$1(o.basePubkey.toBuffer()),
                seed: o.seed,
                lamports: o.lamports,
                space: o.space,
                programId: toBuffer$1(o.programId.toBuffer())
            });
        let j = [{
            pubkey: o.fromPubkey,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: o.newAccountPubkey,
            isSigner: !1,
            isWritable: !0
        }];
        return o.basePubkey.equals(o.fromPubkey) || j.push({
            pubkey: o.basePubkey,
            isSigner: !0,
            isWritable: !1
        }), new TransactionInstruction({
            keys: j,
            programId: this.programId,
            data: $
        })
    }
    static createNonceAccount(o) {
        const a = new Transaction;
        "basePubkey" in o && "seed" in o ? a.add(SystemProgram.createAccountWithSeed({
            fromPubkey: o.fromPubkey,
            newAccountPubkey: o.noncePubkey,
            basePubkey: o.basePubkey,
            seed: o.seed,
            lamports: o.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
        })) : a.add(SystemProgram.createAccount({
            fromPubkey: o.fromPubkey,
            newAccountPubkey: o.noncePubkey,
            lamports: o.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
        }));
        const $ = {
            noncePubkey: o.noncePubkey,
            authorizedPubkey: o.authorizedPubkey
        };
        return a.add(this.nonceInitialize($)), a
    }
    static nonceInitialize(o) {
        const a = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,
            $ = encodeData(a, {
                authorized: toBuffer$1(o.authorizedPubkey.toBuffer())
            }),
            j = {
                keys: [{
                    pubkey: o.noncePubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: !1,
                    isWritable: !1
                }],
                programId: this.programId,
                data: $
            };
        return new TransactionInstruction(j)
    }
    static nonceAdvance(o) {
        const a = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount,
            $ = encodeData(a),
            j = {
                keys: [{
                    pubkey: o.noncePubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: o.authorizedPubkey,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: $
            };
        return new TransactionInstruction(j)
    }
    static nonceWithdraw(o) {
        const a = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,
            $ = encodeData(a, {
                lamports: o.lamports
            });
        return new TransactionInstruction({
            keys: [{
                pubkey: o.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.toPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: o.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: $
        })
    }
    static nonceAuthorize(o) {
        const a = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,
            $ = encodeData(a, {
                authorized: toBuffer$1(o.newAuthorizedPubkey.toBuffer())
            });
        return new TransactionInstruction({
            keys: [{
                pubkey: o.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: $
        })
    }
    static allocate(o) {
        let a, $;
        if ("basePubkey" in o) {
            const j = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
            a = encodeData(j, {
                base: toBuffer$1(o.basePubkey.toBuffer()),
                seed: o.seed,
                space: o.space,
                programId: toBuffer$1(o.programId.toBuffer())
            }), $ = [{
                pubkey: o.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const j = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
            a = encodeData(j, {
                space: o.space
            }), $ = [{
                pubkey: o.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new TransactionInstruction({
            keys: $,
            programId: this.programId,
            data: a
        })
    }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
class Loader {
    constructor() {}
    static getMinNumSignatures(o) {
        return 2 * (Math.ceil(o / Loader.chunkSize) + 1 + 1)
    }
    static async load(o, a, $, j, _e) {
        {
            const st = await o.getMinimumBalanceForRentExemption(_e.length),
                lt = await o.getAccountInfo($.publicKey, "confirmed");
            let ft = null;
            if (lt !== null) {
                if (lt.executable) return console.error("Program load failed, account is already executable"), !1;
                lt.data.length !== _e.length && (ft = ft || new Transaction, ft.add(SystemProgram.allocate({
                    accountPubkey: $.publicKey,
                    space: _e.length
                }))), lt.owner.equals(j) || (ft = ft || new Transaction, ft.add(SystemProgram.assign({
                    accountPubkey: $.publicKey,
                    programId: j
                }))), lt.lamports < st && (ft = ft || new Transaction, ft.add(SystemProgram.transfer({
                    fromPubkey: a.publicKey,
                    toPubkey: $.publicKey,
                    lamports: st - lt.lamports
                })))
            } else ft = new Transaction().add(SystemProgram.createAccount({
                fromPubkey: a.publicKey,
                newAccountPubkey: $.publicKey,
                lamports: st > 0 ? st : 1,
                space: _e.length,
                programId: j
            }));
            ft !== null && await sendAndConfirmTransaction(o, ft, [a, $], {
                commitment: "confirmed"
            })
        }
        const et = struct$1([u32$1("instruction"), u32$1("offset"), u32$1("bytesLength"), u32$1("bytesLengthPadding"), seq(u8$1("byte"), offset$1(u32$1(), -8), "bytes")]),
            tt = Loader.chunkSize;
        let nt = 0,
            rt = _e,
            ot = [];
        for (; rt.length > 0;) {
            const st = rt.slice(0, tt),
                lt = buffer.Buffer.alloc(tt + 16);
            et.encode({
                instruction: 0,
                offset: nt,
                bytes: st,
                bytesLength: 0,
                bytesLengthPadding: 0
            }, lt);
            const ft = new Transaction().add({
                keys: [{
                    pubkey: $.publicKey,
                    isSigner: !0,
                    isWritable: !0
                }],
                programId: j,
                data: lt
            });
            ot.push(sendAndConfirmTransaction(o, ft, [a, $], {
                commitment: "confirmed"
            })), o._rpcEndpoint.includes("solana.com") && await sleep(1e3 / 4), nt += tt, rt = rt.slice(tt)
        }
        await Promise.all(ot); {
            const st = struct$1([u32$1("instruction")]),
                lt = buffer.Buffer.alloc(st.span);
            st.encode({
                instruction: 1
            }, lt);
            const ft = new Transaction().add({
                    keys: [{
                        pubkey: $.publicKey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: SYSVAR_RENT_PUBKEY,
                        isSigner: !1,
                        isWritable: !1
                    }],
                    programId: j,
                    data: lt
                }),
                yt = "processed",
                bt = await o.sendTransaction(ft, [a, $], {
                    preflightCommitment: yt
                }),
                {
                    context: ht,
                    value: vt
                } = await o.confirmTransaction({
                    signature: bt,
                    lastValidBlockHeight: ft.lastValidBlockHeight,
                    blockhash: ft.recentBlockhash
                }, yt);
            if (vt.err) throw new Error(`Transaction ${bt} failed (${JSON.stringify(vt)})`);
            for (;;) {
                try {
                    if (await o.getSlot({
                            commitment: yt
                        }) > ht.slot) break
                } catch {}
                await new Promise(wt => setTimeout(wt, Math.round(MS_PER_SLOT / 2)))
            }
        }
        return !0
    }
}
Loader.chunkSize = CHUNK_SIZE;
const BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
class BpfLoader {
    static getMinNumSignatures(o) {
        return Loader.getMinNumSignatures(o)
    }
    static load(o, a, $, j, _e) {
        return Loader.load(o, a, $, _e, j)
    }
}

function getDefaultExportFromCjs$1(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}
var objToString = Object.prototype.toString,
    objKeys = Object.keys || function(s) {
        var o = [];
        for (var a in s) o.push(a);
        return o
    };

function stringify(s, o) {
    var a, $, j, _e, et, tt, nt;
    if (s === !0) return "true";
    if (s === !1) return "false";
    switch (typeof s) {
        case "object":
            if (s === null) return null;
            if (s.toJSON && typeof s.toJSON == "function") return stringify(s.toJSON(), o);
            if (nt = objToString.call(s), nt === "[object Array]") {
                for (j = "[", $ = s.length - 1, a = 0; a < $; a++) j += stringify(s[a], !0) + ",";
                return $ > -1 && (j += stringify(s[a], !0)), j + "]"
            } else if (nt === "[object Object]") {
                for (_e = objKeys(s).sort(), $ = _e.length, j = "", a = 0; a < $;) et = _e[a], tt = stringify(s[et], !1), tt !== void 0 && (j && (j += ","), j += JSON.stringify(et) + ":" + tt), a++;
                return "{" + j + "}"
            } else return JSON.stringify(s);
        case "function":
        case "undefined":
            return o ? null : void 0;
        case "string":
            return JSON.stringify(s);
        default:
            return isFinite(s) ? s : null
    }
}
var fastStableStringify = function(s) {
        var o = stringify(s, !1);
        if (o !== void 0) return "" + o
    },
    fastStableStringify$1 = getDefaultExportFromCjs$1(fastStableStringify);
const MINIMUM_SLOT_PER_EPOCH = 32;

function trailingZeros(s) {
    let o = 0;
    for (; s > 1;) s /= 2, o++;
    return o
}

function nextPowerOfTwo(s) {
    return s === 0 ? 1 : (s--, s |= s >> 1, s |= s >> 2, s |= s >> 4, s |= s >> 8, s |= s >> 16, s |= s >> 32, s + 1)
}
class EpochSchedule {
    constructor(o, a, $, j, _e) {
        this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = o, this.leaderScheduleSlotOffset = a, this.warmup = $, this.firstNormalEpoch = j, this.firstNormalSlot = _e
    }
    getEpoch(o) {
        return this.getEpochAndSlotIndex(o)[0]
    }
    getEpochAndSlotIndex(o) {
        if (o < this.firstNormalSlot) {
            const a = trailingZeros(nextPowerOfTwo(o + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1,
                $ = this.getSlotsInEpoch(a),
                j = o - ($ - MINIMUM_SLOT_PER_EPOCH);
            return [a, j]
        } else {
            const a = o - this.firstNormalSlot,
                $ = Math.floor(a / this.slotsPerEpoch),
                j = this.firstNormalEpoch + $,
                _e = a % this.slotsPerEpoch;
            return [j, _e]
        }
    }
    getFirstSlotInEpoch(o) {
        return o <= this.firstNormalEpoch ? (Math.pow(2, o) - 1) * MINIMUM_SLOT_PER_EPOCH : (o - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }
    getLastSlotInEpoch(o) {
        return this.getFirstSlotInEpoch(o) + this.getSlotsInEpoch(o) - 1
    }
    getSlotsInEpoch(o) {
        return o < this.firstNormalEpoch ? Math.pow(2, o + trailingZeros(MINIMUM_SLOT_PER_EPOCH)) : this.slotsPerEpoch
    }
}
var fetchImpl = globalThis.fetch;
class RpcWebSocketClient extends CommonClient {
    constructor(o, a, $) {
        const j = _e => {
            const et = WebSocket$1(_e, {
                autoconnect: !0,
                max_reconnects: 5,
                reconnect: !0,
                reconnect_interval: 1e3,
                ...a
            });
            return "socket" in et ? this.underlyingSocket = et.socket : this.underlyingSocket = et, et
        };
        super(j, o, a, $), this.underlyingSocket = void 0
    }
    call(...o) {
        var $;
        const a = ($ = this.underlyingSocket) == null ? void 0 : $.readyState;
        return a === 1 ? super.call(...o) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + o[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + a + ")"))
    }
    notify(...o) {
        var $;
        const a = ($ = this.underlyingSocket) == null ? void 0 : $.readyState;
        return a === 1 ? super.notify(...o) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + o[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + a + ")"))
    }
}

function decodeData(s, o) {
    let a;
    try {
        a = s.layout.decode(o)
    } catch ($) {
        throw new Error("invalid instruction; " + $)
    }
    if (a.typeIndex !== s.index) throw new Error(`invalid account data; account type mismatch ${a.typeIndex} != ${s.index}`);
    return a
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
    constructor(o) {
        this.key = void 0, this.state = void 0, this.key = o.key, this.state = o.state
    }
    isActive() {
        const o = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === o
    }
    static deserialize(o) {
        const a = decodeData(LookupTableMetaLayout, o),
            $ = o.length - LOOKUP_TABLE_META_SIZE;
        assert$2($ >= 0, "lookup table is invalid"), assert$2($ % 32 === 0, "lookup table is invalid");
        const j = $ / 32,
            {
                addresses: _e
            } = struct$1([seq(publicKey$3(), j, "addresses")]).decode(o.slice(LOOKUP_TABLE_META_SIZE));
        return {
            deactivationSlot: a.deactivationSlot,
            lastExtendedSlot: a.lastExtendedSlot,
            lastExtendedSlotStartIndex: a.lastExtendedStartIndex,
            authority: a.authority.length !== 0 ? new PublicKey(a.authority[0]) : void 0,
            addresses: _e.map(et => new PublicKey(et))
        }
    }
}
const LookupTableMetaLayout = {
        index: 1,
        layout: struct$1([u32$1("typeIndex"), u64$1("deactivationSlot"), nu64$1("lastExtendedSlot"), u8$1("lastExtendedStartIndex"), u8$1(), seq(publicKey$3(), offset$1(u8$1(), -1), "authority")])
    },
    URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;

function makeWebsocketUrl(s) {
    const o = s.match(URL_RE);
    if (o == null) throw TypeError(`Failed to validate endpoint URL \`${s}\``);
    const [a, $, j, _e] = o, et = s.startsWith("https:") ? "wss:" : "ws:", tt = j == null ? null : parseInt(j.slice(1), 10), nt = tt == null ? "" : `:${tt+1}`;
    return `${et}//${$}${nt}${_e}`
}
const PublicKeyFromString = coerce$1(instance(PublicKey), string$1(), s => new PublicKey(s)),
    RawAccountDataResult = tuple([string$1(), literal$1("base64")]),
    BufferFromRawAccountData = coerce$1(instance(buffer.Buffer), RawAccountDataResult, s => buffer.Buffer.from(s[0], "base64")),
    BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;

function assertEndpointUrl(s) {
    if (/^https?:/.test(s) === !1) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return s
}

function extractCommitmentFromConfig(s) {
    let o, a;
    if (typeof s == "string") o = s;
    else if (s) {
        const {
            commitment: $,
            ...j
        } = s;
        o = $, a = j
    }
    return {
        commitment: o,
        config: a
    }
}

function applyDefaultMemcmpEncodingToFilters(s) {
    return s.map(o => "memcmp" in o ? { ...o,
        memcmp: { ...o.memcmp,
            encoding: o.memcmp.encoding ? ? "base58"
        }
    } : o)
}

function createRpcResult$1(s) {
    return union$2([type$2({
        jsonrpc: literal$1("2.0"),
        id: string$1(),
        result: s
    }), type$2({
        jsonrpc: literal$1("2.0"),
        id: string$1(),
        error: type$2({
            code: unknown$1(),
            message: string$1(),
            data: optional$1(any$1())
        })
    })])
}
const UnknownRpcResult$1 = createRpcResult$1(unknown$1());

function jsonRpcResult$1(s) {
    return coerce$1(createRpcResult$1(s), UnknownRpcResult$1, o => "error" in o ? o : { ...o,
        result: create$1(o.result, s)
    })
}

function jsonRpcResultAndContext$1(s) {
    return jsonRpcResult$1(type$2({
        context: type$2({
            slot: number$1()
        }),
        value: s
    }))
}

function notificationResultAndContext(s) {
    return type$2({
        context: type$2({
            slot: number$1()
        }),
        value: s
    })
}

function versionedMessageFromResponse(s, o) {
    return s === 0 ? new MessageV0({
        header: o.header,
        staticAccountKeys: o.accountKeys.map(a => new PublicKey(a)),
        recentBlockhash: o.recentBlockhash,
        compiledInstructions: o.instructions.map(a => ({
            programIdIndex: a.programIdIndex,
            accountKeyIndexes: a.accounts,
            data: bs58$1$1.decode(a.data)
        })),
        addressTableLookups: o.addressTableLookups
    }) : new Message(o)
}
const GetInflationGovernorResult = type$2({
        foundation: number$1(),
        foundationTerm: number$1(),
        initial: number$1(),
        taper: number$1(),
        terminal: number$1()
    }),
    GetInflationRewardResult = jsonRpcResult$1(array$1(nullable$1(type$2({
        epoch: number$1(),
        effectiveSlot: number$1(),
        amount: number$1(),
        postBalance: number$1(),
        commission: optional$1(nullable$1(number$1()))
    })))),
    GetRecentPrioritizationFeesResult = array$1(type$2({
        slot: number$1(),
        prioritizationFee: number$1()
    })),
    GetInflationRateResult = type$2({
        total: number$1(),
        validator: number$1(),
        foundation: number$1(),
        epoch: number$1()
    }),
    GetEpochInfoResult = type$2({
        epoch: number$1(),
        slotIndex: number$1(),
        slotsInEpoch: number$1(),
        absoluteSlot: number$1(),
        blockHeight: optional$1(number$1()),
        transactionCount: optional$1(number$1())
    }),
    GetEpochScheduleResult = type$2({
        slotsPerEpoch: number$1(),
        leaderScheduleSlotOffset: number$1(),
        warmup: boolean$1(),
        firstNormalEpoch: number$1(),
        firstNormalSlot: number$1()
    }),
    GetLeaderScheduleResult = record(string$1(), array$1(number$1())),
    TransactionErrorResult = nullable$1(union$2([type$2({}), string$1()])),
    SignatureStatusResult = type$2({
        err: TransactionErrorResult
    }),
    SignatureReceivedResult = literal$1("receivedSignature"),
    VersionResult = type$2({
        "solana-core": string$1(),
        "feature-set": optional$1(number$1())
    }),
    ParsedInstructionStruct = type$2({
        program: string$1(),
        programId: PublicKeyFromString,
        parsed: unknown$1()
    }),
    PartiallyDecodedInstructionStruct = type$2({
        programId: PublicKeyFromString,
        accounts: array$1(PublicKeyFromString),
        data: string$1()
    }),
    SimulatedTransactionResponseStruct$1 = jsonRpcResultAndContext$1(type$2({
        err: nullable$1(union$2([type$2({}), string$1()])),
        logs: nullable$1(array$1(string$1())),
        accounts: optional$1(nullable$1(array$1(nullable$1(type$2({
            executable: boolean$1(),
            owner: string$1(),
            lamports: number$1(),
            data: array$1(string$1()),
            rentEpoch: optional$1(number$1())
        }))))),
        unitsConsumed: optional$1(number$1()),
        returnData: optional$1(nullable$1(type$2({
            programId: string$1(),
            data: tuple([string$1(), literal$1("base64")])
        }))),
        innerInstructions: optional$1(nullable$1(array$1(type$2({
            index: number$1(),
            instructions: array$1(union$2([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
        }))))
    })),
    BlockProductionResponseStruct = jsonRpcResultAndContext$1(type$2({
        byIdentity: record(string$1(), array$1(number$1())),
        range: type$2({
            firstSlot: number$1(),
            lastSlot: number$1()
        })
    }));

function createRpcClient(s, o, a, $, j, _e) {
    const et = a || fetchImpl;
    let tt;
    _e != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    let nt;
    return $ && (nt = async (ot, st) => {
        const lt = await new Promise((ft, yt) => {
            try {
                $(ot, st, (bt, ht) => ft([bt, ht]))
            } catch (bt) {
                yt(bt)
            }
        });
        return await et(...lt)
    }), new RpcClient(async (ot, st) => {
        const lt = {
            method: "POST",
            body: ot,
            agent: tt,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, o || {}, COMMON_HTTP_HEADERS)
        };
        try {
            let ft = 5,
                yt, bt = 500;
            for (; nt ? yt = await nt(s, lt) : yt = await et(s, lt), !(yt.status !== 429 || j === !0 || (ft -= 1, ft === 0));) console.error(`Server responded with ${yt.status} ${yt.statusText}.  Retrying after ${bt}ms delay...`), await sleep(bt), bt *= 2;
            const ht = await yt.text();
            yt.ok ? st(null, ht) : st(new Error(`${yt.status} ${yt.statusText}: ${ht}`))
        } catch (ft) {
            ft instanceof Error && st(ft)
        }
    }, {})
}

function createRpcRequest(s) {
    return (o, a) => new Promise(($, j) => {
        s.request(o, a, (_e, et) => {
            if (_e) {
                j(_e);
                return
            }
            $(et)
        })
    })
}

function createRpcBatchRequest(s) {
    return o => new Promise((a, $) => {
        o.length === 0 && a([]);
        const j = o.map(_e => s.request(_e.methodName, _e.args));
        s.request(j, (_e, et) => {
            if (_e) {
                $(_e);
                return
            }
            a(et)
        })
    })
}
const GetInflationGovernorRpcResult = jsonRpcResult$1(GetInflationGovernorResult),
    GetInflationRateRpcResult = jsonRpcResult$1(GetInflationRateResult),
    GetRecentPrioritizationFeesRpcResult = jsonRpcResult$1(GetRecentPrioritizationFeesResult),
    GetEpochInfoRpcResult = jsonRpcResult$1(GetEpochInfoResult),
    GetEpochScheduleRpcResult = jsonRpcResult$1(GetEpochScheduleResult),
    GetLeaderScheduleRpcResult = jsonRpcResult$1(GetLeaderScheduleResult),
    SlotRpcResult = jsonRpcResult$1(number$1()),
    GetSupplyRpcResult = jsonRpcResultAndContext$1(type$2({
        total: number$1(),
        circulating: number$1(),
        nonCirculating: number$1(),
        nonCirculatingAccounts: array$1(PublicKeyFromString)
    })),
    TokenAmountResult = type$2({
        amount: string$1(),
        uiAmount: nullable$1(number$1()),
        decimals: number$1(),
        uiAmountString: optional$1(string$1())
    }),
    GetTokenLargestAccountsResult = jsonRpcResultAndContext$1(array$1(type$2({
        address: PublicKeyFromString,
        amount: string$1(),
        uiAmount: nullable$1(number$1()),
        decimals: number$1(),
        uiAmountString: optional$1(string$1())
    }))),
    GetTokenAccountsByOwner = jsonRpcResultAndContext$1(array$1(type$2({
        pubkey: PublicKeyFromString,
        account: type$2({
            executable: boolean$1(),
            owner: PublicKeyFromString,
            lamports: number$1(),
            data: BufferFromRawAccountData,
            rentEpoch: number$1()
        })
    }))),
    ParsedAccountDataResult = type$2({
        program: string$1(),
        parsed: unknown$1(),
        space: number$1()
    }),
    GetParsedTokenAccountsByOwner = jsonRpcResultAndContext$1(array$1(type$2({
        pubkey: PublicKeyFromString,
        account: type$2({
            executable: boolean$1(),
            owner: PublicKeyFromString,
            lamports: number$1(),
            data: ParsedAccountDataResult,
            rentEpoch: number$1()
        })
    }))),
    GetLargestAccountsRpcResult = jsonRpcResultAndContext$1(array$1(type$2({
        lamports: number$1(),
        address: PublicKeyFromString
    }))),
    AccountInfoResult = type$2({
        executable: boolean$1(),
        owner: PublicKeyFromString,
        lamports: number$1(),
        data: BufferFromRawAccountData,
        rentEpoch: number$1()
    }),
    KeyedAccountInfoResult = type$2({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
    }),
    ParsedOrRawAccountData = coerce$1(union$2([instance(buffer.Buffer), ParsedAccountDataResult]), union$2([RawAccountDataResult, ParsedAccountDataResult]), s => Array.isArray(s) ? create$1(s, BufferFromRawAccountData) : s),
    ParsedAccountInfoResult = type$2({
        executable: boolean$1(),
        owner: PublicKeyFromString,
        lamports: number$1(),
        data: ParsedOrRawAccountData,
        rentEpoch: number$1()
    }),
    KeyedParsedAccountInfoResult = type$2({
        pubkey: PublicKeyFromString,
        account: ParsedAccountInfoResult
    }),
    StakeActivationResult = type$2({
        state: union$2([literal$1("active"), literal$1("inactive"), literal$1("activating"), literal$1("deactivating")]),
        active: number$1(),
        inactive: number$1()
    }),
    GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult$1(array$1(type$2({
        signature: string$1(),
        slot: number$1(),
        err: TransactionErrorResult,
        memo: nullable$1(string$1()),
        blockTime: optional$1(nullable$1(number$1()))
    }))),
    GetSignaturesForAddressRpcResult = jsonRpcResult$1(array$1(type$2({
        signature: string$1(),
        slot: number$1(),
        err: TransactionErrorResult,
        memo: nullable$1(string$1()),
        blockTime: optional$1(nullable$1(number$1()))
    }))),
    AccountNotificationResult = type$2({
        subscription: number$1(),
        result: notificationResultAndContext(AccountInfoResult)
    }),
    ProgramAccountInfoResult = type$2({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
    }),
    ProgramAccountNotificationResult = type$2({
        subscription: number$1(),
        result: notificationResultAndContext(ProgramAccountInfoResult)
    }),
    SlotInfoResult = type$2({
        parent: number$1(),
        slot: number$1(),
        root: number$1()
    }),
    SlotNotificationResult = type$2({
        subscription: number$1(),
        result: SlotInfoResult
    }),
    SlotUpdateResult = union$2([type$2({
        type: union$2([literal$1("firstShredReceived"), literal$1("completed"), literal$1("optimisticConfirmation"), literal$1("root")]),
        slot: number$1(),
        timestamp: number$1()
    }), type$2({
        type: literal$1("createdBank"),
        parent: number$1(),
        slot: number$1(),
        timestamp: number$1()
    }), type$2({
        type: literal$1("frozen"),
        slot: number$1(),
        timestamp: number$1(),
        stats: type$2({
            numTransactionEntries: number$1(),
            numSuccessfulTransactions: number$1(),
            numFailedTransactions: number$1(),
            maxTransactionsPerEntry: number$1()
        })
    }), type$2({
        type: literal$1("dead"),
        slot: number$1(),
        timestamp: number$1(),
        err: string$1()
    })]),
    SlotUpdateNotificationResult = type$2({
        subscription: number$1(),
        result: SlotUpdateResult
    }),
    SignatureNotificationResult = type$2({
        subscription: number$1(),
        result: notificationResultAndContext(union$2([SignatureStatusResult, SignatureReceivedResult]))
    }),
    RootNotificationResult = type$2({
        subscription: number$1(),
        result: number$1()
    }),
    ContactInfoResult = type$2({
        pubkey: string$1(),
        gossip: nullable$1(string$1()),
        tpu: nullable$1(string$1()),
        rpc: nullable$1(string$1()),
        version: nullable$1(string$1())
    }),
    VoteAccountInfoResult = type$2({
        votePubkey: string$1(),
        nodePubkey: string$1(),
        activatedStake: number$1(),
        epochVoteAccount: boolean$1(),
        epochCredits: array$1(tuple([number$1(), number$1(), number$1()])),
        commission: number$1(),
        lastVote: number$1(),
        rootSlot: nullable$1(number$1())
    }),
    GetVoteAccounts = jsonRpcResult$1(type$2({
        current: array$1(VoteAccountInfoResult),
        delinquent: array$1(VoteAccountInfoResult)
    })),
    ConfirmationStatus = union$2([literal$1("processed"), literal$1("confirmed"), literal$1("finalized")]),
    SignatureStatusResponse = type$2({
        slot: number$1(),
        confirmations: nullable$1(number$1()),
        err: TransactionErrorResult,
        confirmationStatus: optional$1(ConfirmationStatus)
    }),
    GetSignatureStatusesRpcResult = jsonRpcResultAndContext$1(array$1(nullable$1(SignatureStatusResponse))),
    GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult$1(number$1()),
    AddressTableLookupStruct = type$2({
        accountKey: PublicKeyFromString,
        writableIndexes: array$1(number$1()),
        readonlyIndexes: array$1(number$1())
    }),
    ConfirmedTransactionResult = type$2({
        signatures: array$1(string$1()),
        message: type$2({
            accountKeys: array$1(string$1()),
            header: type$2({
                numRequiredSignatures: number$1(),
                numReadonlySignedAccounts: number$1(),
                numReadonlyUnsignedAccounts: number$1()
            }),
            instructions: array$1(type$2({
                accounts: array$1(number$1()),
                data: string$1(),
                programIdIndex: number$1()
            })),
            recentBlockhash: string$1(),
            addressTableLookups: optional$1(array$1(AddressTableLookupStruct))
        })
    }),
    AnnotatedAccountKey = type$2({
        pubkey: PublicKeyFromString,
        signer: boolean$1(),
        writable: boolean$1(),
        source: optional$1(union$2([literal$1("transaction"), literal$1("lookupTable")]))
    }),
    ConfirmedTransactionAccountsModeResult = type$2({
        accountKeys: array$1(AnnotatedAccountKey),
        signatures: array$1(string$1())
    }),
    ParsedInstructionResult = type$2({
        parsed: unknown$1(),
        program: string$1(),
        programId: PublicKeyFromString
    }),
    RawInstructionResult = type$2({
        accounts: array$1(PublicKeyFromString),
        data: string$1(),
        programId: PublicKeyFromString
    }),
    InstructionResult = union$2([RawInstructionResult, ParsedInstructionResult]),
    UnknownInstructionResult = union$2([type$2({
        parsed: unknown$1(),
        program: string$1(),
        programId: string$1()
    }), type$2({
        accounts: array$1(string$1()),
        data: string$1(),
        programId: string$1()
    })]),
    ParsedOrRawInstruction = coerce$1(InstructionResult, UnknownInstructionResult, s => "accounts" in s ? create$1(s, RawInstructionResult) : create$1(s, ParsedInstructionResult)),
    ParsedConfirmedTransactionResult = type$2({
        signatures: array$1(string$1()),
        message: type$2({
            accountKeys: array$1(AnnotatedAccountKey),
            instructions: array$1(ParsedOrRawInstruction),
            recentBlockhash: string$1(),
            addressTableLookups: optional$1(nullable$1(array$1(AddressTableLookupStruct)))
        })
    }),
    TokenBalanceResult = type$2({
        accountIndex: number$1(),
        mint: string$1(),
        owner: optional$1(string$1()),
        uiTokenAmount: TokenAmountResult
    }),
    LoadedAddressesResult = type$2({
        writable: array$1(PublicKeyFromString),
        readonly: array$1(PublicKeyFromString)
    }),
    ConfirmedTransactionMetaResult = type$2({
        err: TransactionErrorResult,
        fee: number$1(),
        innerInstructions: optional$1(nullable$1(array$1(type$2({
            index: number$1(),
            instructions: array$1(type$2({
                accounts: array$1(number$1()),
                data: string$1(),
                programIdIndex: number$1()
            }))
        })))),
        preBalances: array$1(number$1()),
        postBalances: array$1(number$1()),
        logMessages: optional$1(nullable$1(array$1(string$1()))),
        preTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult))),
        postTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult))),
        loadedAddresses: optional$1(LoadedAddressesResult),
        computeUnitsConsumed: optional$1(number$1())
    }),
    ParsedConfirmedTransactionMetaResult = type$2({
        err: TransactionErrorResult,
        fee: number$1(),
        innerInstructions: optional$1(nullable$1(array$1(type$2({
            index: number$1(),
            instructions: array$1(ParsedOrRawInstruction)
        })))),
        preBalances: array$1(number$1()),
        postBalances: array$1(number$1()),
        logMessages: optional$1(nullable$1(array$1(string$1()))),
        preTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult))),
        postTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult))),
        loadedAddresses: optional$1(LoadedAddressesResult),
        computeUnitsConsumed: optional$1(number$1())
    }),
    TransactionVersionStruct = union$2([literal$1(0), literal$1("legacy")]),
    RewardsResult = type$2({
        pubkey: string$1(),
        lamports: number$1(),
        postBalance: nullable$1(number$1()),
        rewardType: nullable$1(string$1()),
        commission: optional$1(nullable$1(number$1()))
    }),
    GetBlockRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        transactions: array$1(type$2({
            transaction: ConfirmedTransactionResult,
            meta: nullable$1(ConfirmedTransactionMetaResult),
            version: optional$1(TransactionVersionStruct)
        })),
        rewards: optional$1(array$1(RewardsResult)),
        blockTime: nullable$1(number$1()),
        blockHeight: nullable$1(number$1())
    }))),
    GetNoneModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        rewards: optional$1(array$1(RewardsResult)),
        blockTime: nullable$1(number$1()),
        blockHeight: nullable$1(number$1())
    }))),
    GetAccountsModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        transactions: array$1(type$2({
            transaction: ConfirmedTransactionAccountsModeResult,
            meta: nullable$1(ConfirmedTransactionMetaResult),
            version: optional$1(TransactionVersionStruct)
        })),
        rewards: optional$1(array$1(RewardsResult)),
        blockTime: nullable$1(number$1()),
        blockHeight: nullable$1(number$1())
    }))),
    GetParsedBlockRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        transactions: array$1(type$2({
            transaction: ParsedConfirmedTransactionResult,
            meta: nullable$1(ParsedConfirmedTransactionMetaResult),
            version: optional$1(TransactionVersionStruct)
        })),
        rewards: optional$1(array$1(RewardsResult)),
        blockTime: nullable$1(number$1()),
        blockHeight: nullable$1(number$1())
    }))),
    GetParsedAccountsModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        transactions: array$1(type$2({
            transaction: ConfirmedTransactionAccountsModeResult,
            meta: nullable$1(ParsedConfirmedTransactionMetaResult),
            version: optional$1(TransactionVersionStruct)
        })),
        rewards: optional$1(array$1(RewardsResult)),
        blockTime: nullable$1(number$1()),
        blockHeight: nullable$1(number$1())
    }))),
    GetParsedNoneModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        rewards: optional$1(array$1(RewardsResult)),
        blockTime: nullable$1(number$1()),
        blockHeight: nullable$1(number$1())
    }))),
    GetConfirmedBlockRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        transactions: array$1(type$2({
            transaction: ConfirmedTransactionResult,
            meta: nullable$1(ConfirmedTransactionMetaResult)
        })),
        rewards: optional$1(array$1(RewardsResult)),
        blockTime: nullable$1(number$1())
    }))),
    GetBlockSignaturesRpcResult = jsonRpcResult$1(nullable$1(type$2({
        blockhash: string$1(),
        previousBlockhash: string$1(),
        parentSlot: number$1(),
        signatures: array$1(string$1()),
        blockTime: nullable$1(number$1())
    }))),
    GetTransactionRpcResult = jsonRpcResult$1(nullable$1(type$2({
        slot: number$1(),
        meta: nullable$1(ConfirmedTransactionMetaResult),
        blockTime: optional$1(nullable$1(number$1())),
        transaction: ConfirmedTransactionResult,
        version: optional$1(TransactionVersionStruct)
    }))),
    GetParsedTransactionRpcResult = jsonRpcResult$1(nullable$1(type$2({
        slot: number$1(),
        transaction: ParsedConfirmedTransactionResult,
        meta: nullable$1(ParsedConfirmedTransactionMetaResult),
        blockTime: optional$1(nullable$1(number$1())),
        version: optional$1(TransactionVersionStruct)
    }))),
    GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext$1(type$2({
        blockhash: string$1(),
        feeCalculator: type$2({
            lamportsPerSignature: number$1()
        })
    })),
    GetLatestBlockhashRpcResult = jsonRpcResultAndContext$1(type$2({
        blockhash: string$1(),
        lastValidBlockHeight: number$1()
    })),
    IsBlockhashValidRpcResult = jsonRpcResultAndContext$1(boolean$1()),
    PerfSampleResult = type$2({
        slot: number$1(),
        numTransactions: number$1(),
        numSlots: number$1(),
        samplePeriodSecs: number$1()
    }),
    GetRecentPerformanceSamplesRpcResult = jsonRpcResult$1(array$1(PerfSampleResult)),
    GetFeeCalculatorRpcResult = jsonRpcResultAndContext$1(nullable$1(type$2({
        feeCalculator: type$2({
            lamportsPerSignature: number$1()
        })
    }))),
    RequestAirdropRpcResult = jsonRpcResult$1(string$1()),
    SendTransactionRpcResult = jsonRpcResult$1(string$1()),
    LogsResult = type$2({
        err: TransactionErrorResult,
        logs: array$1(string$1()),
        signature: string$1()
    }),
    LogsNotificationResult = type$2({
        result: notificationResultAndContext(LogsResult),
        subscription: number$1()
    }),
    COMMON_HTTP_HEADERS = {
        "solana-client": "js/1.0.0-maintenance"
    };
class Connection {
    constructor(o, a) {
        this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set, this.getBlockHeight = (() => {
            const rt = {};
            return async ot => {
                const {
                    commitment: st,
                    config: lt
                } = extractCommitmentFromConfig(ot), ft = this._buildArgs([], st, void 0, lt), yt = fastStableStringify$1(ft);
                return rt[yt] = rt[yt] ? ? (async () => {
                    try {
                        const bt = await this._rpcRequest("getBlockHeight", ft),
                            ht = create$1(bt, jsonRpcResult$1(number$1()));
                        if ("error" in ht) throw new SolanaJSONRPCError(ht.error, "failed to get block height information");
                        return ht.result
                    } finally {
                        delete rt[yt]
                    }
                })(), await rt[yt]
            }
        })();
        let $, j, _e, et, tt, nt;
        a && typeof a == "string" ? this._commitment = a : a && (this._commitment = a.commitment, this._confirmTransactionInitialTimeout = a.confirmTransactionInitialTimeout, $ = a.wsEndpoint, j = a.httpHeaders, _e = a.fetch, et = a.fetchMiddleware, tt = a.disableRetryOnRateLimit, nt = a.httpAgent), this._rpcEndpoint = assertEndpointUrl(o), this._rpcWsEndpoint = $ || makeWebsocketUrl(o), this._rpcClient = createRpcClient(o, j, _e, et, tt, nt), this._rpcRequest = createRpcRequest(this._rpcClient), this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient), this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
            autoconnect: !1,
            max_reconnects: 1 / 0
        }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }
    get commitment() {
        return this._commitment
    }
    get rpcEndpoint() {
        return this._rpcEndpoint
    }
    async getBalanceAndContext(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgs([o.toBase58()], $, void 0, j), et = await this._rpcRequest("getBalance", _e), tt = create$1(et, jsonRpcResultAndContext$1(number$1()));
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, `failed to get balance for ${o.toBase58()}`);
        return tt.result
    }
    async getBalance(o, a) {
        return await this.getBalanceAndContext(o, a).then($ => $.value).catch($ => {
            throw new Error("failed to get balance of account " + o.toBase58() + ": " + $)
        })
    }
    async getBlockTime(o) {
        const a = await this._rpcRequest("getBlockTime", [o]),
            $ = create$1(a, jsonRpcResult$1(nullable$1(number$1())));
        if ("error" in $) throw new SolanaJSONRPCError($.error, `failed to get block time for slot ${o}`);
        return $.result
    }
    async getMinimumLedgerSlot() {
        const o = await this._rpcRequest("minimumLedgerSlot", []),
            a = create$1(o, jsonRpcResult$1(number$1()));
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get minimum ledger slot");
        return a.result
    }
    async getFirstAvailableBlock() {
        const o = await this._rpcRequest("getFirstAvailableBlock", []),
            a = create$1(o, SlotRpcResult);
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get first available block");
        return a.result
    }
    async getSupply(o) {
        let a = {};
        typeof o == "string" ? a = {
            commitment: o
        } : o ? a = { ...o,
            commitment: o && o.commitment || this.commitment
        } : a = {
            commitment: this.commitment
        };
        const $ = await this._rpcRequest("getSupply", [a]),
            j = create$1($, GetSupplyRpcResult);
        if ("error" in j) throw new SolanaJSONRPCError(j.error, "failed to get supply");
        return j.result
    }
    async getTokenSupply(o, a) {
        const $ = this._buildArgs([o.toBase58()], a),
            j = await this._rpcRequest("getTokenSupply", $),
            _e = create$1(j, jsonRpcResultAndContext$1(TokenAmountResult));
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get token supply");
        return _e.result
    }
    async getTokenAccountBalance(o, a) {
        const $ = this._buildArgs([o.toBase58()], a),
            j = await this._rpcRequest("getTokenAccountBalance", $),
            _e = create$1(j, jsonRpcResultAndContext$1(TokenAmountResult));
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get token account balance");
        return _e.result
    }
    async getTokenAccountsByOwner(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig($);
        let et = [o.toBase58()];
        "mint" in a ? et.push({
            mint: a.mint.toBase58()
        }) : et.push({
            programId: a.programId.toBase58()
        });
        const tt = this._buildArgs(et, j, "base64", _e),
            nt = await this._rpcRequest("getTokenAccountsByOwner", tt),
            rt = create$1(nt, GetTokenAccountsByOwner);
        if ("error" in rt) throw new SolanaJSONRPCError(rt.error, `failed to get token accounts owned by account ${o.toBase58()}`);
        return rt.result
    }
    async getParsedTokenAccountsByOwner(o, a, $) {
        let j = [o.toBase58()];
        "mint" in a ? j.push({
            mint: a.mint.toBase58()
        }) : j.push({
            programId: a.programId.toBase58()
        });
        const _e = this._buildArgs(j, $, "jsonParsed"),
            et = await this._rpcRequest("getTokenAccountsByOwner", _e),
            tt = create$1(et, GetParsedTokenAccountsByOwner);
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, `failed to get token accounts owned by account ${o.toBase58()}`);
        return tt.result
    }
    async getLargestAccounts(o) {
        const a = { ...o,
                commitment: o && o.commitment || this.commitment
            },
            $ = a.filter || a.commitment ? [a] : [],
            j = await this._rpcRequest("getLargestAccounts", $),
            _e = create$1(j, GetLargestAccountsRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get largest accounts");
        return _e.result
    }
    async getTokenLargestAccounts(o, a) {
        const $ = this._buildArgs([o.toBase58()], a),
            j = await this._rpcRequest("getTokenLargestAccounts", $),
            _e = create$1(j, GetTokenLargestAccountsResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get token largest accounts");
        return _e.result
    }
    async getAccountInfoAndContext(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgs([o.toBase58()], $, "base64", j), et = await this._rpcRequest("getAccountInfo", _e), tt = create$1(et, jsonRpcResultAndContext$1(nullable$1(AccountInfoResult)));
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, `failed to get info about account ${o.toBase58()}`);
        return tt.result
    }
    async getParsedAccountInfo(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgs([o.toBase58()], $, "jsonParsed", j), et = await this._rpcRequest("getAccountInfo", _e), tt = create$1(et, jsonRpcResultAndContext$1(nullable$1(ParsedAccountInfoResult)));
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, `failed to get info about account ${o.toBase58()}`);
        return tt.result
    }
    async getAccountInfo(o, a) {
        try {
            return (await this.getAccountInfoAndContext(o, a)).value
        } catch ($) {
            throw new Error("failed to get info about account " + o.toBase58() + ": " + $)
        }
    }
    async getMultipleParsedAccounts(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = o.map(rt => rt.toBase58()), et = this._buildArgs([_e], $, "jsonParsed", j), tt = await this._rpcRequest("getMultipleAccounts", et), nt = create$1(tt, jsonRpcResultAndContext$1(array$1(nullable$1(ParsedAccountInfoResult))));
        if ("error" in nt) throw new SolanaJSONRPCError(nt.error, `failed to get info for accounts ${_e}`);
        return nt.result
    }
    async getMultipleAccountsInfoAndContext(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = o.map(rt => rt.toBase58()), et = this._buildArgs([_e], $, "base64", j), tt = await this._rpcRequest("getMultipleAccounts", et), nt = create$1(tt, jsonRpcResultAndContext$1(array$1(nullable$1(AccountInfoResult))));
        if ("error" in nt) throw new SolanaJSONRPCError(nt.error, `failed to get info for accounts ${_e}`);
        return nt.result
    }
    async getMultipleAccountsInfo(o, a) {
        return (await this.getMultipleAccountsInfoAndContext(o, a)).value
    }
    async getStakeActivation(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig(a), et = this._buildArgs([o.toBase58()], j, void 0, { ..._e,
            epoch: $ ? ? (_e == null ? void 0 : _e.epoch)
        }), tt = await this._rpcRequest("getStakeActivation", et), nt = create$1(tt, jsonRpcResult$1(StakeActivationResult));
        if ("error" in nt) throw new SolanaJSONRPCError(nt.error, `failed to get Stake Activation ${o.toBase58()}`);
        return nt.result
    }
    async getProgramAccounts(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), {
            encoding: _e,
            ...et
        } = j || {}, tt = this._buildArgs([o.toBase58()], $, _e || "base64", { ...et,
            ...et.filters ? {
                filters: applyDefaultMemcmpEncodingToFilters(et.filters)
            } : null
        }), nt = await this._rpcRequest("getProgramAccounts", tt), rt = array$1(KeyedAccountInfoResult), ot = et.withContext === !0 ? create$1(nt, jsonRpcResultAndContext$1(rt)) : create$1(nt, jsonRpcResult$1(rt));
        if ("error" in ot) throw new SolanaJSONRPCError(ot.error, `failed to get accounts owned by program ${o.toBase58()}`);
        return ot.result
    }
    async getParsedProgramAccounts(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgs([o.toBase58()], $, "jsonParsed", j), et = await this._rpcRequest("getProgramAccounts", _e), tt = create$1(et, jsonRpcResult$1(array$1(KeyedParsedAccountInfoResult)));
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, `failed to get accounts owned by program ${o.toBase58()}`);
        return tt.result
    }
    async confirmTransaction(o, a) {
        var _e;
        let $;
        if (typeof o == "string") $ = o;
        else {
            const et = o;
            if ((_e = et.abortSignal) != null && _e.aborted) return Promise.reject(et.abortSignal.reason);
            $ = et.signature
        }
        let j;
        try {
            j = bs58$1$1.decode($)
        } catch {
            throw new Error("signature must be base58 encoded: " + $)
        }
        return assert$2(j.length === 64, "signature has invalid length"), typeof o == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: a || this.commitment,
            signature: $
        }) : "lastValidBlockHeight" in o ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: a || this.commitment,
            strategy: o
        }) : await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: a || this.commitment,
            strategy: o
        })
    }
    getCancellationPromise(o) {
        return new Promise((a, $) => {
            o != null && (o.aborted ? $(o.reason) : o.addEventListener("abort", () => {
                $(o.reason)
            }))
        })
    }
    getTransactionConfirmationPromise({
        commitment: o,
        signature: a
    }) {
        let $, j, _e = !1;
        const et = new Promise((nt, rt) => {
            try {
                $ = this.onSignature(a, (st, lt) => {
                    $ = void 0;
                    const ft = {
                        context: lt,
                        value: st
                    };
                    nt({
                        __type: TransactionStatus.PROCESSED,
                        response: ft
                    })
                }, o);
                const ot = new Promise(st => {
                    $ == null ? st() : j = this._onSubscriptionStateChange($, lt => {
                        lt === "subscribed" && st()
                    })
                });
                (async () => {
                    if (await ot, _e) return;
                    const st = await this.getSignatureStatus(a);
                    if (_e || st == null) return;
                    const {
                        context: lt,
                        value: ft
                    } = st;
                    if (ft != null)
                        if (ft != null && ft.err) rt(ft.err);
                        else {
                            switch (o) {
                                case "confirmed":
                                case "single":
                                case "singleGossip":
                                    {
                                        if (ft.confirmationStatus === "processed") return;
                                        break
                                    }
                                case "finalized":
                                case "max":
                                case "root":
                                    {
                                        if (ft.confirmationStatus === "processed" || ft.confirmationStatus === "confirmed") return;
                                        break
                                    }
                                case "processed":
                                case "recent":
                            }
                            _e = !0, nt({
                                __type: TransactionStatus.PROCESSED,
                                response: {
                                    context: lt,
                                    value: ft
                                }
                            })
                        }
                })()
            } catch (ot) {
                rt(ot)
            }
        });
        return {
            abortConfirmation: () => {
                j && (j(), j = void 0), $ != null && (this.removeSignatureListener($), $ = void 0)
            },
            confirmationPromise: et
        }
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: o,
        strategy: {
            abortSignal: a,
            lastValidBlockHeight: $,
            signature: j
        }
    }) {
        let _e = !1;
        const et = new Promise(st => {
                const lt = async () => {
                    try {
                        return await this.getBlockHeight(o)
                    } catch {
                        return -1
                    }
                };
                (async () => {
                    let ft = await lt();
                    if (!_e) {
                        for (; ft <= $;)
                            if (await sleep(1e3), _e || (ft = await lt(), _e)) return;
                        st({
                            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
                        })
                    }
                })()
            }),
            {
                abortConfirmation: tt,
                confirmationPromise: nt
            } = this.getTransactionConfirmationPromise({
                commitment: o,
                signature: j
            }),
            rt = this.getCancellationPromise(a);
        let ot;
        try {
            const st = await Promise.race([rt, nt, et]);
            if (st.__type === TransactionStatus.PROCESSED) ot = st.response;
            else throw new TransactionExpiredBlockheightExceededError(j)
        } finally {
            _e = !0, tt()
        }
        return ot
    }
    async confirmTransactionUsingDurableNonceStrategy({
        commitment: o,
        strategy: {
            abortSignal: a,
            minContextSlot: $,
            nonceAccountPubkey: j,
            nonceValue: _e,
            signature: et
        }
    }) {
        let tt = !1;
        const nt = new Promise(ft => {
                let yt = _e,
                    bt = null;
                const ht = async () => {
                    try {
                        const {
                            context: vt,
                            value: wt
                        } = await this.getNonceAndContext(j, {
                            commitment: o,
                            minContextSlot: $
                        });
                        return bt = vt.slot, wt == null ? void 0 : wt.nonce
                    } catch {
                        return yt
                    }
                };
                (async () => {
                    if (yt = await ht(), !tt)
                        for (;;) {
                            if (_e !== yt) {
                                ft({
                                    __type: TransactionStatus.NONCE_INVALID,
                                    slotInWhichNonceDidAdvance: bt
                                });
                                return
                            }
                            if (await sleep(2e3), tt || (yt = await ht(), tt)) return
                        }
                })()
            }),
            {
                abortConfirmation: rt,
                confirmationPromise: ot
            } = this.getTransactionConfirmationPromise({
                commitment: o,
                signature: et
            }),
            st = this.getCancellationPromise(a);
        let lt;
        try {
            const ft = await Promise.race([st, ot, nt]);
            if (ft.__type === TransactionStatus.PROCESSED) lt = ft.response;
            else {
                let yt;
                for (;;) {
                    const bt = await this.getSignatureStatus(et);
                    if (bt == null) break;
                    if (bt.context.slot < (ft.slotInWhichNonceDidAdvance ? ? $)) {
                        await sleep(400);
                        continue
                    }
                    yt = bt;
                    break
                }
                if (yt != null && yt.value) {
                    const bt = o || "finalized",
                        {
                            confirmationStatus: ht
                        } = yt.value;
                    switch (bt) {
                        case "processed":
                        case "recent":
                            if (ht !== "processed" && ht !== "confirmed" && ht !== "finalized") throw new TransactionExpiredNonceInvalidError(et);
                            break;
                        case "confirmed":
                        case "single":
                        case "singleGossip":
                            if (ht !== "confirmed" && ht !== "finalized") throw new TransactionExpiredNonceInvalidError(et);
                            break;
                        case "finalized":
                        case "max":
                        case "root":
                            if (ht !== "finalized") throw new TransactionExpiredNonceInvalidError(et);
                            break;
                        default:
                    }
                    lt = {
                        context: yt.context,
                        value: {
                            err: yt.value.err
                        }
                    }
                } else throw new TransactionExpiredNonceInvalidError(et)
            }
        } finally {
            tt = !0, rt()
        }
        return lt
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: o,
        signature: a
    }) {
        let $;
        const j = new Promise(nt => {
                let rt = this._confirmTransactionInitialTimeout || 6e4;
                switch (o) {
                    case "processed":
                    case "recent":
                    case "single":
                    case "confirmed":
                    case "singleGossip":
                        {
                            rt = this._confirmTransactionInitialTimeout || 3e4;
                            break
                        }
                }
                $ = setTimeout(() => nt({
                    __type: TransactionStatus.TIMED_OUT,
                    timeoutMs: rt
                }), rt)
            }),
            {
                abortConfirmation: _e,
                confirmationPromise: et
            } = this.getTransactionConfirmationPromise({
                commitment: o,
                signature: a
            });
        let tt;
        try {
            const nt = await Promise.race([et, j]);
            if (nt.__type === TransactionStatus.PROCESSED) tt = nt.response;
            else throw new TransactionExpiredTimeoutError(a, nt.timeoutMs / 1e3)
        } finally {
            clearTimeout($), _e()
        }
        return tt
    }
    async getClusterNodes() {
        const o = await this._rpcRequest("getClusterNodes", []),
            a = create$1(o, jsonRpcResult$1(array$1(ContactInfoResult)));
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get cluster nodes");
        return a.result
    }
    async getVoteAccounts(o) {
        const a = this._buildArgs([], o),
            $ = await this._rpcRequest("getVoteAccounts", a),
            j = create$1($, GetVoteAccounts);
        if ("error" in j) throw new SolanaJSONRPCError(j.error, "failed to get vote accounts");
        return j.result
    }
    async getSlot(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getSlot", j), et = create$1(_e, jsonRpcResult$1(number$1()));
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get slot");
        return et.result
    }
    async getSlotLeader(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getSlotLeader", j), et = create$1(_e, jsonRpcResult$1(string$1()));
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get slot leader");
        return et.result
    }
    async getSlotLeaders(o, a) {
        const $ = [o, a],
            j = await this._rpcRequest("getSlotLeaders", $),
            _e = create$1(j, jsonRpcResult$1(array$1(PublicKeyFromString)));
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get slot leaders");
        return _e.result
    }
    async getSignatureStatus(o, a) {
        const {
            context: $,
            value: j
        } = await this.getSignatureStatuses([o], a);
        assert$2(j.length === 1);
        const _e = j[0];
        return {
            context: $,
            value: _e
        }
    }
    async getSignatureStatuses(o, a) {
        const $ = [o];
        a && $.push(a);
        const j = await this._rpcRequest("getSignatureStatuses", $),
            _e = create$1(j, GetSignatureStatusesRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get signature status");
        return _e.result
    }
    async getTransactionCount(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getTransactionCount", j), et = create$1(_e, jsonRpcResult$1(number$1()));
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get transaction count");
        return et.result
    }
    async getTotalSupply(o) {
        return (await this.getSupply({
            commitment: o,
            excludeNonCirculatingAccountsList: !0
        })).value.total
    }
    async getInflationGovernor(o) {
        const a = this._buildArgs([], o),
            $ = await this._rpcRequest("getInflationGovernor", a),
            j = create$1($, GetInflationGovernorRpcResult);
        if ("error" in j) throw new SolanaJSONRPCError(j.error, "failed to get inflation");
        return j.result
    }
    async getInflationReward(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig($), et = this._buildArgs([o.map(rt => rt.toBase58())], j, void 0, { ..._e,
            epoch: a ? ? (_e == null ? void 0 : _e.epoch)
        }), tt = await this._rpcRequest("getInflationReward", et), nt = create$1(tt, GetInflationRewardResult);
        if ("error" in nt) throw new SolanaJSONRPCError(nt.error, "failed to get inflation reward");
        return nt.result
    }
    async getInflationRate() {
        const o = await this._rpcRequest("getInflationRate", []),
            a = create$1(o, GetInflationRateRpcResult);
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get inflation rate");
        return a.result
    }
    async getEpochInfo(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getEpochInfo", j), et = create$1(_e, GetEpochInfoRpcResult);
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get epoch info");
        return et.result
    }
    async getEpochSchedule() {
        const o = await this._rpcRequest("getEpochSchedule", []),
            a = create$1(o, GetEpochScheduleRpcResult);
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get epoch schedule");
        const $ = a.result;
        return new EpochSchedule($.slotsPerEpoch, $.leaderScheduleSlotOffset, $.warmup, $.firstNormalEpoch, $.firstNormalSlot)
    }
    async getLeaderSchedule() {
        const o = await this._rpcRequest("getLeaderSchedule", []),
            a = create$1(o, GetLeaderScheduleRpcResult);
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get leader schedule");
        return a.result
    }
    async getMinimumBalanceForRentExemption(o, a) {
        const $ = this._buildArgs([o], a),
            j = await this._rpcRequest("getMinimumBalanceForRentExemption", $),
            _e = create$1(j, GetMinimumBalanceForRentExemptionRpcResult);
        return "error" in _e ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : _e.result
    }
    async getRecentBlockhashAndContext(o) {
        const a = this._buildArgs([], o),
            $ = await this._rpcRequest("getRecentBlockhash", a),
            j = create$1($, GetRecentBlockhashAndContextRpcResult);
        if ("error" in j) throw new SolanaJSONRPCError(j.error, "failed to get recent blockhash");
        return j.result
    }
    async getRecentPerformanceSamples(o) {
        const a = await this._rpcRequest("getRecentPerformanceSamples", o ? [o] : []),
            $ = create$1(a, GetRecentPerformanceSamplesRpcResult);
        if ("error" in $) throw new SolanaJSONRPCError($.error, "failed to get recent performance samples");
        return $.result
    }
    async getFeeCalculatorForBlockhash(o, a) {
        const $ = this._buildArgs([o], a),
            j = await this._rpcRequest("getFeeCalculatorForBlockhash", $),
            _e = create$1(j, GetFeeCalculatorRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get fee calculator");
        const {
            context: et,
            value: tt
        } = _e.result;
        return {
            context: et,
            value: tt !== null ? tt.feeCalculator : null
        }
    }
    async getFeeForMessage(o, a) {
        const $ = toBuffer$1(o.serialize()).toString("base64"),
            j = this._buildArgs([$], a),
            _e = await this._rpcRequest("getFeeForMessage", j),
            et = create$1(_e, jsonRpcResultAndContext$1(nullable$1(number$1())));
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get fee for message");
        if (et.result === null) throw new Error("invalid blockhash");
        return et.result
    }
    async getRecentPrioritizationFees(o) {
        var et;
        const a = (et = o == null ? void 0 : o.lockedWritableAccounts) == null ? void 0 : et.map(tt => tt.toBase58()),
            $ = a != null && a.length ? [a] : [],
            j = await this._rpcRequest("getRecentPrioritizationFees", $),
            _e = create$1(j, GetRecentPrioritizationFeesRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get recent prioritization fees");
        return _e.result
    }
    async getRecentBlockhash(o) {
        try {
            return (await this.getRecentBlockhashAndContext(o)).value
        } catch (a) {
            throw new Error("failed to get recent blockhash: " + a)
        }
    }
    async getLatestBlockhash(o) {
        try {
            return (await this.getLatestBlockhashAndContext(o)).value
        } catch (a) {
            throw new Error("failed to get recent blockhash: " + a)
        }
    }
    async getLatestBlockhashAndContext(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig(o), j = this._buildArgs([], a, void 0, $), _e = await this._rpcRequest("getLatestBlockhash", j), et = create$1(_e, GetLatestBlockhashRpcResult);
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get latest blockhash");
        return et.result
    }
    async isBlockhashValid(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgs([o], $, void 0, j), et = await this._rpcRequest("isBlockhashValid", _e), tt = create$1(et, IsBlockhashValidRpcResult);
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, "failed to determine if the blockhash `" + o + "`is valid");
        return tt.result
    }
    async getVersion() {
        const o = await this._rpcRequest("getVersion", []),
            a = create$1(o, jsonRpcResult$1(VersionResult));
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get version");
        return a.result
    }
    async getGenesisHash() {
        const o = await this._rpcRequest("getGenesisHash", []),
            a = create$1(o, jsonRpcResult$1(string$1()));
        if ("error" in a) throw new SolanaJSONRPCError(a.error, "failed to get genesis hash");
        return a.result
    }
    async getBlock(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgsAtLeastConfirmed([o], $, void 0, j), et = await this._rpcRequest("getBlock", _e);
        try {
            switch (j == null ? void 0 : j.transactionDetails) {
                case "accounts":
                    {
                        const tt = create$1(et, GetAccountsModeBlockRpcResult);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                case "none":
                    {
                        const tt = create$1(et, GetNoneModeBlockRpcResult);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                default:
                    {
                        const tt = create$1(et, GetBlockRpcResult);
                        if ("error" in tt) throw tt.error;
                        const {
                            result: nt
                        } = tt;
                        return nt ? { ...nt,
                            transactions: nt.transactions.map(({
                                transaction: rt,
                                meta: ot,
                                version: st
                            }) => ({
                                meta: ot,
                                transaction: { ...rt,
                                    message: versionedMessageFromResponse(st, rt.message)
                                },
                                version: st
                            }))
                        } : null
                    }
            }
        } catch (tt) {
            throw new SolanaJSONRPCError(tt, "failed to get confirmed block")
        }
    }
    async getParsedBlock(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgsAtLeastConfirmed([o], $, "jsonParsed", j), et = await this._rpcRequest("getBlock", _e);
        try {
            switch (j == null ? void 0 : j.transactionDetails) {
                case "accounts":
                    {
                        const tt = create$1(et, GetParsedAccountsModeBlockRpcResult);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                case "none":
                    {
                        const tt = create$1(et, GetParsedNoneModeBlockRpcResult);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
                default:
                    {
                        const tt = create$1(et, GetParsedBlockRpcResult);
                        if ("error" in tt) throw tt.error;
                        return tt.result
                    }
            }
        } catch (tt) {
            throw new SolanaJSONRPCError(tt, "failed to get block")
        }
    }
    async getBlockProduction(o) {
        let a, $;
        if (typeof o == "string") $ = o;
        else if (o) {
            const {
                commitment: tt,
                ...nt
            } = o;
            $ = tt, a = nt
        }
        const j = this._buildArgs([], $, "base64", a),
            _e = await this._rpcRequest("getBlockProduction", j),
            et = create$1(_e, BlockProductionResponseStruct);
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get block production information");
        return et.result
    }
    async getTransaction(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgsAtLeastConfirmed([o], $, void 0, j), et = await this._rpcRequest("getTransaction", _e), tt = create$1(et, GetTransactionRpcResult);
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, "failed to get transaction");
        const nt = tt.result;
        return nt && { ...nt,
            transaction: { ...nt.transaction,
                message: versionedMessageFromResponse(nt.version, nt.transaction.message)
            }
        }
    }
    async getParsedTransaction(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = this._buildArgsAtLeastConfirmed([o], $, "jsonParsed", j), et = await this._rpcRequest("getTransaction", _e), tt = create$1(et, GetParsedTransactionRpcResult);
        if ("error" in tt) throw new SolanaJSONRPCError(tt.error, "failed to get transaction");
        return tt.result
    }
    async getParsedTransactions(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = o.map(nt => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([nt], $, "jsonParsed", j)
        }));
        return (await this._rpcBatchRequest(_e)).map(nt => {
            const rt = create$1(nt, GetParsedTransactionRpcResult);
            if ("error" in rt) throw new SolanaJSONRPCError(rt.error, "failed to get transactions");
            return rt.result
        })
    }
    async getTransactions(o, a) {
        const {
            commitment: $,
            config: j
        } = extractCommitmentFromConfig(a), _e = o.map(nt => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([nt], $, void 0, j)
        }));
        return (await this._rpcBatchRequest(_e)).map(nt => {
            const rt = create$1(nt, GetTransactionRpcResult);
            if ("error" in rt) throw new SolanaJSONRPCError(rt.error, "failed to get transactions");
            const ot = rt.result;
            return ot && { ...ot,
                transaction: { ...ot.transaction,
                    message: versionedMessageFromResponse(ot.version, ot.transaction.message)
                }
            }
        })
    }
    async getConfirmedBlock(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a),
            j = await this._rpcRequest("getConfirmedBlock", $),
            _e = create$1(j, GetConfirmedBlockRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get confirmed block");
        const et = _e.result;
        if (!et) throw new Error("Confirmed block " + o + " not found");
        const tt = { ...et,
            transactions: et.transactions.map(({
                transaction: nt,
                meta: rt
            }) => {
                const ot = new Message(nt.message);
                return {
                    meta: rt,
                    transaction: { ...nt,
                        message: ot
                    }
                }
            })
        };
        return { ...tt,
            transactions: tt.transactions.map(({
                transaction: nt,
                meta: rt
            }) => ({
                meta: rt,
                transaction: Transaction.populate(nt.message, nt.signatures)
            }))
        }
    }
    async getBlocks(o, a, $) {
        const j = this._buildArgsAtLeastConfirmed(a !== void 0 ? [o, a] : [o], $),
            _e = await this._rpcRequest("getBlocks", j),
            et = create$1(_e, jsonRpcResult$1(array$1(number$1())));
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get blocks");
        return et.result
    }
    async getBlockSignatures(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            }),
            j = await this._rpcRequest("getBlock", $),
            _e = create$1(j, GetBlockSignaturesRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get block");
        const et = _e.result;
        if (!et) throw new Error("Block " + o + " not found");
        return et
    }
    async getConfirmedBlockSignatures(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            }),
            j = await this._rpcRequest("getConfirmedBlock", $),
            _e = create$1(j, GetBlockSignaturesRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get confirmed block");
        const et = _e.result;
        if (!et) throw new Error("Confirmed block " + o + " not found");
        return et
    }
    async getConfirmedTransaction(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a),
            j = await this._rpcRequest("getConfirmedTransaction", $),
            _e = create$1(j, GetTransactionRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get transaction");
        const et = _e.result;
        if (!et) return et;
        const tt = new Message(et.transaction.message),
            nt = et.transaction.signatures;
        return { ...et,
            transaction: Transaction.populate(tt, nt)
        }
    }
    async getParsedConfirmedTransaction(o, a) {
        const $ = this._buildArgsAtLeastConfirmed([o], a, "jsonParsed"),
            j = await this._rpcRequest("getConfirmedTransaction", $),
            _e = create$1(j, GetParsedTransactionRpcResult);
        if ("error" in _e) throw new SolanaJSONRPCError(_e.error, "failed to get confirmed transaction");
        return _e.result
    }
    async getParsedConfirmedTransactions(o, a) {
        const $ = o.map(et => ({
            methodName: "getConfirmedTransaction",
            args: this._buildArgsAtLeastConfirmed([et], a, "jsonParsed")
        }));
        return (await this._rpcBatchRequest($)).map(et => {
            const tt = create$1(et, GetParsedTransactionRpcResult);
            if ("error" in tt) throw new SolanaJSONRPCError(tt.error, "failed to get confirmed transactions");
            return tt.result
        })
    }
    async getConfirmedSignaturesForAddress(o, a, $) {
        let j = {},
            _e = await this.getFirstAvailableBlock();
        for (; !("until" in j) && (a--, !(a <= 0 || a < _e));) try {
            const nt = await this.getConfirmedBlockSignatures(a, "finalized");
            nt.signatures.length > 0 && (j.until = nt.signatures[nt.signatures.length - 1].toString())
        } catch (nt) {
            if (nt instanceof Error && nt.message.includes("skipped")) continue;
            throw nt
        }
        let et = await this.getSlot("finalized");
        for (; !("before" in j) && ($++, !($ > et));) try {
            const nt = await this.getConfirmedBlockSignatures($);
            nt.signatures.length > 0 && (j.before = nt.signatures[nt.signatures.length - 1].toString())
        } catch (nt) {
            if (nt instanceof Error && nt.message.includes("skipped")) continue;
            throw nt
        }
        return (await this.getConfirmedSignaturesForAddress2(o, j)).map(nt => nt.signature)
    }
    async getConfirmedSignaturesForAddress2(o, a, $) {
        const j = this._buildArgsAtLeastConfirmed([o.toBase58()], $, void 0, a),
            _e = await this._rpcRequest("getConfirmedSignaturesForAddress2", j),
            et = create$1(_e, GetConfirmedSignaturesForAddress2RpcResult);
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get confirmed signatures for address");
        return et.result
    }
    async getSignaturesForAddress(o, a, $) {
        const j = this._buildArgsAtLeastConfirmed([o.toBase58()], $, void 0, a),
            _e = await this._rpcRequest("getSignaturesForAddress", j),
            et = create$1(_e, GetSignaturesForAddressRpcResult);
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get signatures for address");
        return et.result
    }
    async getAddressLookupTable(o, a) {
        const {
            context: $,
            value: j
        } = await this.getAccountInfoAndContext(o, a);
        let _e = null;
        return j !== null && (_e = new AddressLookupTableAccount({
            key: o,
            state: AddressLookupTableAccount.deserialize(j.data)
        })), {
            context: $,
            value: _e
        }
    }
    async getNonceAndContext(o, a) {
        const {
            context: $,
            value: j
        } = await this.getAccountInfoAndContext(o, a);
        let _e = null;
        return j !== null && (_e = NonceAccount.fromAccountData(j.data)), {
            context: $,
            value: _e
        }
    }
    async getNonce(o, a) {
        return await this.getNonceAndContext(o, a).then($ => $.value).catch($ => {
            throw new Error("failed to get nonce for account " + o.toBase58() + ": " + $)
        })
    }
    async requestAirdrop(o, a) {
        const $ = await this._rpcRequest("requestAirdrop", [o.toBase58(), a]),
            j = create$1($, RequestAirdropRpcResult);
        if ("error" in j) throw new SolanaJSONRPCError(j.error, `airdrop to ${o.toBase58()} failed`);
        return j.result
    }
    async _blockhashWithExpiryBlockHeight(o) {
        if (!o) {
            for (; this._pollingBlockhash;) await sleep(100);
            const $ = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
            if (this._blockhashInfo.latestBlockhash !== null && !$) return this._blockhashInfo.latestBlockhash
        }
        return await this._pollNewBlockhash()
    }
    async _pollNewBlockhash() {
        this._pollingBlockhash = !0;
        try {
            const o = Date.now(),
                a = this._blockhashInfo.latestBlockhash,
                $ = a ? a.blockhash : null;
            for (let j = 0; j < 50; j++) {
                const _e = await this.getLatestBlockhash("finalized");
                if ($ !== _e.blockhash) return this._blockhashInfo = {
                    latestBlockhash: _e,
                    lastFetch: Date.now(),
                    transactionSignatures: [],
                    simulatedSignatures: []
                }, _e;
                await sleep(MS_PER_SLOT / 2)
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now()-o}ms`)
        } finally {
            this._pollingBlockhash = !1
        }
    }
    async getStakeMinimumDelegation(o) {
        const {
            commitment: a,
            config: $
        } = extractCommitmentFromConfig(o), j = this._buildArgs([], a, "base64", $), _e = await this._rpcRequest("getStakeMinimumDelegation", j), et = create$1(_e, jsonRpcResultAndContext$1(number$1()));
        if ("error" in et) throw new SolanaJSONRPCError(et.error, "failed to get stake minimum delegation");
        return et.result
    }
    async simulateTransaction(o, a, $) {
        if ("message" in o) {
            const bt = o.serialize(),
                ht = buffer.Buffer.from(bt).toString("base64");
            if (Array.isArray(a) || $ !== void 0) throw new Error("Invalid arguments");
            const vt = a || {};
            vt.encoding = "base64", "commitment" in vt || (vt.commitment = this.commitment), a && typeof a == "object" && "innerInstructions" in a && (vt.innerInstructions = a.innerInstructions);
            const wt = [ht, vt],
                gt = await this._rpcRequest("simulateTransaction", wt),
                At = create$1(gt, SimulatedTransactionResponseStruct$1);
            if ("error" in At) throw new Error("failed to simulate transaction: " + At.error.message);
            return At.result
        }
        let j;
        if (o instanceof Transaction) {
            let yt = o;
            j = new Transaction, j.feePayer = yt.feePayer, j.instructions = o.instructions, j.nonceInfo = yt.nonceInfo, j.signatures = yt.signatures
        } else j = Transaction.populate(o), j._message = j._json = void 0;
        if (a !== void 0 && !Array.isArray(a)) throw new Error("Invalid arguments");
        const _e = a;
        if (j.nonceInfo && _e) j.sign(..._e);
        else {
            let yt = this._disableBlockhashCaching;
            for (;;) {
                const bt = await this._blockhashWithExpiryBlockHeight(yt);
                if (j.lastValidBlockHeight = bt.lastValidBlockHeight, j.recentBlockhash = bt.blockhash, !_e) break;
                if (j.sign(..._e), !j.signature) throw new Error("!signature");
                const ht = j.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(ht) && !this._blockhashInfo.transactionSignatures.includes(ht)) {
                    this._blockhashInfo.simulatedSignatures.push(ht);
                    break
                } else yt = !0
            }
        }
        const et = j._compile(),
            tt = et.serialize(),
            rt = j._serialize(tt).toString("base64"),
            ot = {
                encoding: "base64",
                commitment: this.commitment
            };
        if ($) {
            const yt = (Array.isArray($) ? $ : et.nonProgramIds()).map(bt => bt.toBase58());
            ot.accounts = {
                encoding: "base64",
                addresses: yt
            }
        }
        _e && (ot.sigVerify = !0), a && typeof a == "object" && "innerInstructions" in a && (ot.innerInstructions = a.innerInstructions);
        const st = [rt, ot],
            lt = await this._rpcRequest("simulateTransaction", st),
            ft = create$1(lt, SimulatedTransactionResponseStruct$1);
        if ("error" in ft) {
            let yt;
            if ("data" in ft.error && (yt = ft.error.data.logs, yt && Array.isArray(yt))) {
                const bt = `
    `,
                    ht = bt + yt.join(bt);
                console.error(ft.error.message, ht)
            }
            throw new SendTransactionError({
                action: "simulate",
                signature: "",
                transactionMessage: ft.error.message,
                logs: yt
            })
        }
        return ft.result
    }
    async sendTransaction(o, a, $) {
        if ("version" in o) {
            if (a && Array.isArray(a)) throw new Error("Invalid arguments");
            const et = o.serialize();
            return await this.sendRawTransaction(et, a)
        }
        if (a === void 0 || !Array.isArray(a)) throw new Error("Invalid arguments");
        const j = a;
        if (o.nonceInfo) o.sign(...j);
        else {
            let et = this._disableBlockhashCaching;
            for (;;) {
                const tt = await this._blockhashWithExpiryBlockHeight(et);
                if (o.lastValidBlockHeight = tt.lastValidBlockHeight, o.recentBlockhash = tt.blockhash, o.sign(...j), !o.signature) throw new Error("!signature");
                const nt = o.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(nt)) et = !0;
                else {
                    this._blockhashInfo.transactionSignatures.push(nt);
                    break
                }
            }
        }
        const _e = o.serialize();
        return await this.sendRawTransaction(_e, $)
    }
    async sendRawTransaction(o, a) {
        const $ = toBuffer$1(o).toString("base64");
        return await this.sendEncodedTransaction($, a)
    }
    async sendEncodedTransaction(o, a) {
        const $ = {
                encoding: "base64"
            },
            j = a && a.skipPreflight,
            _e = j === !0 ? "processed" : a && a.preflightCommitment || this.commitment;
        a && a.maxRetries != null && ($.maxRetries = a.maxRetries), a && a.minContextSlot != null && ($.minContextSlot = a.minContextSlot), j && ($.skipPreflight = j), _e && ($.preflightCommitment = _e);
        const et = [o, $],
            tt = await this._rpcRequest("sendTransaction", et),
            nt = create$1(tt, SendTransactionRpcResult);
        if ("error" in nt) {
            let rt;
            throw "data" in nt.error && (rt = nt.error.data.logs), new SendTransactionError({
                action: j ? "send" : "simulate",
                signature: "",
                transactionMessage: nt.error.message,
                logs: rt
            })
        }
        return nt.result
    }
    _wsOnOpen() {
        this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
            (async () => {
                try {
                    await this._rpcWebSocket.notify("ping")
                } catch {}
            })()
        }, 5e3), this._updateSubscriptions()
    }
    _wsOnError(o) {
        this._rpcWebSocketConnected = !1, console.error("ws error:", o.message)
    }
    _wsOnClose(o) {
        if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), o === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([a, $]) => {
            this._setSubscription(a, { ...$,
                state: "pending"
            })
        })
    }
    _setSubscription(o, a) {
        var j;
        const $ = (j = this._subscriptionsByHash[o]) == null ? void 0 : j.state;
        if (this._subscriptionsByHash[o] = a, $ !== a.state) {
            const _e = this._subscriptionStateChangeCallbacksByHash[o];
            _e && _e.forEach(et => {
                try {
                    et(a.state)
                } catch {}
            })
        }
    }
    _onSubscriptionStateChange(o, a) {
        var _e;
        const $ = this._subscriptionHashByClientSubscriptionId[o];
        if ($ == null) return () => {};
        const j = (_e = this._subscriptionStateChangeCallbacksByHash)[$] || (_e[$] = new Set);
        return j.add(a), () => {
            j.delete(a), j.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[$]
        }
    }
    async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                    this._rpcWebSocket.close()
                } catch ($) {
                    $ instanceof Error && console.log(`Error when closing socket connection: ${$.message}`)
                }
            }, 500));
            return
        }
        if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return
        }
        const o = this._rpcWebSocketGeneration,
            a = () => o === this._rpcWebSocketGeneration;
        await Promise.all(Object.keys(this._subscriptionsByHash).map(async $ => {
            const j = this._subscriptionsByHash[$];
            if (j !== void 0) switch (j.state) {
                case "pending":
                case "unsubscribed":
                    if (j.callbacks.size === 0) {
                        delete this._subscriptionsByHash[$], j.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[j.serverSubscriptionId], await this._updateSubscriptions();
                        return
                    }
                    await (async () => {
                        const {
                            args: _e,
                            method: et
                        } = j;
                        try {
                            this._setSubscription($, { ...j,
                                state: "subscribing"
                            });
                            const tt = await this._rpcWebSocket.call(et, _e);
                            this._setSubscription($, { ...j,
                                serverSubscriptionId: tt,
                                state: "subscribed"
                            }), this._subscriptionCallbacksByServerSubscriptionId[tt] = j.callbacks, await this._updateSubscriptions()
                        } catch (tt) {
                            if (tt instanceof Error && console.error(`${et} error for argument`, _e, tt.message), !a()) return;
                            this._setSubscription($, { ...j,
                                state: "pending"
                            }), await this._updateSubscriptions()
                        }
                    })();
                    break;
                case "subscribed":
                    j.callbacks.size === 0 && await (async () => {
                        const {
                            serverSubscriptionId: _e,
                            unsubscribeMethod: et
                        } = j;
                        if (this._subscriptionsAutoDisposedByRpc.has(_e)) this._subscriptionsAutoDisposedByRpc.delete(_e);
                        else {
                            this._setSubscription($, { ...j,
                                state: "unsubscribing"
                            }), this._setSubscription($, { ...j,
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(et, [_e])
                            } catch (tt) {
                                if (tt instanceof Error && console.error(`${et} error:`, tt.message), !a()) return;
                                this._setSubscription($, { ...j,
                                    state: "subscribed"
                                }), await this._updateSubscriptions();
                                return
                            }
                        }
                        this._setSubscription($, { ...j,
                            state: "unsubscribed"
                        }), await this._updateSubscriptions()
                    })();
                    break
            }
        }))
    }
    _handleServerNotification(o, a) {
        const $ = this._subscriptionCallbacksByServerSubscriptionId[o];
        $ !== void 0 && $.forEach(j => {
            try {
                j(...a)
            } catch (_e) {
                console.error(_e)
            }
        })
    }
    _wsOnAccountNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$1(o, AccountNotificationResult);
        this._handleServerNotification($, [a.value, a.context])
    }
    _makeSubscription(o, a) {
        const $ = this._nextClientSubscriptionId++,
            j = fastStableStringify$1([o.method, a]),
            _e = this._subscriptionsByHash[j];
        return _e === void 0 ? this._subscriptionsByHash[j] = { ...o,
            args: a,
            callbacks: new Set([o.callback]),
            state: "pending"
        } : _e.callbacks.add(o.callback), this._subscriptionHashByClientSubscriptionId[$] = j, this._subscriptionDisposeFunctionsByClientSubscriptionId[$] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[$], delete this._subscriptionHashByClientSubscriptionId[$];
            const et = this._subscriptionsByHash[j];
            assert$2(et !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${$}`), et.callbacks.delete(o.callback), await this._updateSubscriptions()
        }, this._updateSubscriptions(), $
    }
    onAccountChange(o, a, $) {
        const {
            commitment: j,
            config: _e
        } = extractCommitmentFromConfig($), et = this._buildArgs([o.toBase58()], j || this._commitment || "finalized", "base64", _e);
        return this._makeSubscription({
            callback: a,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, et)
    }
    async removeAccountChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "account change")
    }
    _wsOnProgramAccountNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$1(o, ProgramAccountNotificationResult);
        this._handleServerNotification($, [{
            accountId: a.value.pubkey,
            accountInfo: a.value.account
        }, a.context])
    }
    onProgramAccountChange(o, a, $, j) {
        const {
            commitment: _e,
            config: et
        } = extractCommitmentFromConfig($), tt = this._buildArgs([o.toBase58()], _e || this._commitment || "finalized", "base64", et || (j ? {
            filters: applyDefaultMemcmpEncodingToFilters(j)
        } : void 0));
        return this._makeSubscription({
            callback: a,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, tt)
    }
    async removeProgramAccountChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "program account change")
    }
    onLogs(o, a, $) {
        const j = this._buildArgs([typeof o == "object" ? {
            mentions: [o.toString()]
        } : o], $ || this._commitment || "finalized");
        return this._makeSubscription({
            callback: a,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, j)
    }
    async removeOnLogsListener(o) {
        await this._unsubscribeClientSubscription(o, "logs")
    }
    _wsOnLogsNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$1(o, LogsNotificationResult);
        this._handleServerNotification($, [a.value, a.context])
    }
    _wsOnSlotNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$1(o, SlotNotificationResult);
        this._handleServerNotification($, [a])
    }
    onSlotChange(o) {
        return this._makeSubscription({
            callback: o,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, [])
    }
    async removeSlotChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "slot change")
    }
    _wsOnSlotUpdatesNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$1(o, SlotUpdateNotificationResult);
        this._handleServerNotification($, [a])
    }
    onSlotUpdate(o) {
        return this._makeSubscription({
            callback: o,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }
    async removeSlotUpdateListener(o) {
        await this._unsubscribeClientSubscription(o, "slot update")
    }
    async _unsubscribeClientSubscription(o, a) {
        const $ = this._subscriptionDisposeFunctionsByClientSubscriptionId[o];
        $ ? await $() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${o}\` for '${a}' events could not be found.`)
    }
    _buildArgs(o, a, $, j) {
        const _e = a || this._commitment;
        if (_e || $ || j) {
            let et = {};
            $ && (et.encoding = $), _e && (et.commitment = _e), j && (et = Object.assign(et, j)), o.push(et)
        }
        return o
    }
    _buildArgsAtLeastConfirmed(o, a, $, j) {
        const _e = a || this._commitment;
        if (_e && !["confirmed", "finalized"].includes(_e)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(o, a, $, j)
    }
    _wsOnSignatureNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$1(o, SignatureNotificationResult);
        a.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add($), this._handleServerNotification($, a.value === "receivedSignature" ? [{
            type: "received"
        }, a.context] : [{
            type: "status",
            result: a.value
        }, a.context])
    }
    onSignature(o, a, $) {
        const j = this._buildArgs([o], $ || this._commitment || "finalized"),
            _e = this._makeSubscription({
                callback: (et, tt) => {
                    if (et.type === "status") {
                        a(et.result, tt);
                        try {
                            this.removeSignatureListener(_e)
                        } catch {}
                    }
                },
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe"
            }, j);
        return _e
    }
    onSignatureWithOptions(o, a, $) {
        const {
            commitment: j,
            ..._e
        } = { ...$,
            commitment: $ && $.commitment || this._commitment || "finalized"
        }, et = this._buildArgs([o], j, void 0, _e), tt = this._makeSubscription({
            callback: (nt, rt) => {
                a(nt, rt);
                try {
                    this.removeSignatureListener(tt)
                } catch {}
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, et);
        return tt
    }
    async removeSignatureListener(o) {
        await this._unsubscribeClientSubscription(o, "signature result")
    }
    _wsOnRootNotification(o) {
        const {
            result: a,
            subscription: $
        } = create$1(o, RootNotificationResult);
        this._handleServerNotification($, [a])
    }
    onRootChange(o) {
        return this._makeSubscription({
            callback: o,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, [])
    }
    async removeRootChangeListener(o) {
        await this._unsubscribeClientSubscription(o, "root change")
    }
}
class Keypair {
    constructor(o) {
        this._keypair = void 0, this._keypair = o ? ? generateKeypair()
    }
    static generate() {
        return new Keypair(generateKeypair())
    }
    static fromSecretKey(o, a) {
        if (o.byteLength !== 64) throw new Error("bad secret key size");
        const $ = o.slice(32, 64);
        if (!a || !a.skipValidation) {
            const j = o.slice(0, 32),
                _e = getPublicKey(j);
            for (let et = 0; et < 32; et++)
                if ($[et] !== _e[et]) throw new Error("provided secretKey is invalid")
        }
        return new Keypair({
            publicKey: $,
            secretKey: o
        })
    }
    static fromSeed(o) {
        const a = getPublicKey(o),
            $ = new Uint8Array(64);
        return $.set(o), $.set(a, 32), new Keypair({
            publicKey: a,
            secretKey: $
        })
    }
    get publicKey() {
        return new PublicKey(this._keypair.publicKey)
    }
    get secretKey() {
        return new Uint8Array(this._keypair.secretKey)
    }
}
const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: struct$1([u32$1("instruction"), u64$1("recentSlot"), u8$1("bumpSeed")])
    },
    FreezeLookupTable: {
        index: 1,
        layout: struct$1([u32$1("instruction")])
    },
    ExtendLookupTable: {
        index: 2,
        layout: struct$1([u32$1("instruction"), u64$1(), seq(publicKey$3(), offset$1(u32$1(), -8), "addresses")])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: struct$1([u32$1("instruction")])
    },
    CloseLookupTable: {
        index: 4,
        layout: struct$1([u32$1("instruction")])
    }
});
class AddressLookupTableInstruction {
    constructor() {}
    static decodeInstructionType(o) {
        this.checkProgramId(o.programId);
        const $ = u32$1("instruction").decode(o.data);
        let j;
        for (const [_e, et] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS))
            if (et.index == $) {
                j = _e;
                break
            }
        if (!j) throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
        return j
    }
    static decodeCreateLookupTable(o) {
        this.checkProgramId(o.programId), this.checkKeysLength(o.keys, 4);
        const {
            recentSlot: a
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, o.data);
        return {
            authority: o.keys[1].pubkey,
            payer: o.keys[2].pubkey,
            recentSlot: Number(a)
        }
    }
    static decodeExtendLookupTable(o) {
        if (this.checkProgramId(o.programId), o.keys.length < 2) throw new Error(`invalid instruction; found ${o.keys.length} keys, expected at least 2`);
        const {
            addresses: a
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, o.data);
        return {
            lookupTable: o.keys[0].pubkey,
            authority: o.keys[1].pubkey,
            payer: o.keys.length > 2 ? o.keys[2].pubkey : void 0,
            addresses: a.map($ => new PublicKey($))
        }
    }
    static decodeCloseLookupTable(o) {
        return this.checkProgramId(o.programId), this.checkKeysLength(o.keys, 3), {
            lookupTable: o.keys[0].pubkey,
            authority: o.keys[1].pubkey,
            recipient: o.keys[2].pubkey
        }
    }
    static decodeFreezeLookupTable(o) {
        return this.checkProgramId(o.programId), this.checkKeysLength(o.keys, 2), {
            lookupTable: o.keys[0].pubkey,
            authority: o.keys[1].pubkey
        }
    }
    static decodeDeactivateLookupTable(o) {
        return this.checkProgramId(o.programId), this.checkKeysLength(o.keys, 2), {
            lookupTable: o.keys[0].pubkey,
            authority: o.keys[1].pubkey
        }
    }
    static checkProgramId(o) {
        if (!o.equals(AddressLookupTableProgram.programId)) throw new Error("invalid instruction; programId is not AddressLookupTable Program")
    }
    static checkKeysLength(o, a) {
        if (o.length < a) throw new Error(`invalid instruction; found ${o.length} keys, expected at least ${a}`)
    }
}
class AddressLookupTableProgram {
    constructor() {}
    static createLookupTable(o) {
        const [a, $] = PublicKey.findProgramAddressSync([o.authority.toBuffer(), toBufferLE_1(BigInt(o.recentSlot), 8)], this.programId), j = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, _e = encodeData(j, {
            recentSlot: BigInt(o.recentSlot),
            bumpSeed: $
        }), et = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: o.authority,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: o.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: SystemProgram.programId,
            isSigner: !1,
            isWritable: !1
        }];
        return [new TransactionInstruction({
            programId: this.programId,
            keys: et,
            data: _e
        }), a]
    }
    static freezeLookupTable(o) {
        const a = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable,
            $ = encodeData(a),
            j = [{
                pubkey: o.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.authority,
                isSigner: !0,
                isWritable: !1
            }];
        return new TransactionInstruction({
            programId: this.programId,
            keys: j,
            data: $
        })
    }
    static extendLookupTable(o) {
        const a = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,
            $ = encodeData(a, {
                addresses: o.addresses.map(_e => _e.toBytes())
            }),
            j = [{
                pubkey: o.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.authority,
                isSigner: !0,
                isWritable: !1
            }];
        return o.payer && j.push({
            pubkey: o.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: SystemProgram.programId,
            isSigner: !1,
            isWritable: !1
        }), new TransactionInstruction({
            programId: this.programId,
            keys: j,
            data: $
        })
    }
    static deactivateLookupTable(o) {
        const a = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable,
            $ = encodeData(a),
            j = [{
                pubkey: o.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.authority,
                isSigner: !0,
                isWritable: !1
            }];
        return new TransactionInstruction({
            programId: this.programId,
            keys: j,
            data: $
        })
    }
    static closeLookupTable(o) {
        const a = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable,
            $ = encodeData(a),
            j = [{
                pubkey: o.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: o.authority,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: o.recipient,
                isSigner: !1,
                isWritable: !0
            }];
        return new TransactionInstruction({
            programId: this.programId,
            keys: j,
            data: $
        })
    }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
class ComputeBudgetInstruction {
    constructor() {}
    static decodeInstructionType(o) {
        this.checkProgramId(o.programId);
        const $ = u8$1("instruction").decode(o.data);
        let j;
        for (const [_e, et] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS))
            if (et.index == $) {
                j = _e;
                break
            }
        if (!j) throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
        return j
    }
    static decodeRequestUnits(o) {
        this.checkProgramId(o.programId);
        const {
            units: a,
            additionalFee: $
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, o.data);
        return {
            units: a,
            additionalFee: $
        }
    }
    static decodeRequestHeapFrame(o) {
        this.checkProgramId(o.programId);
        const {
            bytes: a
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, o.data);
        return {
            bytes: a
        }
    }
    static decodeSetComputeUnitLimit(o) {
        this.checkProgramId(o.programId);
        const {
            units: a
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, o.data);
        return {
            units: a
        }
    }
    static decodeSetComputeUnitPrice(o) {
        this.checkProgramId(o.programId);
        const {
            microLamports: a
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, o.data);
        return {
            microLamports: a
        }
    }
    static checkProgramId(o) {
        if (!o.equals(ComputeBudgetProgram.programId)) throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
    }
}
const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
    RequestUnits: {
        index: 0,
        layout: struct$1([u8$1("instruction"), u32$1("units"), u32$1("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: struct$1([u8$1("instruction"), u32$1("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: struct$1([u8$1("instruction"), u32$1("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: struct$1([u8$1("instruction"), u64$1("microLamports")])
    }
});
class ComputeBudgetProgram {
    constructor() {}
    static requestUnits(o) {
        const a = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,
            $ = encodeData(a, o);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: $
        })
    }
    static requestHeapFrame(o) {
        const a = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,
            $ = encodeData(a, o);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: $
        })
    }
    static setComputeUnitLimit(o) {
        const a = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,
            $ = encodeData(a, o);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: $
        })
    }
    static setComputeUnitPrice(o) {
        const a = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,
            $ = encodeData(a, {
                microLamports: BigInt(o.microLamports)
            });
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: $
        })
    }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
const PRIVATE_KEY_BYTES$1 = 64,
    PUBLIC_KEY_BYTES$1 = 32,
    SIGNATURE_BYTES = 64,
    ED25519_INSTRUCTION_LAYOUT = struct$1([u8$1("numSignatures"), u8$1("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
class Ed25519Program {
    constructor() {}
    static createInstructionWithPublicKey(o) {
        const {
            publicKey: a,
            message: $,
            signature: j,
            instructionIndex: _e
        } = o;
        assert$2(a.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${a.length} bytes`), assert$2(j.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${j.length} bytes`);
        const et = ED25519_INSTRUCTION_LAYOUT.span,
            tt = et + a.length,
            nt = tt + j.length,
            rt = 1,
            ot = buffer.Buffer.alloc(nt + $.length),
            st = _e ? ? 65535;
        return ED25519_INSTRUCTION_LAYOUT.encode({
            numSignatures: rt,
            padding: 0,
            signatureOffset: tt,
            signatureInstructionIndex: st,
            publicKeyOffset: et,
            publicKeyInstructionIndex: st,
            messageDataOffset: nt,
            messageDataSize: $.length,
            messageInstructionIndex: st
        }, ot), ot.fill(a, et), ot.fill(j, tt), ot.fill($, nt), new TransactionInstruction({
            keys: [],
            programId: Ed25519Program.programId,
            data: ot
        })
    }
    static createInstructionWithPrivateKey(o) {
        const {
            privateKey: a,
            message: $,
            instructionIndex: j
        } = o;
        assert$2(a.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${a.length} bytes`);
        try {
            const _e = Keypair.fromSecretKey(a),
                et = _e.publicKey.toBytes(),
                tt = sign($, _e.secretKey);
            return this.createInstructionWithPublicKey({
                publicKey: et,
                message: $,
                signature: tt,
                instructionIndex: j
            })
        } catch (_e) {
            throw new Error(`Error creating instruction; ${_e}`)
        }
    }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
const ecdsaSign = (s, o) => {
    const a = secp256k1.sign(s, o);
    return [a.toCompactRawBytes(), a.recovery]
};
secp256k1.utils.isValidPrivateKey;
const publicKeyCreate = secp256k1.getPublicKey,
    PRIVATE_KEY_BYTES = 32,
    ETHEREUM_ADDRESS_BYTES = 20,
    PUBLIC_KEY_BYTES = 64,
    SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11,
    SECP256K1_INSTRUCTION_LAYOUT = struct$1([u8$1("numSignatures"), u16("signatureOffset"), u8$1("signatureInstructionIndex"), u16("ethAddressOffset"), u8$1("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8$1("messageInstructionIndex"), blob$1(20, "ethAddress"), blob$1(64, "signature"), u8$1("recoveryId")]);
class Secp256k1Program {
    constructor() {}
    static publicKeyToEthAddress(o) {
        assert$2(o.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${o.length} bytes`);
        try {
            return buffer.Buffer.from(keccak_256(toBuffer$1(o))).slice(-ETHEREUM_ADDRESS_BYTES)
        } catch (a) {
            throw new Error(`Error constructing Ethereum address: ${a}`)
        }
    }
    static createInstructionWithPublicKey(o) {
        const {
            publicKey: a,
            message: $,
            signature: j,
            recoveryId: _e,
            instructionIndex: et
        } = o;
        return Secp256k1Program.createInstructionWithEthAddress({
            ethAddress: Secp256k1Program.publicKeyToEthAddress(a),
            message: $,
            signature: j,
            recoveryId: _e,
            instructionIndex: et
        })
    }
    static createInstructionWithEthAddress(o) {
        const {
            ethAddress: a,
            message: $,
            signature: j,
            recoveryId: _e,
            instructionIndex: et = 0
        } = o;
        let tt;
        typeof a == "string" ? a.startsWith("0x") ? tt = buffer.Buffer.from(a.substr(2), "hex") : tt = buffer.Buffer.from(a, "hex") : tt = a, assert$2(tt.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${tt.length} bytes`);
        const nt = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE,
            rt = nt,
            ot = nt + tt.length,
            st = ot + j.length + 1,
            lt = 1,
            ft = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + $.length);
        return SECP256K1_INSTRUCTION_LAYOUT.encode({
            numSignatures: lt,
            signatureOffset: ot,
            signatureInstructionIndex: et,
            ethAddressOffset: rt,
            ethAddressInstructionIndex: et,
            messageDataOffset: st,
            messageDataSize: $.length,
            messageInstructionIndex: et,
            signature: toBuffer$1(j),
            ethAddress: toBuffer$1(tt),
            recoveryId: _e
        }, ft), ft.fill(toBuffer$1($), SECP256K1_INSTRUCTION_LAYOUT.span), new TransactionInstruction({
            keys: [],
            programId: Secp256k1Program.programId,
            data: ft
        })
    }
    static createInstructionWithPrivateKey(o) {
        const {
            privateKey: a,
            message: $,
            instructionIndex: j
        } = o;
        assert$2(a.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${a.length} bytes`);
        try {
            const _e = toBuffer$1(a),
                et = publicKeyCreate(_e, !1).slice(1),
                tt = buffer.Buffer.from(keccak_256(toBuffer$1($))),
                [nt, rt] = ecdsaSign(tt, _e);
            return this.createInstructionWithPublicKey({
                publicKey: et,
                message: $,
                signature: nt,
                recoveryId: rt,
                instructionIndex: j
            })
        } catch (_e) {
            throw new Error(`Error creating instruction; ${_e}`)
        }
    }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
const STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
class Authorized {
    constructor(o, a) {
        this.staker = void 0, this.withdrawer = void 0, this.staker = o, this.withdrawer = a
    }
}
class Lockup {
    constructor(o, a, $) {
        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = o, this.epoch = a, this.custodian = $
    }
}
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey.default);
class StakeInstruction {
    constructor() {}
    static decodeInstructionType(o) {
        this.checkProgramId(o.programId);
        const $ = u32$1("instruction").decode(o.data);
        let j;
        for (const [_e, et] of Object.entries(STAKE_INSTRUCTION_LAYOUTS))
            if (et.index == $) {
                j = _e;
                break
            }
        if (!j) throw new Error("Instruction type incorrect; not a StakeInstruction");
        return j
    }
    static decodeInitialize(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 2);
        const {
            authorized: a,
            lockup: $
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, o.data);
        return {
            stakePubkey: o.keys[0].pubkey,
            authorized: new Authorized(new PublicKey(a.staker), new PublicKey(a.withdrawer)),
            lockup: new Lockup($.unixTimestamp, $.epoch, new PublicKey($.custodian))
        }
    }
    static decodeDelegate(o) {
        return this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 6), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, o.data), {
            stakePubkey: o.keys[0].pubkey,
            votePubkey: o.keys[1].pubkey,
            authorizedPubkey: o.keys[5].pubkey
        }
    }
    static decodeAuthorize(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3);
        const {
            newAuthorized: a,
            stakeAuthorizationType: $
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, o.data), j = {
            stakePubkey: o.keys[0].pubkey,
            authorizedPubkey: o.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(a),
            stakeAuthorizationType: {
                index: $
            }
        };
        return o.keys.length > 3 && (j.custodianPubkey = o.keys[3].pubkey), j
    }
    static decodeAuthorizeWithSeed(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 2);
        const {
            newAuthorized: a,
            stakeAuthorizationType: $,
            authoritySeed: j,
            authorityOwner: _e
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, o.data), et = {
            stakePubkey: o.keys[0].pubkey,
            authorityBase: o.keys[1].pubkey,
            authoritySeed: j,
            authorityOwner: new PublicKey(_e),
            newAuthorizedPubkey: new PublicKey(a),
            stakeAuthorizationType: {
                index: $
            }
        };
        return o.keys.length > 3 && (et.custodianPubkey = o.keys[3].pubkey), et
    }
    static decodeSplit(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3);
        const {
            lamports: a
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, o.data);
        return {
            stakePubkey: o.keys[0].pubkey,
            splitStakePubkey: o.keys[1].pubkey,
            authorizedPubkey: o.keys[2].pubkey,
            lamports: a
        }
    }
    static decodeMerge(o) {
        return this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, o.data), {
            stakePubkey: o.keys[0].pubkey,
            sourceStakePubKey: o.keys[1].pubkey,
            authorizedPubkey: o.keys[4].pubkey
        }
    }
    static decodeWithdraw(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 5);
        const {
            lamports: a
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, o.data), $ = {
            stakePubkey: o.keys[0].pubkey,
            toPubkey: o.keys[1].pubkey,
            authorizedPubkey: o.keys[4].pubkey,
            lamports: a
        };
        return o.keys.length > 5 && ($.custodianPubkey = o.keys[5].pubkey), $
    }
    static decodeDeactivate(o) {
        return this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, o.data), {
            stakePubkey: o.keys[0].pubkey,
            authorizedPubkey: o.keys[2].pubkey
        }
    }
    static checkProgramId(o) {
        if (!o.equals(StakeProgram.programId)) throw new Error("invalid instruction; programId is not StakeProgram")
    }
    static checkKeyLength(o, a) {
        if (o.length < a) throw new Error(`invalid instruction; found ${o.length} keys, expected at least ${a}`)
    }
}
const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
        Initialize: {
            index: 0,
            layout: struct$1([u32$1("instruction"), authorized(), lockup()])
        },
        Authorize: {
            index: 1,
            layout: struct$1([u32$1("instruction"), publicKey$3("newAuthorized"), u32$1("stakeAuthorizationType")])
        },
        Delegate: {
            index: 2,
            layout: struct$1([u32$1("instruction")])
        },
        Split: {
            index: 3,
            layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
        },
        Withdraw: {
            index: 4,
            layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
        },
        Deactivate: {
            index: 5,
            layout: struct$1([u32$1("instruction")])
        },
        Merge: {
            index: 7,
            layout: struct$1([u32$1("instruction")])
        },
        AuthorizeWithSeed: {
            index: 8,
            layout: struct$1([u32$1("instruction"), publicKey$3("newAuthorized"), u32$1("stakeAuthorizationType"), rustString("authoritySeed"), publicKey$3("authorityOwner")])
        }
    }),
    StakeAuthorizationLayout = Object.freeze({
        Staker: {
            index: 0
        },
        Withdrawer: {
            index: 1
        }
    });
class StakeProgram {
    constructor() {}
    static initialize(o) {
        const {
            stakePubkey: a,
            authorized: $,
            lockup: j
        } = o, _e = j || Lockup.default, et = STAKE_INSTRUCTION_LAYOUTS.Initialize, tt = encodeData(et, {
            authorized: {
                staker: toBuffer$1($.staker.toBuffer()),
                withdrawer: toBuffer$1($.withdrawer.toBuffer())
            },
            lockup: {
                unixTimestamp: _e.unixTimestamp,
                epoch: _e.epoch,
                custodian: toBuffer$1(_e.custodian.toBuffer())
            }
        }), nt = {
            keys: [{
                pubkey: a,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: tt
        };
        return new TransactionInstruction(nt)
    }
    static createAccountWithSeed(o) {
        const a = new Transaction;
        a.add(SystemProgram.createAccountWithSeed({
            fromPubkey: o.fromPubkey,
            newAccountPubkey: o.stakePubkey,
            basePubkey: o.basePubkey,
            seed: o.seed,
            lamports: o.lamports,
            space: this.space,
            programId: this.programId
        }));
        const {
            stakePubkey: $,
            authorized: j,
            lockup: _e
        } = o;
        return a.add(this.initialize({
            stakePubkey: $,
            authorized: j,
            lockup: _e
        }))
    }
    static createAccount(o) {
        const a = new Transaction;
        a.add(SystemProgram.createAccount({
            fromPubkey: o.fromPubkey,
            newAccountPubkey: o.stakePubkey,
            lamports: o.lamports,
            space: this.space,
            programId: this.programId
        }));
        const {
            stakePubkey: $,
            authorized: j,
            lockup: _e
        } = o;
        return a.add(this.initialize({
            stakePubkey: $,
            authorized: j,
            lockup: _e
        }))
    }
    static delegate(o) {
        const {
            stakePubkey: a,
            authorizedPubkey: $,
            votePubkey: j
        } = o, _e = STAKE_INSTRUCTION_LAYOUTS.Delegate, et = encodeData(_e);
        return new Transaction().add({
            keys: [{
                pubkey: a,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: j,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: STAKE_CONFIG_ID,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: $,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: et
        })
    }
    static authorize(o) {
        const {
            stakePubkey: a,
            authorizedPubkey: $,
            newAuthorizedPubkey: j,
            stakeAuthorizationType: _e,
            custodianPubkey: et
        } = o, tt = STAKE_INSTRUCTION_LAYOUTS.Authorize, nt = encodeData(tt, {
            newAuthorized: toBuffer$1(j.toBuffer()),
            stakeAuthorizationType: _e.index
        }), rt = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $,
            isSigner: !0,
            isWritable: !1
        }];
        return et && rt.push({
            pubkey: et,
            isSigner: !0,
            isWritable: !1
        }), new Transaction().add({
            keys: rt,
            programId: this.programId,
            data: nt
        })
    }
    static authorizeWithSeed(o) {
        const {
            stakePubkey: a,
            authorityBase: $,
            authoritySeed: j,
            authorityOwner: _e,
            newAuthorizedPubkey: et,
            stakeAuthorizationType: tt,
            custodianPubkey: nt
        } = o, rt = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, ot = encodeData(rt, {
            newAuthorized: toBuffer$1(et.toBuffer()),
            stakeAuthorizationType: tt.index,
            authoritySeed: j,
            authorityOwner: toBuffer$1(_e.toBuffer())
        }), st = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }];
        return nt && st.push({
            pubkey: nt,
            isSigner: !0,
            isWritable: !1
        }), new Transaction().add({
            keys: st,
            programId: this.programId,
            data: ot
        })
    }
    static splitInstruction(o) {
        const {
            stakePubkey: a,
            authorizedPubkey: $,
            splitStakePubkey: j,
            lamports: _e
        } = o, et = STAKE_INSTRUCTION_LAYOUTS.Split, tt = encodeData(et, {
            lamports: _e
        });
        return new TransactionInstruction({
            keys: [{
                pubkey: a,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: j,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: tt
        })
    }
    static split(o, a) {
        const $ = new Transaction;
        return $.add(SystemProgram.createAccount({
            fromPubkey: o.authorizedPubkey,
            newAccountPubkey: o.splitStakePubkey,
            lamports: a,
            space: this.space,
            programId: this.programId
        })), $.add(this.splitInstruction(o))
    }
    static splitWithSeed(o, a) {
        const {
            stakePubkey: $,
            authorizedPubkey: j,
            splitStakePubkey: _e,
            basePubkey: et,
            seed: tt,
            lamports: nt
        } = o, rt = new Transaction;
        return rt.add(SystemProgram.allocate({
            accountPubkey: _e,
            basePubkey: et,
            seed: tt,
            space: this.space,
            programId: this.programId
        })), a && a > 0 && rt.add(SystemProgram.transfer({
            fromPubkey: o.authorizedPubkey,
            toPubkey: _e,
            lamports: a
        })), rt.add(this.splitInstruction({
            stakePubkey: $,
            authorizedPubkey: j,
            splitStakePubkey: _e,
            lamports: nt
        }))
    }
    static merge(o) {
        const {
            stakePubkey: a,
            sourceStakePubKey: $,
            authorizedPubkey: j
        } = o, _e = STAKE_INSTRUCTION_LAYOUTS.Merge, et = encodeData(_e);
        return new Transaction().add({
            keys: [{
                pubkey: a,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: j,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: et
        })
    }
    static withdraw(o) {
        const {
            stakePubkey: a,
            authorizedPubkey: $,
            toPubkey: j,
            lamports: _e,
            custodianPubkey: et
        } = o, tt = STAKE_INSTRUCTION_LAYOUTS.Withdraw, nt = encodeData(tt, {
            lamports: _e
        }), rt = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: j,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: $,
            isSigner: !0,
            isWritable: !1
        }];
        return et && rt.push({
            pubkey: et,
            isSigner: !0,
            isWritable: !1
        }), new Transaction().add({
            keys: rt,
            programId: this.programId,
            data: nt
        })
    }
    static deactivate(o) {
        const {
            stakePubkey: a,
            authorizedPubkey: $
        } = o, j = STAKE_INSTRUCTION_LAYOUTS.Deactivate, _e = encodeData(j);
        return new Transaction().add({
            keys: [{
                pubkey: a,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: $,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: _e
        })
    }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
class VoteInit {
    constructor(o, a, $, j) {
        this.nodePubkey = void 0, this.authorizedVoter = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.nodePubkey = o, this.authorizedVoter = a, this.authorizedWithdrawer = $, this.commission = j
    }
}
class VoteInstruction {
    constructor() {}
    static decodeInstructionType(o) {
        this.checkProgramId(o.programId);
        const $ = u32$1("instruction").decode(o.data);
        let j;
        for (const [_e, et] of Object.entries(VOTE_INSTRUCTION_LAYOUTS))
            if (et.index == $) {
                j = _e;
                break
            }
        if (!j) throw new Error("Instruction type incorrect; not a VoteInstruction");
        return j
    }
    static decodeInitializeAccount(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 4);
        const {
            voteInit: a
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, o.data);
        return {
            votePubkey: o.keys[0].pubkey,
            nodePubkey: o.keys[3].pubkey,
            voteInit: new VoteInit(new PublicKey(a.nodePubkey), new PublicKey(a.authorizedVoter), new PublicKey(a.authorizedWithdrawer), a.commission)
        }
    }
    static decodeAuthorize(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3);
        const {
            newAuthorized: a,
            voteAuthorizationType: $
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, o.data);
        return {
            votePubkey: o.keys[0].pubkey,
            authorizedPubkey: o.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(a),
            voteAuthorizationType: {
                index: $
            }
        }
    }
    static decodeAuthorizeWithSeed(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3);
        const {
            voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: a,
                currentAuthorityDerivedKeySeed: $,
                newAuthorized: j,
                voteAuthorizationType: _e
            }
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, o.data);
        return {
            currentAuthorityDerivedKeyBasePubkey: o.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(a),
            currentAuthorityDerivedKeySeed: $,
            newAuthorizedPubkey: new PublicKey(j),
            voteAuthorizationType: {
                index: _e
            },
            votePubkey: o.keys[0].pubkey
        }
    }
    static decodeWithdraw(o) {
        this.checkProgramId(o.programId), this.checkKeyLength(o.keys, 3);
        const {
            lamports: a
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, o.data);
        return {
            votePubkey: o.keys[0].pubkey,
            authorizedWithdrawerPubkey: o.keys[2].pubkey,
            lamports: a,
            toPubkey: o.keys[1].pubkey
        }
    }
    static checkProgramId(o) {
        if (!o.equals(VoteProgram.programId)) throw new Error("invalid instruction; programId is not VoteProgram")
    }
    static checkKeyLength(o, a) {
        if (o.length < a) throw new Error(`invalid instruction; found ${o.length} keys, expected at least ${a}`)
    }
}
const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
        InitializeAccount: {
            index: 0,
            layout: struct$1([u32$1("instruction"), voteInit()])
        },
        Authorize: {
            index: 1,
            layout: struct$1([u32$1("instruction"), publicKey$3("newAuthorized"), u32$1("voteAuthorizationType")])
        },
        Withdraw: {
            index: 3,
            layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
        },
        UpdateValidatorIdentity: {
            index: 4,
            layout: struct$1([u32$1("instruction")])
        },
        AuthorizeWithSeed: {
            index: 10,
            layout: struct$1([u32$1("instruction"), voteAuthorizeWithSeedArgs()])
        }
    }),
    VoteAuthorizationLayout = Object.freeze({
        Voter: {
            index: 0
        },
        Withdrawer: {
            index: 1
        }
    });
class VoteProgram {
    constructor() {}
    static initializeAccount(o) {
        const {
            votePubkey: a,
            nodePubkey: $,
            voteInit: j
        } = o, _e = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, et = encodeData(_e, {
            voteInit: {
                nodePubkey: toBuffer$1(j.nodePubkey.toBuffer()),
                authorizedVoter: toBuffer$1(j.authorizedVoter.toBuffer()),
                authorizedWithdrawer: toBuffer$1(j.authorizedWithdrawer.toBuffer()),
                commission: j.commission
            }
        }), tt = {
            keys: [{
                pubkey: a,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: $,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: et
        };
        return new TransactionInstruction(tt)
    }
    static createAccount(o) {
        const a = new Transaction;
        return a.add(SystemProgram.createAccount({
            fromPubkey: o.fromPubkey,
            newAccountPubkey: o.votePubkey,
            lamports: o.lamports,
            space: this.space,
            programId: this.programId
        })), a.add(this.initializeAccount({
            votePubkey: o.votePubkey,
            nodePubkey: o.voteInit.nodePubkey,
            voteInit: o.voteInit
        }))
    }
    static authorize(o) {
        const {
            votePubkey: a,
            authorizedPubkey: $,
            newAuthorizedPubkey: j,
            voteAuthorizationType: _e
        } = o, et = VOTE_INSTRUCTION_LAYOUTS.Authorize, tt = encodeData(et, {
            newAuthorized: toBuffer$1(j.toBuffer()),
            voteAuthorizationType: _e.index
        }), nt = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: $,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: nt,
            programId: this.programId,
            data: tt
        })
    }
    static authorizeWithSeed(o) {
        const {
            currentAuthorityDerivedKeyBasePubkey: a,
            currentAuthorityDerivedKeyOwnerPubkey: $,
            currentAuthorityDerivedKeySeed: j,
            newAuthorizedPubkey: _e,
            voteAuthorizationType: et,
            votePubkey: tt
        } = o, nt = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, rt = encodeData(nt, {
            voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: toBuffer$1($.toBuffer()),
                currentAuthorityDerivedKeySeed: j,
                newAuthorized: toBuffer$1(_e.toBuffer()),
                voteAuthorizationType: et.index
            }
        }), ot = [{
            pubkey: tt,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: a,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: ot,
            programId: this.programId,
            data: rt
        })
    }
    static withdraw(o) {
        const {
            votePubkey: a,
            authorizedWithdrawerPubkey: $,
            lamports: j,
            toPubkey: _e
        } = o, et = VOTE_INSTRUCTION_LAYOUTS.Withdraw, tt = encodeData(et, {
            lamports: j
        }), nt = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: _e,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: nt,
            programId: this.programId,
            data: tt
        })
    }
    static safeWithdraw(o, a, $) {
        if (o.lamports > a - $) throw new Error("Withdraw will leave vote account with insufficient funds.");
        return VoteProgram.withdraw(o)
    }
    static updateValidatorIdentity(o) {
        const {
            votePubkey: a,
            authorizedWithdrawerPubkey: $,
            nodePubkey: j
        } = o, _e = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity, et = encodeData(_e), tt = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: j,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: $,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: tt,
            programId: this.programId,
            data: et
        })
    }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3762;
const VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111"),
    InfoString = type$2({
        name: string$1(),
        website: optional$1(string$1()),
        details: optional$1(string$1()),
        iconUrl: optional$1(string$1()),
        keybaseUsername: optional$1(string$1())
    });
class ValidatorInfo {
    constructor(o, a) {
        this.key = void 0, this.info = void 0, this.key = o, this.info = a
    }
    static fromConfigData(o) {
        let a = [...o];
        if (decodeLength(a) !== 2) return null;
        const j = [];
        for (let _e = 0; _e < 2; _e++) {
            const et = new PublicKey(guardedSplice(a, 0, PUBLIC_KEY_LENGTH)),
                tt = guardedShift(a) === 1;
            j.push({
                publicKey: et,
                isSigner: tt
            })
        }
        if (j[0].publicKey.equals(VALIDATOR_INFO_KEY) && j[1].isSigner) {
            const _e = rustString().decode(buffer.Buffer.from(a)),
                et = JSON.parse(_e);
            return assert$3(et, InfoString), new ValidatorInfo(j[1].publicKey, et)
        }
        return null
    }
}
const VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111"),
    VoteAccountLayout = struct$1([publicKey$3("nodePubkey"), publicKey$3("authorizedWithdrawer"), u8$1("commission"), nu64$1(), seq(struct$1([nu64$1("slot"), u32$1("confirmationCount")]), offset$1(u32$1(), -8), "votes"), u8$1("rootSlotValid"), nu64$1("rootSlot"), nu64$1(), seq(struct$1([nu64$1("epoch"), publicKey$3("authorizedVoter")]), offset$1(u32$1(), -8), "authorizedVoters"), struct$1([seq(struct$1([publicKey$3("authorizedPubkey"), nu64$1("epochOfLastAuthorizedSwitch"), nu64$1("targetEpoch")]), 32, "buf"), nu64$1("idx"), u8$1("isEmpty")], "priorVoters"), nu64$1(), seq(struct$1([nu64$1("epoch"), nu64$1("credits"), nu64$1("prevCredits")]), offset$1(u32$1(), -8), "epochCredits"), struct$1([nu64$1("slot"), nu64$1("timestamp")], "lastTimestamp")]);
class VoteAccount {
    constructor(o) {
        this.nodePubkey = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.rootSlot = void 0, this.votes = void 0, this.authorizedVoters = void 0, this.priorVoters = void 0, this.epochCredits = void 0, this.lastTimestamp = void 0, this.nodePubkey = o.nodePubkey, this.authorizedWithdrawer = o.authorizedWithdrawer, this.commission = o.commission, this.rootSlot = o.rootSlot, this.votes = o.votes, this.authorizedVoters = o.authorizedVoters, this.priorVoters = o.priorVoters, this.epochCredits = o.epochCredits, this.lastTimestamp = o.lastTimestamp
    }
    static fromAccountData(o) {
        const $ = VoteAccountLayout.decode(toBuffer$1(o), 4);
        let j = $.rootSlot;
        return $.rootSlotValid || (j = null), new VoteAccount({
            nodePubkey: new PublicKey($.nodePubkey),
            authorizedWithdrawer: new PublicKey($.authorizedWithdrawer),
            commission: $.commission,
            votes: $.votes,
            rootSlot: j,
            authorizedVoters: $.authorizedVoters.map(parseAuthorizedVoter),
            priorVoters: getPriorVoters($.priorVoters),
            epochCredits: $.epochCredits,
            lastTimestamp: $.lastTimestamp
        })
    }
}

function parseAuthorizedVoter({
    authorizedVoter: s,
    epoch: o
}) {
    return {
        epoch: o,
        authorizedVoter: new PublicKey(s)
    }
}

function parsePriorVoters({
    authorizedPubkey: s,
    epochOfLastAuthorizedSwitch: o,
    targetEpoch: a
}) {
    return {
        authorizedPubkey: new PublicKey(s),
        epochOfLastAuthorizedSwitch: o,
        targetEpoch: a
    }
}

function getPriorVoters({
    buf: s,
    idx: o,
    isEmpty: a
}) {
    return a ? [] : [...s.slice(o + 1).map(parsePriorVoters), ...s.slice(0, o).map(parsePriorVoters)]
}
const endpoint = {
    http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
    },
    https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
    }
};

function clusterApiUrl(s, o) {
    const a = o === !1 ? "http" : "https";
    if (!s) return endpoint[a].devnet;
    const $ = endpoint[a][s];
    if (!$) throw new Error(`Unknown ${a} cluster: ${s}`);
    return $
}
async function sendAndConfirmRawTransaction$1(s, o, a, $) {
    let j, _e;
    a && Object.prototype.hasOwnProperty.call(a, "lastValidBlockHeight") || a && Object.prototype.hasOwnProperty.call(a, "nonceValue") ? (j = a, _e = $) : _e = a;
    const et = _e && {
            skipPreflight: _e.skipPreflight,
            preflightCommitment: _e.preflightCommitment || _e.commitment,
            minContextSlot: _e.minContextSlot
        },
        tt = await s.sendRawTransaction(o, et),
        nt = _e && _e.commitment,
        ot = (await (j ? s.confirmTransaction(j, nt) : s.confirmTransaction(tt, nt))).value;
    if (ot.err) throw tt != null ? new SendTransactionError({
        action: et != null && et.skipPreflight ? "send" : "simulate",
        signature: tt,
        transactionMessage: `Status: (${JSON.stringify(ot)})`
    }) : new Error(`Raw transaction ${tt} failed (${JSON.stringify(ot)})`);
    return tt
}
const LAMPORTS_PER_SOL = 1e9,
    index_browser_esm = Object.freeze(Object.defineProperty({
        __proto__: null,
        Account,
        AddressLookupTableAccount,
        AddressLookupTableInstruction,
        AddressLookupTableProgram,
        Authorized,
        BLOCKHASH_CACHE_TIMEOUT_MS,
        BPF_LOADER_DEPRECATED_PROGRAM_ID,
        BPF_LOADER_PROGRAM_ID,
        BpfLoader,
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
        ComputeBudgetInstruction,
        ComputeBudgetProgram,
        Connection,
        Ed25519Program,
        Enum,
        EpochSchedule,
        FeeCalculatorLayout,
        Keypair,
        LAMPORTS_PER_SOL,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
        Loader,
        Lockup,
        MAX_SEED_LENGTH,
        Message,
        MessageAccountKeys,
        MessageV0,
        NONCE_ACCOUNT_LENGTH,
        NonceAccount,
        PACKET_DATA_SIZE,
        PUBLIC_KEY_LENGTH,
        PublicKey,
        SIGNATURE_LENGTH_IN_BYTES,
        SOLANA_SCHEMA,
        STAKE_CONFIG_ID,
        STAKE_INSTRUCTION_LAYOUTS,
        SYSTEM_INSTRUCTION_LAYOUTS,
        SYSVAR_CLOCK_PUBKEY,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY,
        SYSVAR_INSTRUCTIONS_PUBKEY,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        SYSVAR_RENT_PUBKEY,
        SYSVAR_REWARDS_PUBKEY,
        SYSVAR_SLOT_HASHES_PUBKEY,
        SYSVAR_SLOT_HISTORY_PUBKEY,
        SYSVAR_STAKE_HISTORY_PUBKEY,
        Secp256k1Program,
        SendTransactionError,
        SolanaJSONRPCError,
        SolanaJSONRPCErrorCode,
        StakeAuthorizationLayout,
        StakeInstruction,
        StakeProgram,
        Struct: Struct$1,
        SystemInstruction,
        SystemProgram,
        Transaction,
        TransactionExpiredBlockheightExceededError,
        TransactionExpiredNonceInvalidError,
        TransactionExpiredTimeoutError,
        TransactionInstruction,
        TransactionMessage,
        TransactionStatus,
        VALIDATOR_INFO_KEY,
        VERSION_PREFIX_MASK,
        VOTE_PROGRAM_ID,
        ValidatorInfo,
        VersionedMessage,
        VersionedTransaction,
        VoteAccount,
        VoteAuthorizationLayout,
        VoteInit,
        VoteInstruction,
        VoteProgram,
        clusterApiUrl,
        sendAndConfirmRawTransaction: sendAndConfirmRawTransaction$1,
        sendAndConfirmTransaction
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var camelcase = {
    exports: {}
};
const UPPERCASE = /[\p{Lu}]/u,
    LOWERCASE = /[\p{Ll}]/u,
    LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu,
    IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u,
    SEPARATORS = /[_.\- ]+/,
    LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source),
    SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"),
    NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"),
    preserveCamelCase = (s, o, a) => {
        let $ = !1,
            j = !1,
            _e = !1;
        for (let et = 0; et < s.length; et++) {
            const tt = s[et];
            $ && UPPERCASE.test(tt) ? (s = s.slice(0, et) + "-" + s.slice(et), $ = !1, _e = j, j = !0, et++) : j && _e && LOWERCASE.test(tt) ? (s = s.slice(0, et - 1) + "-" + s.slice(et - 1), _e = j, j = !1, $ = !0) : ($ = o(tt) === tt && a(tt) !== tt, _e = j, j = a(tt) === tt && o(tt) !== tt)
        }
        return s
    },
    preserveConsecutiveUppercase = (s, o) => (LEADING_CAPITAL.lastIndex = 0, s.replace(LEADING_CAPITAL, a => o(a))),
    postProcess = (s, o) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, s.replace(SEPARATORS_AND_IDENTIFIER, (a, $) => o($)).replace(NUMBERS_AND_IDENTIFIER, a => o(a))),
    camelCase = (s, o) => {
        if (!(typeof s == "string" || Array.isArray(s))) throw new TypeError("Expected the input to be `string | string[]`");
        if (o = {
                pascalCase: !1,
                preserveConsecutiveUppercase: !1,
                ...o
            }, Array.isArray(s) ? s = s.map(_e => _e.trim()).filter(_e => _e.length).join("-") : s = s.trim(), s.length === 0) return "";
        const a = o.locale === !1 ? _e => _e.toLowerCase() : _e => _e.toLocaleLowerCase(o.locale),
            $ = o.locale === !1 ? _e => _e.toUpperCase() : _e => _e.toLocaleUpperCase(o.locale);
        return s.length === 1 ? o.pascalCase ? $(s) : a(s) : (s !== a(s) && (s = preserveCamelCase(s, a, $)), s = s.replace(LEADING_SEPARATORS, ""), o.preserveConsecutiveUppercase ? s = preserveConsecutiveUppercase(s, a) : s = a(s), o.pascalCase && (s = $(s.charAt(0)) + s.slice(1)), postProcess(s, $))
    };
camelcase.exports = camelCase;
camelcase.exports.default = camelCase;
var camelcaseExports = camelcase.exports;
const camelCase$1 = getDefaultExportFromCjs$3(camelcaseExports);
var sha256$1 = {
    exports: {}
};
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
    (function() {
        var ERROR = "input is invalid type",
            WINDOW = typeof window == "object",
            root = WINDOW ? window : {};
        root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
        var WEB_WORKER = !WINDOW && typeof self == "object",
            NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
        NODE_JS ? root = commonjsGlobal$1 : WEB_WORKER && (root = self);
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && !0 && module.exports,
            ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
            HEX_CHARS = "0123456789abcdef".split(""),
            EXTRA = [-2147483648, 8388608, 32768, 128],
            SHIFT = [24, 16, 8, 0],
            K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
            OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"],
            blocks = [];
        (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(s) {
            return Object.prototype.toString.call(s) === "[object Array]"
        }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(s) {
            return typeof s == "object" && s.buffer && s.buffer.constructor === ArrayBuffer
        });
        var createOutputMethod = function(s, o) {
                return function(a) {
                    return new Sha256(o, !0).update(a)[s]()
                }
            },
            createMethod = function(s) {
                var o = createOutputMethod("hex", s);
                NODE_JS && (o = nodeWrap(o, s)), o.create = function() {
                    return new Sha256(s)
                }, o.update = function(j) {
                    return o.create().update(j)
                };
                for (var a = 0; a < OUTPUT_TYPES.length; ++a) {
                    var $ = OUTPUT_TYPES[a];
                    o[$] = createOutputMethod($, s)
                }
                return o
            },
            nodeWrap = function(method, is224) {
                var crypto = eval("require('crypto')"),
                    Buffer = eval("require('buffer').Buffer"),
                    algorithm = is224 ? "sha224" : "sha256",
                    nodeMethod = function(s) {
                        if (typeof s == "string") return crypto.createHash(algorithm).update(s, "utf8").digest("hex");
                        if (s == null) throw new Error(ERROR);
                        return s.constructor === ArrayBuffer && (s = new Uint8Array(s)), Array.isArray(s) || ArrayBuffer.isView(s) || s.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(s)).digest("hex") : method(s)
                    };
                return nodeMethod
            },
            createHmacOutputMethod = function(s, o) {
                return function(a, $) {
                    return new HmacSha256(a, o, !0).update($)[s]()
                }
            },
            createHmacMethod = function(s) {
                var o = createHmacOutputMethod("hex", s);
                o.create = function(j) {
                    return new HmacSha256(j, s)
                }, o.update = function(j, _e) {
                    return o.create(j).update(_e)
                };
                for (var a = 0; a < OUTPUT_TYPES.length; ++a) {
                    var $ = OUTPUT_TYPES[a];
                    o[$] = createHmacOutputMethod($, s)
                }
                return o
            };

        function Sha256(s, o) {
            o ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], s ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = s
        }
        Sha256.prototype.update = function(s) {
            if (!this.finalized) {
                var o, a = typeof s;
                if (a !== "string") {
                    if (a === "object") {
                        if (s === null) throw new Error(ERROR);
                        if (ARRAY_BUFFER && s.constructor === ArrayBuffer) s = new Uint8Array(s);
                        else if (!Array.isArray(s) && (!ARRAY_BUFFER || !ArrayBuffer.isView(s))) throw new Error(ERROR)
                    } else throw new Error(ERROR);
                    o = !0
                }
                for (var $, j = 0, _e, et = s.length, tt = this.blocks; j < et;) {
                    if (this.hashed && (this.hashed = !1, tt[0] = this.block, tt[16] = tt[1] = tt[2] = tt[3] = tt[4] = tt[5] = tt[6] = tt[7] = tt[8] = tt[9] = tt[10] = tt[11] = tt[12] = tt[13] = tt[14] = tt[15] = 0), o)
                        for (_e = this.start; j < et && _e < 64; ++j) tt[_e >> 2] |= s[j] << SHIFT[_e++ & 3];
                    else
                        for (_e = this.start; j < et && _e < 64; ++j) $ = s.charCodeAt(j), $ < 128 ? tt[_e >> 2] |= $ << SHIFT[_e++ & 3] : $ < 2048 ? (tt[_e >> 2] |= (192 | $ >> 6) << SHIFT[_e++ & 3], tt[_e >> 2] |= (128 | $ & 63) << SHIFT[_e++ & 3]) : $ < 55296 || $ >= 57344 ? (tt[_e >> 2] |= (224 | $ >> 12) << SHIFT[_e++ & 3], tt[_e >> 2] |= (128 | $ >> 6 & 63) << SHIFT[_e++ & 3], tt[_e >> 2] |= (128 | $ & 63) << SHIFT[_e++ & 3]) : ($ = 65536 + (($ & 1023) << 10 | s.charCodeAt(++j) & 1023), tt[_e >> 2] |= (240 | $ >> 18) << SHIFT[_e++ & 3], tt[_e >> 2] |= (128 | $ >> 12 & 63) << SHIFT[_e++ & 3], tt[_e >> 2] |= (128 | $ >> 6 & 63) << SHIFT[_e++ & 3], tt[_e >> 2] |= (128 | $ & 63) << SHIFT[_e++ & 3]);
                    this.lastByteIndex = _e, this.bytes += _e - this.start, _e >= 64 ? (this.block = tt[16], this.start = _e - 64, this.hash(), this.hashed = !0) : this.start = _e
                }
                return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
            }
        }, Sha256.prototype.finalize = function() {
            if (!this.finalized) {
                this.finalized = !0;
                var s = this.blocks,
                    o = this.lastByteIndex;
                s[16] = this.block, s[o >> 2] |= EXTRA[o & 3], this.block = s[16], o >= 56 && (this.hashed || this.hash(), s[0] = this.block, s[16] = s[1] = s[2] = s[3] = s[4] = s[5] = s[6] = s[7] = s[8] = s[9] = s[10] = s[11] = s[12] = s[13] = s[14] = s[15] = 0), s[14] = this.hBytes << 3 | this.bytes >>> 29, s[15] = this.bytes << 3, this.hash()
            }
        }, Sha256.prototype.hash = function() {
            var s = this.h0,
                o = this.h1,
                a = this.h2,
                $ = this.h3,
                j = this.h4,
                _e = this.h5,
                et = this.h6,
                tt = this.h7,
                nt = this.blocks,
                rt, ot, st, lt, ft, yt, bt, ht, vt, wt, gt;
            for (rt = 16; rt < 64; ++rt) ft = nt[rt - 15], ot = (ft >>> 7 | ft << 25) ^ (ft >>> 18 | ft << 14) ^ ft >>> 3, ft = nt[rt - 2], st = (ft >>> 17 | ft << 15) ^ (ft >>> 19 | ft << 13) ^ ft >>> 10, nt[rt] = nt[rt - 16] + ot + nt[rt - 7] + st << 0;
            for (gt = o & a, rt = 0; rt < 64; rt += 4) this.first ? (this.is224 ? (ht = 300032, ft = nt[0] - 1413257819, tt = ft - 150054599 << 0, $ = ft + 24177077 << 0) : (ht = 704751109, ft = nt[0] - 210244248, tt = ft - 1521486534 << 0, $ = ft + 143694565 << 0), this.first = !1) : (ot = (s >>> 2 | s << 30) ^ (s >>> 13 | s << 19) ^ (s >>> 22 | s << 10), st = (j >>> 6 | j << 26) ^ (j >>> 11 | j << 21) ^ (j >>> 25 | j << 7), ht = s & o, lt = ht ^ s & a ^ gt, bt = j & _e ^ ~j & et, ft = tt + st + bt + K[rt] + nt[rt], yt = ot + lt, tt = $ + ft << 0, $ = ft + yt << 0), ot = ($ >>> 2 | $ << 30) ^ ($ >>> 13 | $ << 19) ^ ($ >>> 22 | $ << 10), st = (tt >>> 6 | tt << 26) ^ (tt >>> 11 | tt << 21) ^ (tt >>> 25 | tt << 7), vt = $ & s, lt = vt ^ $ & o ^ ht, bt = tt & j ^ ~tt & _e, ft = et + st + bt + K[rt + 1] + nt[rt + 1], yt = ot + lt, et = a + ft << 0, a = ft + yt << 0, ot = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10), st = (et >>> 6 | et << 26) ^ (et >>> 11 | et << 21) ^ (et >>> 25 | et << 7), wt = a & $, lt = wt ^ a & s ^ vt, bt = et & tt ^ ~et & j, ft = _e + st + bt + K[rt + 2] + nt[rt + 2], yt = ot + lt, _e = o + ft << 0, o = ft + yt << 0, ot = (o >>> 2 | o << 30) ^ (o >>> 13 | o << 19) ^ (o >>> 22 | o << 10), st = (_e >>> 6 | _e << 26) ^ (_e >>> 11 | _e << 21) ^ (_e >>> 25 | _e << 7), gt = o & a, lt = gt ^ o & $ ^ wt, bt = _e & et ^ ~_e & tt, ft = j + st + bt + K[rt + 3] + nt[rt + 3], yt = ot + lt, j = s + ft << 0, s = ft + yt << 0;
            this.h0 = this.h0 + s << 0, this.h1 = this.h1 + o << 0, this.h2 = this.h2 + a << 0, this.h3 = this.h3 + $ << 0, this.h4 = this.h4 + j << 0, this.h5 = this.h5 + _e << 0, this.h6 = this.h6 + et << 0, this.h7 = this.h7 + tt << 0
        }, Sha256.prototype.hex = function() {
            this.finalize();
            var s = this.h0,
                o = this.h1,
                a = this.h2,
                $ = this.h3,
                j = this.h4,
                _e = this.h5,
                et = this.h6,
                tt = this.h7,
                nt = HEX_CHARS[s >> 28 & 15] + HEX_CHARS[s >> 24 & 15] + HEX_CHARS[s >> 20 & 15] + HEX_CHARS[s >> 16 & 15] + HEX_CHARS[s >> 12 & 15] + HEX_CHARS[s >> 8 & 15] + HEX_CHARS[s >> 4 & 15] + HEX_CHARS[s & 15] + HEX_CHARS[o >> 28 & 15] + HEX_CHARS[o >> 24 & 15] + HEX_CHARS[o >> 20 & 15] + HEX_CHARS[o >> 16 & 15] + HEX_CHARS[o >> 12 & 15] + HEX_CHARS[o >> 8 & 15] + HEX_CHARS[o >> 4 & 15] + HEX_CHARS[o & 15] + HEX_CHARS[a >> 28 & 15] + HEX_CHARS[a >> 24 & 15] + HEX_CHARS[a >> 20 & 15] + HEX_CHARS[a >> 16 & 15] + HEX_CHARS[a >> 12 & 15] + HEX_CHARS[a >> 8 & 15] + HEX_CHARS[a >> 4 & 15] + HEX_CHARS[a & 15] + HEX_CHARS[$ >> 28 & 15] + HEX_CHARS[$ >> 24 & 15] + HEX_CHARS[$ >> 20 & 15] + HEX_CHARS[$ >> 16 & 15] + HEX_CHARS[$ >> 12 & 15] + HEX_CHARS[$ >> 8 & 15] + HEX_CHARS[$ >> 4 & 15] + HEX_CHARS[$ & 15] + HEX_CHARS[j >> 28 & 15] + HEX_CHARS[j >> 24 & 15] + HEX_CHARS[j >> 20 & 15] + HEX_CHARS[j >> 16 & 15] + HEX_CHARS[j >> 12 & 15] + HEX_CHARS[j >> 8 & 15] + HEX_CHARS[j >> 4 & 15] + HEX_CHARS[j & 15] + HEX_CHARS[_e >> 28 & 15] + HEX_CHARS[_e >> 24 & 15] + HEX_CHARS[_e >> 20 & 15] + HEX_CHARS[_e >> 16 & 15] + HEX_CHARS[_e >> 12 & 15] + HEX_CHARS[_e >> 8 & 15] + HEX_CHARS[_e >> 4 & 15] + HEX_CHARS[_e & 15] + HEX_CHARS[et >> 28 & 15] + HEX_CHARS[et >> 24 & 15] + HEX_CHARS[et >> 20 & 15] + HEX_CHARS[et >> 16 & 15] + HEX_CHARS[et >> 12 & 15] + HEX_CHARS[et >> 8 & 15] + HEX_CHARS[et >> 4 & 15] + HEX_CHARS[et & 15];
            return this.is224 || (nt += HEX_CHARS[tt >> 28 & 15] + HEX_CHARS[tt >> 24 & 15] + HEX_CHARS[tt >> 20 & 15] + HEX_CHARS[tt >> 16 & 15] + HEX_CHARS[tt >> 12 & 15] + HEX_CHARS[tt >> 8 & 15] + HEX_CHARS[tt >> 4 & 15] + HEX_CHARS[tt & 15]), nt
        }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
            this.finalize();
            var s = this.h0,
                o = this.h1,
                a = this.h2,
                $ = this.h3,
                j = this.h4,
                _e = this.h5,
                et = this.h6,
                tt = this.h7,
                nt = [s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255, o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, o & 255, a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255, $ >> 24 & 255, $ >> 16 & 255, $ >> 8 & 255, $ & 255, j >> 24 & 255, j >> 16 & 255, j >> 8 & 255, j & 255, _e >> 24 & 255, _e >> 16 & 255, _e >> 8 & 255, _e & 255, et >> 24 & 255, et >> 16 & 255, et >> 8 & 255, et & 255];
            return this.is224 || nt.push(tt >> 24 & 255, tt >> 16 & 255, tt >> 8 & 255, tt & 255), nt
        }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
            this.finalize();
            var s = new ArrayBuffer(this.is224 ? 28 : 32),
                o = new DataView(s);
            return o.setUint32(0, this.h0), o.setUint32(4, this.h1), o.setUint32(8, this.h2), o.setUint32(12, this.h3), o.setUint32(16, this.h4), o.setUint32(20, this.h5), o.setUint32(24, this.h6), this.is224 || o.setUint32(28, this.h7), s
        };

        function HmacSha256(s, o, a) {
            var $, j = typeof s;
            if (j === "string") {
                var _e = [],
                    et = s.length,
                    tt = 0,
                    nt;
                for ($ = 0; $ < et; ++$) nt = s.charCodeAt($), nt < 128 ? _e[tt++] = nt : nt < 2048 ? (_e[tt++] = 192 | nt >> 6, _e[tt++] = 128 | nt & 63) : nt < 55296 || nt >= 57344 ? (_e[tt++] = 224 | nt >> 12, _e[tt++] = 128 | nt >> 6 & 63, _e[tt++] = 128 | nt & 63) : (nt = 65536 + ((nt & 1023) << 10 | s.charCodeAt(++$) & 1023), _e[tt++] = 240 | nt >> 18, _e[tt++] = 128 | nt >> 12 & 63, _e[tt++] = 128 | nt >> 6 & 63, _e[tt++] = 128 | nt & 63);
                s = _e
            } else if (j === "object") {
                if (s === null) throw new Error(ERROR);
                if (ARRAY_BUFFER && s.constructor === ArrayBuffer) s = new Uint8Array(s);
                else if (!Array.isArray(s) && (!ARRAY_BUFFER || !ArrayBuffer.isView(s))) throw new Error(ERROR)
            } else throw new Error(ERROR);
            s.length > 64 && (s = new Sha256(o, !0).update(s).array());
            var rt = [],
                ot = [];
            for ($ = 0; $ < 64; ++$) {
                var st = s[$] || 0;
                rt[$] = 92 ^ st, ot[$] = 54 ^ st
            }
            Sha256.call(this, o, a), this.update(ot), this.oKeyPad = rt, this.inner = !0, this.sharedMemory = a
        }
        HmacSha256.prototype = new Sha256, HmacSha256.prototype.finalize = function() {
            if (Sha256.prototype.finalize.call(this), this.inner) {
                this.inner = !1;
                var s = this.array();
                Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(s), Sha256.prototype.finalize.call(this)
            }
        };
        var exports = createMethod();
        exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224)
    })()
})(sha256$1);
var sha256Exports = sha256$1.exports,
    dist = {},
    Layout$3 = {};
let Layout$2 = class {
    constructor(o, a) {
        if (!Number.isInteger(o)) throw new TypeError("span must be an integer");
        this.span = o, this.property = a
    }
    makeDestinationObject() {
        return {}
    }
    decode(o, a) {
        throw new Error("Layout is abstract")
    }
    encode(o, a, $) {
        throw new Error("Layout is abstract")
    }
    getSpan(o, a) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(o) {
        const a = Object.create(this.constructor.prototype);
        return Object.assign(a, this), a.property = o, a
    }
    fromArray(o) {}
};
Layout$3.Layout = Layout$2;

function nameWithProperty$1(s, o) {
    return o.property ? s + "[" + o.property + "]" : s
}
Layout$3.nameWithProperty = nameWithProperty$1;

function bindConstructorLayout(s, o) {
    if (typeof s != "function") throw new TypeError("Class must be constructor");
    if (s.hasOwnProperty("layout_")) throw new Error("Class is already bound to a layout");
    if (!(o && o instanceof Layout$2)) throw new TypeError("layout must be a Layout");
    if (o.hasOwnProperty("boundConstructor_")) throw new Error("layout is already bound to a constructor");
    s.layout_ = o, o.boundConstructor_ = s, o.makeDestinationObject = () => new s, Object.defineProperty(s.prototype, "encode", {
        value: function(a, $) {
            return o.encode(this, a, $)
        },
        writable: !0
    }), Object.defineProperty(s, "decode", {
        value: function(a, $) {
            return o.decode(a, $)
        },
        writable: !0
    })
}
Layout$3.bindConstructorLayout = bindConstructorLayout;
let ExternalLayout$1 = class extends Layout$2 {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
};
class GreedyCount extends ExternalLayout$1 {
    constructor(o, a) {
        if (o === void 0 && (o = 1), !Number.isInteger(o) || 0 >= o) throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, a), this.elementSpan = o
    }
    isCount() {
        return !0
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = o.length - a;
        return Math.floor($ / this.elementSpan)
    }
    encode(o, a, $) {
        return 0
    }
}
let OffsetLayout$1 = class extends ExternalLayout$1 {
        constructor(o, a, $) {
            if (!(o instanceof Layout$2)) throw new TypeError("layout must be a Layout");
            if (a === void 0) a = 0;
            else if (!Number.isInteger(a)) throw new TypeError("offset must be integer or undefined");
            super(o.span, $ || o.property), this.layout = o, this.offset = a
        }
        isCount() {
            return this.layout instanceof UInt$1 || this.layout instanceof UIntBE$1
        }
        decode(o, a) {
            return a === void 0 && (a = 0), this.layout.decode(o, a + this.offset)
        }
        encode(o, a, $) {
            return $ === void 0 && ($ = 0), this.layout.encode(o, a, $ + this.offset)
        }
    },
    UInt$1 = class extends Layout$2 {
        constructor(o, a) {
            if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
        }
        decode(o, a) {
            return a === void 0 && (a = 0), o.readUIntLE(a, this.span)
        }
        encode(o, a, $) {
            return $ === void 0 && ($ = 0), a.writeUIntLE(o, $, this.span), this.span
        }
    },
    UIntBE$1 = class extends Layout$2 {
        constructor(o, a) {
            if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
        }
        decode(o, a) {
            return a === void 0 && (a = 0), o.readUIntBE(a, this.span)
        }
        encode(o, a, $) {
            return $ === void 0 && ($ = 0), a.writeUIntBE(o, $, this.span), this.span
        }
    };
class Int extends Layout$2 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readIntLE(a, this.span)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeIntLE(o, $, this.span), this.span
    }
}
class IntBE extends Layout$2 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readIntBE(a, this.span)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeIntBE(o, $, this.span), this.span
    }
}
const V2E32$1 = Math.pow(2, 32);

function divmodInt64$1(s) {
    const o = Math.floor(s / V2E32$1),
        a = s - o * V2E32$1;
    return {
        hi32: o,
        lo32: a
    }
}

function roundedInt64$1(s, o) {
    return s * V2E32$1 + o
}
let NearUInt64$1 = class extends Layout$2 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = o.readUInt32LE(a),
            j = o.readUInt32LE(a + 4);
        return roundedInt64$1(j, $)
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = divmodInt64$1(o);
        return a.writeUInt32LE(j.lo32, $), a.writeUInt32LE(j.hi32, $ + 4), 8
    }
};
class NearUInt64BE extends Layout$2 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = o.readUInt32BE(a),
            j = o.readUInt32BE(a + 4);
        return roundedInt64$1($, j)
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = divmodInt64$1(o);
        return a.writeUInt32BE(j.hi32, $), a.writeUInt32BE(j.lo32, $ + 4), 8
    }
}
let NearInt64$1 = class extends Layout$2 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = o.readUInt32LE(a),
            j = o.readInt32LE(a + 4);
        return roundedInt64$1(j, $)
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = divmodInt64$1(o);
        return a.writeUInt32LE(j.lo32, $), a.writeInt32LE(j.hi32, $ + 4), 8
    }
};
class NearInt64BE extends Layout$2 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = o.readInt32BE(a),
            j = o.readUInt32BE(a + 4);
        return roundedInt64$1($, j)
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = divmodInt64$1(o);
        return a.writeInt32BE(j.hi32, $), a.writeUInt32BE(j.lo32, $ + 4), 8
    }
}
class Float extends Layout$2 {
    constructor(o) {
        super(4, o)
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readFloatLE(a)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeFloatLE(o, $), 4
    }
}
class FloatBE extends Layout$2 {
    constructor(o) {
        super(4, o)
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readFloatBE(a)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeFloatBE(o, $), 4
    }
}
class Double extends Layout$2 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readDoubleLE(a)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeDoubleLE(o, $), 8
    }
}
class DoubleBE extends Layout$2 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readDoubleBE(a)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeDoubleBE(o, $), 8
    }
}
class Sequence extends Layout$2 {
    constructor(o, a, $) {
        if (!(o instanceof Layout$2)) throw new TypeError("elementLayout must be a Layout");
        if (!(a instanceof ExternalLayout$1 && a.isCount() || Number.isInteger(a) && 0 <= a)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let j = -1;
        !(a instanceof ExternalLayout$1) && 0 < o.span && (j = a * o.span), super(j, $), this.elementLayout = o, this.count = a
    }
    getSpan(o, a) {
        if (0 <= this.span) return this.span;
        a === void 0 && (a = 0);
        let $ = 0,
            j = this.count;
        if (j instanceof ExternalLayout$1 && (j = j.decode(o, a)), 0 < this.elementLayout.span) $ = j * this.elementLayout.span;
        else {
            let _e = 0;
            for (; _e < j;) $ += this.elementLayout.getSpan(o, a + $), ++_e
        }
        return $
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = [];
        let j = 0,
            _e = this.count;
        for (_e instanceof ExternalLayout$1 && (_e = _e.decode(o, a)); j < _e;) $.push(this.elementLayout.decode(o, a)), a += this.elementLayout.getSpan(o, a), j += 1;
        return $
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = this.elementLayout,
            _e = o.reduce((et, tt) => et + j.encode(tt, a, $ + et), 0);
        return this.count instanceof ExternalLayout$1 && this.count.encode(o.length, a, $), _e
    }
}
let Structure$1 = class extends Layout$2 {
        constructor(o, a, $) {
            if (!(Array.isArray(o) && o.reduce((_e, et) => _e && et instanceof Layout$2, !0))) throw new TypeError("fields must be array of Layout instances");
            typeof a == "boolean" && $ === void 0 && ($ = a, a = void 0);
            for (const _e of o)
                if (0 > _e.span && _e.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
            let j = -1;
            try {
                j = o.reduce((_e, et) => _e + et.getSpan(), 0)
            } catch {}
            super(j, a), this.fields = o, this.decodePrefixes = !!$
        }
        getSpan(o, a) {
            if (0 <= this.span) return this.span;
            a === void 0 && (a = 0);
            let $ = 0;
            try {
                $ = this.fields.reduce((j, _e) => {
                    const et = _e.getSpan(o, a);
                    return a += et, j + et
                }, 0)
            } catch {
                throw new RangeError("indeterminate span")
            }
            return $
        }
        decode(o, a) {
            a === void 0 && (a = 0);
            const $ = this.makeDestinationObject();
            for (const j of this.fields)
                if (j.property !== void 0 && ($[j.property] = j.decode(o, a)), a += j.getSpan(o, a), this.decodePrefixes && o.length === a) break;
            return $
        }
        encode(o, a, $) {
            $ === void 0 && ($ = 0);
            const j = $;
            let _e = 0,
                et = 0;
            for (const tt of this.fields) {
                let nt = tt.span;
                if (et = 0 < nt ? nt : 0, tt.property !== void 0) {
                    const rt = o[tt.property];
                    rt !== void 0 && (et = tt.encode(rt, a, $), 0 > nt && (nt = tt.getSpan(a, $)))
                }
                _e = $, $ += nt
            }
            return _e + et - j
        }
        fromArray(o) {
            const a = this.makeDestinationObject();
            for (const $ of this.fields) $.property !== void 0 && 0 < o.length && (a[$.property] = o.shift());
            return a
        }
        layoutFor(o) {
            if (typeof o != "string") throw new TypeError("property must be string");
            for (const a of this.fields)
                if (a.property === o) return a
        }
        offsetOf(o) {
            if (typeof o != "string") throw new TypeError("property must be string");
            let a = 0;
            for (const $ of this.fields) {
                if ($.property === o) return a;
                0 > $.span ? a = -1 : 0 <= a && (a += $.span)
            }
        }
    },
    UnionDiscriminator$1 = class {
        constructor(o) {
            this.property = o
        }
        decode() {
            throw new Error("UnionDiscriminator is abstract")
        }
        encode() {
            throw new Error("UnionDiscriminator is abstract")
        }
    },
    UnionLayoutDiscriminator$1 = class extends UnionDiscriminator$1 {
        constructor(o, a) {
            if (!(o instanceof ExternalLayout$1 && o.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(a || o.property || "variant"), this.layout = o
        }
        decode(o, a) {
            return this.layout.decode(o, a)
        }
        encode(o, a, $) {
            return this.layout.encode(o, a, $)
        }
    },
    Union$1 = class extends Layout$2 {
        constructor(o, a, $) {
            const j = o instanceof UInt$1 || o instanceof UIntBE$1;
            if (j) o = new UnionLayoutDiscriminator$1(new OffsetLayout$1(o));
            else if (o instanceof ExternalLayout$1 && o.isCount()) o = new UnionLayoutDiscriminator$1(o);
            else if (!(o instanceof UnionDiscriminator$1)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
            if (a === void 0 && (a = null), !(a === null || a instanceof Layout$2)) throw new TypeError("defaultLayout must be null or a Layout");
            if (a !== null) {
                if (0 > a.span) throw new Error("defaultLayout must have constant span");
                a.property === void 0 && (a = a.replicate("content"))
            }
            let _e = -1;
            a && (_e = a.span, 0 <= _e && j && (_e += o.layout.span)), super(_e, $), this.discriminator = o, this.usesPrefixDiscriminator = j, this.defaultLayout = a, this.registry = {};
            let et = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(tt) {
                return et(tt)
            }, this.configGetSourceVariant = function(tt) {
                et = tt.bind(this)
            }
        }
        getSpan(o, a) {
            if (0 <= this.span) return this.span;
            a === void 0 && (a = 0);
            const $ = this.getVariant(o, a);
            if (!$) throw new Error("unable to determine span for unrecognized variant");
            return $.getSpan(o, a)
        }
        defaultGetSourceVariant(o) {
            if (o.hasOwnProperty(this.discriminator.property)) {
                if (this.defaultLayout && o.hasOwnProperty(this.defaultLayout.property)) return;
                const a = this.registry[o[this.discriminator.property]];
                if (a && (!a.layout || o.hasOwnProperty(a.property))) return a
            } else
                for (const a in this.registry) {
                    const $ = this.registry[a];
                    if (o.hasOwnProperty($.property)) return $
                }
            throw new Error("unable to infer src variant")
        }
        decode(o, a) {
            a === void 0 && (a = 0);
            let $;
            const j = this.discriminator,
                _e = j.decode(o, a);
            let et = this.registry[_e];
            if (et === void 0) {
                let tt = 0;
                et = this.defaultLayout, this.usesPrefixDiscriminator && (tt = j.layout.span), $ = this.makeDestinationObject(), $[j.property] = _e, $[et.property] = this.defaultLayout.decode(o, a + tt)
            } else $ = et.decode(o, a);
            return $
        }
        encode(o, a, $) {
            $ === void 0 && ($ = 0);
            const j = this.getSourceVariant(o);
            if (j === void 0) {
                const _e = this.discriminator,
                    et = this.defaultLayout;
                let tt = 0;
                return this.usesPrefixDiscriminator && (tt = _e.layout.span), _e.encode(o[_e.property], a, $), tt + et.encode(o[et.property], a, $ + tt)
            }
            return j.encode(o, a, $)
        }
        addVariant(o, a, $) {
            const j = new VariantLayout$1(this, o, a, $);
            return this.registry[o] = j, j
        }
        getVariant(o, a) {
            let $ = o;
            return Buffer.isBuffer(o) && (a === void 0 && (a = 0), $ = this.discriminator.decode(o, a)), this.registry[$]
        }
    },
    VariantLayout$1 = class extends Layout$2 {
        constructor(o, a, $, j) {
            if (!(o instanceof Union$1)) throw new TypeError("union must be a Union");
            if (!Number.isInteger(a) || 0 > a) throw new TypeError("variant must be a (non-negative) integer");
            if (typeof $ == "string" && j === void 0 && (j = $, $ = null), $) {
                if (!($ instanceof Layout$2)) throw new TypeError("layout must be a Layout");
                if (o.defaultLayout !== null && 0 <= $.span && $.span > o.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                if (typeof j != "string") throw new TypeError("variant must have a String property")
            }
            let _e = o.span;
            0 > o.span && (_e = $ ? $.span : 0, 0 <= _e && o.usesPrefixDiscriminator && (_e += o.discriminator.layout.span)), super(_e, j), this.union = o, this.variant = a, this.layout = $ || null
        }
        getSpan(o, a) {
            if (0 <= this.span) return this.span;
            a === void 0 && (a = 0);
            let $ = 0;
            return this.union.usesPrefixDiscriminator && ($ = this.union.discriminator.layout.span), $ + this.layout.getSpan(o, a + $)
        }
        decode(o, a) {
            const $ = this.makeDestinationObject();
            if (a === void 0 && (a = 0), this !== this.union.getVariant(o, a)) throw new Error("variant mismatch");
            let j = 0;
            return this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout ? $[this.property] = this.layout.decode(o, a + j) : this.property ? $[this.property] = !0 : this.union.usesPrefixDiscriminator && ($[this.union.discriminator.property] = this.variant), $
        }
        encode(o, a, $) {
            $ === void 0 && ($ = 0);
            let j = 0;
            if (this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout && !o.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, a, $);
            let _e = j;
            if (this.layout && (this.layout.encode(o[this.property], a, $ + j), _e += this.layout.getSpan(a, $ + j), 0 <= this.union.span && _e > this.union.span)) throw new Error("encoded variant overruns containing union");
            return _e
        }
        fromArray(o) {
            if (this.layout) return this.layout.fromArray(o)
        }
    };

function fixBitwiseResult(s) {
    return 0 > s && (s += 4294967296), s
}
class BitStructure extends Layout$2 {
    constructor(o, a, $) {
        if (!(o instanceof UInt$1 || o instanceof UIntBE$1)) throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof a == "string" && $ === void 0 && ($ = a, a = void 0), 4 < o.span) throw new RangeError("word cannot exceed 32 bits");
        super(o.span, $), this.word = o, this.msb = !!a, this.fields = [];
        let j = 0;
        this._packedSetValue = function(_e) {
            return j = fixBitwiseResult(_e), this
        }, this._packedGetValue = function() {
            return j
        }
    }
    decode(o, a) {
        const $ = this.makeDestinationObject();
        a === void 0 && (a = 0);
        const j = this.word.decode(o, a);
        this._packedSetValue(j);
        for (const _e of this.fields) _e.property !== void 0 && ($[_e.property] = _e.decode(j));
        return $
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = this.word.decode(a, $);
        this._packedSetValue(j);
        for (const _e of this.fields)
            if (_e.property !== void 0) {
                const et = o[_e.property];
                et !== void 0 && _e.encode(et)
            }
        return this.word.encode(this._packedGetValue(), a, $)
    }
    addField(o, a) {
        const $ = new BitField(this, o, a);
        return this.fields.push($), $
    }
    addBoolean(o) {
        const a = new Boolean$1(this, o);
        return this.fields.push(a), a
    }
    fieldFor(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        for (const a of this.fields)
            if (a.property === o) return a
    }
}
class BitField {
    constructor(o, a, $) {
        if (!(o instanceof BitStructure)) throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(a) || 0 >= a) throw new TypeError("bits must be positive integer");
        const j = 8 * o.span,
            _e = o.fields.reduce((et, tt) => et + tt.bits, 0);
        if (a + _e > j) throw new Error("bits too long for span remainder (" + (j - _e) + " of " + j + " remain)");
        this.container = o, this.bits = a, this.valueMask = (1 << a) - 1, a === 32 && (this.valueMask = 4294967295), this.start = _e, this.container.msb && (this.start = j - _e - a), this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = $
    }
    decode() {
        const o = this.container._packedGetValue();
        return fixBitwiseResult(o & this.wordMask) >>> this.start
    }
    encode(o) {
        if (!Number.isInteger(o) || o !== fixBitwiseResult(o & this.valueMask)) throw new TypeError(nameWithProperty$1("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const a = this.container._packedGetValue(),
            $ = fixBitwiseResult(o << this.start);
        this.container._packedSetValue(fixBitwiseResult(a & ~this.wordMask) | $)
    }
}
let Boolean$1 = class extends BitField {
        constructor(o, a) {
            super(o, 1, a)
        }
        decode(o, a) {
            return !!BitField.prototype.decode.call(this, o, a)
        }
        encode(o) {
            return typeof o == "boolean" && (o = +o), BitField.prototype.encode.call(this, o)
        }
    },
    Blob$2 = class extends Layout$2 {
        constructor(o, a) {
            if (!(o instanceof ExternalLayout$1 && o.isCount() || Number.isInteger(o) && 0 <= o)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let $ = -1;
            o instanceof ExternalLayout$1 || ($ = o), super($, a), this.length = o
        }
        getSpan(o, a) {
            let $ = this.span;
            return 0 > $ && ($ = this.length.decode(o, a)), $
        }
        decode(o, a) {
            a === void 0 && (a = 0);
            let $ = this.span;
            return 0 > $ && ($ = this.length.decode(o, a)), o.slice(a, a + $)
        }
        encode(o, a, $) {
            let j = this.length;
            if (this.length instanceof ExternalLayout$1 && (j = o.length), !(Buffer.isBuffer(o) && j === o.length)) throw new TypeError(nameWithProperty$1("Blob.encode", this) + " requires (length " + j + ") Buffer as src");
            if ($ + j > a.length) throw new RangeError("encoding overruns Buffer");
            return a.write(o.toString("hex"), $, j, "hex"), this.length instanceof ExternalLayout$1 && this.length.encode(j, a, $), j
        }
    };
class CString extends Layout$2 {
    constructor(o) {
        super(-1, o)
    }
    getSpan(o, a) {
        if (!Buffer.isBuffer(o)) throw new TypeError("b must be a Buffer");
        a === void 0 && (a = 0);
        let $ = a;
        for (; $ < o.length && o[$] !== 0;) $ += 1;
        return 1 + $ - a
    }
    decode(o, a, $) {
        a === void 0 && (a = 0);
        let j = this.getSpan(o, a);
        return o.slice(a, a + j - 1).toString("utf-8")
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0), typeof o != "string" && (o = o.toString());
        const j = new Buffer(o, "utf8"),
            _e = j.length;
        if ($ + _e > a.length) throw new RangeError("encoding overruns Buffer");
        return j.copy(a, $), a[$ + _e] = 0, _e + 1
    }
}
class UTF8 extends Layout$2 {
    constructor(o, a) {
        if (typeof o == "string" && a === void 0 && (a = o, o = void 0), o === void 0) o = -1;
        else if (!Number.isInteger(o)) throw new TypeError("maxSpan must be an integer");
        super(-1, a), this.maxSpan = o
    }
    getSpan(o, a) {
        if (!Buffer.isBuffer(o)) throw new TypeError("b must be a Buffer");
        return a === void 0 && (a = 0), o.length - a
    }
    decode(o, a, $) {
        a === void 0 && (a = 0);
        let j = this.getSpan(o, a);
        if (0 <= this.maxSpan && this.maxSpan < j) throw new RangeError("text length exceeds maxSpan");
        return o.slice(a, a + j).toString("utf-8")
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0), typeof o != "string" && (o = o.toString());
        const j = new Buffer(o, "utf8"),
            _e = j.length;
        if (0 <= this.maxSpan && this.maxSpan < _e) throw new RangeError("text length exceeds maxSpan");
        if ($ + _e > a.length) throw new RangeError("encoding overruns Buffer");
        return j.copy(a, $), _e
    }
}
class Constant extends Layout$2 {
    constructor(o, a) {
        super(0, a), this.value = o
    }
    decode(o, a, $) {
        return this.value
    }
    encode(o, a, $) {
        return 0
    }
}
Layout$3.ExternalLayout = ExternalLayout$1;
Layout$3.GreedyCount = GreedyCount;
Layout$3.OffsetLayout = OffsetLayout$1;
Layout$3.UInt = UInt$1;
Layout$3.UIntBE = UIntBE$1;
Layout$3.Int = Int;
Layout$3.IntBE = IntBE;
Layout$3.Float = Float;
Layout$3.FloatBE = FloatBE;
Layout$3.Double = Double;
Layout$3.DoubleBE = DoubleBE;
Layout$3.Sequence = Sequence;
Layout$3.Structure = Structure$1;
Layout$3.UnionDiscriminator = UnionDiscriminator$1;
Layout$3.UnionLayoutDiscriminator = UnionLayoutDiscriminator$1;
Layout$3.Union = Union$1;
Layout$3.VariantLayout = VariantLayout$1;
Layout$3.BitStructure = BitStructure;
Layout$3.BitField = BitField;
Layout$3.Boolean = Boolean$1;
Layout$3.Blob = Blob$2;
Layout$3.CString = CString;
Layout$3.UTF8 = UTF8;
Layout$3.Constant = Constant;
Layout$3.greedy = (s, o) => new GreedyCount(s, o);
Layout$3.offset = (s, o, a) => new OffsetLayout$1(s, o, a);
Layout$3.u8 = s => new UInt$1(1, s);
Layout$3.u16 = s => new UInt$1(2, s);
Layout$3.u24 = s => new UInt$1(3, s);
Layout$3.u32 = s => new UInt$1(4, s);
Layout$3.u40 = s => new UInt$1(5, s);
Layout$3.u48 = s => new UInt$1(6, s);
Layout$3.nu64 = s => new NearUInt64$1(s);
Layout$3.u16be = s => new UIntBE$1(2, s);
Layout$3.u24be = s => new UIntBE$1(3, s);
Layout$3.u32be = s => new UIntBE$1(4, s);
Layout$3.u40be = s => new UIntBE$1(5, s);
Layout$3.u48be = s => new UIntBE$1(6, s);
Layout$3.nu64be = s => new NearUInt64BE(s);
Layout$3.s8 = s => new Int(1, s);
Layout$3.s16 = s => new Int(2, s);
Layout$3.s24 = s => new Int(3, s);
Layout$3.s32 = s => new Int(4, s);
Layout$3.s40 = s => new Int(5, s);
Layout$3.s48 = s => new Int(6, s);
Layout$3.ns64 = s => new NearInt64$1(s);
Layout$3.s16be = s => new IntBE(2, s);
Layout$3.s24be = s => new IntBE(3, s);
Layout$3.s32be = s => new IntBE(4, s);
Layout$3.s40be = s => new IntBE(5, s);
Layout$3.s48be = s => new IntBE(6, s);
Layout$3.ns64be = s => new NearInt64BE(s);
Layout$3.f32 = s => new Float(s);
Layout$3.f32be = s => new FloatBE(s);
Layout$3.f64 = s => new Double(s);
Layout$3.f64be = s => new DoubleBE(s);
Layout$3.struct = (s, o, a) => new Structure$1(s, o, a);
Layout$3.bits = (s, o, a) => new BitStructure(s, o, a);
Layout$3.seq = (s, o, a) => new Sequence(s, o, a);
Layout$3.union = (s, o, a) => new Union$1(s, o, a);
Layout$3.unionLayoutDiscriminator = (s, o) => new UnionLayoutDiscriminator$1(s, o);
Layout$3.blob = (s, o) => new Blob$2(s, o);
Layout$3.cstr = s => new CString(s);
Layout$3.utf8 = (s, o) => new UTF8(s, o);
Layout$3.const = (s, o) => new Constant(s, o);
const require$$1 = getAugmentedNamespace(index_browser_esm);
(function(s) {
    var o = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Wt) {
        return Wt && Wt.__esModule ? Wt : {
            default: Wt
        }
    };
    Object.defineProperty(s, "__esModule", {
        value: !0
    }), s.map = s.array = s.rustEnum = s.str = s.vecU8 = s.tagged = s.vec = s.bool = s.option = s.publicKey = s.i256 = s.u256 = s.i128 = s.u128 = s.i64 = s.u64 = s.struct = s.f64 = s.f32 = s.i32 = s.u32 = s.i16 = s.u16 = s.i8 = s.u8 = void 0;
    const a = Layout$3,
        $ = require$$1,
        j = o(bnExports);
    var _e = Layout$3;
    Object.defineProperty(s, "u8", {
        enumerable: !0,
        get: function() {
            return _e.u8
        }
    }), Object.defineProperty(s, "i8", {
        enumerable: !0,
        get: function() {
            return _e.s8
        }
    }), Object.defineProperty(s, "u16", {
        enumerable: !0,
        get: function() {
            return _e.u16
        }
    }), Object.defineProperty(s, "i16", {
        enumerable: !0,
        get: function() {
            return _e.s16
        }
    }), Object.defineProperty(s, "u32", {
        enumerable: !0,
        get: function() {
            return _e.u32
        }
    }), Object.defineProperty(s, "i32", {
        enumerable: !0,
        get: function() {
            return _e.s32
        }
    }), Object.defineProperty(s, "f32", {
        enumerable: !0,
        get: function() {
            return _e.f32
        }
    }), Object.defineProperty(s, "f64", {
        enumerable: !0,
        get: function() {
            return _e.f64
        }
    }), Object.defineProperty(s, "struct", {
        enumerable: !0,
        get: function() {
            return _e.struct
        }
    });
    class et extends a.Layout {
        constructor(Ct, it, at) {
            super(Ct, at), this.blob = (0, a.blob)(Ct), this.signed = it
        }
        decode(Ct, it = 0) {
            const at = new j.default(this.blob.decode(Ct, it), 10, "le");
            return this.signed ? at.fromTwos(this.span * 8).clone() : at
        }
        encode(Ct, it, at = 0) {
            return this.signed && (Ct = Ct.toTwos(this.span * 8)), this.blob.encode(Ct.toArrayLike(Buffer, "le", this.span), it, at)
        }
    }

    function tt(Wt) {
        return new et(8, !1, Wt)
    }
    s.u64 = tt;

    function nt(Wt) {
        return new et(8, !0, Wt)
    }
    s.i64 = nt;

    function rt(Wt) {
        return new et(16, !1, Wt)
    }
    s.u128 = rt;

    function ot(Wt) {
        return new et(16, !0, Wt)
    }
    s.i128 = ot;

    function st(Wt) {
        return new et(32, !1, Wt)
    }
    s.u256 = st;

    function lt(Wt) {
        return new et(32, !0, Wt)
    }
    s.i256 = lt;
    class ft extends a.Layout {
        constructor(Ct, it, at, mt) {
            super(Ct.span, mt), this.layout = Ct, this.decoder = it, this.encoder = at
        }
        decode(Ct, it) {
            return this.decoder(this.layout.decode(Ct, it))
        }
        encode(Ct, it, at) {
            return this.layout.encode(this.encoder(Ct), it, at)
        }
        getSpan(Ct, it) {
            return this.layout.getSpan(Ct, it)
        }
    }

    function yt(Wt) {
        return new ft((0, a.blob)(32), Ct => new $.PublicKey(Ct), Ct => Ct.toBuffer(), Wt)
    }
    s.publicKey = yt;
    class bt extends a.Layout {
        constructor(Ct, it) {
            super(-1, it), this.layout = Ct, this.discriminator = (0, a.u8)()
        }
        encode(Ct, it, at = 0) {
            return Ct == null ? this.discriminator.encode(0, it, at) : (this.discriminator.encode(1, it, at), this.layout.encode(Ct, it, at + 1) + 1)
        }
        decode(Ct, it = 0) {
            const at = this.discriminator.decode(Ct, it);
            if (at === 0) return null;
            if (at === 1) return this.layout.decode(Ct, it + 1);
            throw new Error("Invalid option " + this.property)
        }
        getSpan(Ct, it = 0) {
            const at = this.discriminator.decode(Ct, it);
            if (at === 0) return 1;
            if (at === 1) return this.layout.getSpan(Ct, it + 1) + 1;
            throw new Error("Invalid option " + this.property)
        }
    }

    function ht(Wt, Ct) {
        return new bt(Wt, Ct)
    }
    s.option = ht;

    function vt(Wt) {
        return new ft((0, a.u8)(), wt, gt, Wt)
    }
    s.bool = vt;

    function wt(Wt) {
        if (Wt === 0) return !1;
        if (Wt === 1) return !0;
        throw new Error("Invalid bool: " + Wt)
    }

    function gt(Wt) {
        return Wt ? 1 : 0
    }

    function At(Wt, Ct) {
        const it = (0, a.u32)("length"),
            at = (0, a.struct)([it, (0, a.seq)(Wt, (0, a.offset)(it, -it.span), "values")]);
        return new ft(at, ({
            values: mt
        }) => mt, mt => ({
            values: mt
        }), Ct)
    }
    s.vec = At;

    function Pt(Wt, Ct, it) {
        const at = (0, a.struct)([tt("tag"), Ct.replicate("data")]);

        function mt({
            tag: xt,
            data: $t
        }) {
            if (!xt.eq(Wt)) throw new Error("Invalid tag, expected: " + Wt.toString("hex") + ", got: " + xt.toString("hex"));
            return $t
        }
        return new ft(at, mt, xt => ({
            tag: Wt,
            data: xt
        }), it)
    }
    s.tagged = Pt;

    function Bt(Wt) {
        const Ct = (0, a.u32)("length"),
            it = (0, a.struct)([Ct, (0, a.blob)((0, a.offset)(Ct, -Ct.span), "data")]);
        return new ft(it, ({
            data: at
        }) => at, at => ({
            data: at
        }), Wt)
    }
    s.vecU8 = Bt;

    function Lt(Wt) {
        return new ft(Bt(), Ct => Ct.toString("utf-8"), Ct => Buffer.from(Ct, "utf-8"), Wt)
    }
    s.str = Lt;

    function Nt(Wt, Ct, it) {
        const at = (0, a.union)(it ? ? (0, a.u8)(), Ct);
        return Wt.forEach((mt, xt) => at.addVariant(xt, mt, mt.property)), at
    }
    s.rustEnum = Nt;

    function Ut(Wt, Ct, it) {
        const at = (0, a.struct)([(0, a.seq)(Wt, Ct, "values")]);
        return new ft(at, ({
            values: mt
        }) => mt, mt => ({
            values: mt
        }), it)
    }
    s.array = Ut;
    class Vt extends a.Layout {
        constructor(Ct, it, at) {
            super(Ct.span + it.span, at), this.keyLayout = Ct, this.valueLayout = it
        }
        decode(Ct, it) {
            it = it || 0;
            const at = this.keyLayout.decode(Ct, it),
                mt = this.valueLayout.decode(Ct, it + this.keyLayout.getSpan(Ct, it));
            return [at, mt]
        }
        encode(Ct, it, at) {
            at = at || 0;
            const mt = this.keyLayout.encode(Ct[0], it, at),
                xt = this.valueLayout.encode(Ct[1], it, at + mt);
            return mt + xt
        }
        getSpan(Ct, it) {
            return this.keyLayout.getSpan(Ct, it) + this.valueLayout.getSpan(Ct, it)
        }
    }

    function Ft(Wt, Ct, it) {
        const at = (0, a.u32)("length"),
            mt = (0, a.struct)([at, (0, a.seq)(new Vt(Wt, Ct), (0, a.offset)(at, -at.span), "values")]);
        return new ft(mt, ({
            values: xt
        }) => new Map(xt), xt => ({
            values: Array.from(xt.entries())
        }), it)
    }
    s.map = Ft
})(dist); /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4,
    Z_BINARY = 0,
    Z_TEXT = 1,
    Z_UNKNOWN$1 = 2;

function zero$1(s) {
    let o = s.length;
    for (; --o >= 0;) s[o] = 0
}
const STORED_BLOCK = 0,
    STATIC_TREES = 1,
    DYN_TREES = 2,
    MIN_MATCH$1 = 3,
    MAX_MATCH$1 = 258,
    LENGTH_CODES$1 = 29,
    LITERALS$1 = 256,
    L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1,
    D_CODES$1 = 30,
    BL_CODES$1 = 19,
    HEAP_SIZE$1 = 2 * L_CODES$1 + 1,
    MAX_BITS$1 = 15,
    Buf_size = 16,
    MAX_BL_BITS = 7,
    END_BLOCK = 256,
    REP_3_6 = 16,
    REPZ_3_10 = 17,
    REPZ_11_138 = 18,
    extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
    extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
    extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
    bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    DIST_CODE_LEN = 512,
    static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);

function StaticTreeDesc(s, o, a, $, j) {
    this.static_tree = s, this.extra_bits = o, this.extra_base = a, this.elems = $, this.max_length = j, this.has_stree = s && s.length
}
let static_l_desc, static_d_desc, static_bl_desc;

function TreeDesc(s, o) {
    this.dyn_tree = s, this.max_code = 0, this.stat_desc = o
}
const d_code = s => s < 256 ? _dist_code[s] : _dist_code[256 + (s >>> 7)],
    put_short = (s, o) => {
        s.pending_buf[s.pending++] = o & 255, s.pending_buf[s.pending++] = o >>> 8 & 255
    },
    send_bits = (s, o, a) => {
        s.bi_valid > Buf_size - a ? (s.bi_buf |= o << s.bi_valid & 65535, put_short(s, s.bi_buf), s.bi_buf = o >> Buf_size - s.bi_valid, s.bi_valid += a - Buf_size) : (s.bi_buf |= o << s.bi_valid & 65535, s.bi_valid += a)
    },
    send_code = (s, o, a) => {
        send_bits(s, a[o * 2], a[o * 2 + 1])
    },
    bi_reverse = (s, o) => {
        let a = 0;
        do a |= s & 1, s >>>= 1, a <<= 1; while (--o > 0);
        return a >>> 1
    },
    bi_flush = s => {
        s.bi_valid === 16 ? (put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = s.bi_buf & 255, s.bi_buf >>= 8, s.bi_valid -= 8)
    },
    gen_bitlen = (s, o) => {
        const a = o.dyn_tree,
            $ = o.max_code,
            j = o.stat_desc.static_tree,
            _e = o.stat_desc.has_stree,
            et = o.stat_desc.extra_bits,
            tt = o.stat_desc.extra_base,
            nt = o.stat_desc.max_length;
        let rt, ot, st, lt, ft, yt, bt = 0;
        for (lt = 0; lt <= MAX_BITS$1; lt++) s.bl_count[lt] = 0;
        for (a[s.heap[s.heap_max] * 2 + 1] = 0, rt = s.heap_max + 1; rt < HEAP_SIZE$1; rt++) ot = s.heap[rt], lt = a[a[ot * 2 + 1] * 2 + 1] + 1, lt > nt && (lt = nt, bt++), a[ot * 2 + 1] = lt, !(ot > $) && (s.bl_count[lt]++, ft = 0, ot >= tt && (ft = et[ot - tt]), yt = a[ot * 2], s.opt_len += yt * (lt + ft), _e && (s.static_len += yt * (j[ot * 2 + 1] + ft)));
        if (bt !== 0) {
            do {
                for (lt = nt - 1; s.bl_count[lt] === 0;) lt--;
                s.bl_count[lt]--, s.bl_count[lt + 1] += 2, s.bl_count[nt]--, bt -= 2
            } while (bt > 0);
            for (lt = nt; lt !== 0; lt--)
                for (ot = s.bl_count[lt]; ot !== 0;) st = s.heap[--rt], !(st > $) && (a[st * 2 + 1] !== lt && (s.opt_len += (lt - a[st * 2 + 1]) * a[st * 2], a[st * 2 + 1] = lt), ot--)
        }
    },
    gen_codes = (s, o, a) => {
        const $ = new Array(MAX_BITS$1 + 1);
        let j = 0,
            _e, et;
        for (_e = 1; _e <= MAX_BITS$1; _e++) j = j + a[_e - 1] << 1, $[_e] = j;
        for (et = 0; et <= o; et++) {
            let tt = s[et * 2 + 1];
            tt !== 0 && (s[et * 2] = bi_reverse($[tt]++, tt))
        }
    },
    tr_static_init = () => {
        let s, o, a, $, j;
        const _e = new Array(MAX_BITS$1 + 1);
        for (a = 0, $ = 0; $ < LENGTH_CODES$1 - 1; $++)
            for (base_length[$] = a, s = 0; s < 1 << extra_lbits[$]; s++) _length_code[a++] = $;
        for (_length_code[a - 1] = $, j = 0, $ = 0; $ < 16; $++)
            for (base_dist[$] = j, s = 0; s < 1 << extra_dbits[$]; s++) _dist_code[j++] = $;
        for (j >>= 7; $ < D_CODES$1; $++)
            for (base_dist[$] = j << 7, s = 0; s < 1 << extra_dbits[$] - 7; s++) _dist_code[256 + j++] = $;
        for (o = 0; o <= MAX_BITS$1; o++) _e[o] = 0;
        for (s = 0; s <= 143;) static_ltree[s * 2 + 1] = 8, s++, _e[8]++;
        for (; s <= 255;) static_ltree[s * 2 + 1] = 9, s++, _e[9]++;
        for (; s <= 279;) static_ltree[s * 2 + 1] = 7, s++, _e[7]++;
        for (; s <= 287;) static_ltree[s * 2 + 1] = 8, s++, _e[8]++;
        for (gen_codes(static_ltree, L_CODES$1 + 1, _e), s = 0; s < D_CODES$1; s++) static_dtree[s * 2 + 1] = 5, static_dtree[s * 2] = bi_reverse(s, 5);
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS)
    },
    init_block = s => {
        let o;
        for (o = 0; o < L_CODES$1; o++) s.dyn_ltree[o * 2] = 0;
        for (o = 0; o < D_CODES$1; o++) s.dyn_dtree[o * 2] = 0;
        for (o = 0; o < BL_CODES$1; o++) s.bl_tree[o * 2] = 0;
        s.dyn_ltree[END_BLOCK * 2] = 1, s.opt_len = s.static_len = 0, s.sym_next = s.matches = 0
    },
    bi_windup = s => {
        s.bi_valid > 8 ? put_short(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf), s.bi_buf = 0, s.bi_valid = 0
    },
    smaller = (s, o, a, $) => {
        const j = o * 2,
            _e = a * 2;
        return s[j] < s[_e] || s[j] === s[_e] && $[o] <= $[a]
    },
    pqdownheap = (s, o, a) => {
        const $ = s.heap[a];
        let j = a << 1;
        for (; j <= s.heap_len && (j < s.heap_len && smaller(o, s.heap[j + 1], s.heap[j], s.depth) && j++, !smaller(o, $, s.heap[j], s.depth));) s.heap[a] = s.heap[j], a = j, j <<= 1;
        s.heap[a] = $
    },
    compress_block = (s, o, a) => {
        let $, j, _e = 0,
            et, tt;
        if (s.sym_next !== 0)
            do $ = s.pending_buf[s.sym_buf + _e++] & 255, $ += (s.pending_buf[s.sym_buf + _e++] & 255) << 8, j = s.pending_buf[s.sym_buf + _e++], $ === 0 ? send_code(s, j, o) : (et = _length_code[j], send_code(s, et + LITERALS$1 + 1, o), tt = extra_lbits[et], tt !== 0 && (j -= base_length[et], send_bits(s, j, tt)), $--, et = d_code($), send_code(s, et, a), tt = extra_dbits[et], tt !== 0 && ($ -= base_dist[et], send_bits(s, $, tt))); while (_e < s.sym_next);
        send_code(s, END_BLOCK, o)
    },
    build_tree = (s, o) => {
        const a = o.dyn_tree,
            $ = o.stat_desc.static_tree,
            j = o.stat_desc.has_stree,
            _e = o.stat_desc.elems;
        let et, tt, nt = -1,
            rt;
        for (s.heap_len = 0, s.heap_max = HEAP_SIZE$1, et = 0; et < _e; et++) a[et * 2] !== 0 ? (s.heap[++s.heap_len] = nt = et, s.depth[et] = 0) : a[et * 2 + 1] = 0;
        for (; s.heap_len < 2;) rt = s.heap[++s.heap_len] = nt < 2 ? ++nt : 0, a[rt * 2] = 1, s.depth[rt] = 0, s.opt_len--, j && (s.static_len -= $[rt * 2 + 1]);
        for (o.max_code = nt, et = s.heap_len >> 1; et >= 1; et--) pqdownheap(s, a, et);
        rt = _e;
        do et = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, a, 1), tt = s.heap[1], s.heap[--s.heap_max] = et, s.heap[--s.heap_max] = tt, a[rt * 2] = a[et * 2] + a[tt * 2], s.depth[rt] = (s.depth[et] >= s.depth[tt] ? s.depth[et] : s.depth[tt]) + 1, a[et * 2 + 1] = a[tt * 2 + 1] = rt, s.heap[1] = rt++, pqdownheap(s, a, 1); while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1], gen_bitlen(s, o), gen_codes(a, nt, s.bl_count)
    },
    scan_tree = (s, o, a) => {
        let $, j = -1,
            _e, et = o[0 * 2 + 1],
            tt = 0,
            nt = 7,
            rt = 4;
        for (et === 0 && (nt = 138, rt = 3), o[(a + 1) * 2 + 1] = 65535, $ = 0; $ <= a; $++) _e = et, et = o[($ + 1) * 2 + 1], !(++tt < nt && _e === et) && (tt < rt ? s.bl_tree[_e * 2] += tt : _e !== 0 ? (_e !== j && s.bl_tree[_e * 2]++, s.bl_tree[REP_3_6 * 2]++) : tt <= 10 ? s.bl_tree[REPZ_3_10 * 2]++ : s.bl_tree[REPZ_11_138 * 2]++, tt = 0, j = _e, et === 0 ? (nt = 138, rt = 3) : _e === et ? (nt = 6, rt = 3) : (nt = 7, rt = 4))
    },
    send_tree = (s, o, a) => {
        let $, j = -1,
            _e, et = o[0 * 2 + 1],
            tt = 0,
            nt = 7,
            rt = 4;
        for (et === 0 && (nt = 138, rt = 3), $ = 0; $ <= a; $++)
            if (_e = et, et = o[($ + 1) * 2 + 1], !(++tt < nt && _e === et)) {
                if (tt < rt)
                    do send_code(s, _e, s.bl_tree); while (--tt !== 0);
                else _e !== 0 ? (_e !== j && (send_code(s, _e, s.bl_tree), tt--), send_code(s, REP_3_6, s.bl_tree), send_bits(s, tt - 3, 2)) : tt <= 10 ? (send_code(s, REPZ_3_10, s.bl_tree), send_bits(s, tt - 3, 3)) : (send_code(s, REPZ_11_138, s.bl_tree), send_bits(s, tt - 11, 7));
                tt = 0, j = _e, et === 0 ? (nt = 138, rt = 3) : _e === et ? (nt = 6, rt = 3) : (nt = 7, rt = 4)
            }
    },
    build_bl_tree = s => {
        let o;
        for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), build_tree(s, s.bl_desc), o = BL_CODES$1 - 1; o >= 3 && s.bl_tree[bl_order[o] * 2 + 1] === 0; o--);
        return s.opt_len += 3 * (o + 1) + 5 + 5 + 4, o
    },
    send_all_trees = (s, o, a, $) => {
        let j;
        for (send_bits(s, o - 257, 5), send_bits(s, a - 1, 5), send_bits(s, $ - 4, 4), j = 0; j < $; j++) send_bits(s, s.bl_tree[bl_order[j] * 2 + 1], 3);
        send_tree(s, s.dyn_ltree, o - 1), send_tree(s, s.dyn_dtree, a - 1)
    },
    detect_data_type = s => {
        let o = 4093624447,
            a;
        for (a = 0; a <= 31; a++, o >>>= 1)
            if (o & 1 && s.dyn_ltree[a * 2] !== 0) return Z_BINARY;
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) return Z_TEXT;
        for (a = 32; a < LITERALS$1; a++)
            if (s.dyn_ltree[a * 2] !== 0) return Z_TEXT;
        return Z_BINARY
    };
let static_init_done = !1;
const _tr_init$1 = s => {
        static_init_done || (tr_static_init(), static_init_done = !0), s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), s.bi_buf = 0, s.bi_valid = 0, init_block(s)
    },
    _tr_stored_block$1 = (s, o, a, $) => {
        send_bits(s, (STORED_BLOCK << 1) + ($ ? 1 : 0), 3), bi_windup(s), put_short(s, a), put_short(s, ~a), a && s.pending_buf.set(s.window.subarray(o, o + a), s.pending), s.pending += a
    },
    _tr_align$1 = s => {
        send_bits(s, STATIC_TREES << 1, 3), send_code(s, END_BLOCK, static_ltree), bi_flush(s)
    },
    _tr_flush_block$1 = (s, o, a, $) => {
        let j, _e, et = 0;
        s.level > 0 ? (s.strm.data_type === Z_UNKNOWN$1 && (s.strm.data_type = detect_data_type(s)), build_tree(s, s.l_desc), build_tree(s, s.d_desc), et = build_bl_tree(s), j = s.opt_len + 3 + 7 >>> 3, _e = s.static_len + 3 + 7 >>> 3, _e <= j && (j = _e)) : j = _e = a + 5, a + 4 <= j && o !== -1 ? _tr_stored_block$1(s, o, a, $) : s.strategy === Z_FIXED$1 || _e === j ? (send_bits(s, (STATIC_TREES << 1) + ($ ? 1 : 0), 3), compress_block(s, static_ltree, static_dtree)) : (send_bits(s, (DYN_TREES << 1) + ($ ? 1 : 0), 3), send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, et + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree)), init_block(s), $ && bi_windup(s)
    },
    _tr_tally$1 = (s, o, a) => (s.pending_buf[s.sym_buf + s.sym_next++] = o, s.pending_buf[s.sym_buf + s.sym_next++] = o >> 8, s.pending_buf[s.sym_buf + s.sym_next++] = a, o === 0 ? s.dyn_ltree[a * 2]++ : (s.matches++, o--, s.dyn_ltree[(_length_code[a] + LITERALS$1 + 1) * 2]++, s.dyn_dtree[d_code(o) * 2]++), s.sym_next === s.sym_end);
var _tr_init_1 = _tr_init$1,
    _tr_stored_block_1 = _tr_stored_block$1,
    _tr_flush_block_1 = _tr_flush_block$1,
    _tr_tally_1 = _tr_tally$1,
    _tr_align_1 = _tr_align$1,
    trees = {
        _tr_init: _tr_init_1,
        _tr_stored_block: _tr_stored_block_1,
        _tr_flush_block: _tr_flush_block_1,
        _tr_tally: _tr_tally_1,
        _tr_align: _tr_align_1
    };
const adler32 = (s, o, a, $) => {
    let j = s & 65535 | 0,
        _e = s >>> 16 & 65535 | 0,
        et = 0;
    for (; a !== 0;) {
        et = a > 2e3 ? 2e3 : a, a -= et;
        do j = j + o[$++] | 0, _e = _e + j | 0; while (--et);
        j %= 65521, _e %= 65521
    }
    return j | _e << 16 | 0
};
var adler32_1 = adler32;
const makeTable = () => {
        let s, o = [];
        for (var a = 0; a < 256; a++) {
            s = a;
            for (var $ = 0; $ < 8; $++) s = s & 1 ? 3988292384 ^ s >>> 1 : s >>> 1;
            o[a] = s
        }
        return o
    },
    crcTable = new Uint32Array(makeTable()),
    crc32 = (s, o, a, $) => {
        const j = crcTable,
            _e = $ + a;
        s ^= -1;
        for (let et = $; et < _e; et++) s = s >>> 8 ^ j[(s ^ o[et]) & 255];
        return s ^ -1
    };
var crc32_1 = crc32,
    messages = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    },
    constants$2 = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    };
const {
    _tr_init,
    _tr_stored_block,
    _tr_flush_block,
    _tr_tally,
    _tr_align
} = trees, {
    Z_NO_FLUSH: Z_NO_FLUSH$2,
    Z_PARTIAL_FLUSH,
    Z_FULL_FLUSH: Z_FULL_FLUSH$1,
    Z_FINISH: Z_FINISH$3,
    Z_BLOCK: Z_BLOCK$1,
    Z_OK: Z_OK$3,
    Z_STREAM_END: Z_STREAM_END$3,
    Z_STREAM_ERROR: Z_STREAM_ERROR$2,
    Z_DATA_ERROR: Z_DATA_ERROR$2,
    Z_BUF_ERROR: Z_BUF_ERROR$1,
    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
    Z_FILTERED,
    Z_HUFFMAN_ONLY,
    Z_RLE,
    Z_FIXED,
    Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
    Z_UNKNOWN,
    Z_DEFLATED: Z_DEFLATED$2
} = constants$2, MAX_MEM_LEVEL = 9, MAX_WBITS$1 = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, GZIP_STATE = 57, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3, err = (s, o) => (s.msg = messages[o], o), rank = s => s * 2 - (s > 4 ? 9 : 0), zero = s => {
    let o = s.length;
    for (; --o >= 0;) s[o] = 0
}, slide_hash = s => {
    let o, a, $, j = s.w_size;
    o = s.hash_size, $ = o;
    do a = s.head[--$], s.head[$] = a >= j ? a - j : 0; while (--o);
    o = j, $ = o;
    do a = s.prev[--$], s.prev[$] = a >= j ? a - j : 0; while (--o)
};
let HASH_ZLIB = (s, o, a) => (o << s.hash_shift ^ a) & s.hash_mask,
    HASH = HASH_ZLIB;
const flush_pending = s => {
        const o = s.state;
        let a = o.pending;
        a > s.avail_out && (a = s.avail_out), a !== 0 && (s.output.set(o.pending_buf.subarray(o.pending_out, o.pending_out + a), s.next_out), s.next_out += a, o.pending_out += a, s.total_out += a, s.avail_out -= a, o.pending -= a, o.pending === 0 && (o.pending_out = 0))
    },
    flush_block_only = (s, o) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, o), s.block_start = s.strstart, flush_pending(s.strm)
    },
    put_byte = (s, o) => {
        s.pending_buf[s.pending++] = o
    },
    putShortMSB = (s, o) => {
        s.pending_buf[s.pending++] = o >>> 8 & 255, s.pending_buf[s.pending++] = o & 255
    },
    read_buf = (s, o, a, $) => {
        let j = s.avail_in;
        return j > $ && (j = $), j === 0 ? 0 : (s.avail_in -= j, o.set(s.input.subarray(s.next_in, s.next_in + j), a), s.state.wrap === 1 ? s.adler = adler32_1(s.adler, o, j, a) : s.state.wrap === 2 && (s.adler = crc32_1(s.adler, o, j, a)), s.next_in += j, s.total_in += j, j)
    },
    longest_match = (s, o) => {
        let a = s.max_chain_length,
            $ = s.strstart,
            j, _e, et = s.prev_length,
            tt = s.nice_match;
        const nt = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0,
            rt = s.window,
            ot = s.w_mask,
            st = s.prev,
            lt = s.strstart + MAX_MATCH;
        let ft = rt[$ + et - 1],
            yt = rt[$ + et];
        s.prev_length >= s.good_match && (a >>= 2), tt > s.lookahead && (tt = s.lookahead);
        do
            if (j = o, !(rt[j + et] !== yt || rt[j + et - 1] !== ft || rt[j] !== rt[$] || rt[++j] !== rt[$ + 1])) {
                $ += 2, j++;
                do; while (rt[++$] === rt[++j] && rt[++$] === rt[++j] && rt[++$] === rt[++j] && rt[++$] === rt[++j] && rt[++$] === rt[++j] && rt[++$] === rt[++j] && rt[++$] === rt[++j] && rt[++$] === rt[++j] && $ < lt);
                if (_e = MAX_MATCH - (lt - $), $ = lt - MAX_MATCH, _e > et) {
                    if (s.match_start = o, et = _e, _e >= tt) break;
                    ft = rt[$ + et - 1], yt = rt[$ + et]
                }
            }
        while ((o = st[o & ot]) > nt && --a !== 0);
        return et <= s.lookahead ? et : s.lookahead
    },
    fill_window = s => {
        const o = s.w_size;
        let a, $, j;
        do {
            if ($ = s.window_size - s.lookahead - s.strstart, s.strstart >= o + (o - MIN_LOOKAHEAD) && (s.window.set(s.window.subarray(o, o + o - $), 0), s.match_start -= o, s.strstart -= o, s.block_start -= o, s.insert > s.strstart && (s.insert = s.strstart), slide_hash(s), $ += o), s.strm.avail_in === 0) break;
            if (a = read_buf(s.strm, s.window, s.strstart + s.lookahead, $), s.lookahead += a, s.lookahead + s.insert >= MIN_MATCH)
                for (j = s.strstart - s.insert, s.ins_h = s.window[j], s.ins_h = HASH(s, s.ins_h, s.window[j + 1]); s.insert && (s.ins_h = HASH(s, s.ins_h, s.window[j + MIN_MATCH - 1]), s.prev[j & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = j, j++, s.insert--, !(s.lookahead + s.insert < MIN_MATCH)););
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
    },
    deflate_stored = (s, o) => {
        let a = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5,
            $, j, _e, et = 0,
            tt = s.strm.avail_in;
        do {
            if ($ = 65535, _e = s.bi_valid + 42 >> 3, s.strm.avail_out < _e || (_e = s.strm.avail_out - _e, j = s.strstart - s.block_start, $ > j + s.strm.avail_in && ($ = j + s.strm.avail_in), $ > _e && ($ = _e), $ < a && ($ === 0 && o !== Z_FINISH$3 || o === Z_NO_FLUSH$2 || $ !== j + s.strm.avail_in))) break;
            et = o === Z_FINISH$3 && $ === j + s.strm.avail_in ? 1 : 0, _tr_stored_block(s, 0, 0, et), s.pending_buf[s.pending - 4] = $, s.pending_buf[s.pending - 3] = $ >> 8, s.pending_buf[s.pending - 2] = ~$, s.pending_buf[s.pending - 1] = ~$ >> 8, flush_pending(s.strm), j && (j > $ && (j = $), s.strm.output.set(s.window.subarray(s.block_start, s.block_start + j), s.strm.next_out), s.strm.next_out += j, s.strm.avail_out -= j, s.strm.total_out += j, s.block_start += j, $ -= j), $ && (read_buf(s.strm, s.strm.output, s.strm.next_out, $), s.strm.next_out += $, s.strm.avail_out -= $, s.strm.total_out += $)
        } while (et === 0);
        return tt -= s.strm.avail_in, tt && (tt >= s.w_size ? (s.matches = 2, s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0), s.strstart = s.w_size, s.insert = s.strstart) : (s.window_size - s.strstart <= tt && (s.strstart -= s.w_size, s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0), s.matches < 2 && s.matches++, s.insert > s.strstart && (s.insert = s.strstart)), s.window.set(s.strm.input.subarray(s.strm.next_in - tt, s.strm.next_in), s.strstart), s.strstart += tt, s.insert += tt > s.w_size - s.insert ? s.w_size - s.insert : tt), s.block_start = s.strstart), s.high_water < s.strstart && (s.high_water = s.strstart), et ? BS_FINISH_DONE : o !== Z_NO_FLUSH$2 && o !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start ? BS_BLOCK_DONE : (_e = s.window_size - s.strstart, s.strm.avail_in > _e && s.block_start >= s.w_size && (s.block_start -= s.w_size, s.strstart -= s.w_size, s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0), s.matches < 2 && s.matches++, _e += s.w_size, s.insert > s.strstart && (s.insert = s.strstart)), _e > s.strm.avail_in && (_e = s.strm.avail_in), _e && (read_buf(s.strm, s.window, s.strstart, _e), s.strstart += _e, s.insert += _e > s.w_size - s.insert ? s.w_size - s.insert : _e), s.high_water < s.strstart && (s.high_water = s.strstart), _e = s.bi_valid + 42 >> 3, _e = s.pending_buf_size - _e > 65535 ? 65535 : s.pending_buf_size - _e, a = _e > s.w_size ? s.w_size : _e, j = s.strstart - s.block_start, (j >= a || (j || o === Z_FINISH$3) && o !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && j <= _e) && ($ = j > _e ? _e : j, et = o === Z_FINISH$3 && s.strm.avail_in === 0 && $ === j ? 1 : 0, _tr_stored_block(s, s.block_start, $, et), s.block_start += $, flush_pending(s.strm)), et ? BS_FINISH_STARTED : BS_NEED_MORE)
    },
    deflate_fast = (s, o) => {
        let a, $;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && o === Z_NO_FLUSH$2) return BS_NEED_MORE;
                if (s.lookahead === 0) break
            }
            if (a = 0, s.lookahead >= MIN_MATCH && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), a !== 0 && s.strstart - a <= s.w_size - MIN_LOOKAHEAD && (s.match_length = longest_match(s, a)), s.match_length >= MIN_MATCH)
                if ($ = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                    s.match_length--;
                    do s.strstart++, s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart; while (--s.match_length !== 0);
                    s.strstart++
                } else s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            else $ = _tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;
            if ($ && (flush_block_only(s, !1), s.strm.avail_out === 0)) return BS_NEED_MORE
        }
        return s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1, o === Z_FINISH$3 ? (flush_block_only(s, !0), s.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.sym_next && (flush_block_only(s, !1), s.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
    },
    deflate_slow = (s, o) => {
        let a, $, j;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && o === Z_NO_FLUSH$2) return BS_NEED_MORE;
                if (s.lookahead === 0) break
            }
            if (a = 0, s.lookahead >= MIN_MATCH && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = MIN_MATCH - 1, a !== 0 && s.prev_length < s.max_lazy_match && s.strstart - a <= s.w_size - MIN_LOOKAHEAD && (s.match_length = longest_match(s, a), s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096) && (s.match_length = MIN_MATCH - 1)), s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                j = s.strstart + s.lookahead - MIN_MATCH, $ = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH), s.lookahead -= s.prev_length - 1, s.prev_length -= 2;
                do ++s.strstart <= j && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]), a = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart); while (--s.prev_length !== 0);
                if (s.match_available = 0, s.match_length = MIN_MATCH - 1, s.strstart++, $ && (flush_block_only(s, !1), s.strm.avail_out === 0)) return BS_NEED_MORE
            } else if (s.match_available) {
                if ($ = _tr_tally(s, 0, s.window[s.strstart - 1]), $ && flush_block_only(s, !1), s.strstart++, s.lookahead--, s.strm.avail_out === 0) return BS_NEED_MORE
            } else s.match_available = 1, s.strstart++, s.lookahead--
        }
        return s.match_available && ($ = _tr_tally(s, 0, s.window[s.strstart - 1]), s.match_available = 0), s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1, o === Z_FINISH$3 ? (flush_block_only(s, !0), s.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.sym_next && (flush_block_only(s, !1), s.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
    },
    deflate_rle = (s, o) => {
        let a, $, j, _e;
        const et = s.window;
        for (;;) {
            if (s.lookahead <= MAX_MATCH) {
                if (fill_window(s), s.lookahead <= MAX_MATCH && o === Z_NO_FLUSH$2) return BS_NEED_MORE;
                if (s.lookahead === 0) break
            }
            if (s.match_length = 0, s.lookahead >= MIN_MATCH && s.strstart > 0 && (j = s.strstart - 1, $ = et[j], $ === et[++j] && $ === et[++j] && $ === et[++j])) {
                _e = s.strstart + MAX_MATCH;
                do; while ($ === et[++j] && $ === et[++j] && $ === et[++j] && $ === et[++j] && $ === et[++j] && $ === et[++j] && $ === et[++j] && $ === et[++j] && j < _e);
                s.match_length = MAX_MATCH - (_e - j), s.match_length > s.lookahead && (s.match_length = s.lookahead)
            }
            if (s.match_length >= MIN_MATCH ? (a = _tr_tally(s, 1, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.strstart += s.match_length, s.match_length = 0) : (a = _tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++), a && (flush_block_only(s, !1), s.strm.avail_out === 0)) return BS_NEED_MORE
        }
        return s.insert = 0, o === Z_FINISH$3 ? (flush_block_only(s, !0), s.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.sym_next && (flush_block_only(s, !1), s.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
    },
    deflate_huff = (s, o) => {
        let a;
        for (;;) {
            if (s.lookahead === 0 && (fill_window(s), s.lookahead === 0)) {
                if (o === Z_NO_FLUSH$2) return BS_NEED_MORE;
                break
            }
            if (s.match_length = 0, a = _tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++, a && (flush_block_only(s, !1), s.strm.avail_out === 0)) return BS_NEED_MORE
        }
        return s.insert = 0, o === Z_FINISH$3 ? (flush_block_only(s, !0), s.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.sym_next && (flush_block_only(s, !1), s.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
    };

function Config(s, o, a, $, j) {
    this.good_length = s, this.max_lazy = o, this.nice_length = a, this.max_chain = $, this.func = j
}
const configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)],
    lm_init = s => {
        s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, s.ins_h = 0
    };

function DeflateState() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED$2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2), this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2), this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(MAX_BITS + 1), this.heap = new Uint16Array(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * L_CODES + 1), zero(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
}
const deflateStateCheck = s => {
        if (!s) return 1;
        const o = s.state;
        return !o || o.strm !== s || o.status !== INIT_STATE && o.status !== GZIP_STATE && o.status !== EXTRA_STATE && o.status !== NAME_STATE && o.status !== COMMENT_STATE && o.status !== HCRC_STATE && o.status !== BUSY_STATE && o.status !== FINISH_STATE ? 1 : 0
    },
    deflateResetKeep = s => {
        if (deflateStateCheck(s)) return err(s, Z_STREAM_ERROR$2);
        s.total_in = s.total_out = 0, s.data_type = Z_UNKNOWN;
        const o = s.state;
        return o.pending = 0, o.pending_out = 0, o.wrap < 0 && (o.wrap = -o.wrap), o.status = o.wrap === 2 ? GZIP_STATE : o.wrap ? INIT_STATE : BUSY_STATE, s.adler = o.wrap === 2 ? 0 : 1, o.last_flush = -2, _tr_init(o), Z_OK$3
    },
    deflateReset = s => {
        const o = deflateResetKeep(s);
        return o === Z_OK$3 && lm_init(s.state), o
    },
    deflateSetHeader = (s, o) => deflateStateCheck(s) || s.state.wrap !== 2 ? Z_STREAM_ERROR$2 : (s.state.gzhead = o, Z_OK$3),
    deflateInit2 = (s, o, a, $, j, _e) => {
        if (!s) return Z_STREAM_ERROR$2;
        let et = 1;
        if (o === Z_DEFAULT_COMPRESSION$1 && (o = 6), $ < 0 ? (et = 0, $ = -$) : $ > 15 && (et = 2, $ -= 16), j < 1 || j > MAX_MEM_LEVEL || a !== Z_DEFLATED$2 || $ < 8 || $ > 15 || o < 0 || o > 9 || _e < 0 || _e > Z_FIXED || $ === 8 && et !== 1) return err(s, Z_STREAM_ERROR$2);
        $ === 8 && ($ = 9);
        const tt = new DeflateState;
        return s.state = tt, tt.strm = s, tt.status = INIT_STATE, tt.wrap = et, tt.gzhead = null, tt.w_bits = $, tt.w_size = 1 << tt.w_bits, tt.w_mask = tt.w_size - 1, tt.hash_bits = j + 7, tt.hash_size = 1 << tt.hash_bits, tt.hash_mask = tt.hash_size - 1, tt.hash_shift = ~~((tt.hash_bits + MIN_MATCH - 1) / MIN_MATCH), tt.window = new Uint8Array(tt.w_size * 2), tt.head = new Uint16Array(tt.hash_size), tt.prev = new Uint16Array(tt.w_size), tt.lit_bufsize = 1 << j + 6, tt.pending_buf_size = tt.lit_bufsize * 4, tt.pending_buf = new Uint8Array(tt.pending_buf_size), tt.sym_buf = tt.lit_bufsize, tt.sym_end = (tt.lit_bufsize - 1) * 3, tt.level = o, tt.strategy = _e, tt.method = a, deflateReset(s)
    },
    deflateInit = (s, o) => deflateInit2(s, o, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1),
    deflate$2 = (s, o) => {
        if (deflateStateCheck(s) || o > Z_BLOCK$1 || o < 0) return s ? err(s, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
        const a = s.state;
        if (!s.output || s.avail_in !== 0 && !s.input || a.status === FINISH_STATE && o !== Z_FINISH$3) return err(s, s.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
        const $ = a.last_flush;
        if (a.last_flush = o, a.pending !== 0) {
            if (flush_pending(s), s.avail_out === 0) return a.last_flush = -1, Z_OK$3
        } else if (s.avail_in === 0 && rank(o) <= rank($) && o !== Z_FINISH$3) return err(s, Z_BUF_ERROR$1);
        if (a.status === FINISH_STATE && s.avail_in !== 0) return err(s, Z_BUF_ERROR$1);
        if (a.status === INIT_STATE && a.wrap === 0 && (a.status = BUSY_STATE), a.status === INIT_STATE) {
            let j = Z_DEFLATED$2 + (a.w_bits - 8 << 4) << 8,
                _e = -1;
            if (a.strategy >= Z_HUFFMAN_ONLY || a.level < 2 ? _e = 0 : a.level < 6 ? _e = 1 : a.level === 6 ? _e = 2 : _e = 3, j |= _e << 6, a.strstart !== 0 && (j |= PRESET_DICT), j += 31 - j % 31, putShortMSB(a, j), a.strstart !== 0 && (putShortMSB(a, s.adler >>> 16), putShortMSB(a, s.adler & 65535)), s.adler = 1, a.status = BUSY_STATE, flush_pending(s), a.pending !== 0) return a.last_flush = -1, Z_OK$3
        }
        if (a.status === GZIP_STATE) {
            if (s.adler = 0, put_byte(a, 31), put_byte(a, 139), put_byte(a, 8), a.gzhead) put_byte(a, (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)), put_byte(a, a.gzhead.time & 255), put_byte(a, a.gzhead.time >> 8 & 255), put_byte(a, a.gzhead.time >> 16 & 255), put_byte(a, a.gzhead.time >> 24 & 255), put_byte(a, a.level === 9 ? 2 : a.strategy >= Z_HUFFMAN_ONLY || a.level < 2 ? 4 : 0), put_byte(a, a.gzhead.os & 255), a.gzhead.extra && a.gzhead.extra.length && (put_byte(a, a.gzhead.extra.length & 255), put_byte(a, a.gzhead.extra.length >> 8 & 255)), a.gzhead.hcrc && (s.adler = crc32_1(s.adler, a.pending_buf, a.pending, 0)), a.gzindex = 0, a.status = EXTRA_STATE;
            else if (put_byte(a, 0), put_byte(a, 0), put_byte(a, 0), put_byte(a, 0), put_byte(a, 0), put_byte(a, a.level === 9 ? 2 : a.strategy >= Z_HUFFMAN_ONLY || a.level < 2 ? 4 : 0), put_byte(a, OS_CODE), a.status = BUSY_STATE, flush_pending(s), a.pending !== 0) return a.last_flush = -1, Z_OK$3
        }
        if (a.status === EXTRA_STATE) {
            if (a.gzhead.extra) {
                let j = a.pending,
                    _e = (a.gzhead.extra.length & 65535) - a.gzindex;
                for (; a.pending + _e > a.pending_buf_size;) {
                    let tt = a.pending_buf_size - a.pending;
                    if (a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex, a.gzindex + tt), a.pending), a.pending = a.pending_buf_size, a.gzhead.hcrc && a.pending > j && (s.adler = crc32_1(s.adler, a.pending_buf, a.pending - j, j)), a.gzindex += tt, flush_pending(s), a.pending !== 0) return a.last_flush = -1, Z_OK$3;
                    j = 0, _e -= tt
                }
                let et = new Uint8Array(a.gzhead.extra);
                a.pending_buf.set(et.subarray(a.gzindex, a.gzindex + _e), a.pending), a.pending += _e, a.gzhead.hcrc && a.pending > j && (s.adler = crc32_1(s.adler, a.pending_buf, a.pending - j, j)), a.gzindex = 0
            }
            a.status = NAME_STATE
        }
        if (a.status === NAME_STATE) {
            if (a.gzhead.name) {
                let j = a.pending,
                    _e;
                do {
                    if (a.pending === a.pending_buf_size) {
                        if (a.gzhead.hcrc && a.pending > j && (s.adler = crc32_1(s.adler, a.pending_buf, a.pending - j, j)), flush_pending(s), a.pending !== 0) return a.last_flush = -1, Z_OK$3;
                        j = 0
                    }
                    a.gzindex < a.gzhead.name.length ? _e = a.gzhead.name.charCodeAt(a.gzindex++) & 255 : _e = 0, put_byte(a, _e)
                } while (_e !== 0);
                a.gzhead.hcrc && a.pending > j && (s.adler = crc32_1(s.adler, a.pending_buf, a.pending - j, j)), a.gzindex = 0
            }
            a.status = COMMENT_STATE
        }
        if (a.status === COMMENT_STATE) {
            if (a.gzhead.comment) {
                let j = a.pending,
                    _e;
                do {
                    if (a.pending === a.pending_buf_size) {
                        if (a.gzhead.hcrc && a.pending > j && (s.adler = crc32_1(s.adler, a.pending_buf, a.pending - j, j)), flush_pending(s), a.pending !== 0) return a.last_flush = -1, Z_OK$3;
                        j = 0
                    }
                    a.gzindex < a.gzhead.comment.length ? _e = a.gzhead.comment.charCodeAt(a.gzindex++) & 255 : _e = 0, put_byte(a, _e)
                } while (_e !== 0);
                a.gzhead.hcrc && a.pending > j && (s.adler = crc32_1(s.adler, a.pending_buf, a.pending - j, j))
            }
            a.status = HCRC_STATE
        }
        if (a.status === HCRC_STATE) {
            if (a.gzhead.hcrc) {
                if (a.pending + 2 > a.pending_buf_size && (flush_pending(s), a.pending !== 0)) return a.last_flush = -1, Z_OK$3;
                put_byte(a, s.adler & 255), put_byte(a, s.adler >> 8 & 255), s.adler = 0
            }
            if (a.status = BUSY_STATE, flush_pending(s), a.pending !== 0) return a.last_flush = -1, Z_OK$3
        }
        if (s.avail_in !== 0 || a.lookahead !== 0 || o !== Z_NO_FLUSH$2 && a.status !== FINISH_STATE) {
            let j = a.level === 0 ? deflate_stored(a, o) : a.strategy === Z_HUFFMAN_ONLY ? deflate_huff(a, o) : a.strategy === Z_RLE ? deflate_rle(a, o) : configuration_table[a.level].func(a, o);
            if ((j === BS_FINISH_STARTED || j === BS_FINISH_DONE) && (a.status = FINISH_STATE), j === BS_NEED_MORE || j === BS_FINISH_STARTED) return s.avail_out === 0 && (a.last_flush = -1), Z_OK$3;
            if (j === BS_BLOCK_DONE && (o === Z_PARTIAL_FLUSH ? _tr_align(a) : o !== Z_BLOCK$1 && (_tr_stored_block(a, 0, 0, !1), o === Z_FULL_FLUSH$1 && (zero(a.head), a.lookahead === 0 && (a.strstart = 0, a.block_start = 0, a.insert = 0))), flush_pending(s), s.avail_out === 0)) return a.last_flush = -1, Z_OK$3
        }
        return o !== Z_FINISH$3 ? Z_OK$3 : a.wrap <= 0 ? Z_STREAM_END$3 : (a.wrap === 2 ? (put_byte(a, s.adler & 255), put_byte(a, s.adler >> 8 & 255), put_byte(a, s.adler >> 16 & 255), put_byte(a, s.adler >> 24 & 255), put_byte(a, s.total_in & 255), put_byte(a, s.total_in >> 8 & 255), put_byte(a, s.total_in >> 16 & 255), put_byte(a, s.total_in >> 24 & 255)) : (putShortMSB(a, s.adler >>> 16), putShortMSB(a, s.adler & 65535)), flush_pending(s), a.wrap > 0 && (a.wrap = -a.wrap), a.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3)
    },
    deflateEnd = s => {
        if (deflateStateCheck(s)) return Z_STREAM_ERROR$2;
        const o = s.state.status;
        return s.state = null, o === BUSY_STATE ? err(s, Z_DATA_ERROR$2) : Z_OK$3
    },
    deflateSetDictionary = (s, o) => {
        let a = o.length;
        if (deflateStateCheck(s)) return Z_STREAM_ERROR$2;
        const $ = s.state,
            j = $.wrap;
        if (j === 2 || j === 1 && $.status !== INIT_STATE || $.lookahead) return Z_STREAM_ERROR$2;
        if (j === 1 && (s.adler = adler32_1(s.adler, o, a, 0)), $.wrap = 0, a >= $.w_size) {
            j === 0 && (zero($.head), $.strstart = 0, $.block_start = 0, $.insert = 0);
            let nt = new Uint8Array($.w_size);
            nt.set(o.subarray(a - $.w_size, a), 0), o = nt, a = $.w_size
        }
        const _e = s.avail_in,
            et = s.next_in,
            tt = s.input;
        for (s.avail_in = a, s.next_in = 0, s.input = o, fill_window($); $.lookahead >= MIN_MATCH;) {
            let nt = $.strstart,
                rt = $.lookahead - (MIN_MATCH - 1);
            do $.ins_h = HASH($, $.ins_h, $.window[nt + MIN_MATCH - 1]), $.prev[nt & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = nt, nt++; while (--rt);
            $.strstart = nt, $.lookahead = MIN_MATCH - 1, fill_window($)
        }
        return $.strstart += $.lookahead, $.block_start = $.strstart, $.insert = $.lookahead, $.lookahead = 0, $.match_length = $.prev_length = MIN_MATCH - 1, $.match_available = 0, s.next_in = et, s.input = tt, s.avail_in = _e, $.wrap = j, Z_OK$3
    };
var deflateInit_1 = deflateInit,
    deflateInit2_1 = deflateInit2,
    deflateReset_1 = deflateReset,
    deflateResetKeep_1 = deflateResetKeep,
    deflateSetHeader_1 = deflateSetHeader,
    deflate_2$1 = deflate$2,
    deflateEnd_1 = deflateEnd,
    deflateSetDictionary_1 = deflateSetDictionary,
    deflateInfo = "pako deflate (from Nodeca project)",
    deflate_1$2 = {
        deflateInit: deflateInit_1,
        deflateInit2: deflateInit2_1,
        deflateReset: deflateReset_1,
        deflateResetKeep: deflateResetKeep_1,
        deflateSetHeader: deflateSetHeader_1,
        deflate: deflate_2$1,
        deflateEnd: deflateEnd_1,
        deflateSetDictionary: deflateSetDictionary_1,
        deflateInfo
    };
const _has = (s, o) => Object.prototype.hasOwnProperty.call(s, o);
var assign = function(s) {
        const o = Array.prototype.slice.call(arguments, 1);
        for (; o.length;) {
            const a = o.shift();
            if (a) {
                if (typeof a != "object") throw new TypeError(a + "must be non-object");
                for (const $ in a) _has(a, $) && (s[$] = a[$])
            }
        }
        return s
    },
    flattenChunks = s => {
        let o = 0;
        for (let $ = 0, j = s.length; $ < j; $++) o += s[$].length;
        const a = new Uint8Array(o);
        for (let $ = 0, j = 0, _e = s.length; $ < _e; $++) {
            let et = s[$];
            a.set(et, j), j += et.length
        }
        return a
    },
    common = {
        assign,
        flattenChunks
    };
let STR_APPLY_UIA_OK = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1))
} catch (s) {
    STR_APPLY_UIA_OK = !1
}
const _utf8len = new Uint8Array(256);
for (let s = 0; s < 256; s++) _utf8len[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1;
_utf8len[254] = _utf8len[254] = 1;
var string2buf = s => {
    if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(s);
    let o, a, $, j, _e, et = s.length,
        tt = 0;
    for (j = 0; j < et; j++) a = s.charCodeAt(j), (a & 64512) === 55296 && j + 1 < et && ($ = s.charCodeAt(j + 1), ($ & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + ($ - 56320), j++)), tt += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
    for (o = new Uint8Array(tt), _e = 0, j = 0; _e < tt; j++) a = s.charCodeAt(j), (a & 64512) === 55296 && j + 1 < et && ($ = s.charCodeAt(j + 1), ($ & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + ($ - 56320), j++)), a < 128 ? o[_e++] = a : a < 2048 ? (o[_e++] = 192 | a >>> 6, o[_e++] = 128 | a & 63) : a < 65536 ? (o[_e++] = 224 | a >>> 12, o[_e++] = 128 | a >>> 6 & 63, o[_e++] = 128 | a & 63) : (o[_e++] = 240 | a >>> 18, o[_e++] = 128 | a >>> 12 & 63, o[_e++] = 128 | a >>> 6 & 63, o[_e++] = 128 | a & 63);
    return o
};
const buf2binstring = (s, o) => {
    if (o < 65534 && s.subarray && STR_APPLY_UIA_OK) return String.fromCharCode.apply(null, s.length === o ? s : s.subarray(0, o));
    let a = "";
    for (let $ = 0; $ < o; $++) a += String.fromCharCode(s[$]);
    return a
};
var buf2string = (s, o) => {
        const a = o || s.length;
        if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(s.subarray(0, o));
        let $, j;
        const _e = new Array(a * 2);
        for (j = 0, $ = 0; $ < a;) {
            let et = s[$++];
            if (et < 128) {
                _e[j++] = et;
                continue
            }
            let tt = _utf8len[et];
            if (tt > 4) {
                _e[j++] = 65533, $ += tt - 1;
                continue
            }
            for (et &= tt === 2 ? 31 : tt === 3 ? 15 : 7; tt > 1 && $ < a;) et = et << 6 | s[$++] & 63, tt--;
            if (tt > 1) {
                _e[j++] = 65533;
                continue
            }
            et < 65536 ? _e[j++] = et : (et -= 65536, _e[j++] = 55296 | et >> 10 & 1023, _e[j++] = 56320 | et & 1023)
        }
        return buf2binstring(_e, j)
    },
    utf8border = (s, o) => {
        o = o || s.length, o > s.length && (o = s.length);
        let a = o - 1;
        for (; a >= 0 && (s[a] & 192) === 128;) a--;
        return a < 0 || a === 0 ? o : a + _utf8len[s[a]] > o ? a : o
    },
    strings = {
        string2buf,
        buf2string,
        utf8border
    };

function ZStream() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString,
    {
        Z_NO_FLUSH: Z_NO_FLUSH$1,
        Z_SYNC_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH: Z_FINISH$2,
        Z_OK: Z_OK$2,
        Z_STREAM_END: Z_STREAM_END$2,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_STRATEGY,
        Z_DEFLATED: Z_DEFLATED$1
    } = constants$2;

function Deflate$1(s) {
    this.options = common.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED$1,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
    }, s || {});
    let o = this.options;
    o.raw && o.windowBits > 0 ? o.windowBits = -o.windowBits : o.gzip && o.windowBits > 0 && o.windowBits < 16 && (o.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0;
    let a = deflate_1$2.deflateInit2(this.strm, o.level, o.method, o.windowBits, o.memLevel, o.strategy);
    if (a !== Z_OK$2) throw new Error(messages[a]);
    if (o.header && deflate_1$2.deflateSetHeader(this.strm, o.header), o.dictionary) {
        let $;
        if (typeof o.dictionary == "string" ? $ = strings.string2buf(o.dictionary) : toString$1.call(o.dictionary) === "[object ArrayBuffer]" ? $ = new Uint8Array(o.dictionary) : $ = o.dictionary, a = deflate_1$2.deflateSetDictionary(this.strm, $), a !== Z_OK$2) throw new Error(messages[a]);
        this._dict_set = !0
    }
}
Deflate$1.prototype.push = function(s, o) {
    const a = this.strm,
        $ = this.options.chunkSize;
    let j, _e;
    if (this.ended) return !1;
    for (o === ~~o ? _e = o : _e = o === !0 ? Z_FINISH$2 : Z_NO_FLUSH$1, typeof s == "string" ? a.input = strings.string2buf(s) : toString$1.call(s) === "[object ArrayBuffer]" ? a.input = new Uint8Array(s) : a.input = s, a.next_in = 0, a.avail_in = a.input.length;;) {
        if (a.avail_out === 0 && (a.output = new Uint8Array($), a.next_out = 0, a.avail_out = $), (_e === Z_SYNC_FLUSH || _e === Z_FULL_FLUSH) && a.avail_out <= 6) {
            this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
            continue
        }
        if (j = deflate_1$2.deflate(a, _e), j === Z_STREAM_END$2) return a.next_out > 0 && this.onData(a.output.subarray(0, a.next_out)), j = deflate_1$2.deflateEnd(this.strm), this.onEnd(j), this.ended = !0, j === Z_OK$2;
        if (a.avail_out === 0) {
            this.onData(a.output);
            continue
        }
        if (_e > 0 && a.next_out > 0) {
            this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
            continue
        }
        if (a.avail_in === 0) break
    }
    return !0
};
Deflate$1.prototype.onData = function(s) {
    this.chunks.push(s)
};
Deflate$1.prototype.onEnd = function(s) {
    s === Z_OK$2 && (this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = s, this.msg = this.strm.msg
};
const BAD$1 = 16209,
    TYPE$1 = 16191;
var inffast = function s(o, a) {
    let $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht, vt, wt, gt, At, Pt, Bt, Lt, Nt, Ut, Vt;
    const Ft = o.state;
    $ = o.next_in, Ut = o.input, j = $ + (o.avail_in - 5), _e = o.next_out, Vt = o.output, et = _e - (a - o.avail_out), tt = _e + (o.avail_out - 257), nt = Ft.dmax, rt = Ft.wsize, ot = Ft.whave, st = Ft.wnext, lt = Ft.window, ft = Ft.hold, yt = Ft.bits, bt = Ft.lencode, ht = Ft.distcode, vt = (1 << Ft.lenbits) - 1, wt = (1 << Ft.distbits) - 1;
    e: do {
        yt < 15 && (ft += Ut[$++] << yt, yt += 8, ft += Ut[$++] << yt, yt += 8), gt = bt[ft & vt];
        t: for (;;) {
            if (At = gt >>> 24, ft >>>= At, yt -= At, At = gt >>> 16 & 255, At === 0) Vt[_e++] = gt & 65535;
            else if (At & 16) {
                Pt = gt & 65535, At &= 15, At && (yt < At && (ft += Ut[$++] << yt, yt += 8), Pt += ft & (1 << At) - 1, ft >>>= At, yt -= At), yt < 15 && (ft += Ut[$++] << yt, yt += 8, ft += Ut[$++] << yt, yt += 8), gt = ht[ft & wt];
                n: for (;;) {
                    if (At = gt >>> 24, ft >>>= At, yt -= At, At = gt >>> 16 & 255, At & 16) {
                        if (Bt = gt & 65535, At &= 15, yt < At && (ft += Ut[$++] << yt, yt += 8, yt < At && (ft += Ut[$++] << yt, yt += 8)), Bt += ft & (1 << At) - 1, Bt > nt) {
                            o.msg = "invalid distance too far back", Ft.mode = BAD$1;
                            break e
                        }
                        if (ft >>>= At, yt -= At, At = _e - et, Bt > At) {
                            if (At = Bt - At, At > ot && Ft.sane) {
                                o.msg = "invalid distance too far back", Ft.mode = BAD$1;
                                break e
                            }
                            if (Lt = 0, Nt = lt, st === 0) {
                                if (Lt += rt - At, At < Pt) {
                                    Pt -= At;
                                    do Vt[_e++] = lt[Lt++]; while (--At);
                                    Lt = _e - Bt, Nt = Vt
                                }
                            } else if (st < At) {
                                if (Lt += rt + st - At, At -= st, At < Pt) {
                                    Pt -= At;
                                    do Vt[_e++] = lt[Lt++]; while (--At);
                                    if (Lt = 0, st < Pt) {
                                        At = st, Pt -= At;
                                        do Vt[_e++] = lt[Lt++]; while (--At);
                                        Lt = _e - Bt, Nt = Vt
                                    }
                                }
                            } else if (Lt += st - At, At < Pt) {
                                Pt -= At;
                                do Vt[_e++] = lt[Lt++]; while (--At);
                                Lt = _e - Bt, Nt = Vt
                            }
                            for (; Pt > 2;) Vt[_e++] = Nt[Lt++], Vt[_e++] = Nt[Lt++], Vt[_e++] = Nt[Lt++], Pt -= 3;
                            Pt && (Vt[_e++] = Nt[Lt++], Pt > 1 && (Vt[_e++] = Nt[Lt++]))
                        } else {
                            Lt = _e - Bt;
                            do Vt[_e++] = Vt[Lt++], Vt[_e++] = Vt[Lt++], Vt[_e++] = Vt[Lt++], Pt -= 3; while (Pt > 2);
                            Pt && (Vt[_e++] = Vt[Lt++], Pt > 1 && (Vt[_e++] = Vt[Lt++]))
                        }
                    } else if (At & 64) {
                        o.msg = "invalid distance code", Ft.mode = BAD$1;
                        break e
                    } else {
                        gt = ht[(gt & 65535) + (ft & (1 << At) - 1)];
                        continue n
                    }
                    break
                }
            } else if (At & 64)
                if (At & 32) {
                    Ft.mode = TYPE$1;
                    break e
                } else {
                    o.msg = "invalid literal/length code", Ft.mode = BAD$1;
                    break e
                }
            else {
                gt = bt[(gt & 65535) + (ft & (1 << At) - 1)];
                continue t
            }
            break
        }
    } while ($ < j && _e < tt);
    Pt = yt >> 3, $ -= Pt, yt -= Pt << 3, ft &= (1 << yt) - 1, o.next_in = $, o.next_out = _e, o.avail_in = $ < j ? 5 + (j - $) : 5 - ($ - j), o.avail_out = _e < tt ? 257 + (tt - _e) : 257 - (_e - tt), Ft.hold = ft, Ft.bits = yt
};
const MAXBITS = 15,
    ENOUGH_LENS$1 = 852,
    ENOUGH_DISTS$1 = 592,
    CODES$1 = 0,
    LENS$1 = 1,
    DISTS$1 = 2,
    lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
    lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
    dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
    dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
    inflate_table = (s, o, a, $, j, _e, et, tt) => {
        const nt = tt.bits;
        let rt = 0,
            ot = 0,
            st = 0,
            lt = 0,
            ft = 0,
            yt = 0,
            bt = 0,
            ht = 0,
            vt = 0,
            wt = 0,
            gt, At, Pt, Bt, Lt, Nt = null,
            Ut;
        const Vt = new Uint16Array(MAXBITS + 1),
            Ft = new Uint16Array(MAXBITS + 1);
        let Wt = null,
            Ct, it, at;
        for (rt = 0; rt <= MAXBITS; rt++) Vt[rt] = 0;
        for (ot = 0; ot < $; ot++) Vt[o[a + ot]]++;
        for (ft = nt, lt = MAXBITS; lt >= 1 && Vt[lt] === 0; lt--);
        if (ft > lt && (ft = lt), lt === 0) return j[_e++] = 1 << 24 | 64 << 16 | 0, j[_e++] = 1 << 24 | 64 << 16 | 0, tt.bits = 1, 0;
        for (st = 1; st < lt && Vt[st] === 0; st++);
        for (ft < st && (ft = st), ht = 1, rt = 1; rt <= MAXBITS; rt++)
            if (ht <<= 1, ht -= Vt[rt], ht < 0) return -1;
        if (ht > 0 && (s === CODES$1 || lt !== 1)) return -1;
        for (Ft[1] = 0, rt = 1; rt < MAXBITS; rt++) Ft[rt + 1] = Ft[rt] + Vt[rt];
        for (ot = 0; ot < $; ot++) o[a + ot] !== 0 && (et[Ft[o[a + ot]]++] = ot);
        if (s === CODES$1 ? (Nt = Wt = et, Ut = 20) : s === LENS$1 ? (Nt = lbase, Wt = lext, Ut = 257) : (Nt = dbase, Wt = dext, Ut = 0), wt = 0, ot = 0, rt = st, Lt = _e, yt = ft, bt = 0, Pt = -1, vt = 1 << ft, Bt = vt - 1, s === LENS$1 && vt > ENOUGH_LENS$1 || s === DISTS$1 && vt > ENOUGH_DISTS$1) return 1;
        for (;;) {
            Ct = rt - bt, et[ot] + 1 < Ut ? (it = 0, at = et[ot]) : et[ot] >= Ut ? (it = Wt[et[ot] - Ut], at = Nt[et[ot] - Ut]) : (it = 96, at = 0), gt = 1 << rt - bt, At = 1 << yt, st = At;
            do At -= gt, j[Lt + (wt >> bt) + At] = Ct << 24 | it << 16 | at | 0; while (At !== 0);
            for (gt = 1 << rt - 1; wt & gt;) gt >>= 1;
            if (gt !== 0 ? (wt &= gt - 1, wt += gt) : wt = 0, ot++, --Vt[rt] === 0) {
                if (rt === lt) break;
                rt = o[a + et[ot]]
            }
            if (rt > ft && (wt & Bt) !== Pt) {
                for (bt === 0 && (bt = ft), Lt += st, yt = rt - bt, ht = 1 << yt; yt + bt < lt && (ht -= Vt[yt + bt], !(ht <= 0));) yt++, ht <<= 1;
                if (vt += 1 << yt, s === LENS$1 && vt > ENOUGH_LENS$1 || s === DISTS$1 && vt > ENOUGH_DISTS$1) return 1;
                Pt = wt & Bt, j[Pt] = ft << 24 | yt << 16 | Lt - _e | 0
            }
        }
        return wt !== 0 && (j[Lt + wt] = rt - bt << 24 | 64 << 16 | 0), tt.bits = ft, 0
    };
var inftrees = inflate_table;
const CODES = 0,
    LENS = 1,
    DISTS = 2,
    {
        Z_FINISH: Z_FINISH$1,
        Z_BLOCK,
        Z_TREES,
        Z_OK: Z_OK$1,
        Z_STREAM_END: Z_STREAM_END$1,
        Z_NEED_DICT: Z_NEED_DICT$1,
        Z_STREAM_ERROR: Z_STREAM_ERROR$1,
        Z_DATA_ERROR: Z_DATA_ERROR$1,
        Z_MEM_ERROR: Z_MEM_ERROR$1,
        Z_BUF_ERROR,
        Z_DEFLATED
    } = constants$2,
    HEAD = 16180,
    FLAGS = 16181,
    TIME = 16182,
    OS = 16183,
    EXLEN = 16184,
    EXTRA = 16185,
    NAME = 16186,
    COMMENT = 16187,
    HCRC = 16188,
    DICTID = 16189,
    DICT = 16190,
    TYPE = 16191,
    TYPEDO = 16192,
    STORED = 16193,
    COPY_ = 16194,
    COPY = 16195,
    TABLE = 16196,
    LENLENS = 16197,
    CODELENS = 16198,
    LEN_ = 16199,
    LEN = 16200,
    LENEXT = 16201,
    DIST = 16202,
    DISTEXT = 16203,
    MATCH = 16204,
    LIT = 16205,
    CHECK = 16206,
    LENGTH = 16207,
    DONE = 16208,
    BAD = 16209,
    MEM = 16210,
    SYNC = 16211,
    ENOUGH_LENS = 852,
    ENOUGH_DISTS = 592,
    MAX_WBITS = 15,
    DEF_WBITS = MAX_WBITS,
    zswap32 = s => (s >>> 24 & 255) + (s >>> 8 & 65280) + ((s & 65280) << 8) + ((s & 255) << 24);

function InflateState() {
    this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
}
const inflateStateCheck = s => {
        if (!s) return 1;
        const o = s.state;
        return !o || o.strm !== s || o.mode < HEAD || o.mode > SYNC ? 1 : 0
    },
    inflateResetKeep = s => {
        if (inflateStateCheck(s)) return Z_STREAM_ERROR$1;
        const o = s.state;
        return s.total_in = s.total_out = o.total = 0, s.msg = "", o.wrap && (s.adler = o.wrap & 1), o.mode = HEAD, o.last = 0, o.havedict = 0, o.flags = -1, o.dmax = 32768, o.head = null, o.hold = 0, o.bits = 0, o.lencode = o.lendyn = new Int32Array(ENOUGH_LENS), o.distcode = o.distdyn = new Int32Array(ENOUGH_DISTS), o.sane = 1, o.back = -1, Z_OK$1
    },
    inflateReset = s => {
        if (inflateStateCheck(s)) return Z_STREAM_ERROR$1;
        const o = s.state;
        return o.wsize = 0, o.whave = 0, o.wnext = 0, inflateResetKeep(s)
    },
    inflateReset2 = (s, o) => {
        let a;
        if (inflateStateCheck(s)) return Z_STREAM_ERROR$1;
        const $ = s.state;
        return o < 0 ? (a = 0, o = -o) : (a = (o >> 4) + 5, o < 48 && (o &= 15)), o && (o < 8 || o > 15) ? Z_STREAM_ERROR$1 : ($.window !== null && $.wbits !== o && ($.window = null), $.wrap = a, $.wbits = o, inflateReset(s))
    },
    inflateInit2 = (s, o) => {
        if (!s) return Z_STREAM_ERROR$1;
        const a = new InflateState;
        s.state = a, a.strm = s, a.window = null, a.mode = HEAD;
        const $ = inflateReset2(s, o);
        return $ !== Z_OK$1 && (s.state = null), $
    },
    inflateInit = s => inflateInit2(s, DEF_WBITS);
let virgin = !0,
    lenfix, distfix;
const fixedtables = s => {
        if (virgin) {
            lenfix = new Int32Array(512), distfix = new Int32Array(32);
            let o = 0;
            for (; o < 144;) s.lens[o++] = 8;
            for (; o < 256;) s.lens[o++] = 9;
            for (; o < 280;) s.lens[o++] = 7;
            for (; o < 288;) s.lens[o++] = 8;
            for (inftrees(LENS, s.lens, 0, 288, lenfix, 0, s.work, {
                    bits: 9
                }), o = 0; o < 32;) s.lens[o++] = 5;
            inftrees(DISTS, s.lens, 0, 32, distfix, 0, s.work, {
                bits: 5
            }), virgin = !1
        }
        s.lencode = lenfix, s.lenbits = 9, s.distcode = distfix, s.distbits = 5
    },
    updatewindow = (s, o, a, $) => {
        let j;
        const _e = s.state;
        return _e.window === null && (_e.wsize = 1 << _e.wbits, _e.wnext = 0, _e.whave = 0, _e.window = new Uint8Array(_e.wsize)), $ >= _e.wsize ? (_e.window.set(o.subarray(a - _e.wsize, a), 0), _e.wnext = 0, _e.whave = _e.wsize) : (j = _e.wsize - _e.wnext, j > $ && (j = $), _e.window.set(o.subarray(a - $, a - $ + j), _e.wnext), $ -= j, $ ? (_e.window.set(o.subarray(a - $, a), 0), _e.wnext = $, _e.whave = _e.wsize) : (_e.wnext += j, _e.wnext === _e.wsize && (_e.wnext = 0), _e.whave < _e.wsize && (_e.whave += j))), 0
    },
    inflate$2 = (s, o) => {
        let a, $, j, _e, et, tt, nt, rt, ot, st, lt, ft, yt, bt, ht = 0,
            vt, wt, gt, At, Pt, Bt, Lt, Nt;
        const Ut = new Uint8Array(4);
        let Vt, Ft;
        const Wt = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (inflateStateCheck(s) || !s.output || !s.input && s.avail_in !== 0) return Z_STREAM_ERROR$1;
        a = s.state, a.mode === TYPE && (a.mode = TYPEDO), et = s.next_out, j = s.output, nt = s.avail_out, _e = s.next_in, $ = s.input, tt = s.avail_in, rt = a.hold, ot = a.bits, st = tt, lt = nt, Nt = Z_OK$1;
        e: for (;;) switch (a.mode) {
            case HEAD:
                if (a.wrap === 0) {
                    a.mode = TYPEDO;
                    break
                }
                for (; ot < 16;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                if (a.wrap & 2 && rt === 35615) {
                    a.wbits === 0 && (a.wbits = 15), a.check = 0, Ut[0] = rt & 255, Ut[1] = rt >>> 8 & 255, a.check = crc32_1(a.check, Ut, 2, 0), rt = 0, ot = 0, a.mode = FLAGS;
                    break
                }
                if (a.head && (a.head.done = !1), !(a.wrap & 1) || (((rt & 255) << 8) + (rt >> 8)) % 31) {
                    s.msg = "incorrect header check", a.mode = BAD;
                    break
                }
                if ((rt & 15) !== Z_DEFLATED) {
                    s.msg = "unknown compression method", a.mode = BAD;
                    break
                }
                if (rt >>>= 4, ot -= 4, Lt = (rt & 15) + 8, a.wbits === 0 && (a.wbits = Lt), Lt > 15 || Lt > a.wbits) {
                    s.msg = "invalid window size", a.mode = BAD;
                    break
                }
                a.dmax = 1 << a.wbits, a.flags = 0, s.adler = a.check = 1, a.mode = rt & 512 ? DICTID : TYPE, rt = 0, ot = 0;
                break;
            case FLAGS:
                for (; ot < 16;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                if (a.flags = rt, (a.flags & 255) !== Z_DEFLATED) {
                    s.msg = "unknown compression method", a.mode = BAD;
                    break
                }
                if (a.flags & 57344) {
                    s.msg = "unknown header flags set", a.mode = BAD;
                    break
                }
                a.head && (a.head.text = rt >> 8 & 1), a.flags & 512 && a.wrap & 4 && (Ut[0] = rt & 255, Ut[1] = rt >>> 8 & 255, a.check = crc32_1(a.check, Ut, 2, 0)), rt = 0, ot = 0, a.mode = TIME;
            case TIME:
                for (; ot < 32;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                a.head && (a.head.time = rt), a.flags & 512 && a.wrap & 4 && (Ut[0] = rt & 255, Ut[1] = rt >>> 8 & 255, Ut[2] = rt >>> 16 & 255, Ut[3] = rt >>> 24 & 255, a.check = crc32_1(a.check, Ut, 4, 0)), rt = 0, ot = 0, a.mode = OS;
            case OS:
                for (; ot < 16;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                a.head && (a.head.xflags = rt & 255, a.head.os = rt >> 8), a.flags & 512 && a.wrap & 4 && (Ut[0] = rt & 255, Ut[1] = rt >>> 8 & 255, a.check = crc32_1(a.check, Ut, 2, 0)), rt = 0, ot = 0, a.mode = EXLEN;
            case EXLEN:
                if (a.flags & 1024) {
                    for (; ot < 16;) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    a.length = rt, a.head && (a.head.extra_len = rt), a.flags & 512 && a.wrap & 4 && (Ut[0] = rt & 255, Ut[1] = rt >>> 8 & 255, a.check = crc32_1(a.check, Ut, 2, 0)), rt = 0, ot = 0
                } else a.head && (a.head.extra = null);
                a.mode = EXTRA;
            case EXTRA:
                if (a.flags & 1024 && (ft = a.length, ft > tt && (ft = tt), ft && (a.head && (Lt = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Uint8Array(a.head.extra_len)), a.head.extra.set($.subarray(_e, _e + ft), Lt)), a.flags & 512 && a.wrap & 4 && (a.check = crc32_1(a.check, $, ft, _e)), tt -= ft, _e += ft, a.length -= ft), a.length)) break e;
                a.length = 0, a.mode = NAME;
            case NAME:
                if (a.flags & 2048) {
                    if (tt === 0) break e;
                    ft = 0;
                    do Lt = $[_e + ft++], a.head && Lt && a.length < 65536 && (a.head.name += String.fromCharCode(Lt)); while (Lt && ft < tt);
                    if (a.flags & 512 && a.wrap & 4 && (a.check = crc32_1(a.check, $, ft, _e)), tt -= ft, _e += ft, Lt) break e
                } else a.head && (a.head.name = null);
                a.length = 0, a.mode = COMMENT;
            case COMMENT:
                if (a.flags & 4096) {
                    if (tt === 0) break e;
                    ft = 0;
                    do Lt = $[_e + ft++], a.head && Lt && a.length < 65536 && (a.head.comment += String.fromCharCode(Lt)); while (Lt && ft < tt);
                    if (a.flags & 512 && a.wrap & 4 && (a.check = crc32_1(a.check, $, ft, _e)), tt -= ft, _e += ft, Lt) break e
                } else a.head && (a.head.comment = null);
                a.mode = HCRC;
            case HCRC:
                if (a.flags & 512) {
                    for (; ot < 16;) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    if (a.wrap & 4 && rt !== (a.check & 65535)) {
                        s.msg = "header crc mismatch", a.mode = BAD;
                        break
                    }
                    rt = 0, ot = 0
                }
                a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), s.adler = a.check = 0, a.mode = TYPE;
                break;
            case DICTID:
                for (; ot < 32;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                s.adler = a.check = zswap32(rt), rt = 0, ot = 0, a.mode = DICT;
            case DICT:
                if (a.havedict === 0) return s.next_out = et, s.avail_out = nt, s.next_in = _e, s.avail_in = tt, a.hold = rt, a.bits = ot, Z_NEED_DICT$1;
                s.adler = a.check = 1, a.mode = TYPE;
            case TYPE:
                if (o === Z_BLOCK || o === Z_TREES) break e;
            case TYPEDO:
                if (a.last) {
                    rt >>>= ot & 7, ot -= ot & 7, a.mode = CHECK;
                    break
                }
                for (; ot < 3;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                switch (a.last = rt & 1, rt >>>= 1, ot -= 1, rt & 3) {
                    case 0:
                        a.mode = STORED;
                        break;
                    case 1:
                        if (fixedtables(a), a.mode = LEN_, o === Z_TREES) {
                            rt >>>= 2, ot -= 2;
                            break e
                        }
                        break;
                    case 2:
                        a.mode = TABLE;
                        break;
                    case 3:
                        s.msg = "invalid block type", a.mode = BAD
                }
                rt >>>= 2, ot -= 2;
                break;
            case STORED:
                for (rt >>>= ot & 7, ot -= ot & 7; ot < 32;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                if ((rt & 65535) !== (rt >>> 16 ^ 65535)) {
                    s.msg = "invalid stored block lengths", a.mode = BAD;
                    break
                }
                if (a.length = rt & 65535, rt = 0, ot = 0, a.mode = COPY_, o === Z_TREES) break e;
            case COPY_:
                a.mode = COPY;
            case COPY:
                if (ft = a.length, ft) {
                    if (ft > tt && (ft = tt), ft > nt && (ft = nt), ft === 0) break e;
                    j.set($.subarray(_e, _e + ft), et), tt -= ft, _e += ft, nt -= ft, et += ft, a.length -= ft;
                    break
                }
                a.mode = TYPE;
                break;
            case TABLE:
                for (; ot < 14;) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                if (a.nlen = (rt & 31) + 257, rt >>>= 5, ot -= 5, a.ndist = (rt & 31) + 1, rt >>>= 5, ot -= 5, a.ncode = (rt & 15) + 4, rt >>>= 4, ot -= 4, a.nlen > 286 || a.ndist > 30) {
                    s.msg = "too many length or distance symbols", a.mode = BAD;
                    break
                }
                a.have = 0, a.mode = LENLENS;
            case LENLENS:
                for (; a.have < a.ncode;) {
                    for (; ot < 3;) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    a.lens[Wt[a.have++]] = rt & 7, rt >>>= 3, ot -= 3
                }
                for (; a.have < 19;) a.lens[Wt[a.have++]] = 0;
                if (a.lencode = a.lendyn, a.lenbits = 7, Vt = {
                        bits: a.lenbits
                    }, Nt = inftrees(CODES, a.lens, 0, 19, a.lencode, 0, a.work, Vt), a.lenbits = Vt.bits, Nt) {
                    s.msg = "invalid code lengths set", a.mode = BAD;
                    break
                }
                a.have = 0, a.mode = CODELENS;
            case CODELENS:
                for (; a.have < a.nlen + a.ndist;) {
                    for (; ht = a.lencode[rt & (1 << a.lenbits) - 1], vt = ht >>> 24, wt = ht >>> 16 & 255, gt = ht & 65535, !(vt <= ot);) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    if (gt < 16) rt >>>= vt, ot -= vt, a.lens[a.have++] = gt;
                    else {
                        if (gt === 16) {
                            for (Ft = vt + 2; ot < Ft;) {
                                if (tt === 0) break e;
                                tt--, rt += $[_e++] << ot, ot += 8
                            }
                            if (rt >>>= vt, ot -= vt, a.have === 0) {
                                s.msg = "invalid bit length repeat", a.mode = BAD;
                                break
                            }
                            Lt = a.lens[a.have - 1], ft = 3 + (rt & 3), rt >>>= 2, ot -= 2
                        } else if (gt === 17) {
                            for (Ft = vt + 3; ot < Ft;) {
                                if (tt === 0) break e;
                                tt--, rt += $[_e++] << ot, ot += 8
                            }
                            rt >>>= vt, ot -= vt, Lt = 0, ft = 3 + (rt & 7), rt >>>= 3, ot -= 3
                        } else {
                            for (Ft = vt + 7; ot < Ft;) {
                                if (tt === 0) break e;
                                tt--, rt += $[_e++] << ot, ot += 8
                            }
                            rt >>>= vt, ot -= vt, Lt = 0, ft = 11 + (rt & 127), rt >>>= 7, ot -= 7
                        }
                        if (a.have + ft > a.nlen + a.ndist) {
                            s.msg = "invalid bit length repeat", a.mode = BAD;
                            break
                        }
                        for (; ft--;) a.lens[a.have++] = Lt
                    }
                }
                if (a.mode === BAD) break;
                if (a.lens[256] === 0) {
                    s.msg = "invalid code -- missing end-of-block", a.mode = BAD;
                    break
                }
                if (a.lenbits = 9, Vt = {
                        bits: a.lenbits
                    }, Nt = inftrees(LENS, a.lens, 0, a.nlen, a.lencode, 0, a.work, Vt), a.lenbits = Vt.bits, Nt) {
                    s.msg = "invalid literal/lengths set", a.mode = BAD;
                    break
                }
                if (a.distbits = 6, a.distcode = a.distdyn, Vt = {
                        bits: a.distbits
                    }, Nt = inftrees(DISTS, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, Vt), a.distbits = Vt.bits, Nt) {
                    s.msg = "invalid distances set", a.mode = BAD;
                    break
                }
                if (a.mode = LEN_, o === Z_TREES) break e;
            case LEN_:
                a.mode = LEN;
            case LEN:
                if (tt >= 6 && nt >= 258) {
                    s.next_out = et, s.avail_out = nt, s.next_in = _e, s.avail_in = tt, a.hold = rt, a.bits = ot, inffast(s, lt), et = s.next_out, j = s.output, nt = s.avail_out, _e = s.next_in, $ = s.input, tt = s.avail_in, rt = a.hold, ot = a.bits, a.mode === TYPE && (a.back = -1);
                    break
                }
                for (a.back = 0; ht = a.lencode[rt & (1 << a.lenbits) - 1], vt = ht >>> 24, wt = ht >>> 16 & 255, gt = ht & 65535, !(vt <= ot);) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                if (wt && !(wt & 240)) {
                    for (At = vt, Pt = wt, Bt = gt; ht = a.lencode[Bt + ((rt & (1 << At + Pt) - 1) >> At)], vt = ht >>> 24, wt = ht >>> 16 & 255, gt = ht & 65535, !(At + vt <= ot);) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    rt >>>= At, ot -= At, a.back += At
                }
                if (rt >>>= vt, ot -= vt, a.back += vt, a.length = gt, wt === 0) {
                    a.mode = LIT;
                    break
                }
                if (wt & 32) {
                    a.back = -1, a.mode = TYPE;
                    break
                }
                if (wt & 64) {
                    s.msg = "invalid literal/length code", a.mode = BAD;
                    break
                }
                a.extra = wt & 15, a.mode = LENEXT;
            case LENEXT:
                if (a.extra) {
                    for (Ft = a.extra; ot < Ft;) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    a.length += rt & (1 << a.extra) - 1, rt >>>= a.extra, ot -= a.extra, a.back += a.extra
                }
                a.was = a.length, a.mode = DIST;
            case DIST:
                for (; ht = a.distcode[rt & (1 << a.distbits) - 1], vt = ht >>> 24, wt = ht >>> 16 & 255, gt = ht & 65535, !(vt <= ot);) {
                    if (tt === 0) break e;
                    tt--, rt += $[_e++] << ot, ot += 8
                }
                if (!(wt & 240)) {
                    for (At = vt, Pt = wt, Bt = gt; ht = a.distcode[Bt + ((rt & (1 << At + Pt) - 1) >> At)], vt = ht >>> 24, wt = ht >>> 16 & 255, gt = ht & 65535, !(At + vt <= ot);) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    rt >>>= At, ot -= At, a.back += At
                }
                if (rt >>>= vt, ot -= vt, a.back += vt, wt & 64) {
                    s.msg = "invalid distance code", a.mode = BAD;
                    break
                }
                a.offset = gt, a.extra = wt & 15, a.mode = DISTEXT;
            case DISTEXT:
                if (a.extra) {
                    for (Ft = a.extra; ot < Ft;) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    a.offset += rt & (1 << a.extra) - 1, rt >>>= a.extra, ot -= a.extra, a.back += a.extra
                }
                if (a.offset > a.dmax) {
                    s.msg = "invalid distance too far back", a.mode = BAD;
                    break
                }
                a.mode = MATCH;
            case MATCH:
                if (nt === 0) break e;
                if (ft = lt - nt, a.offset > ft) {
                    if (ft = a.offset - ft, ft > a.whave && a.sane) {
                        s.msg = "invalid distance too far back", a.mode = BAD;
                        break
                    }
                    ft > a.wnext ? (ft -= a.wnext, yt = a.wsize - ft) : yt = a.wnext - ft, ft > a.length && (ft = a.length), bt = a.window
                } else bt = j, yt = et - a.offset, ft = a.length;
                ft > nt && (ft = nt), nt -= ft, a.length -= ft;
                do j[et++] = bt[yt++]; while (--ft);
                a.length === 0 && (a.mode = LEN);
                break;
            case LIT:
                if (nt === 0) break e;
                j[et++] = a.length, nt--, a.mode = LEN;
                break;
            case CHECK:
                if (a.wrap) {
                    for (; ot < 32;) {
                        if (tt === 0) break e;
                        tt--, rt |= $[_e++] << ot, ot += 8
                    }
                    if (lt -= nt, s.total_out += lt, a.total += lt, a.wrap & 4 && lt && (s.adler = a.check = a.flags ? crc32_1(a.check, j, lt, et - lt) : adler32_1(a.check, j, lt, et - lt)), lt = nt, a.wrap & 4 && (a.flags ? rt : zswap32(rt)) !== a.check) {
                        s.msg = "incorrect data check", a.mode = BAD;
                        break
                    }
                    rt = 0, ot = 0
                }
                a.mode = LENGTH;
            case LENGTH:
                if (a.wrap && a.flags) {
                    for (; ot < 32;) {
                        if (tt === 0) break e;
                        tt--, rt += $[_e++] << ot, ot += 8
                    }
                    if (a.wrap & 4 && rt !== (a.total & 4294967295)) {
                        s.msg = "incorrect length check", a.mode = BAD;
                        break
                    }
                    rt = 0, ot = 0
                }
                a.mode = DONE;
            case DONE:
                Nt = Z_STREAM_END$1;
                break e;
            case BAD:
                Nt = Z_DATA_ERROR$1;
                break e;
            case MEM:
                return Z_MEM_ERROR$1;
            case SYNC:
            default:
                return Z_STREAM_ERROR$1
        }
        return s.next_out = et, s.avail_out = nt, s.next_in = _e, s.avail_in = tt, a.hold = rt, a.bits = ot, (a.wsize || lt !== s.avail_out && a.mode < BAD && (a.mode < CHECK || o !== Z_FINISH$1)) && updatewindow(s, s.output, s.next_out, lt - s.avail_out), st -= s.avail_in, lt -= s.avail_out, s.total_in += st, s.total_out += lt, a.total += lt, a.wrap & 4 && lt && (s.adler = a.check = a.flags ? crc32_1(a.check, j, lt, s.next_out - lt) : adler32_1(a.check, j, lt, s.next_out - lt)), s.data_type = a.bits + (a.last ? 64 : 0) + (a.mode === TYPE ? 128 : 0) + (a.mode === LEN_ || a.mode === COPY_ ? 256 : 0), (st === 0 && lt === 0 || o === Z_FINISH$1) && Nt === Z_OK$1 && (Nt = Z_BUF_ERROR), Nt
    },
    inflateEnd = s => {
        if (inflateStateCheck(s)) return Z_STREAM_ERROR$1;
        let o = s.state;
        return o.window && (o.window = null), s.state = null, Z_OK$1
    },
    inflateGetHeader = (s, o) => {
        if (inflateStateCheck(s)) return Z_STREAM_ERROR$1;
        const a = s.state;
        return a.wrap & 2 ? (a.head = o, o.done = !1, Z_OK$1) : Z_STREAM_ERROR$1
    },
    inflateSetDictionary = (s, o) => {
        const a = o.length;
        let $, j, _e;
        return inflateStateCheck(s) || ($ = s.state, $.wrap !== 0 && $.mode !== DICT) ? Z_STREAM_ERROR$1 : $.mode === DICT && (j = 1, j = adler32_1(j, o, a, 0), j !== $.check) ? Z_DATA_ERROR$1 : (_e = updatewindow(s, o, a, a), _e ? ($.mode = MEM, Z_MEM_ERROR$1) : ($.havedict = 1, Z_OK$1))
    };
var inflateReset_1 = inflateReset,
    inflateReset2_1 = inflateReset2,
    inflateResetKeep_1 = inflateResetKeep,
    inflateInit_1 = inflateInit,
    inflateInit2_1 = inflateInit2,
    inflate_2$1 = inflate$2,
    inflateEnd_1 = inflateEnd,
    inflateGetHeader_1 = inflateGetHeader,
    inflateSetDictionary_1 = inflateSetDictionary,
    inflateInfo = "pako inflate (from Nodeca project)",
    inflate_1$2 = {
        inflateReset: inflateReset_1,
        inflateReset2: inflateReset2_1,
        inflateResetKeep: inflateResetKeep_1,
        inflateInit: inflateInit_1,
        inflateInit2: inflateInit2_1,
        inflate: inflate_2$1,
        inflateEnd: inflateEnd_1,
        inflateGetHeader: inflateGetHeader_1,
        inflateSetDictionary: inflateSetDictionary_1,
        inflateInfo
    };

function GZheader() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
}
var gzheader = GZheader;
const toString = Object.prototype.toString,
    {
        Z_NO_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR
    } = constants$2;

function Inflate$1(s) {
    this.options = common.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, s || {});
    const o = this.options;
    o.raw && o.windowBits >= 0 && o.windowBits < 16 && (o.windowBits = -o.windowBits, o.windowBits === 0 && (o.windowBits = -15)), o.windowBits >= 0 && o.windowBits < 16 && !(s && s.windowBits) && (o.windowBits += 32), o.windowBits > 15 && o.windowBits < 48 && (o.windowBits & 15 || (o.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0;
    let a = inflate_1$2.inflateInit2(this.strm, o.windowBits);
    if (a !== Z_OK) throw new Error(messages[a]);
    if (this.header = new gzheader, inflate_1$2.inflateGetHeader(this.strm, this.header), o.dictionary && (typeof o.dictionary == "string" ? o.dictionary = strings.string2buf(o.dictionary) : toString.call(o.dictionary) === "[object ArrayBuffer]" && (o.dictionary = new Uint8Array(o.dictionary)), o.raw && (a = inflate_1$2.inflateSetDictionary(this.strm, o.dictionary), a !== Z_OK))) throw new Error(messages[a])
}
Inflate$1.prototype.push = function(s, o) {
    const a = this.strm,
        $ = this.options.chunkSize,
        j = this.options.dictionary;
    let _e, et, tt;
    if (this.ended) return !1;
    for (o === ~~o ? et = o : et = o === !0 ? Z_FINISH : Z_NO_FLUSH, toString.call(s) === "[object ArrayBuffer]" ? a.input = new Uint8Array(s) : a.input = s, a.next_in = 0, a.avail_in = a.input.length;;) {
        for (a.avail_out === 0 && (a.output = new Uint8Array($), a.next_out = 0, a.avail_out = $), _e = inflate_1$2.inflate(a, et), _e === Z_NEED_DICT && j && (_e = inflate_1$2.inflateSetDictionary(a, j), _e === Z_OK ? _e = inflate_1$2.inflate(a, et) : _e === Z_DATA_ERROR && (_e = Z_NEED_DICT)); a.avail_in > 0 && _e === Z_STREAM_END && a.state.wrap > 0 && s[a.next_in] !== 0;) inflate_1$2.inflateReset(a), _e = inflate_1$2.inflate(a, et);
        switch (_e) {
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
                return this.onEnd(_e), this.ended = !0, !1
        }
        if (tt = a.avail_out, a.next_out && (a.avail_out === 0 || _e === Z_STREAM_END))
            if (this.options.to === "string") {
                let nt = strings.utf8border(a.output, a.next_out),
                    rt = a.next_out - nt,
                    ot = strings.buf2string(a.output, nt);
                a.next_out = rt, a.avail_out = $ - rt, rt && a.output.set(a.output.subarray(nt, nt + rt), 0), this.onData(ot)
            } else this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out));
        if (!(_e === Z_OK && tt === 0)) {
            if (_e === Z_STREAM_END) return _e = inflate_1$2.inflateEnd(this.strm), this.onEnd(_e), this.ended = !0, !0;
            if (a.avail_in === 0) break
        }
    }
    return !0
};
Inflate$1.prototype.onData = function(s) {
    this.chunks.push(s)
};
Inflate$1.prototype.onEnd = function(s) {
    s === Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = s, this.msg = this.strm.msg
};

function inflate$1(s, o) {
    const a = new Inflate$1(o);
    if (a.push(s), a.err) throw a.msg || messages[a.err];
    return a.result
}

function inflateRaw$1(s, o) {
    return o = o || {}, o.raw = !0, inflate$1(s, o)
}
var Inflate_1$1 = Inflate$1,
    inflate_2 = inflate$1,
    inflateRaw_1$1 = inflateRaw$1,
    ungzip$1 = inflate$1,
    constants = constants$2,
    inflate_1$1 = {
        Inflate: Inflate_1$1,
        inflate: inflate_2,
        inflateRaw: inflateRaw_1$1,
        ungzip: ungzip$1,
        constants
    };
const {
    Inflate,
    inflate,
    inflateRaw,
    ungzip
} = inflate_1$1;
var inflate_1 = inflate,
    eventemitter3 = {
        exports: {}
    };
(function(s) {
    var o = Object.prototype.hasOwnProperty,
        a = "~";

    function $() {}
    Object.create && ($.prototype = Object.create(null), new $().__proto__ || (a = !1));

    function j(nt, rt, ot) {
        this.fn = nt, this.context = rt, this.once = ot || !1
    }

    function _e(nt, rt, ot, st, lt) {
        if (typeof ot != "function") throw new TypeError("The listener must be a function");
        var ft = new j(ot, st || nt, lt),
            yt = a ? a + rt : rt;
        return nt._events[yt] ? nt._events[yt].fn ? nt._events[yt] = [nt._events[yt], ft] : nt._events[yt].push(ft) : (nt._events[yt] = ft, nt._eventsCount++), nt
    }

    function et(nt, rt) {
        --nt._eventsCount === 0 ? nt._events = new $ : delete nt._events[rt]
    }

    function tt() {
        this._events = new $, this._eventsCount = 0
    }
    tt.prototype.eventNames = function() {
        var rt = [],
            ot, st;
        if (this._eventsCount === 0) return rt;
        for (st in ot = this._events) o.call(ot, st) && rt.push(a ? st.slice(1) : st);
        return Object.getOwnPropertySymbols ? rt.concat(Object.getOwnPropertySymbols(ot)) : rt
    }, tt.prototype.listeners = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        if (!st) return [];
        if (st.fn) return [st.fn];
        for (var lt = 0, ft = st.length, yt = new Array(ft); lt < ft; lt++) yt[lt] = st[lt].fn;
        return yt
    }, tt.prototype.listenerCount = function(rt) {
        var ot = a ? a + rt : rt,
            st = this._events[ot];
        return st ? st.fn ? 1 : st.length : 0
    }, tt.prototype.emit = function(rt, ot, st, lt, ft, yt) {
        var bt = a ? a + rt : rt;
        if (!this._events[bt]) return !1;
        var ht = this._events[bt],
            vt = arguments.length,
            wt, gt;
        if (ht.fn) {
            switch (ht.once && this.removeListener(rt, ht.fn, void 0, !0), vt) {
                case 1:
                    return ht.fn.call(ht.context), !0;
                case 2:
                    return ht.fn.call(ht.context, ot), !0;
                case 3:
                    return ht.fn.call(ht.context, ot, st), !0;
                case 4:
                    return ht.fn.call(ht.context, ot, st, lt), !0;
                case 5:
                    return ht.fn.call(ht.context, ot, st, lt, ft), !0;
                case 6:
                    return ht.fn.call(ht.context, ot, st, lt, ft, yt), !0
            }
            for (gt = 1, wt = new Array(vt - 1); gt < vt; gt++) wt[gt - 1] = arguments[gt];
            ht.fn.apply(ht.context, wt)
        } else {
            var At = ht.length,
                Pt;
            for (gt = 0; gt < At; gt++) switch (ht[gt].once && this.removeListener(rt, ht[gt].fn, void 0, !0), vt) {
                case 1:
                    ht[gt].fn.call(ht[gt].context);
                    break;
                case 2:
                    ht[gt].fn.call(ht[gt].context, ot);
                    break;
                case 3:
                    ht[gt].fn.call(ht[gt].context, ot, st);
                    break;
                case 4:
                    ht[gt].fn.call(ht[gt].context, ot, st, lt);
                    break;
                default:
                    if (!wt)
                        for (Pt = 1, wt = new Array(vt - 1); Pt < vt; Pt++) wt[Pt - 1] = arguments[Pt];
                    ht[gt].fn.apply(ht[gt].context, wt)
            }
        }
        return !0
    }, tt.prototype.on = function(rt, ot, st) {
        return _e(this, rt, ot, st, !1)
    }, tt.prototype.once = function(rt, ot, st) {
        return _e(this, rt, ot, st, !0)
    }, tt.prototype.removeListener = function(rt, ot, st, lt) {
        var ft = a ? a + rt : rt;
        if (!this._events[ft]) return this;
        if (!ot) return et(this, ft), this;
        var yt = this._events[ft];
        if (yt.fn) yt.fn === ot && (!lt || yt.once) && (!st || yt.context === st) && et(this, ft);
        else {
            for (var bt = 0, ht = [], vt = yt.length; bt < vt; bt++)(yt[bt].fn !== ot || lt && !yt[bt].once || st && yt[bt].context !== st) && ht.push(yt[bt]);
            ht.length ? this._events[ft] = ht.length === 1 ? ht[0] : ht : et(this, ft)
        }
        return this
    }, tt.prototype.removeAllListeners = function(rt) {
        var ot;
        return rt ? (ot = a ? a + rt : rt, this._events[ot] && et(this, ot)) : (this._events = new $, this._eventsCount = 0), this
    }, tt.prototype.off = tt.prototype.removeListener, tt.prototype.addListener = tt.prototype.on, tt.prefixed = a, tt.EventEmitter = tt, s.exports = tt
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = getDefaultExportFromCjs$3(eventemitter3Exports);
var assert$1 = {
        exports: {}
    },
    errors = {},
    util = {},
    types = {},
    shams$1 = function s() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var o = {},
            a = Symbol("test"),
            $ = Object(a);
        if (typeof a == "string" || Object.prototype.toString.call(a) !== "[object Symbol]" || Object.prototype.toString.call($) !== "[object Symbol]") return !1;
        var j = 42;
        o[a] = j;
        for (a in o) return !1;
        if (typeof Object.keys == "function" && Object.keys(o).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(o).length !== 0) return !1;
        var _e = Object.getOwnPropertySymbols(o);
        if (_e.length !== 1 || _e[0] !== a || !Object.prototype.propertyIsEnumerable.call(o, a)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var et = Object.getOwnPropertyDescriptor(o, a);
            if (et.value !== j || et.enumerable !== !0) return !1
        }
        return !0
    },
    hasSymbols$3 = shams$1,
    shams = function s() {
        return hasSymbols$3() && !!Symbol.toStringTag
    },
    esErrors = Error,
    _eval = EvalError,
    range = RangeError,
    ref = ReferenceError,
    syntax = SyntaxError,
    type$1 = TypeError,
    uri = URIError,
    origSymbol = typeof Symbol < "u" && Symbol,
    hasSymbolSham = shams$1,
    hasSymbols$2 = function s() {
        return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham()
    },
    test = {
        __proto__: null,
        foo: {}
    },
    $Object = Object,
    hasProto$1 = function s() {
        return {
            __proto__: test
        }.foo === test.foo && !(test instanceof $Object)
    },
    ERROR_MESSAGE = "Function.prototype.bind called on incompatible ",
    toStr$4 = Object.prototype.toString,
    max = Math.max,
    funcType = "[object Function]",
    concatty = function s(o, a) {
        for (var $ = [], j = 0; j < o.length; j += 1) $[j] = o[j];
        for (var _e = 0; _e < a.length; _e += 1) $[_e + o.length] = a[_e];
        return $
    },
    slicy = function s(o, a) {
        for (var $ = [], j = a, _e = 0; j < o.length; j += 1, _e += 1) $[_e] = o[j];
        return $
    },
    joiny = function(s, o) {
        for (var a = "", $ = 0; $ < s.length; $ += 1) a += s[$], $ + 1 < s.length && (a += o);
        return a
    },
    implementation$7 = function s(o) {
        var a = this;
        if (typeof a != "function" || toStr$4.apply(a) !== funcType) throw new TypeError(ERROR_MESSAGE + a);
        for (var $ = slicy(arguments, 1), j, _e = function() {
                if (this instanceof j) {
                    var ot = a.apply(this, concatty($, arguments));
                    return Object(ot) === ot ? ot : this
                }
                return a.apply(o, concatty($, arguments))
            }, et = max(0, a.length - $.length), tt = [], nt = 0; nt < et; nt++) tt[nt] = "$" + nt;
        if (j = Function("binder", "return function (" + joiny(tt, ",") + "){ return binder.apply(this,arguments); }")(_e), a.prototype) {
            var rt = function() {};
            rt.prototype = a.prototype, j.prototype = new rt, rt.prototype = null
        }
        return j
    },
    implementation$6 = implementation$7,
    functionBind = Function.prototype.bind || implementation$6,
    call = Function.prototype.call,
    $hasOwn = Object.prototype.hasOwnProperty,
    bind$1 = functionBind,
    hasown = bind$1.call(call, $hasOwn),
    undefined$1, $Error = esErrors,
    $EvalError = _eval,
    $RangeError = range,
    $ReferenceError = ref,
    $SyntaxError$1 = syntax,
    $TypeError$2 = type$1,
    $URIError = uri,
    $Function = Function,
    getEvalledConstructor = function(s) {
        try {
            return $Function('"use strict"; return (' + s + ").constructor;")()
        } catch {}
    },
    $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) try {
    $gOPD$1({}, "")
} catch {
    $gOPD$1 = null
}
var throwTypeError = function() {
        throw new $TypeError$2
    },
    ThrowTypeError = $gOPD$1 ? function() {
        try {
            return arguments.callee, throwTypeError
        } catch {
            try {
                return $gOPD$1(arguments, "callee").get
            } catch {
                return throwTypeError
            }
        }
    }() : throwTypeError,
    hasSymbols$1 = hasSymbols$2(),
    hasProto = hasProto$1(),
    getProto$1 = Object.getPrototypeOf || (hasProto ? function(s) {
        return s.__proto__
    } : null),
    needsEval = {},
    TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array),
    INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        "%EvalError%": $EvalError,
        "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
        "%Map%": typeof Map > "u" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1("" [Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError$1,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError$2,
        "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
    };
if (getProto$1) try {
    null.error
} catch (s) {
    var errorProto = getProto$1(getProto$1(s));
    INTRINSICS["%Error.prototype%"] = errorProto
}
var doEval = function s(o) {
        var a;
        if (o === "%AsyncFunction%") a = getEvalledConstructor("async function () {}");
        else if (o === "%GeneratorFunction%") a = getEvalledConstructor("function* () {}");
        else if (o === "%AsyncGeneratorFunction%") a = getEvalledConstructor("async function* () {}");
        else if (o === "%AsyncGenerator%") {
            var $ = s("%AsyncGeneratorFunction%");
            $ && (a = $.prototype)
        } else if (o === "%AsyncIteratorPrototype%") {
            var j = s("%AsyncGenerator%");
            j && getProto$1 && (a = getProto$1(j.prototype))
        }
        return INTRINSICS[o] = a, a
    },
    LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    },
    bind = functionBind,
    hasOwn = hasown,
    $concat = bind.call(Function.call, Array.prototype.concat),
    $spliceApply = bind.call(Function.apply, Array.prototype.splice),
    $replace = bind.call(Function.call, String.prototype.replace),
    $strSlice = bind.call(Function.call, String.prototype.slice),
    $exec = bind.call(Function.call, RegExp.prototype.exec),
    rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    reEscapeChar = /\\(\\)?/g,
    stringToPath = function s(o) {
        var a = $strSlice(o, 0, 1),
            $ = $strSlice(o, -1);
        if (a === "%" && $ !== "%") throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
        if ($ === "%" && a !== "%") throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
        var j = [];
        return $replace(o, rePropName, function(_e, et, tt, nt) {
            j[j.length] = tt ? $replace(nt, reEscapeChar, "$1") : et || _e
        }), j
    },
    getBaseIntrinsic = function s(o, a) {
        var $ = o,
            j;
        if (hasOwn(LEGACY_ALIASES, $) && (j = LEGACY_ALIASES[$], $ = "%" + j[0] + "%"), hasOwn(INTRINSICS, $)) {
            var _e = INTRINSICS[$];
            if (_e === needsEval && (_e = doEval($)), typeof _e > "u" && !a) throw new $TypeError$2("intrinsic " + o + " exists, but is not available. Please file an issue!");
            return {
                alias: j,
                name: $,
                value: _e
            }
        }
        throw new $SyntaxError$1("intrinsic " + o + " does not exist!")
    },
    getIntrinsic = function s(o, a) {
        if (typeof o != "string" || o.length === 0) throw new $TypeError$2("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof a != "boolean") throw new $TypeError$2('"allowMissing" argument must be a boolean');
        if ($exec(/^%?[^%]*%?$/, o) === null) throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var $ = stringToPath(o),
            j = $.length > 0 ? $[0] : "",
            _e = getBaseIntrinsic("%" + j + "%", a),
            et = _e.name,
            tt = _e.value,
            nt = !1,
            rt = _e.alias;
        rt && (j = rt[0], $spliceApply($, $concat([0, 1], rt)));
        for (var ot = 1, st = !0; ot < $.length; ot += 1) {
            var lt = $[ot],
                ft = $strSlice(lt, 0, 1),
                yt = $strSlice(lt, -1);
            if ((ft === '"' || ft === "'" || ft === "`" || yt === '"' || yt === "'" || yt === "`") && ft !== yt) throw new $SyntaxError$1("property names with quotes must have matching quotes");
            if ((lt === "constructor" || !st) && (nt = !0), j += "." + lt, et = "%" + j + "%", hasOwn(INTRINSICS, et)) tt = INTRINSICS[et];
            else if (tt != null) {
                if (!(lt in tt)) {
                    if (!a) throw new $TypeError$2("base intrinsic for " + o + " exists, but the property is not available.");
                    return
                }
                if ($gOPD$1 && ot + 1 >= $.length) {
                    var bt = $gOPD$1(tt, lt);
                    st = !!bt, st && "get" in bt && !("originalValue" in bt.get) ? tt = bt.get : tt = tt[lt]
                } else st = hasOwn(tt, lt), tt = tt[lt];
                st && !nt && (INTRINSICS[et] = tt)
            }
        }
        return tt
    },
    callBind$2 = {
        exports: {}
    },
    esDefineProperty, hasRequiredEsDefineProperty;

function requireEsDefineProperty() {
    if (hasRequiredEsDefineProperty) return esDefineProperty;
    hasRequiredEsDefineProperty = 1;
    var s = getIntrinsic,
        o = s("%Object.defineProperty%", !0) || !1;
    if (o) try {
        o({}, "a", {
            value: 1
        })
    } catch {
        o = !1
    }
    return esDefineProperty = o, esDefineProperty
}
var GetIntrinsic$2 = getIntrinsic,
    $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD) try {
    $gOPD([], "length")
} catch {
    $gOPD = null
}
var gopd$1 = $gOPD,
    $defineProperty$1 = requireEsDefineProperty(),
    $SyntaxError = syntax,
    $TypeError$1 = type$1,
    gopd = gopd$1,
    defineDataProperty = function s(o, a, $) {
        if (!o || typeof o != "object" && typeof o != "function") throw new $TypeError$1("`obj` must be an object or a function`");
        if (typeof a != "string" && typeof a != "symbol") throw new $TypeError$1("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new $TypeError$1("`loose`, if provided, must be a boolean");
        var j = arguments.length > 3 ? arguments[3] : null,
            _e = arguments.length > 4 ? arguments[4] : null,
            et = arguments.length > 5 ? arguments[5] : null,
            tt = arguments.length > 6 ? arguments[6] : !1,
            nt = !!gopd && gopd(o, a);
        if ($defineProperty$1) $defineProperty$1(o, a, {
            configurable: et === null && nt ? nt.configurable : !et,
            enumerable: j === null && nt ? nt.enumerable : !j,
            value: $,
            writable: _e === null && nt ? nt.writable : !_e
        });
        else if (tt || !j && !_e && !et) o[a] = $;
        else throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
    },
    $defineProperty = requireEsDefineProperty(),
    hasPropertyDescriptors = function s() {
        return !!$defineProperty
    };
hasPropertyDescriptors.hasArrayLengthDefineBug = function s() {
    if (!$defineProperty) return null;
    try {
        return $defineProperty([], "length", {
            value: 1
        }).length !== 1
    } catch {
        return !0
    }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors,
    GetIntrinsic$1 = getIntrinsic,
    define$1 = defineDataProperty,
    hasDescriptors = hasPropertyDescriptors_1(),
    gOPD$1 = gopd$1,
    $TypeError = type$1,
    $floor = GetIntrinsic$1("%Math.floor%"),
    setFunctionLength = function s(o, a) {
        if (typeof o != "function") throw new $TypeError("`fn` is not a function");
        if (typeof a != "number" || a < 0 || a > 4294967295 || $floor(a) !== a) throw new $TypeError("`length` must be a positive 32-bit integer");
        var $ = arguments.length > 2 && !!arguments[2],
            j = !0,
            _e = !0;
        if ("length" in o && gOPD$1) {
            var et = gOPD$1(o, "length");
            et && !et.configurable && (j = !1), et && !et.writable && (_e = !1)
        }
        return (j || _e || !$) && (hasDescriptors ? define$1(o, "length", a, !0, !0) : define$1(o, "length", a)), o
    };
(function(s) {
    var o = functionBind,
        a = getIntrinsic,
        $ = setFunctionLength,
        j = type$1,
        _e = a("%Function.prototype.apply%"),
        et = a("%Function.prototype.call%"),
        tt = a("%Reflect.apply%", !0) || o.call(et, _e),
        nt = requireEsDefineProperty(),
        rt = a("%Math.max%");
    s.exports = function(lt) {
        if (typeof lt != "function") throw new j("a function is required");
        var ft = tt(o, et, arguments);
        return $(ft, 1 + rt(0, lt.length - (arguments.length - 1)), !0)
    };
    var ot = function() {
        return tt(o, _e, arguments)
    };
    nt ? nt(s.exports, "apply", {
        value: ot
    }) : s.exports.apply = ot
})(callBind$2);
var callBindExports = callBind$2.exports,
    GetIntrinsic = getIntrinsic,
    callBind$1 = callBindExports,
    $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")),
    callBound$3 = function s(o, a) {
        var $ = GetIntrinsic(o, !!a);
        return typeof $ == "function" && $indexOf$1(o, ".prototype.") > -1 ? callBind$1($) : $
    },
    hasToStringTag$3 = shams(),
    callBound$2 = callBound$3,
    $toString$1 = callBound$2("Object.prototype.toString"),
    isStandardArguments = function s(o) {
        return hasToStringTag$3 && o && typeof o == "object" && Symbol.toStringTag in o ? !1 : $toString$1(o) === "[object Arguments]"
    },
    isLegacyArguments = function s(o) {
        return isStandardArguments(o) ? !0 : o !== null && typeof o == "object" && typeof o.length == "number" && o.length >= 0 && $toString$1(o) !== "[object Array]" && $toString$1(o.callee) === "[object Function]"
    },
    supportsStandardArguments = function() {
        return isStandardArguments(arguments)
    }();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments,
    toStr$3 = Object.prototype.toString,
    fnToStr$1 = Function.prototype.toString,
    isFnRegex = /^\s*(?:function)?\*/,
    hasToStringTag$2 = shams(),
    getProto = Object.getPrototypeOf,
    getGeneratorFunc = function() {
        if (!hasToStringTag$2) return !1;
        try {
            return Function("return function*() {}")()
        } catch {}
    },
    GeneratorFunction, isGeneratorFunction = function s(o) {
        if (typeof o != "function") return !1;
        if (isFnRegex.test(fnToStr$1.call(o))) return !0;
        if (!hasToStringTag$2) {
            var a = toStr$3.call(o);
            return a === "[object GeneratorFunction]"
        }
        if (!getProto) return !1;
        if (typeof GeneratorFunction > "u") {
            var $ = getGeneratorFunc();
            GeneratorFunction = $ ? getProto($) : !1
        }
        return getProto(o) === GeneratorFunction
    },
    fnToStr = Function.prototype.toString,
    reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply,
    badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function") try {
    badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
            throw isCallableMarker
        }
    }), isCallableMarker = {}, reflectApply(function() {
        throw 42
    }, null, badArrayLike)
} catch (s) {
    s !== isCallableMarker && (reflectApply = null)
} else reflectApply = null;
var constructorRegex = /^\s*class\b/,
    isES6ClassFn = function s(o) {
        try {
            var a = fnToStr.call(o);
            return constructorRegex.test(a)
        } catch {
            return !1
        }
    },
    tryFunctionObject = function s(o) {
        try {
            return isES6ClassFn(o) ? !1 : (fnToStr.call(o), !0)
        } catch {
            return !1
        }
    },
    toStr$2 = Object.prototype.toString,
    objectClass = "[object Object]",
    fnClass = "[object Function]",
    genClass = "[object GeneratorFunction]",
    ddaClass = "[object HTMLAllCollection]",
    ddaClass2 = "[object HTML document.all class]",
    ddaClass3 = "[object HTMLCollection]",
    hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag,
    isIE68 = !(0 in [, ]),
    isDDA = function s() {
        return !1
    };
if (typeof document == "object") {
    var all = document.all;
    toStr$2.call(all) === toStr$2.call(document.all) && (isDDA = function(o) {
        if ((isIE68 || !o) && (typeof o > "u" || typeof o == "object")) try {
            var a = toStr$2.call(o);
            return (a === ddaClass || a === ddaClass2 || a === ddaClass3 || a === objectClass) && o("") == null
        } catch {}
        return !1
    })
}
var isCallable$1 = reflectApply ? function s(o) {
        if (isDDA(o)) return !0;
        if (!o || typeof o != "function" && typeof o != "object") return !1;
        try {
            reflectApply(o, null, badArrayLike)
        } catch (a) {
            if (a !== isCallableMarker) return !1
        }
        return !isES6ClassFn(o) && tryFunctionObject(o)
    } : function s(o) {
        if (isDDA(o)) return !0;
        if (!o || typeof o != "function" && typeof o != "object") return !1;
        if (hasToStringTag$1) return tryFunctionObject(o);
        if (isES6ClassFn(o)) return !1;
        var a = toStr$2.call(o);
        return a !== fnClass && a !== genClass && !/^\[object HTML/.test(a) ? !1 : tryFunctionObject(o)
    },
    isCallable = isCallable$1,
    toStr$1 = Object.prototype.toString,
    hasOwnProperty = Object.prototype.hasOwnProperty,
    forEachArray = function s(o, a, $) {
        for (var j = 0, _e = o.length; j < _e; j++) hasOwnProperty.call(o, j) && ($ == null ? a(o[j], j, o) : a.call($, o[j], j, o))
    },
    forEachString = function s(o, a, $) {
        for (var j = 0, _e = o.length; j < _e; j++) $ == null ? a(o.charAt(j), j, o) : a.call($, o.charAt(j), j, o)
    },
    forEachObject = function s(o, a, $) {
        for (var j in o) hasOwnProperty.call(o, j) && ($ == null ? a(o[j], j, o) : a.call($, o[j], j, o))
    },
    forEach$1 = function s(o, a, $) {
        if (!isCallable(a)) throw new TypeError("iterator must be a function");
        var j;
        arguments.length >= 3 && (j = $), toStr$1.call(o) === "[object Array]" ? forEachArray(o, a, j) : typeof o == "string" ? forEachString(o, a, j) : forEachObject(o, a, j)
    },
    forEach_1 = forEach$1,
    possibleTypedArrayNames = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"],
    possibleNames = possibleTypedArrayNames,
    g$1 = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis,
    availableTypedArrays$1 = function s() {
        for (var o = [], a = 0; a < possibleNames.length; a++) typeof g$1[possibleNames[a]] == "function" && (o[o.length] = possibleNames[a]);
        return o
    },
    forEach = forEach_1,
    availableTypedArrays = availableTypedArrays$1,
    callBind = callBindExports,
    callBound$1 = callBound$3,
    gOPD = gopd$1,
    $toString = callBound$1("Object.prototype.toString"),
    hasToStringTag = shams(),
    g = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis,
    typedArrays = availableTypedArrays(),
    $slice = callBound$1("String.prototype.slice"),
    getPrototypeOf = Object.getPrototypeOf,
    $indexOf = callBound$1("Array.prototype.indexOf", !0) || function s(o, a) {
        for (var $ = 0; $ < o.length; $ += 1)
            if (o[$] === a) return $;
        return -1
    },
    cache = {
        __proto__: null
    };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(s) {
    var o = new g[s];
    if (Symbol.toStringTag in o) {
        var a = getPrototypeOf(o),
            $ = gOPD(a, Symbol.toStringTag);
        if (!$) {
            var j = getPrototypeOf(a);
            $ = gOPD(j, Symbol.toStringTag)
        }
        cache["$" + s] = callBind($.get)
    }
}) : forEach(typedArrays, function(s) {
    var o = new g[s],
        a = o.slice || o.set;
    a && (cache["$" + s] = callBind(a))
});
var tryTypedArrays = function s(o) {
        var a = !1;
        return forEach(cache, function($, j) {
            if (!a) try {
                "$" + $(o) === j && (a = $slice(j, 1))
            } catch {}
        }), a
    },
    trySlices = function s(o) {
        var a = !1;
        return forEach(cache, function($, j) {
            if (!a) try {
                $(o), a = $slice(j, 1)
            } catch {}
        }), a
    },
    whichTypedArray$1 = function s(o) {
        if (!o || typeof o != "object") return !1;
        if (!hasToStringTag) {
            var a = $slice($toString(o), 8, -1);
            return $indexOf(typedArrays, a) > -1 ? a : a !== "Object" ? !1 : trySlices(o)
        }
        return gOPD ? tryTypedArrays(o) : null
    },
    whichTypedArray = whichTypedArray$1,
    isTypedArray = function s(o) {
        return !!whichTypedArray(o)
    };
(function(s) {
    var o = isArguments$1,
        a = isGeneratorFunction,
        $ = whichTypedArray$1,
        j = isTypedArray;

    function _e(rn) {
        return rn.call.bind(rn)
    }
    var et = typeof BigInt < "u",
        tt = typeof Symbol < "u",
        nt = _e(Object.prototype.toString),
        rt = _e(Number.prototype.valueOf),
        ot = _e(String.prototype.valueOf),
        st = _e(Boolean.prototype.valueOf);
    if (et) var lt = _e(BigInt.prototype.valueOf);
    if (tt) var ft = _e(Symbol.prototype.valueOf);

    function yt(rn, mn) {
        if (typeof rn != "object") return !1;
        try {
            return mn(rn), !0
        } catch {
            return !1
        }
    }
    s.isArgumentsObject = o, s.isGeneratorFunction = a, s.isTypedArray = j;

    function bt(rn) {
        return typeof Promise < "u" && rn instanceof Promise || rn !== null && typeof rn == "object" && typeof rn.then == "function" && typeof rn.catch == "function"
    }
    s.isPromise = bt;

    function ht(rn) {
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(rn) : j(rn) || Et(rn)
    }
    s.isArrayBufferView = ht;

    function vt(rn) {
        return $(rn) === "Uint8Array"
    }
    s.isUint8Array = vt;

    function wt(rn) {
        return $(rn) === "Uint8ClampedArray"
    }
    s.isUint8ClampedArray = wt;

    function gt(rn) {
        return $(rn) === "Uint16Array"
    }
    s.isUint16Array = gt;

    function At(rn) {
        return $(rn) === "Uint32Array"
    }
    s.isUint32Array = At;

    function Pt(rn) {
        return $(rn) === "Int8Array"
    }
    s.isInt8Array = Pt;

    function Bt(rn) {
        return $(rn) === "Int16Array"
    }
    s.isInt16Array = Bt;

    function Lt(rn) {
        return $(rn) === "Int32Array"
    }
    s.isInt32Array = Lt;

    function Nt(rn) {
        return $(rn) === "Float32Array"
    }
    s.isFloat32Array = Nt;

    function Ut(rn) {
        return $(rn) === "Float64Array"
    }
    s.isFloat64Array = Ut;

    function Vt(rn) {
        return $(rn) === "BigInt64Array"
    }
    s.isBigInt64Array = Vt;

    function Ft(rn) {
        return $(rn) === "BigUint64Array"
    }
    s.isBigUint64Array = Ft;

    function Wt(rn) {
        return nt(rn) === "[object Map]"
    }
    Wt.working = typeof Map < "u" && Wt(new Map);

    function Ct(rn) {
        return typeof Map > "u" ? !1 : Wt.working ? Wt(rn) : rn instanceof Map
    }
    s.isMap = Ct;

    function it(rn) {
        return nt(rn) === "[object Set]"
    }
    it.working = typeof Set < "u" && it(new Set);

    function at(rn) {
        return typeof Set > "u" ? !1 : it.working ? it(rn) : rn instanceof Set
    }
    s.isSet = at;

    function mt(rn) {
        return nt(rn) === "[object WeakMap]"
    }
    mt.working = typeof WeakMap < "u" && mt(new WeakMap);

    function xt(rn) {
        return typeof WeakMap > "u" ? !1 : mt.working ? mt(rn) : rn instanceof WeakMap
    }
    s.isWeakMap = xt;

    function $t(rn) {
        return nt(rn) === "[object WeakSet]"
    }
    $t.working = typeof WeakSet < "u" && $t(new WeakSet);

    function Rt(rn) {
        return $t(rn)
    }
    s.isWeakSet = Rt;

    function It(rn) {
        return nt(rn) === "[object ArrayBuffer]"
    }
    It.working = typeof ArrayBuffer < "u" && It(new ArrayBuffer);

    function Tt(rn) {
        return typeof ArrayBuffer > "u" ? !1 : It.working ? It(rn) : rn instanceof ArrayBuffer
    }
    s.isArrayBuffer = Tt;

    function dt(rn) {
        return nt(rn) === "[object DataView]"
    }
    dt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && dt(new DataView(new ArrayBuffer(1), 0, 1));

    function Et(rn) {
        return typeof DataView > "u" ? !1 : dt.working ? dt(rn) : rn instanceof DataView
    }
    s.isDataView = Et;
    var Ot = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;

    function Mt(rn) {
        return nt(rn) === "[object SharedArrayBuffer]"
    }

    function jt(rn) {
        return typeof Ot > "u" ? !1 : (typeof Mt.working > "u" && (Mt.working = Mt(new Ot)), Mt.working ? Mt(rn) : rn instanceof Ot)
    }
    s.isSharedArrayBuffer = jt;

    function Qt(rn) {
        return nt(rn) === "[object AsyncFunction]"
    }
    s.isAsyncFunction = Qt;

    function Kt(rn) {
        return nt(rn) === "[object Map Iterator]"
    }
    s.isMapIterator = Kt;

    function qt(rn) {
        return nt(rn) === "[object Set Iterator]"
    }
    s.isSetIterator = qt;

    function Jt(rn) {
        return nt(rn) === "[object Generator]"
    }
    s.isGeneratorObject = Jt;

    function Zt(rn) {
        return nt(rn) === "[object WebAssembly.Module]"
    }
    s.isWebAssemblyCompiledModule = Zt;

    function en(rn) {
        return yt(rn, rt)
    }
    s.isNumberObject = en;

    function ln(rn) {
        return yt(rn, ot)
    }
    s.isStringObject = ln;

    function cn(rn) {
        return yt(rn, st)
    }
    s.isBooleanObject = cn;

    function un(rn) {
        return et && yt(rn, lt)
    }
    s.isBigIntObject = un;

    function Nn(rn) {
        return tt && yt(rn, ft)
    }
    s.isSymbolObject = Nn;

    function hn(rn) {
        return en(rn) || ln(rn) || cn(rn) || un(rn) || Nn(rn)
    }
    s.isBoxedPrimitive = hn;

    function fn(rn) {
        return typeof Uint8Array < "u" && (Tt(rn) || jt(rn))
    }
    s.isAnyArrayBuffer = fn, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(rn) {
        Object.defineProperty(s, rn, {
            enumerable: !1,
            value: function() {
                throw new Error(rn + " is not supported in userland")
            }
        })
    })
})(types);
var isBufferBrowser = function s(o) {
        return o && typeof o == "object" && typeof o.copy == "function" && typeof o.fill == "function" && typeof o.readUInt8 == "function"
    },
    inherits_browser = {
        exports: {}
    };
typeof Object.create == "function" ? inherits_browser.exports = function(o, a) {
    a && (o.super_ = a, o.prototype = Object.create(a.prototype, {
        constructor: {
            value: o,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
} : inherits_browser.exports = function(o, a) {
    if (a) {
        o.super_ = a;
        var $ = function() {};
        $.prototype = a.prototype, o.prototype = new $, o.prototype.constructor = o
    }
};
var inherits_browserExports = inherits_browser.exports;
(function(s) {
    var o = {},
        a = Object.getOwnPropertyDescriptors || function(Ot) {
            for (var Mt = Object.keys(Ot), jt = {}, Qt = 0; Qt < Mt.length; Qt++) jt[Mt[Qt]] = Object.getOwnPropertyDescriptor(Ot, Mt[Qt]);
            return jt
        },
        $ = /%[sdj%]/g;
    s.format = function(Et) {
        if (!Bt(Et)) {
            for (var Ot = [], Mt = 0; Mt < arguments.length; Mt++) Ot.push(tt(arguments[Mt]));
            return Ot.join(" ")
        }
        for (var Mt = 1, jt = arguments, Qt = jt.length, Kt = String(Et).replace($, function(Jt) {
                if (Jt === "%%") return "%";
                if (Mt >= Qt) return Jt;
                switch (Jt) {
                    case "%s":
                        return String(jt[Mt++]);
                    case "%d":
                        return Number(jt[Mt++]);
                    case "%j":
                        try {
                            return JSON.stringify(jt[Mt++])
                        } catch {
                            return "[Circular]"
                        }
                    default:
                        return Jt
                }
            }), qt = jt[Mt]; Mt < Qt; qt = jt[++Mt]) gt(qt) || !Vt(qt) ? Kt += " " + qt : Kt += " " + tt(qt);
        return Kt
    }, s.deprecate = function(Et, Ot) {
        if (typeof process < "u" && process.noDeprecation === !0) return Et;
        if (typeof process > "u") return function() {
            return s.deprecate(Et, Ot).apply(this, arguments)
        };
        var Mt = !1;

        function jt() {
            if (!Mt) {
                if (process.throwDeprecation) throw new Error(Ot);
                process.traceDeprecation ? console.trace(Ot) : console.error(Ot), Mt = !0
            }
            return Et.apply(this, arguments)
        }
        return jt
    };
    var j = {},
        _e = /^$/;
    if (o.NODE_DEBUG) {
        var et = o.NODE_DEBUG;
        et = et.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), _e = new RegExp("^" + et + "$", "i")
    }
    s.debuglog = function(Et) {
        if (Et = Et.toUpperCase(), !j[Et])
            if (_e.test(Et)) {
                var Ot = process.pid;
                j[Et] = function() {
                    var Mt = s.format.apply(s, arguments);
                    console.error("%s %d: %s", Et, Ot, Mt)
                }
            } else j[Et] = function() {};
        return j[Et]
    };

    function tt(Et, Ot) {
        var Mt = {
            seen: [],
            stylize: rt
        };
        return arguments.length >= 3 && (Mt.depth = arguments[2]), arguments.length >= 4 && (Mt.colors = arguments[3]), wt(Ot) ? Mt.showHidden = Ot : Ot && s._extend(Mt, Ot), Nt(Mt.showHidden) && (Mt.showHidden = !1), Nt(Mt.depth) && (Mt.depth = 2), Nt(Mt.colors) && (Mt.colors = !1), Nt(Mt.customInspect) && (Mt.customInspect = !0), Mt.colors && (Mt.stylize = nt), st(Mt, Et, Mt.depth)
    }
    s.inspect = tt, tt.colors = {
        bold: [1, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        white: [37, 39],
        grey: [90, 39],
        black: [30, 39],
        blue: [34, 39],
        cyan: [36, 39],
        green: [32, 39],
        magenta: [35, 39],
        red: [31, 39],
        yellow: [33, 39]
    }, tt.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        regexp: "red"
    };

    function nt(Et, Ot) {
        var Mt = tt.styles[Ot];
        return Mt ? "\x1B[" + tt.colors[Mt][0] + "m" + Et + "\x1B[" + tt.colors[Mt][1] + "m" : Et
    }

    function rt(Et, Ot) {
        return Et
    }

    function ot(Et) {
        var Ot = {};
        return Et.forEach(function(Mt, jt) {
            Ot[Mt] = !0
        }), Ot
    }

    function st(Et, Ot, Mt) {
        if (Et.customInspect && Ot && Ct(Ot.inspect) && Ot.inspect !== s.inspect && !(Ot.constructor && Ot.constructor.prototype === Ot)) {
            var jt = Ot.inspect(Mt, Et);
            return Bt(jt) || (jt = st(Et, jt, Mt)), jt
        }
        var Qt = lt(Et, Ot);
        if (Qt) return Qt;
        var Kt = Object.keys(Ot),
            qt = ot(Kt);
        if (Et.showHidden && (Kt = Object.getOwnPropertyNames(Ot)), Wt(Ot) && (Kt.indexOf("message") >= 0 || Kt.indexOf("description") >= 0)) return ft(Ot);
        if (Kt.length === 0) {
            if (Ct(Ot)) {
                var Jt = Ot.name ? ": " + Ot.name : "";
                return Et.stylize("[Function" + Jt + "]", "special")
            }
            if (Ut(Ot)) return Et.stylize(RegExp.prototype.toString.call(Ot), "regexp");
            if (Ft(Ot)) return Et.stylize(Date.prototype.toString.call(Ot), "date");
            if (Wt(Ot)) return ft(Ot)
        }
        var Zt = "",
            en = !1,
            ln = ["{", "}"];
        if (vt(Ot) && (en = !0, ln = ["[", "]"]), Ct(Ot)) {
            var cn = Ot.name ? ": " + Ot.name : "";
            Zt = " [Function" + cn + "]"
        }
        if (Ut(Ot) && (Zt = " " + RegExp.prototype.toString.call(Ot)), Ft(Ot) && (Zt = " " + Date.prototype.toUTCString.call(Ot)), Wt(Ot) && (Zt = " " + ft(Ot)), Kt.length === 0 && (!en || Ot.length == 0)) return ln[0] + Zt + ln[1];
        if (Mt < 0) return Ut(Ot) ? Et.stylize(RegExp.prototype.toString.call(Ot), "regexp") : Et.stylize("[Object]", "special");
        Et.seen.push(Ot);
        var un;
        return en ? un = yt(Et, Ot, Mt, qt, Kt) : un = Kt.map(function(Nn) {
            return bt(Et, Ot, Mt, qt, Nn, en)
        }), Et.seen.pop(), ht(un, Zt, ln)
    }

    function lt(Et, Ot) {
        if (Nt(Ot)) return Et.stylize("undefined", "undefined");
        if (Bt(Ot)) {
            var Mt = "'" + JSON.stringify(Ot).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return Et.stylize(Mt, "string")
        }
        if (Pt(Ot)) return Et.stylize("" + Ot, "number");
        if (wt(Ot)) return Et.stylize("" + Ot, "boolean");
        if (gt(Ot)) return Et.stylize("null", "null")
    }

    function ft(Et) {
        return "[" + Error.prototype.toString.call(Et) + "]"
    }

    function yt(Et, Ot, Mt, jt, Qt) {
        for (var Kt = [], qt = 0, Jt = Ot.length; qt < Jt; ++qt) Rt(Ot, String(qt)) ? Kt.push(bt(Et, Ot, Mt, jt, String(qt), !0)) : Kt.push("");
        return Qt.forEach(function(Zt) {
            Zt.match(/^\d+$/) || Kt.push(bt(Et, Ot, Mt, jt, Zt, !0))
        }), Kt
    }

    function bt(Et, Ot, Mt, jt, Qt, Kt) {
        var qt, Jt, Zt;
        if (Zt = Object.getOwnPropertyDescriptor(Ot, Qt) || {
                value: Ot[Qt]
            }, Zt.get ? Zt.set ? Jt = Et.stylize("[Getter/Setter]", "special") : Jt = Et.stylize("[Getter]", "special") : Zt.set && (Jt = Et.stylize("[Setter]", "special")), Rt(jt, Qt) || (qt = "[" + Qt + "]"), Jt || (Et.seen.indexOf(Zt.value) < 0 ? (gt(Mt) ? Jt = st(Et, Zt.value, null) : Jt = st(Et, Zt.value, Mt - 1), Jt.indexOf(`
`) > -1 && (Kt ? Jt = Jt.split(`
`).map(function(en) {
                return "  " + en
            }).join(`
`).slice(2) : Jt = `
` + Jt.split(`
`).map(function(en) {
                return "   " + en
            }).join(`
`))) : Jt = Et.stylize("[Circular]", "special")), Nt(qt)) {
            if (Kt && Qt.match(/^\d+$/)) return Jt;
            qt = JSON.stringify("" + Qt), qt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (qt = qt.slice(1, -1), qt = Et.stylize(qt, "name")) : (qt = qt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), qt = Et.stylize(qt, "string"))
        }
        return qt + ": " + Jt
    }

    function ht(Et, Ot, Mt) {
        var jt = Et.reduce(function(Qt, Kt) {
            return Kt.indexOf(`
`) >= 0, Qt + Kt.replace(/\u001b\[\d\d?m/g, "").length + 1
        }, 0);
        return jt > 60 ? Mt[0] + (Ot === "" ? "" : Ot + `
 `) + " " + Et.join(`,
  `) + " " + Mt[1] : Mt[0] + Ot + " " + Et.join(", ") + " " + Mt[1]
    }
    s.types = types;

    function vt(Et) {
        return Array.isArray(Et)
    }
    s.isArray = vt;

    function wt(Et) {
        return typeof Et == "boolean"
    }
    s.isBoolean = wt;

    function gt(Et) {
        return Et === null
    }
    s.isNull = gt;

    function At(Et) {
        return Et == null
    }
    s.isNullOrUndefined = At;

    function Pt(Et) {
        return typeof Et == "number"
    }
    s.isNumber = Pt;

    function Bt(Et) {
        return typeof Et == "string"
    }
    s.isString = Bt;

    function Lt(Et) {
        return typeof Et == "symbol"
    }
    s.isSymbol = Lt;

    function Nt(Et) {
        return Et === void 0
    }
    s.isUndefined = Nt;

    function Ut(Et) {
        return Vt(Et) && at(Et) === "[object RegExp]"
    }
    s.isRegExp = Ut, s.types.isRegExp = Ut;

    function Vt(Et) {
        return typeof Et == "object" && Et !== null
    }
    s.isObject = Vt;

    function Ft(Et) {
        return Vt(Et) && at(Et) === "[object Date]"
    }
    s.isDate = Ft, s.types.isDate = Ft;

    function Wt(Et) {
        return Vt(Et) && (at(Et) === "[object Error]" || Et instanceof Error)
    }
    s.isError = Wt, s.types.isNativeError = Wt;

    function Ct(Et) {
        return typeof Et == "function"
    }
    s.isFunction = Ct;

    function it(Et) {
        return Et === null || typeof Et == "boolean" || typeof Et == "number" || typeof Et == "string" || typeof Et == "symbol" || typeof Et > "u"
    }
    s.isPrimitive = it, s.isBuffer = isBufferBrowser;

    function at(Et) {
        return Object.prototype.toString.call(Et)
    }

    function mt(Et) {
        return Et < 10 ? "0" + Et.toString(10) : Et.toString(10)
    }
    var xt = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    function $t() {
        var Et = new Date,
            Ot = [mt(Et.getHours()), mt(Et.getMinutes()), mt(Et.getSeconds())].join(":");
        return [Et.getDate(), xt[Et.getMonth()], Ot].join(" ")
    }
    s.log = function() {
        console.log("%s - %s", $t(), s.format.apply(s, arguments))
    }, s.inherits = inherits_browserExports, s._extend = function(Et, Ot) {
        if (!Ot || !Vt(Ot)) return Et;
        for (var Mt = Object.keys(Ot), jt = Mt.length; jt--;) Et[Mt[jt]] = Ot[Mt[jt]];
        return Et
    };

    function Rt(Et, Ot) {
        return Object.prototype.hasOwnProperty.call(Et, Ot)
    }
    var It = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    s.promisify = function(Ot) {
        if (typeof Ot != "function") throw new TypeError('The "original" argument must be of type Function');
        if (It && Ot[It]) {
            var Mt = Ot[It];
            if (typeof Mt != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(Mt, It, {
                value: Mt,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }), Mt
        }

        function Mt() {
            for (var jt, Qt, Kt = new Promise(function(Zt, en) {
                    jt = Zt, Qt = en
                }), qt = [], Jt = 0; Jt < arguments.length; Jt++) qt.push(arguments[Jt]);
            qt.push(function(Zt, en) {
                Zt ? Qt(Zt) : jt(en)
            });
            try {
                Ot.apply(this, qt)
            } catch (Zt) {
                Qt(Zt)
            }
            return Kt
        }
        return Object.setPrototypeOf(Mt, Object.getPrototypeOf(Ot)), It && Object.defineProperty(Mt, It, {
            value: Mt,
            enumerable: !1,
            writable: !1,
            configurable: !0
        }), Object.defineProperties(Mt, a(Ot))
    }, s.promisify.custom = It;

    function Tt(Et, Ot) {
        if (!Et) {
            var Mt = new Error("Promise was rejected with a falsy value");
            Mt.reason = Et, Et = Mt
        }
        return Ot(Et)
    }

    function dt(Et) {
        if (typeof Et != "function") throw new TypeError('The "original" argument must be of type Function');

        function Ot() {
            for (var Mt = [], jt = 0; jt < arguments.length; jt++) Mt.push(arguments[jt]);
            var Qt = Mt.pop();
            if (typeof Qt != "function") throw new TypeError("The last argument must be of type Function");
            var Kt = this,
                qt = function() {
                    return Qt.apply(Kt, arguments)
                };
            Et.apply(this, Mt).then(function(Jt) {
                process.nextTick(qt.bind(null, null, Jt))
            }, function(Jt) {
                process.nextTick(Tt.bind(null, Jt, qt))
            })
        }
        return Object.setPrototypeOf(Ot, Object.getPrototypeOf(Et)), Object.defineProperties(Ot, a(Et)), Ot
    }
    s.callbackify = dt
})(util);
var hasRequiredErrors;

function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;

    function s(wt) {
        "@babel/helpers - typeof";
        return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(gt) {
            return typeof gt
        } : function(gt) {
            return gt && typeof Symbol == "function" && gt.constructor === Symbol && gt !== Symbol.prototype ? "symbol" : typeof gt
        }, s(wt)
    }

    function o(wt, gt, At) {
        return Object.defineProperty(wt, "prototype", {
            writable: !1
        }), wt
    }

    function a(wt, gt) {
        if (!(wt instanceof gt)) throw new TypeError("Cannot call a class as a function")
    }

    function $(wt, gt) {
        if (typeof gt != "function" && gt !== null) throw new TypeError("Super expression must either be null or a function");
        wt.prototype = Object.create(gt && gt.prototype, {
            constructor: {
                value: wt,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(wt, "prototype", {
            writable: !1
        }), gt && j(wt, gt)
    }

    function j(wt, gt) {
        return j = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Pt, Bt) {
            return Pt.__proto__ = Bt, Pt
        }, j(wt, gt)
    }

    function _e(wt) {
        var gt = nt();
        return function() {
            var Pt = rt(wt),
                Bt;
            if (gt) {
                var Lt = rt(this).constructor;
                Bt = Reflect.construct(Pt, arguments, Lt)
            } else Bt = Pt.apply(this, arguments);
            return et(this, Bt)
        }
    }

    function et(wt, gt) {
        if (gt && (s(gt) === "object" || typeof gt == "function")) return gt;
        if (gt !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return tt(wt)
    }

    function tt(wt) {
        if (wt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return wt
    }

    function nt() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
        } catch {
            return !1
        }
    }

    function rt(wt) {
        return rt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(At) {
            return At.__proto__ || Object.getPrototypeOf(At)
        }, rt(wt)
    }
    var ot = {},
        st, lt;

    function ft(wt, gt, At) {
        At || (At = Error);

        function Pt(Lt, Nt, Ut) {
            return typeof gt == "string" ? gt : gt(Lt, Nt, Ut)
        }
        var Bt = function(Lt) {
            $(Ut, Lt);
            var Nt = _e(Ut);

            function Ut(Vt, Ft, Wt) {
                var Ct;
                return a(this, Ut), Ct = Nt.call(this, Pt(Vt, Ft, Wt)), Ct.code = wt, Ct
            }
            return o(Ut)
        }(At);
        ot[wt] = Bt
    }

    function yt(wt, gt) {
        if (Array.isArray(wt)) {
            var At = wt.length;
            return wt = wt.map(function(Pt) {
                return String(Pt)
            }), At > 2 ? "one of ".concat(gt, " ").concat(wt.slice(0, At - 1).join(", "), ", or ") + wt[At - 1] : At === 2 ? "one of ".concat(gt, " ").concat(wt[0], " or ").concat(wt[1]) : "of ".concat(gt, " ").concat(wt[0])
        } else return "of ".concat(gt, " ").concat(String(wt))
    }

    function bt(wt, gt, At) {
        return wt.substr(0, gt.length) === gt
    }

    function ht(wt, gt, At) {
        return (At === void 0 || At > wt.length) && (At = wt.length), wt.substring(At - gt.length, At) === gt
    }

    function vt(wt, gt, At) {
        return typeof At != "number" && (At = 0), At + gt.length > wt.length ? !1 : wt.indexOf(gt, At) !== -1
    }
    return ft("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), ft("ERR_INVALID_ARG_TYPE", function(wt, gt, At) {
        st === void 0 && (st = requireAssert()), st(typeof wt == "string", "'name' must be a string");
        var Pt;
        typeof gt == "string" && bt(gt, "not ") ? (Pt = "must not be", gt = gt.replace(/^not /, "")) : Pt = "must be";
        var Bt;
        if (ht(wt, " argument")) Bt = "The ".concat(wt, " ").concat(Pt, " ").concat(yt(gt, "type"));
        else {
            var Lt = vt(wt, ".") ? "property" : "argument";
            Bt = 'The "'.concat(wt, '" ').concat(Lt, " ").concat(Pt, " ").concat(yt(gt, "type"))
        }
        return Bt += ". Received type ".concat(s(At)), Bt
    }, TypeError), ft("ERR_INVALID_ARG_VALUE", function(wt, gt) {
        var At = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
        lt === void 0 && (lt = util);
        var Pt = lt.inspect(gt);
        return Pt.length > 128 && (Pt = "".concat(Pt.slice(0, 128), "...")), "The argument '".concat(wt, "' ").concat(At, ". Received ").concat(Pt)
    }, TypeError), ft("ERR_INVALID_RETURN_VALUE", function(wt, gt, At) {
        var Pt;
        return At && At.constructor && At.constructor.name ? Pt = "instance of ".concat(At.constructor.name) : Pt = "type ".concat(s(At)), "Expected ".concat(wt, ' to be returned from the "').concat(gt, '"') + " function but got ".concat(Pt, ".")
    }, TypeError), ft("ERR_MISSING_ARGS", function() {
        for (var wt = arguments.length, gt = new Array(wt), At = 0; At < wt; At++) gt[At] = arguments[At];
        st === void 0 && (st = requireAssert()), st(gt.length > 0, "At least one arg needs to be specified");
        var Pt = "The ",
            Bt = gt.length;
        switch (gt = gt.map(function(Lt) {
            return '"'.concat(Lt, '"')
        }), Bt) {
            case 1:
                Pt += "".concat(gt[0], " argument");
                break;
            case 2:
                Pt += "".concat(gt[0], " and ").concat(gt[1], " arguments");
                break;
            default:
                Pt += gt.slice(0, Bt - 1).join(", "), Pt += ", and ".concat(gt[Bt - 1], " arguments");
                break
        }
        return "".concat(Pt, " must be specified")
    }, TypeError), errors.codes = ot, errors
}
var assertion_error, hasRequiredAssertion_error;

function requireAssertion_error() {
    if (hasRequiredAssertion_error) return assertion_error;
    hasRequiredAssertion_error = 1;

    function s(Rt, It) {
        var Tt = Object.keys(Rt);
        if (Object.getOwnPropertySymbols) {
            var dt = Object.getOwnPropertySymbols(Rt);
            It && (dt = dt.filter(function(Et) {
                return Object.getOwnPropertyDescriptor(Rt, Et).enumerable
            })), Tt.push.apply(Tt, dt)
        }
        return Tt
    }

    function o(Rt) {
        for (var It = 1; It < arguments.length; It++) {
            var Tt = arguments[It] != null ? arguments[It] : {};
            It % 2 ? s(Object(Tt), !0).forEach(function(dt) {
                a(Rt, dt, Tt[dt])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Rt, Object.getOwnPropertyDescriptors(Tt)) : s(Object(Tt)).forEach(function(dt) {
                Object.defineProperty(Rt, dt, Object.getOwnPropertyDescriptor(Tt, dt))
            })
        }
        return Rt
    }

    function a(Rt, It, Tt) {
        return It = et(It), It in Rt ? Object.defineProperty(Rt, It, {
            value: Tt,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : Rt[It] = Tt, Rt
    }

    function $(Rt, It) {
        if (!(Rt instanceof It)) throw new TypeError("Cannot call a class as a function")
    }

    function j(Rt, It) {
        for (var Tt = 0; Tt < It.length; Tt++) {
            var dt = It[Tt];
            dt.enumerable = dt.enumerable || !1, dt.configurable = !0, "value" in dt && (dt.writable = !0), Object.defineProperty(Rt, et(dt.key), dt)
        }
    }

    function _e(Rt, It, Tt) {
        return It && j(Rt.prototype, It), Object.defineProperty(Rt, "prototype", {
            writable: !1
        }), Rt
    }

    function et(Rt) {
        var It = tt(Rt, "string");
        return wt(It) === "symbol" ? It : String(It)
    }

    function tt(Rt, It) {
        if (wt(Rt) !== "object" || Rt === null) return Rt;
        var Tt = Rt[Symbol.toPrimitive];
        if (Tt !== void 0) {
            var dt = Tt.call(Rt, It || "default");
            if (wt(dt) !== "object") return dt;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (It === "string" ? String : Number)(Rt)
    }

    function nt(Rt, It) {
        if (typeof It != "function" && It !== null) throw new TypeError("Super expression must either be null or a function");
        Rt.prototype = Object.create(It && It.prototype, {
            constructor: {
                value: Rt,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(Rt, "prototype", {
            writable: !1
        }), It && ht(Rt, It)
    }

    function rt(Rt) {
        var It = yt();
        return function() {
            var dt = vt(Rt),
                Et;
            if (It) {
                var Ot = vt(this).constructor;
                Et = Reflect.construct(dt, arguments, Ot)
            } else Et = dt.apply(this, arguments);
            return ot(this, Et)
        }
    }

    function ot(Rt, It) {
        if (It && (wt(It) === "object" || typeof It == "function")) return It;
        if (It !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return st(Rt)
    }

    function st(Rt) {
        if (Rt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return Rt
    }

    function lt(Rt) {
        var It = typeof Map == "function" ? new Map : void 0;
        return lt = function(dt) {
            if (dt === null || !bt(dt)) return dt;
            if (typeof dt != "function") throw new TypeError("Super expression must either be null or a function");
            if (typeof It < "u") {
                if (It.has(dt)) return It.get(dt);
                It.set(dt, Et)
            }

            function Et() {
                return ft(dt, arguments, vt(this).constructor)
            }
            return Et.prototype = Object.create(dt.prototype, {
                constructor: {
                    value: Et,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), ht(Et, dt)
        }, lt(Rt)
    }

    function ft(Rt, It, Tt) {
        return yt() ? ft = Reflect.construct.bind() : ft = function(Et, Ot, Mt) {
            var jt = [null];
            jt.push.apply(jt, Ot);
            var Qt = Function.bind.apply(Et, jt),
                Kt = new Qt;
            return Mt && ht(Kt, Mt.prototype), Kt
        }, ft.apply(null, arguments)
    }

    function yt() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
        } catch {
            return !1
        }
    }

    function bt(Rt) {
        return Function.toString.call(Rt).indexOf("[native code]") !== -1
    }

    function ht(Rt, It) {
        return ht = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(dt, Et) {
            return dt.__proto__ = Et, dt
        }, ht(Rt, It)
    }

    function vt(Rt) {
        return vt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Tt) {
            return Tt.__proto__ || Object.getPrototypeOf(Tt)
        }, vt(Rt)
    }

    function wt(Rt) {
        "@babel/helpers - typeof";
        return wt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(It) {
            return typeof It
        } : function(It) {
            return It && typeof Symbol == "function" && It.constructor === Symbol && It !== Symbol.prototype ? "symbol" : typeof It
        }, wt(Rt)
    }
    var gt = util,
        At = gt.inspect,
        Pt = requireErrors(),
        Bt = Pt.codes.ERR_INVALID_ARG_TYPE;

    function Lt(Rt, It, Tt) {
        return (Tt === void 0 || Tt > Rt.length) && (Tt = Rt.length), Rt.substring(Tt - It.length, Tt) === It
    }

    function Nt(Rt, It) {
        if (It = Math.floor(It), Rt.length == 0 || It == 0) return "";
        var Tt = Rt.length * It;
        for (It = Math.floor(Math.log(It) / Math.log(2)); It;) Rt += Rt, It--;
        return Rt += Rt.substring(0, Tt - Rt.length), Rt
    }
    var Ut = "",
        Vt = "",
        Ft = "",
        Wt = "",
        Ct = {
            deepStrictEqual: "Expected values to be strictly deep-equal:",
            strictEqual: "Expected values to be strictly equal:",
            strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
            deepEqual: "Expected values to be loosely deep-equal:",
            equal: "Expected values to be loosely equal:",
            notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
            notStrictEqual: 'Expected "actual" to be strictly unequal to:',
            notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
            notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
            notEqual: 'Expected "actual" to be loosely unequal to:',
            notIdentical: "Values identical but not reference-equal:"
        },
        it = 10;

    function at(Rt) {
        var It = Object.keys(Rt),
            Tt = Object.create(Object.getPrototypeOf(Rt));
        return It.forEach(function(dt) {
            Tt[dt] = Rt[dt]
        }), Object.defineProperty(Tt, "message", {
            value: Rt.message
        }), Tt
    }

    function mt(Rt) {
        return At(Rt, {
            compact: !1,
            customInspect: !1,
            depth: 1e3,
            maxArrayLength: 1 / 0,
            showHidden: !1,
            breakLength: 1 / 0,
            showProxy: !1,
            sorted: !0,
            getters: !0
        })
    }

    function xt(Rt, It, Tt) {
        var dt = "",
            Et = "",
            Ot = 0,
            Mt = "",
            jt = !1,
            Qt = mt(Rt),
            Kt = Qt.split(`
`),
            qt = mt(It).split(`
`),
            Jt = 0,
            Zt = "";
        if (Tt === "strictEqual" && wt(Rt) === "object" && wt(It) === "object" && Rt !== null && It !== null && (Tt = "strictEqualObject"), Kt.length === 1 && qt.length === 1 && Kt[0] !== qt[0]) {
            var en = Kt[0].length + qt[0].length;
            if (en <= it) {
                if ((wt(Rt) !== "object" || Rt === null) && (wt(It) !== "object" || It === null) && (Rt !== 0 || It !== 0)) return "".concat(Ct[Tt], `

`) + "".concat(Kt[0], " !== ").concat(qt[0], `
`)
            } else if (Tt !== "strictEqualObject") {
                var ln = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                if (en < ln) {
                    for (; Kt[0][Jt] === qt[0][Jt];) Jt++;
                    Jt > 2 && (Zt = `
  `.concat(Nt(" ", Jt), "^"), Jt = 0)
                }
            }
        }
        for (var cn = Kt[Kt.length - 1], un = qt[qt.length - 1]; cn === un && (Jt++ < 2 ? Mt = `
  `.concat(cn).concat(Mt) : dt = cn, Kt.pop(), qt.pop(), !(Kt.length === 0 || qt.length === 0));) cn = Kt[Kt.length - 1], un = qt[qt.length - 1];
        var Nn = Math.max(Kt.length, qt.length);
        if (Nn === 0) {
            var hn = Qt.split(`
`);
            if (hn.length > 30)
                for (hn[26] = "".concat(Ut, "...").concat(Wt); hn.length > 27;) hn.pop();
            return "".concat(Ct.notIdentical, `

`).concat(hn.join(`
`), `
`)
        }
        Jt > 3 && (Mt = `
`.concat(Ut, "...").concat(Wt).concat(Mt), jt = !0), dt !== "" && (Mt = `
  `.concat(dt).concat(Mt), dt = "");
        var fn = 0,
            rn = Ct[Tt] + `
`.concat(Vt, "+ actual").concat(Wt, " ").concat(Ft, "- expected").concat(Wt),
            mn = " ".concat(Ut, "...").concat(Wt, " Lines skipped");
        for (Jt = 0; Jt < Nn; Jt++) {
            var dn = Jt - Ot;
            if (Kt.length < Jt + 1) dn > 1 && Jt > 2 && (dn > 4 ? (Et += `
`.concat(Ut, "...").concat(Wt), jt = !0) : dn > 3 && (Et += `
  `.concat(qt[Jt - 2]), fn++), Et += `
  `.concat(qt[Jt - 1]), fn++), Ot = Jt, dt += `
`.concat(Ft, "-").concat(Wt, " ").concat(qt[Jt]), fn++;
            else if (qt.length < Jt + 1) dn > 1 && Jt > 2 && (dn > 4 ? (Et += `
`.concat(Ut, "...").concat(Wt), jt = !0) : dn > 3 && (Et += `
  `.concat(Kt[Jt - 2]), fn++), Et += `
  `.concat(Kt[Jt - 1]), fn++), Ot = Jt, Et += `
`.concat(Vt, "+").concat(Wt, " ").concat(Kt[Jt]), fn++;
            else {
                var vn = qt[Jt],
                    gn = Kt[Jt],
                    Gt = gn !== vn && (!Lt(gn, ",") || gn.slice(0, -1) !== vn);
                Gt && Lt(vn, ",") && vn.slice(0, -1) === gn && (Gt = !1, gn += ","), Gt ? (dn > 1 && Jt > 2 && (dn > 4 ? (Et += `
`.concat(Ut, "...").concat(Wt), jt = !0) : dn > 3 && (Et += `
  `.concat(Kt[Jt - 2]), fn++), Et += `
  `.concat(Kt[Jt - 1]), fn++), Ot = Jt, Et += `
`.concat(Vt, "+").concat(Wt, " ").concat(gn), dt += `
`.concat(Ft, "-").concat(Wt, " ").concat(vn), fn += 2) : (Et += dt, dt = "", (dn === 1 || Jt === 0) && (Et += `
  `.concat(gn), fn++))
            }
            if (fn > 20 && Jt < Nn - 2) return "".concat(rn).concat(mn, `
`).concat(Et, `
`).concat(Ut, "...").concat(Wt).concat(dt, `
`) + "".concat(Ut, "...").concat(Wt)
        }
        return "".concat(rn).concat(jt ? mn : "", `
`).concat(Et).concat(dt).concat(Mt).concat(Zt)
    }
    var $t = function(Rt, It) {
        nt(dt, Rt);
        var Tt = rt(dt);

        function dt(Et) {
            var Ot;
            if ($(this, dt), wt(Et) !== "object" || Et === null) throw new Bt("options", "Object", Et);
            var Mt = Et.message,
                jt = Et.operator,
                Qt = Et.stackStartFn,
                Kt = Et.actual,
                qt = Et.expected,
                Jt = Error.stackTraceLimit;
            if (Error.stackTraceLimit = 0, Mt != null) Ot = Tt.call(this, String(Mt));
            else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 ? (Ut = "\x1B[34m", Vt = "\x1B[32m", Wt = "\x1B[39m", Ft = "\x1B[31m") : (Ut = "", Vt = "", Wt = "", Ft = "")), wt(Kt) === "object" && Kt !== null && wt(qt) === "object" && qt !== null && "stack" in Kt && Kt instanceof Error && "stack" in qt && qt instanceof Error && (Kt = at(Kt), qt = at(qt)), jt === "deepStrictEqual" || jt === "strictEqual") Ot = Tt.call(this, xt(Kt, qt, jt));
            else if (jt === "notDeepStrictEqual" || jt === "notStrictEqual") {
                var Zt = Ct[jt],
                    en = mt(Kt).split(`
`);
                if (jt === "notStrictEqual" && wt(Kt) === "object" && Kt !== null && (Zt = Ct.notStrictEqualObject), en.length > 30)
                    for (en[26] = "".concat(Ut, "...").concat(Wt); en.length > 27;) en.pop();
                en.length === 1 ? Ot = Tt.call(this, "".concat(Zt, " ").concat(en[0])) : Ot = Tt.call(this, "".concat(Zt, `

`).concat(en.join(`
`), `
`))
            } else {
                var ln = mt(Kt),
                    cn = "",
                    un = Ct[jt];
                jt === "notDeepEqual" || jt === "notEqual" ? (ln = "".concat(Ct[jt], `

`).concat(ln), ln.length > 1024 && (ln = "".concat(ln.slice(0, 1021), "..."))) : (cn = "".concat(mt(qt)), ln.length > 512 && (ln = "".concat(ln.slice(0, 509), "...")), cn.length > 512 && (cn = "".concat(cn.slice(0, 509), "...")), jt === "deepEqual" || jt === "equal" ? ln = "".concat(un, `

`).concat(ln, `

should equal

`) : cn = " ".concat(jt, " ").concat(cn)), Ot = Tt.call(this, "".concat(ln).concat(cn))
            }
            return Error.stackTraceLimit = Jt, Ot.generatedMessage = !Mt, Object.defineProperty(st(Ot), "name", {
                value: "AssertionError [ERR_ASSERTION]",
                enumerable: !1,
                writable: !0,
                configurable: !0
            }), Ot.code = "ERR_ASSERTION", Ot.actual = Kt, Ot.expected = qt, Ot.operator = jt, Error.captureStackTrace && Error.captureStackTrace(st(Ot), Qt), Ot.stack, Ot.name = "AssertionError", ot(Ot)
        }
        return _e(dt, [{
            key: "toString",
            value: function() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message)
            }
        }, {
            key: It,
            value: function(Ot, Mt) {
                return At(this, o(o({}, Mt), {}, {
                    customInspect: !1,
                    depth: 0
                }))
            }
        }]), dt
    }(lt(Error), At.custom);
    return assertion_error = $t, assertion_error
}
var toStr = Object.prototype.toString,
    isArguments = function s(o) {
        var a = toStr.call(o),
            $ = a === "[object Arguments]";
        return $ || ($ = a !== "[object Array]" && o !== null && typeof o == "object" && typeof o.length == "number" && o.length >= 0 && toStr.call(o.callee) === "[object Function]"), $
    },
    implementation$5, hasRequiredImplementation$1;

function requireImplementation$1() {
    if (hasRequiredImplementation$1) return implementation$5;
    hasRequiredImplementation$1 = 1;
    var s;
    if (!Object.keys) {
        var o = Object.prototype.hasOwnProperty,
            a = Object.prototype.toString,
            $ = isArguments,
            j = Object.prototype.propertyIsEnumerable,
            _e = !j.call({
                toString: null
            }, "toString"),
            et = j.call(function() {}, "prototype"),
            tt = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
            nt = function(lt) {
                var ft = lt.constructor;
                return ft && ft.prototype === lt
            },
            rt = {
                $applicationCache: !0,
                $console: !0,
                $external: !0,
                $frame: !0,
                $frameElement: !0,
                $frames: !0,
                $innerHeight: !0,
                $innerWidth: !0,
                $onmozfullscreenchange: !0,
                $onmozfullscreenerror: !0,
                $outerHeight: !0,
                $outerWidth: !0,
                $pageXOffset: !0,
                $pageYOffset: !0,
                $parent: !0,
                $scrollLeft: !0,
                $scrollTop: !0,
                $scrollX: !0,
                $scrollY: !0,
                $self: !0,
                $webkitIndexedDB: !0,
                $webkitStorageInfo: !0,
                $window: !0
            },
            ot = function() {
                if (typeof window > "u") return !1;
                for (var lt in window) try {
                    if (!rt["$" + lt] && o.call(window, lt) && window[lt] !== null && typeof window[lt] == "object") try {
                        nt(window[lt])
                    } catch {
                        return !0
                    }
                } catch {
                    return !0
                }
                return !1
            }(),
            st = function(lt) {
                if (typeof window > "u" || !ot) return nt(lt);
                try {
                    return nt(lt)
                } catch {
                    return !1
                }
            };
        s = function(ft) {
            var yt = ft !== null && typeof ft == "object",
                bt = a.call(ft) === "[object Function]",
                ht = $(ft),
                vt = yt && a.call(ft) === "[object String]",
                wt = [];
            if (!yt && !bt && !ht) throw new TypeError("Object.keys called on a non-object");
            var gt = et && bt;
            if (vt && ft.length > 0 && !o.call(ft, 0))
                for (var At = 0; At < ft.length; ++At) wt.push(String(At));
            if (ht && ft.length > 0)
                for (var Pt = 0; Pt < ft.length; ++Pt) wt.push(String(Pt));
            else
                for (var Bt in ft) !(gt && Bt === "prototype") && o.call(ft, Bt) && wt.push(String(Bt));
            if (_e)
                for (var Lt = st(ft), Nt = 0; Nt < tt.length; ++Nt) !(Lt && tt[Nt] === "constructor") && o.call(ft, tt[Nt]) && wt.push(tt[Nt]);
            return wt
        }
    }
    return implementation$5 = s, implementation$5
}
var slice = Array.prototype.slice,
    isArgs = isArguments,
    origKeys = Object.keys,
    keysShim = origKeys ? function s(o) {
        return origKeys(o)
    } : requireImplementation$1(),
    originalKeys = Object.keys;
keysShim.shim = function s() {
    if (Object.keys) {
        var o = function() {
            var a = Object.keys(arguments);
            return a && a.length === arguments.length
        }(1, 2);
        o || (Object.keys = function($) {
            return isArgs($) ? originalKeys(slice.call($)) : originalKeys($)
        })
    } else Object.keys = keysShim;
    return Object.keys || keysShim
};
var objectKeys$1 = keysShim,
    objectKeys = objectKeys$1,
    hasSymbols = shams$1(),
    callBound = callBound$3,
    toObject = Object,
    $push = callBound("Array.prototype.push"),
    $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable"),
    originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null,
    implementation$4 = function s(o, a) {
        if (o == null) throw new TypeError("target must be an object");
        var $ = toObject(o);
        if (arguments.length === 1) return $;
        for (var j = 1; j < arguments.length; ++j) {
            var _e = toObject(arguments[j]),
                et = objectKeys(_e),
                tt = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
            if (tt)
                for (var nt = tt(_e), rt = 0; rt < nt.length; ++rt) {
                    var ot = nt[rt];
                    $propIsEnumerable(_e, ot) && $push(et, ot)
                }
            for (var st = 0; st < et.length; ++st) {
                var lt = et[st];
                if ($propIsEnumerable(_e, lt)) {
                    var ft = _e[lt];
                    $[lt] = ft
                }
            }
        }
        return $
    },
    implementation$3 = implementation$4,
    lacksProperEnumerationOrder = function() {
        if (!Object.assign) return !1;
        for (var s = "abcdefghijklmnopqrst", o = s.split(""), a = {}, $ = 0; $ < o.length; ++$) a[o[$]] = o[$];
        var j = Object.assign({}, a),
            _e = "";
        for (var et in j) _e += et;
        return s !== _e
    },
    assignHasPendingExceptions = function() {
        if (!Object.assign || !Object.preventExtensions) return !1;
        var s = Object.preventExtensions({
            1: 2
        });
        try {
            Object.assign(s, "xy")
        } catch {
            return s[1] === "y"
        }
        return !1
    },
    polyfill$2 = function s() {
        return !Object.assign || lacksProperEnumerationOrder() || assignHasPendingExceptions() ? implementation$3 : Object.assign
    },
    numberIsNaN = function(s) {
        return s !== s
    },
    implementation$2 = function s(o, a) {
        return o === 0 && a === 0 ? 1 / o === 1 / a : !!(o === a || numberIsNaN(o) && numberIsNaN(a))
    },
    implementation$1 = implementation$2,
    polyfill$1 = function s() {
        return typeof Object.is == "function" ? Object.is : implementation$1
    },
    defineProperties_1, hasRequiredDefineProperties;

function requireDefineProperties() {
    if (hasRequiredDefineProperties) return defineProperties_1;
    hasRequiredDefineProperties = 1;
    var s = objectKeys$1,
        o = typeof Symbol == "function" && typeof Symbol("foo") == "symbol",
        a = Object.prototype.toString,
        $ = Array.prototype.concat,
        j = defineDataProperty,
        _e = function(rt) {
            return typeof rt == "function" && a.call(rt) === "[object Function]"
        },
        et = hasPropertyDescriptors_1(),
        tt = function(rt, ot, st, lt) {
            if (ot in rt) {
                if (lt === !0) {
                    if (rt[ot] === st) return
                } else if (!_e(lt) || !lt()) return
            }
            et ? j(rt, ot, st, !0) : j(rt, ot, st)
        },
        nt = function(rt, ot) {
            var st = arguments.length > 2 ? arguments[2] : {},
                lt = s(ot);
            o && (lt = $.call(lt, Object.getOwnPropertySymbols(ot)));
            for (var ft = 0; ft < lt.length; ft += 1) tt(rt, lt[ft], ot[lt[ft]], st[lt[ft]])
        };
    return nt.supportsDescriptors = !!et, defineProperties_1 = nt, defineProperties_1
}
var shim$1, hasRequiredShim$1;

function requireShim$1() {
    if (hasRequiredShim$1) return shim$1;
    hasRequiredShim$1 = 1;
    var s = polyfill$1,
        o = requireDefineProperties();
    return shim$1 = function() {
        var $ = s();
        return o(Object, {
            is: $
        }, {
            is: function() {
                return Object.is !== $
            }
        }), $
    }, shim$1
}
var objectIs, hasRequiredObjectIs;

function requireObjectIs() {
    if (hasRequiredObjectIs) return objectIs;
    hasRequiredObjectIs = 1;
    var s = requireDefineProperties(),
        o = callBindExports,
        a = implementation$2,
        $ = polyfill$1,
        j = requireShim$1(),
        _e = o($(), Object);
    return s(_e, {
        getPolyfill: $,
        implementation: a,
        shim: j
    }), objectIs = _e, objectIs
}
var implementation, hasRequiredImplementation;

function requireImplementation() {
    return hasRequiredImplementation || (hasRequiredImplementation = 1, implementation = function(o) {
        return o !== o
    }), implementation
}
var polyfill, hasRequiredPolyfill;

function requirePolyfill() {
    if (hasRequiredPolyfill) return polyfill;
    hasRequiredPolyfill = 1;
    var s = requireImplementation();
    return polyfill = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : s
    }, polyfill
}
var shim, hasRequiredShim;

function requireShim() {
    if (hasRequiredShim) return shim;
    hasRequiredShim = 1;
    var s = requireDefineProperties(),
        o = requirePolyfill();
    return shim = function() {
        var $ = o();
        return s(Number, {
            isNaN: $
        }, {
            isNaN: function() {
                return Number.isNaN !== $
            }
        }), $
    }, shim
}
var isNan, hasRequiredIsNan;

function requireIsNan() {
    if (hasRequiredIsNan) return isNan;
    hasRequiredIsNan = 1;
    var s = callBindExports,
        o = requireDefineProperties(),
        a = requireImplementation(),
        $ = requirePolyfill(),
        j = requireShim(),
        _e = s($(), Number);
    return o(_e, {
        getPolyfill: $,
        implementation: a,
        shim: j
    }), isNan = _e, isNan
}
var comparisons, hasRequiredComparisons;

function requireComparisons() {
    if (hasRequiredComparisons) return comparisons;
    hasRequiredComparisons = 1;

    function s(Gt, Yt) {
        return _e(Gt) || j(Gt, Yt) || a(Gt, Yt) || o()
    }

    function o() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }

    function a(Gt, Yt) {
        if (Gt) {
            if (typeof Gt == "string") return $(Gt, Yt);
            var nn = Object.prototype.toString.call(Gt).slice(8, -1);
            if (nn === "Object" && Gt.constructor && (nn = Gt.constructor.name), nn === "Map" || nn === "Set") return Array.from(Gt);
            if (nn === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(nn)) return $(Gt, Yt)
        }
    }

    function $(Gt, Yt) {
        (Yt == null || Yt > Gt.length) && (Yt = Gt.length);
        for (var nn = 0, St = new Array(Yt); nn < Yt; nn++) St[nn] = Gt[nn];
        return St
    }

    function j(Gt, Yt) {
        var nn = Gt == null ? null : typeof Symbol < "u" && Gt[Symbol.iterator] || Gt["@@iterator"];
        if (nn != null) {
            var St, ct, pt, kt, Dt = [],
                zt = !0,
                Ht = !1;
            try {
                if (pt = (nn = nn.call(Gt)).next, Yt !== 0)
                    for (; !(zt = (St = pt.call(nn)).done) && (Dt.push(St.value), Dt.length !== Yt); zt = !0);
            } catch (an) {
                Ht = !0, ct = an
            } finally {
                try {
                    if (!zt && nn.return != null && (kt = nn.return(), Object(kt) !== kt)) return
                } finally {
                    if (Ht) throw ct
                }
            }
            return Dt
        }
    }

    function _e(Gt) {
        if (Array.isArray(Gt)) return Gt
    }

    function et(Gt) {
        "@babel/helpers - typeof";
        return et = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Yt) {
            return typeof Yt
        } : function(Yt) {
            return Yt && typeof Symbol == "function" && Yt.constructor === Symbol && Yt !== Symbol.prototype ? "symbol" : typeof Yt
        }, et(Gt)
    }
    var tt = /a/g.flags !== void 0,
        nt = function(Yt) {
            var nn = [];
            return Yt.forEach(function(St) {
                return nn.push(St)
            }), nn
        },
        rt = function(Yt) {
            var nn = [];
            return Yt.forEach(function(St, ct) {
                return nn.push([ct, St])
            }), nn
        },
        ot = Object.is ? Object.is : requireObjectIs(),
        st = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
            return []
        },
        lt = Number.isNaN ? Number.isNaN : requireIsNan();

    function ft(Gt) {
        return Gt.call.bind(Gt)
    }
    var yt = ft(Object.prototype.hasOwnProperty),
        bt = ft(Object.prototype.propertyIsEnumerable),
        ht = ft(Object.prototype.toString),
        vt = util.types,
        wt = vt.isAnyArrayBuffer,
        gt = vt.isArrayBufferView,
        At = vt.isDate,
        Pt = vt.isMap,
        Bt = vt.isRegExp,
        Lt = vt.isSet,
        Nt = vt.isNativeError,
        Ut = vt.isBoxedPrimitive,
        Vt = vt.isNumberObject,
        Ft = vt.isStringObject,
        Wt = vt.isBooleanObject,
        Ct = vt.isBigIntObject,
        it = vt.isSymbolObject,
        at = vt.isFloat32Array,
        mt = vt.isFloat64Array;

    function xt(Gt) {
        if (Gt.length === 0 || Gt.length > 10) return !0;
        for (var Yt = 0; Yt < Gt.length; Yt++) {
            var nn = Gt.charCodeAt(Yt);
            if (nn < 48 || nn > 57) return !0
        }
        return Gt.length === 10 && Gt >= Math.pow(2, 32)
    }

    function $t(Gt) {
        return Object.keys(Gt).filter(xt).concat(st(Gt).filter(Object.prototype.propertyIsEnumerable.bind(Gt)))
    }
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    function Rt(Gt, Yt) {
        if (Gt === Yt) return 0;
        for (var nn = Gt.length, St = Yt.length, ct = 0, pt = Math.min(nn, St); ct < pt; ++ct)
            if (Gt[ct] !== Yt[ct]) {
                nn = Gt[ct], St = Yt[ct];
                break
            }
        return nn < St ? -1 : St < nn ? 1 : 0
    }
    var It = !0,
        Tt = !1,
        dt = 0,
        Et = 1,
        Ot = 2,
        Mt = 3;

    function jt(Gt, Yt) {
        return tt ? Gt.source === Yt.source && Gt.flags === Yt.flags : RegExp.prototype.toString.call(Gt) === RegExp.prototype.toString.call(Yt)
    }

    function Qt(Gt, Yt) {
        if (Gt.byteLength !== Yt.byteLength) return !1;
        for (var nn = 0; nn < Gt.byteLength; nn++)
            if (Gt[nn] !== Yt[nn]) return !1;
        return !0
    }

    function Kt(Gt, Yt) {
        return Gt.byteLength !== Yt.byteLength ? !1 : Rt(new Uint8Array(Gt.buffer, Gt.byteOffset, Gt.byteLength), new Uint8Array(Yt.buffer, Yt.byteOffset, Yt.byteLength)) === 0
    }

    function qt(Gt, Yt) {
        return Gt.byteLength === Yt.byteLength && Rt(new Uint8Array(Gt), new Uint8Array(Yt)) === 0
    }

    function Jt(Gt, Yt) {
        return Vt(Gt) ? Vt(Yt) && ot(Number.prototype.valueOf.call(Gt), Number.prototype.valueOf.call(Yt)) : Ft(Gt) ? Ft(Yt) && String.prototype.valueOf.call(Gt) === String.prototype.valueOf.call(Yt) : Wt(Gt) ? Wt(Yt) && Boolean.prototype.valueOf.call(Gt) === Boolean.prototype.valueOf.call(Yt) : Ct(Gt) ? Ct(Yt) && BigInt.prototype.valueOf.call(Gt) === BigInt.prototype.valueOf.call(Yt) : it(Yt) && Symbol.prototype.valueOf.call(Gt) === Symbol.prototype.valueOf.call(Yt)
    }

    function Zt(Gt, Yt, nn, St) {
        if (Gt === Yt) return Gt !== 0 ? !0 : nn ? ot(Gt, Yt) : !0;
        if (nn) {
            if (et(Gt) !== "object") return typeof Gt == "number" && lt(Gt) && lt(Yt);
            if (et(Yt) !== "object" || Gt === null || Yt === null || Object.getPrototypeOf(Gt) !== Object.getPrototypeOf(Yt)) return !1
        } else {
            if (Gt === null || et(Gt) !== "object") return Yt === null || et(Yt) !== "object" ? Gt == Yt : !1;
            if (Yt === null || et(Yt) !== "object") return !1
        }
        var ct = ht(Gt),
            pt = ht(Yt);
        if (ct !== pt) return !1;
        if (Array.isArray(Gt)) {
            if (Gt.length !== Yt.length) return !1;
            var kt = $t(Gt),
                Dt = $t(Yt);
            return kt.length !== Dt.length ? !1 : ln(Gt, Yt, nn, St, Et, kt)
        }
        if (ct === "[object Object]" && (!Pt(Gt) && Pt(Yt) || !Lt(Gt) && Lt(Yt))) return !1;
        if (At(Gt)) {
            if (!At(Yt) || Date.prototype.getTime.call(Gt) !== Date.prototype.getTime.call(Yt)) return !1
        } else if (Bt(Gt)) {
            if (!Bt(Yt) || !jt(Gt, Yt)) return !1
        } else if (Nt(Gt) || Gt instanceof Error) {
            if (Gt.message !== Yt.message || Gt.name !== Yt.name) return !1
        } else if (gt(Gt)) {
            if (!nn && (at(Gt) || mt(Gt))) {
                if (!Qt(Gt, Yt)) return !1
            } else if (!Kt(Gt, Yt)) return !1;
            var zt = $t(Gt),
                Ht = $t(Yt);
            return zt.length !== Ht.length ? !1 : ln(Gt, Yt, nn, St, dt, zt)
        } else {
            if (Lt(Gt)) return !Lt(Yt) || Gt.size !== Yt.size ? !1 : ln(Gt, Yt, nn, St, Ot);
            if (Pt(Gt)) return !Pt(Yt) || Gt.size !== Yt.size ? !1 : ln(Gt, Yt, nn, St, Mt);
            if (wt(Gt)) {
                if (!qt(Gt, Yt)) return !1
            } else if (Ut(Gt) && !Jt(Gt, Yt)) return !1
        }
        return ln(Gt, Yt, nn, St, dt)
    }

    function en(Gt, Yt) {
        return Yt.filter(function(nn) {
            return bt(Gt, nn)
        })
    }

    function ln(Gt, Yt, nn, St, ct, pt) {
        if (arguments.length === 5) {
            pt = Object.keys(Gt);
            var kt = Object.keys(Yt);
            if (pt.length !== kt.length) return !1
        }
        for (var Dt = 0; Dt < pt.length; Dt++)
            if (!yt(Yt, pt[Dt])) return !1;
        if (nn && arguments.length === 5) {
            var zt = st(Gt);
            if (zt.length !== 0) {
                var Ht = 0;
                for (Dt = 0; Dt < zt.length; Dt++) {
                    var an = zt[Dt];
                    if (bt(Gt, an)) {
                        if (!bt(Yt, an)) return !1;
                        pt.push(an), Ht++
                    } else if (bt(Yt, an)) return !1
                }
                var Xt = st(Yt);
                if (zt.length !== Xt.length && en(Yt, Xt).length !== Ht) return !1
            } else {
                var tn = st(Yt);
                if (tn.length !== 0 && en(Yt, tn).length !== 0) return !1
            }
        }
        if (pt.length === 0 && (ct === dt || ct === Et && Gt.length === 0 || Gt.size === 0)) return !0;
        if (St === void 0) St = {
            val1: new Map,
            val2: new Map,
            position: 0
        };
        else {
            var pn = St.val1.get(Gt);
            if (pn !== void 0) {
                var sn = St.val2.get(Yt);
                if (sn !== void 0) return pn === sn
            }
            St.position++
        }
        St.val1.set(Gt, St.position), St.val2.set(Yt, St.position);
        var yn = dn(Gt, Yt, nn, pt, St, ct);
        return St.val1.delete(Gt), St.val2.delete(Yt), yn
    }

    function cn(Gt, Yt, nn, St) {
        for (var ct = nt(Gt), pt = 0; pt < ct.length; pt++) {
            var kt = ct[pt];
            if (Zt(Yt, kt, nn, St)) return Gt.delete(kt), !0
        }
        return !1
    }

    function un(Gt) {
        switch (et(Gt)) {
            case "undefined":
                return null;
            case "object":
                return;
            case "symbol":
                return !1;
            case "string":
                Gt = +Gt;
            case "number":
                if (lt(Gt)) return !1
        }
        return !0
    }

    function Nn(Gt, Yt, nn) {
        var St = un(nn);
        return St ? ? (Yt.has(St) && !Gt.has(St))
    }

    function hn(Gt, Yt, nn, St, ct) {
        var pt = un(nn);
        if (pt != null) return pt;
        var kt = Yt.get(pt);
        return kt === void 0 && !Yt.has(pt) || !Zt(St, kt, !1, ct) ? !1 : !Gt.has(pt) && Zt(St, kt, !1, ct)
    }

    function fn(Gt, Yt, nn, St) {
        for (var ct = null, pt = nt(Gt), kt = 0; kt < pt.length; kt++) {
            var Dt = pt[kt];
            if (et(Dt) === "object" && Dt !== null) ct === null && (ct = new Set), ct.add(Dt);
            else if (!Yt.has(Dt)) {
                if (nn || !Nn(Gt, Yt, Dt)) return !1;
                ct === null && (ct = new Set), ct.add(Dt)
            }
        }
        if (ct !== null) {
            for (var zt = nt(Yt), Ht = 0; Ht < zt.length; Ht++) {
                var an = zt[Ht];
                if (et(an) === "object" && an !== null) {
                    if (!cn(ct, an, nn, St)) return !1
                } else if (!nn && !Gt.has(an) && !cn(ct, an, nn, St)) return !1
            }
            return ct.size === 0
        }
        return !0
    }

    function rn(Gt, Yt, nn, St, ct, pt) {
        for (var kt = nt(Gt), Dt = 0; Dt < kt.length; Dt++) {
            var zt = kt[Dt];
            if (Zt(nn, zt, ct, pt) && Zt(St, Yt.get(zt), ct, pt)) return Gt.delete(zt), !0
        }
        return !1
    }

    function mn(Gt, Yt, nn, St) {
        for (var ct = null, pt = rt(Gt), kt = 0; kt < pt.length; kt++) {
            var Dt = s(pt[kt], 2),
                zt = Dt[0],
                Ht = Dt[1];
            if (et(zt) === "object" && zt !== null) ct === null && (ct = new Set), ct.add(zt);
            else {
                var an = Yt.get(zt);
                if (an === void 0 && !Yt.has(zt) || !Zt(Ht, an, nn, St)) {
                    if (nn || !hn(Gt, Yt, zt, Ht, St)) return !1;
                    ct === null && (ct = new Set), ct.add(zt)
                }
            }
        }
        if (ct !== null) {
            for (var Xt = rt(Yt), tn = 0; tn < Xt.length; tn++) {
                var pn = s(Xt[tn], 2),
                    sn = pn[0],
                    yn = pn[1];
                if (et(sn) === "object" && sn !== null) {
                    if (!rn(ct, Gt, sn, yn, nn, St)) return !1
                } else if (!nn && (!Gt.has(sn) || !Zt(Gt.get(sn), yn, !1, St)) && !rn(ct, Gt, sn, yn, !1, St)) return !1
            }
            return ct.size === 0
        }
        return !0
    }

    function dn(Gt, Yt, nn, St, ct, pt) {
        var kt = 0;
        if (pt === Ot) {
            if (!fn(Gt, Yt, nn, ct)) return !1
        } else if (pt === Mt) {
            if (!mn(Gt, Yt, nn, ct)) return !1
        } else if (pt === Et)
            for (; kt < Gt.length; kt++)
                if (yt(Gt, kt)) {
                    if (!yt(Yt, kt) || !Zt(Gt[kt], Yt[kt], nn, ct)) return !1
                } else {
                    if (yt(Yt, kt)) return !1;
                    for (var Dt = Object.keys(Gt); kt < Dt.length; kt++) {
                        var zt = Dt[kt];
                        if (!yt(Yt, zt) || !Zt(Gt[zt], Yt[zt], nn, ct)) return !1
                    }
                    return Dt.length === Object.keys(Yt).length
                }
        for (kt = 0; kt < St.length; kt++) {
            var Ht = St[kt];
            if (!Zt(Gt[Ht], Yt[Ht], nn, ct)) return !1
        }
        return !0
    }

    function vn(Gt, Yt) {
        return Zt(Gt, Yt, Tt)
    }

    function gn(Gt, Yt) {
        return Zt(Gt, Yt, It)
    }
    return comparisons = {
        isDeepEqual: vn,
        isDeepStrictEqual: gn
    }, comparisons
}
var hasRequiredAssert;

function requireAssert() {
    if (hasRequiredAssert) return assert$1.exports;
    hasRequiredAssert = 1;

    function s(Ot) {
        "@babel/helpers - typeof";
        return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Mt) {
            return typeof Mt
        } : function(Mt) {
            return Mt && typeof Symbol == "function" && Mt.constructor === Symbol && Mt !== Symbol.prototype ? "symbol" : typeof Mt
        }, s(Ot)
    }

    function o(Ot, Mt, jt) {
        return Object.defineProperty(Ot, "prototype", {
            writable: !1
        }), Ot
    }

    function a(Ot, Mt) {
        if (!(Ot instanceof Mt)) throw new TypeError("Cannot call a class as a function")
    }
    var $ = requireErrors(),
        j = $.codes,
        _e = j.ERR_AMBIGUOUS_ARGUMENT,
        et = j.ERR_INVALID_ARG_TYPE,
        tt = j.ERR_INVALID_ARG_VALUE,
        nt = j.ERR_INVALID_RETURN_VALUE,
        rt = j.ERR_MISSING_ARGS,
        ot = requireAssertion_error(),
        st = util,
        lt = st.inspect,
        ft = util.types,
        yt = ft.isPromise,
        bt = ft.isRegExp,
        ht = polyfill$2(),
        vt = polyfill$1(),
        wt = callBound$3("RegExp.prototype.test"),
        gt, At;

    function Pt() {
        var Ot = requireComparisons();
        gt = Ot.isDeepEqual, At = Ot.isDeepStrictEqual
    }
    var Bt = !1,
        Lt = assert$1.exports = Wt,
        Nt = {};

    function Ut(Ot) {
        throw Ot.message instanceof Error ? Ot.message : new ot(Ot)
    }

    function Vt(Ot, Mt, jt, Qt, Kt) {
        var qt = arguments.length,
            Jt;
        if (qt === 0) Jt = "Failed";
        else if (qt === 1) jt = Ot, Ot = void 0;
        else {
            if (Bt === !1) {
                Bt = !0;
                var Zt = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                Zt("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")
            }
            qt === 2 && (Qt = "!=")
        }
        if (jt instanceof Error) throw jt;
        var en = {
            actual: Ot,
            expected: Mt,
            operator: Qt === void 0 ? "fail" : Qt,
            stackStartFn: Kt || Vt
        };
        jt !== void 0 && (en.message = jt);
        var ln = new ot(en);
        throw Jt && (ln.message = Jt, ln.generatedMessage = !0), ln
    }
    Lt.fail = Vt, Lt.AssertionError = ot;

    function Ft(Ot, Mt, jt, Qt) {
        if (!jt) {
            var Kt = !1;
            if (Mt === 0) Kt = !0, Qt = "No value argument passed to `assert.ok()`";
            else if (Qt instanceof Error) throw Qt;
            var qt = new ot({
                actual: jt,
                expected: !0,
                message: Qt,
                operator: "==",
                stackStartFn: Ot
            });
            throw qt.generatedMessage = Kt, qt
        }
    }

    function Wt() {
        for (var Ot = arguments.length, Mt = new Array(Ot), jt = 0; jt < Ot; jt++) Mt[jt] = arguments[jt];
        Ft.apply(void 0, [Wt, Mt.length].concat(Mt))
    }
    Lt.ok = Wt, Lt.equal = function Ot(Mt, jt, Qt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        Mt != jt && Ut({
            actual: Mt,
            expected: jt,
            message: Qt,
            operator: "==",
            stackStartFn: Ot
        })
    }, Lt.notEqual = function Ot(Mt, jt, Qt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        Mt == jt && Ut({
            actual: Mt,
            expected: jt,
            message: Qt,
            operator: "!=",
            stackStartFn: Ot
        })
    }, Lt.deepEqual = function Ot(Mt, jt, Qt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        gt === void 0 && Pt(), gt(Mt, jt) || Ut({
            actual: Mt,
            expected: jt,
            message: Qt,
            operator: "deepEqual",
            stackStartFn: Ot
        })
    }, Lt.notDeepEqual = function Ot(Mt, jt, Qt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        gt === void 0 && Pt(), gt(Mt, jt) && Ut({
            actual: Mt,
            expected: jt,
            message: Qt,
            operator: "notDeepEqual",
            stackStartFn: Ot
        })
    }, Lt.deepStrictEqual = function Ot(Mt, jt, Qt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        gt === void 0 && Pt(), At(Mt, jt) || Ut({
            actual: Mt,
            expected: jt,
            message: Qt,
            operator: "deepStrictEqual",
            stackStartFn: Ot
        })
    }, Lt.notDeepStrictEqual = Ct;

    function Ct(Ot, Mt, jt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        gt === void 0 && Pt(), At(Ot, Mt) && Ut({
            actual: Ot,
            expected: Mt,
            message: jt,
            operator: "notDeepStrictEqual",
            stackStartFn: Ct
        })
    }
    Lt.strictEqual = function Ot(Mt, jt, Qt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        vt(Mt, jt) || Ut({
            actual: Mt,
            expected: jt,
            message: Qt,
            operator: "strictEqual",
            stackStartFn: Ot
        })
    }, Lt.notStrictEqual = function Ot(Mt, jt, Qt) {
        if (arguments.length < 2) throw new rt("actual", "expected");
        vt(Mt, jt) && Ut({
            actual: Mt,
            expected: jt,
            message: Qt,
            operator: "notStrictEqual",
            stackStartFn: Ot
        })
    };
    var it = o(function Ot(Mt, jt, Qt) {
        var Kt = this;
        a(this, Ot), jt.forEach(function(qt) {
            qt in Mt && (Qt !== void 0 && typeof Qt[qt] == "string" && bt(Mt[qt]) && wt(Mt[qt], Qt[qt]) ? Kt[qt] = Qt[qt] : Kt[qt] = Mt[qt])
        })
    });

    function at(Ot, Mt, jt, Qt, Kt, qt) {
        if (!(jt in Ot) || !At(Ot[jt], Mt[jt])) {
            if (!Qt) {
                var Jt = new it(Ot, Kt),
                    Zt = new it(Mt, Kt, Ot),
                    en = new ot({
                        actual: Jt,
                        expected: Zt,
                        operator: "deepStrictEqual",
                        stackStartFn: qt
                    });
                throw en.actual = Ot, en.expected = Mt, en.operator = qt.name, en
            }
            Ut({
                actual: Ot,
                expected: Mt,
                message: Qt,
                operator: qt.name,
                stackStartFn: qt
            })
        }
    }

    function mt(Ot, Mt, jt, Qt) {
        if (typeof Mt != "function") {
            if (bt(Mt)) return wt(Mt, Ot);
            if (arguments.length === 2) throw new et("expected", ["Function", "RegExp"], Mt);
            if (s(Ot) !== "object" || Ot === null) {
                var Kt = new ot({
                    actual: Ot,
                    expected: Mt,
                    message: jt,
                    operator: "deepStrictEqual",
                    stackStartFn: Qt
                });
                throw Kt.operator = Qt.name, Kt
            }
            var qt = Object.keys(Mt);
            if (Mt instanceof Error) qt.push("name", "message");
            else if (qt.length === 0) throw new tt("error", Mt, "may not be an empty object");
            return gt === void 0 && Pt(), qt.forEach(function(Jt) {
                typeof Ot[Jt] == "string" && bt(Mt[Jt]) && wt(Mt[Jt], Ot[Jt]) || at(Ot, Mt, Jt, jt, qt, Qt)
            }), !0
        }
        return Mt.prototype !== void 0 && Ot instanceof Mt ? !0 : Error.isPrototypeOf(Mt) ? !1 : Mt.call({}, Ot) === !0
    }

    function xt(Ot) {
        if (typeof Ot != "function") throw new et("fn", "Function", Ot);
        try {
            Ot()
        } catch (Mt) {
            return Mt
        }
        return Nt
    }

    function $t(Ot) {
        return yt(Ot) || Ot !== null && s(Ot) === "object" && typeof Ot.then == "function" && typeof Ot.catch == "function"
    }

    function Rt(Ot) {
        return Promise.resolve().then(function() {
            var Mt;
            if (typeof Ot == "function") {
                if (Mt = Ot(), !$t(Mt)) throw new nt("instance of Promise", "promiseFn", Mt)
            } else if ($t(Ot)) Mt = Ot;
            else throw new et("promiseFn", ["Function", "Promise"], Ot);
            return Promise.resolve().then(function() {
                return Mt
            }).then(function() {
                return Nt
            }).catch(function(jt) {
                return jt
            })
        })
    }

    function It(Ot, Mt, jt, Qt) {
        if (typeof jt == "string") {
            if (arguments.length === 4) throw new et("error", ["Object", "Error", "Function", "RegExp"], jt);
            if (s(Mt) === "object" && Mt !== null) {
                if (Mt.message === jt) throw new _e("error/message", 'The error message "'.concat(Mt.message, '" is identical to the message.'))
            } else if (Mt === jt) throw new _e("error/message", 'The error "'.concat(Mt, '" is identical to the message.'));
            Qt = jt, jt = void 0
        } else if (jt != null && s(jt) !== "object" && typeof jt != "function") throw new et("error", ["Object", "Error", "Function", "RegExp"], jt);
        if (Mt === Nt) {
            var Kt = "";
            jt && jt.name && (Kt += " (".concat(jt.name, ")")), Kt += Qt ? ": ".concat(Qt) : ".";
            var qt = Ot.name === "rejects" ? "rejection" : "exception";
            Ut({
                actual: void 0,
                expected: jt,
                operator: Ot.name,
                message: "Missing expected ".concat(qt).concat(Kt),
                stackStartFn: Ot
            })
        }
        if (jt && !mt(Mt, jt, Qt, Ot)) throw Mt
    }

    function Tt(Ot, Mt, jt, Qt) {
        if (Mt !== Nt) {
            if (typeof jt == "string" && (Qt = jt, jt = void 0), !jt || mt(Mt, jt)) {
                var Kt = Qt ? ": ".concat(Qt) : ".",
                    qt = Ot.name === "doesNotReject" ? "rejection" : "exception";
                Ut({
                    actual: Mt,
                    expected: jt,
                    operator: Ot.name,
                    message: "Got unwanted ".concat(qt).concat(Kt, `
`) + 'Actual message: "'.concat(Mt && Mt.message, '"'),
                    stackStartFn: Ot
                })
            }
            throw Mt
        }
    }
    Lt.throws = function Ot(Mt) {
        for (var jt = arguments.length, Qt = new Array(jt > 1 ? jt - 1 : 0), Kt = 1; Kt < jt; Kt++) Qt[Kt - 1] = arguments[Kt];
        It.apply(void 0, [Ot, xt(Mt)].concat(Qt))
    }, Lt.rejects = function Ot(Mt) {
        for (var jt = arguments.length, Qt = new Array(jt > 1 ? jt - 1 : 0), Kt = 1; Kt < jt; Kt++) Qt[Kt - 1] = arguments[Kt];
        return Rt(Mt).then(function(qt) {
            return It.apply(void 0, [Ot, qt].concat(Qt))
        })
    }, Lt.doesNotThrow = function Ot(Mt) {
        for (var jt = arguments.length, Qt = new Array(jt > 1 ? jt - 1 : 0), Kt = 1; Kt < jt; Kt++) Qt[Kt - 1] = arguments[Kt];
        Tt.apply(void 0, [Ot, xt(Mt)].concat(Qt))
    }, Lt.doesNotReject = function Ot(Mt) {
        for (var jt = arguments.length, Qt = new Array(jt > 1 ? jt - 1 : 0), Kt = 1; Kt < jt; Kt++) Qt[Kt - 1] = arguments[Kt];
        return Rt(Mt).then(function(qt) {
            return Tt.apply(void 0, [Ot, qt].concat(Qt))
        })
    }, Lt.ifError = function Ot(Mt) {
        if (Mt != null) {
            var jt = "ifError got unwanted exception: ";
            s(Mt) === "object" && typeof Mt.message == "string" ? Mt.message.length === 0 && Mt.constructor ? jt += Mt.constructor.name : jt += Mt.message : jt += lt(Mt);
            var Qt = new ot({
                    actual: Mt,
                    expected: null,
                    operator: "ifError",
                    message: jt,
                    stackStartFn: Ot
                }),
                Kt = Mt.stack;
            if (typeof Kt == "string") {
                var qt = Kt.split(`
`);
                qt.shift();
                for (var Jt = Qt.stack.split(`
`), Zt = 0; Zt < qt.length; Zt++) {
                    var en = Jt.indexOf(qt[Zt]);
                    if (en !== -1) {
                        Jt = Jt.slice(0, en);
                        break
                    }
                }
                Qt.stack = "".concat(Jt.join(`
`), `
`).concat(qt.join(`
`))
            }
            throw Qt
        }
    };

    function dt(Ot, Mt, jt, Qt, Kt) {
        if (!bt(Mt)) throw new et("regexp", "RegExp", Mt);
        var qt = Kt === "match";
        if (typeof Ot != "string" || wt(Mt, Ot) !== qt) {
            if (jt instanceof Error) throw jt;
            var Jt = !jt;
            jt = jt || (typeof Ot != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(s(Ot), " (").concat(lt(Ot), ")") : (qt ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(lt(Mt), `. Input:

`).concat(lt(Ot), `
`));
            var Zt = new ot({
                actual: Ot,
                expected: Mt,
                message: jt,
                operator: Kt,
                stackStartFn: Qt
            });
            throw Zt.generatedMessage = Jt, Zt
        }
    }
    Lt.match = function Ot(Mt, jt, Qt) {
        dt(Mt, jt, Qt, Ot, "match")
    }, Lt.doesNotMatch = function Ot(Mt, jt, Qt) {
        dt(Mt, jt, Qt, Ot, "doesNotMatch")
    };

    function Et() {
        for (var Ot = arguments.length, Mt = new Array(Ot), jt = 0; jt < Ot; jt++) Mt[jt] = arguments[jt];
        Ft.apply(void 0, [Et, Mt.length].concat(Mt))
    }
    return Lt.strict = ht(Et, Lt, {
        equal: Lt.strictEqual,
        deepEqual: Lt.deepStrictEqual,
        notEqual: Lt.notStrictEqual,
        notDeepEqual: Lt.notDeepStrictEqual
    }), Lt.strict.strict = Lt.strict, assert$1.exports
}
var assertExports = requireAssert();

function chunks(s, o) {
    return Array.apply(0, new Array(Math.ceil(s.length / o))).map((a, $) => s.slice($ * o, ($ + 1) * o))
}

function encode$3(s) {
    return s.reduce((o, a) => o + a.toString(16).padStart(2, "0"), "0x")
}

function decode$3(s) {
    s.indexOf("0x") === 0 && (s = s.substr(2)), s.length % 2 === 1 && (s = "0" + s);
    let o = s.match(/.{2}/g);
    return o === null ? buffer.Buffer.from([]) : buffer.Buffer.from(o.map(a => parseInt(a, 16)))
}
var hex = Object.freeze({
    __proto__: null,
    encode: encode$3,
    decode: decode$3
});

function decode$2(s) {
    return new TextDecoder("utf-8").decode(s)
}

function encode$2(s) {
    return new TextEncoder().encode(s)
}
var utf8 = Object.freeze({
    __proto__: null,
    decode: decode$2,
    encode: encode$2
});

function encode$1(s) {
    return bs58$1$1.encode(s)
}

function decode$1(s) {
    return bs58$1$1.decode(s)
}
var bs58 = Object.freeze({
    __proto__: null,
    encode: encode$1,
    decode: decode$1
});

function encode(s) {
    return fromByteArray_1(s)
}

function decode(s) {
    return buffer.Buffer.from(toByteArray_1(s))
}
var base64 = Object.freeze({
        __proto__: null,
        encode,
        decode
    }),
    index$1 = Object.freeze({
        __proto__: null,
        hex,
        utf8,
        bs58,
        base64
    });

function parseIdlErrors(s) {
    const o = new Map;
    return s.errors && s.errors.forEach(a => {
        var $;
        let j = ($ = a.msg) !== null && $ !== void 0 ? $ : a.name;
        o.set(a.code, j)
    }), o
}

function toInstruction(s, ...o) {
    if (s.args.length != o.length) throw new Error("Invalid argument length");
    const a = {};
    let $ = 0;
    return s.args.forEach(j => {
        a[j.name] = o[$], $ += 1
    }), a
}

function validateAccounts(s, o = {}) {
    s.forEach(a => {
        if ("accounts" in a) validateAccounts(a.accounts, o[a.name]);
        else if (o[a.name] === void 0) throw new Error(`Invalid arguments: ${a.name} not provided.`)
    })
}

function translateAddress(s) {
    return s instanceof PublicKey ? s : new PublicKey(s)
}
class StructError extends TypeError {
    constructor(o, a) {
        let $;
        const {
            message: j,
            ..._e
        } = o, {
            path: et
        } = o, tt = et.length === 0 ? j : "At path: " + et.join(".") + " -- " + j;
        super(tt), this.value = void 0, this.key = void 0, this.type = void 0, this.refinement = void 0, this.path = void 0, this.branch = void 0, this.failures = void 0, Object.assign(this, _e), this.name = this.constructor.name, this.failures = () => {
            var nt;
            return (nt = $) != null ? nt : $ = [o, ...a()]
        }
    }
}

function isIterable(s) {
    return isObject(s) && typeof s[Symbol.iterator] == "function"
}

function isObject(s) {
    return typeof s == "object" && s != null
}

function print(s) {
    return typeof s == "string" ? JSON.stringify(s) : "" + s
}

function shiftIterator(s) {
    const {
        done: o,
        value: a
    } = s.next();
    return o ? void 0 : a
}

function toFailure(s, o, a, $) {
    if (s === !0) return;
    s === !1 ? s = {} : typeof s == "string" && (s = {
        message: s
    });
    const {
        path: j,
        branch: _e
    } = o, {
        type: et
    } = a, {
        refinement: tt,
        message: nt = "Expected a value of type `" + et + "`" + (tt ? " with refinement `" + tt + "`" : "") + ", but received: `" + print($) + "`"
    } = s;
    return {
        value: $,
        type: et,
        refinement: tt,
        key: j[j.length - 1],
        path: j,
        branch: _e,
        ...s,
        message: nt
    }
}

function* toFailures(s, o, a, $) {
    isIterable(s) || (s = [s]);
    for (const j of s) {
        const _e = toFailure(j, o, a, $);
        _e && (yield _e)
    }
}

function* run(s, o, a) {
    a === void 0 && (a = {});
    const {
        path: $ = [],
        branch: j = [s],
        coerce: _e = !1,
        mask: et = !1
    } = a, tt = {
        path: $,
        branch: j
    };
    if (_e && (s = o.coercer(s, tt), et && o.type !== "type" && isObject(o.schema) && isObject(s) && !Array.isArray(s)))
        for (const rt in s) o.schema[rt] === void 0 && delete s[rt];
    let nt = !0;
    for (const rt of o.validator(s, tt)) nt = !1, yield [rt, void 0];
    for (let [rt, ot, st] of o.entries(s, tt)) {
        const lt = run(ot, st, {
            path: rt === void 0 ? $ : [...$, rt],
            branch: rt === void 0 ? j : [...j, ot],
            coerce: _e,
            mask: et
        });
        for (const ft of lt) ft[0] ? (nt = !1, yield [ft[0], void 0]) : _e && (ot = ft[1], rt === void 0 ? s = ot : s instanceof Map ? s.set(rt, ot) : s instanceof Set ? s.add(ot) : isObject(s) && (s[rt] = ot))
    }
    if (nt)
        for (const rt of o.refiner(s, tt)) nt = !1, yield [rt, void 0];
    nt && (yield [void 0, s])
}
class Struct {
    constructor(o) {
        this.TYPE = void 0, this.type = void 0, this.schema = void 0, this.coercer = void 0, this.validator = void 0, this.refiner = void 0, this.entries = void 0;
        const {
            type: a,
            schema: $,
            validator: j,
            refiner: _e,
            coercer: et = nt => nt,
            entries: tt = function*() {}
        } = o;
        this.type = a, this.schema = $, this.entries = tt, this.coercer = et, j ? this.validator = (nt, rt) => {
            const ot = j(nt, rt);
            return toFailures(ot, rt, this, nt)
        } : this.validator = () => [], _e ? this.refiner = (nt, rt) => {
            const ot = _e(nt, rt);
            return toFailures(ot, rt, this, nt)
        } : this.refiner = () => []
    }
    assert(o) {
        return assert(o, this)
    }
    create(o) {
        return create(o, this)
    }
    is(o) {
        return is(o, this)
    }
    mask(o) {
        return mask(o, this)
    }
    validate(o, a) {
        return a === void 0 && (a = {}), validate(o, this, a)
    }
}

function assert(s, o) {
    const a = validate(s, o);
    if (a[0]) throw a[0]
}

function create(s, o) {
    const a = validate(s, o, {
        coerce: !0
    });
    if (a[0]) throw a[0];
    return a[1]
}

function mask(s, o) {
    const a = validate(s, o, {
        coerce: !0,
        mask: !0
    });
    if (a[0]) throw a[0];
    return a[1]
}

function is(s, o) {
    return !validate(s, o)[0]
}

function validate(s, o, a) {
    a === void 0 && (a = {});
    const $ = run(s, o, a),
        j = shiftIterator($);
    return j[0] ? [new StructError(j[0], function*() {
        for (const et of $) et[0] && (yield et[0])
    }), void 0] : [void 0, j[1]]
}

function define(s, o) {
    return new Struct({
        type: s,
        schema: null,
        validator: o
    })
}

function any() {
    return define("any", () => !0)
}

function array(s) {
    return new Struct({
        type: "array",
        schema: s,
        * entries(o) {
            if (s && Array.isArray(o))
                for (const [a, $] of o.entries()) yield [a, $, s]
        },
        coercer(o) {
            return Array.isArray(o) ? o.slice() : o
        },
        validator(o) {
            return Array.isArray(o) || "Expected an array value, but received: " + print(o)
        }
    })
}

function boolean() {
    return define("boolean", s => typeof s == "boolean")
}

function literal(s) {
    const o = print(s);
    return new Struct({
        type: "literal",
        schema: s,
        validator(a) {
            return a === s || "Expected the literal `" + o + "`, but received: " + print(a)
        }
    })
}

function nullable(s) {
    return new Struct({ ...s,
        validator: (o, a) => o === null || s.validator(o, a),
        refiner: (o, a) => o === null || s.refiner(o, a)
    })
}

function number() {
    return define("number", s => typeof s == "number" && !isNaN(s) || "Expected a number, but received: " + print(s))
}

function optional(s) {
    return new Struct({ ...s,
        validator: (o, a) => o === void 0 || s.validator(o, a),
        refiner: (o, a) => o === void 0 || s.refiner(o, a)
    })
}

function string() {
    return define("string", s => typeof s == "string" || "Expected a string, but received: " + print(s))
}

function type(s) {
    const o = Object.keys(s);
    return new Struct({
        type: "type",
        schema: s,
        * entries(a) {
            if (isObject(a))
                for (const $ of o) yield [$, a[$], s[$]]
        },
        validator(a) {
            return isObject(a) || "Expected an object, but received: " + print(a)
        }
    })
}

function union$1(s) {
    const o = s.map(a => a.type).join(" | ");
    return new Struct({
        type: "union",
        schema: null,
        coercer(a, $) {
            return (s.find(_e => {
                const [et] = _e.validate(a, {
                    coerce: !0
                });
                return !et
            }) || unknown()).coercer(a, $)
        },
        validator(a, $) {
            const j = [];
            for (const _e of s) {
                const [...et] = run(a, _e, $), [tt] = et;
                if (tt[0])
                    for (const [nt] of et) nt && j.push(nt);
                else return []
            }
            return ["Expected the value to satisfy a union of `" + o + "`, but received: " + print(a), ...j]
        }
    })
}

function unknown() {
    return define("unknown", () => !0)
}

function coerce(s, o, a) {
    return new Struct({ ...s,
        coercer: ($, j) => is($, o) ? s.coercer(a($, j), j) : s.coercer($, j)
    })
}
async function invoke(s, o, a, $) {
    s = translateAddress(s), $ || ($ = getProvider());
    const j = new Transaction;
    if (j.add(new TransactionInstruction({
            programId: s,
            keys: o ? ? [],
            data: a
        })), $.sendAndConfirm === void 0) throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
    return await $.sendAndConfirm(j, [])
}
const GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
async function getMultipleAccounts(s, o, a) {
    return (await getMultipleAccountsAndContext(s, o, a)).map(j => j ? {
        publicKey: j.publicKey,
        account: j.account
    } : null)
}
async function getMultipleAccountsAndContext(s, o, a) {
    if (o.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) return await getMultipleAccountsAndContextCore(s, o, a); {
        const $ = chunks(o, GET_MULTIPLE_ACCOUNTS_LIMIT);
        return (await Promise.all($.map(_e => getMultipleAccountsAndContextCore(s, _e, a)))).flat()
    }
}
async function getMultipleAccountsAndContextCore(s, o, a) {
    const $ = a ? ? s.commitment,
        {
            value: j,
            context: _e
        } = await s.getMultipleAccountsInfoAndContext(o, $);
    return j.map((tt, nt) => tt === null ? null : {
        publicKey: o[nt],
        account: tt,
        context: _e
    })
}
async function simulateTransaction(s, o, a, $, j) {
    a && a.length > 0 && o.sign(...a);
    const _e = o._compile(),
        et = _e.serialize(),
        nt = o._serialize(et).toString("base64"),
        rt = {
            encoding: "base64",
            commitment: $ ? ? s.commitment
        };
    if (j) {
        const ft = (Array.isArray(j) ? j : _e.nonProgramIds()).map(yt => yt.toBase58());
        rt.accounts = {
            encoding: "base64",
            addresses: ft
        }
    }
    a && (rt.sigVerify = !0);
    const ot = [nt, rt],
        st = await s._rpcRequest("simulateTransaction", ot),
        lt = create(st, SimulatedTransactionResponseStruct);
    if ("error" in lt) {
        let ft;
        if ("data" in lt.error && (ft = lt.error.data.logs, ft && Array.isArray(ft))) {
            const yt = `
    `,
                bt = yt + ft.join(yt);
            console.error(lt.error.message, bt)
        }
        throw new SendTransactionError("failed to simulate transaction: " + lt.error.message, ft)
    }
    return lt.result
}

function jsonRpcResult(s) {
    return coerce(createRpcResult(s), UnknownRpcResult, o => "error" in o ? o : { ...o,
        result: create(o.result, s)
    })
}
const UnknownRpcResult = createRpcResult(unknown());

function createRpcResult(s) {
    return union$1([type({
        jsonrpc: literal("2.0"),
        id: string(),
        result: s
    }), type({
        jsonrpc: literal("2.0"),
        id: string(),
        error: type({
            code: unknown(),
            message: string(),
            data: optional(any())
        })
    })])
}

function jsonRpcResultAndContext(s) {
    return jsonRpcResult(type({
        context: type({
            slot: number()
        }),
        value: s
    }))
}
const SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
    err: nullable(union$1([type({}), string()])),
    logs: nullable(array(string())),
    accounts: optional(nullable(array(nullable(type({
        executable: boolean(),
        owner: string(),
        lamports: number(),
        data: array(string()),
        rentEpoch: optional(number())
    }))))),
    unitsConsumed: optional(number())
}));
var rpc = Object.freeze({
    __proto__: null,
    invoke,
    getMultipleAccounts,
    getMultipleAccountsAndContext,
    simulateTransaction
});
class AnchorProvider {
    constructor(o, a, $) {
        this.connection = o, this.wallet = a, this.opts = $, this.publicKey = a == null ? void 0 : a.publicKey
    }
    static defaultOptions() {
        return {
            preflightCommitment: "processed",
            commitment: "processed"
        }
    }
    static local(o, a) {
        throw new Error("Provider local is not available on browser.")
    }
    static env() {
        throw new Error("Provider env is not available on browser.")
    }
    async sendAndConfirm(o, a, $) {
        var j;
        $ === void 0 && ($ = this.opts), o.feePayer = o.feePayer || this.wallet.publicKey, o.recentBlockhash = (await this.connection.getLatestBlockhash($.preflightCommitment)).blockhash, o = await this.wallet.signTransaction(o), (a ? ? []).forEach(et => {
            o.partialSign(et)
        });
        const _e = o.serialize();
        try {
            return await sendAndConfirmRawTransaction(this.connection, _e, $)
        } catch (et) {
            if (et instanceof ConfirmError) {
                const tt = await this.connection.getTransaction(encode$1(o.signature), {
                    commitment: "confirmed"
                });
                if (tt) {
                    const nt = (j = tt.meta) === null || j === void 0 ? void 0 : j.logMessages;
                    throw nt ? new SendTransactionError(et.message, nt) : et
                } else throw et
            } else throw et
        }
    }
    async sendAll(o, a) {
        var $;
        a === void 0 && (a = this.opts);
        const j = await this.connection.getLatestBlockhash(a.preflightCommitment);
        let _e = o.map(nt => {
            var rt;
            let ot = nt.tx,
                st = (rt = nt.signers) !== null && rt !== void 0 ? rt : [];
            return ot.feePayer = ot.feePayer || this.wallet.publicKey, ot.recentBlockhash = j.blockhash, st.forEach(lt => {
                ot.partialSign(lt)
            }), ot
        });
        const et = await this.wallet.signAllTransactions(_e),
            tt = [];
        for (let nt = 0; nt < _e.length; nt += 1) {
            const rt = et[nt],
                ot = rt.serialize();
            try {
                tt.push(await sendAndConfirmRawTransaction(this.connection, ot, a))
            } catch (st) {
                if (st instanceof ConfirmError) {
                    const lt = await this.connection.getTransaction(encode$1(rt.signature), {
                        commitment: "confirmed"
                    });
                    if (lt) {
                        const ft = ($ = lt.meta) === null || $ === void 0 ? void 0 : $.logMessages;
                        throw ft ? new SendTransactionError(st.message, ft) : st
                    } else throw st
                } else throw st
            }
        }
        return tt
    }
    async simulate(o, a, $, j) {
        o.feePayer = o.feePayer || this.wallet.publicKey, o.recentBlockhash = (await this.connection.getLatestBlockhash($ ? ? this.connection.commitment)).blockhash, o = await this.wallet.signTransaction(o);
        const _e = await simulateTransaction(this.connection, o, a, $, j);
        if (_e.value.err) throw new SimulateError(_e.value);
        return _e.value
    }
}
class SimulateError extends Error {
    constructor(o, a) {
        super(a), this.simulationResponse = o
    }
}
async function sendAndConfirmRawTransaction(s, o, a) {
    const $ = a && {
            skipPreflight: a.skipPreflight,
            preflightCommitment: a.preflightCommitment || a.commitment
        },
        j = await s.sendRawTransaction(o, $),
        _e = (await s.confirmTransaction(j, a && a.commitment)).value;
    if (_e.err) throw new ConfirmError(`Raw transaction ${j} failed (${JSON.stringify(_e)})`);
    return j
}
class ConfirmError extends Error {
    constructor(o) {
        super(o)
    }
}

function getProvider() {
    return AnchorProvider.local()
}
const _AVAILABLE_FEATURES = new Set(["anchor-deprecated-state", "debug-logs"]),
    _FEATURES = new Map;

function set(s) {
    if (!_AVAILABLE_FEATURES.has(s)) throw new Error("Invalid feature");
    _FEATURES.set(s, !0)
}

function isSet(s) {
    return _FEATURES.get(s) !== void 0
}
var features = Object.freeze({
    __proto__: null,
    set,
    isSet
});
class IdlError extends Error {
    constructor(o) {
        super(o), this.name = "IdlError"
    }
}
class ProgramErrorStack {
    constructor(o) {
        this.stack = o
    }
    static parse(o) {
        var a;
        const $ = /^Program (\w*) invoke/,
            j = /^Program \w* success/,
            _e = [];
        for (let et = 0; et < o.length; et++) {
            if (j.exec(o[et])) {
                _e.pop();
                continue
            }
            const tt = (a = $.exec(o[et])) === null || a === void 0 ? void 0 : a[1];
            tt && _e.push(new PublicKey(tt))
        }
        return new ProgramErrorStack(_e)
    }
}
class AnchorError extends Error {
    constructor(o, a, $, j, _e, et) {
        super($.join(`
`).replace("Program log: ", "")), this.errorLogs = $, this.logs = j, this.error = {
            errorCode: o,
            errorMessage: a,
            comparedValues: et,
            origin: _e
        }, this._programErrorStack = ProgramErrorStack.parse(j)
    }
    static parse(o) {
        if (!o) return null;
        const a = o.findIndex(lt => lt.startsWith("Program log: AnchorError"));
        if (a === -1) return null;
        const $ = o[a],
            j = [$];
        let _e;
        if (a + 1 < o.length) {
            if (o[a + 1] === "Program log: Left:") {
                const lt = /^Program log: (.*)$/,
                    ft = lt.exec(o[a + 2])[1],
                    yt = lt.exec(o[a + 4])[1];
                _e = [new PublicKey(ft), new PublicKey(yt)], j.push(...o.slice(a + 1, a + 5))
            } else if (o[a + 1].startsWith("Program log: Left:")) {
                const lt = /^Program log: (Left|Right): (.*)$/,
                    ft = lt.exec(o[a + 1])[2],
                    yt = lt.exec(o[a + 2])[2];
                j.push(...o.slice(a + 1, a + 3)), _e = [ft, yt]
            }
        }
        const tt = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec($),
            rt = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec($),
            st = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec($);
        if (tt) {
            const [lt, ft, yt] = tt.slice(1, 4), bt = {
                code: lt,
                number: parseInt(ft)
            };
            return new AnchorError(bt, yt, j, o, void 0, _e)
        } else if (rt) {
            const [lt, ft, yt, bt, ht] = rt.slice(1, 6), vt = {
                code: yt,
                number: parseInt(bt)
            }, wt = {
                file: lt,
                line: parseInt(ft)
            };
            return new AnchorError(vt, ht, j, o, wt, _e)
        } else if (st) {
            const [lt, ft, yt, bt] = st.slice(1, 5), ht = lt, vt = {
                code: ft,
                number: parseInt(yt)
            };
            return new AnchorError(vt, bt, j, o, ht, _e)
        } else return null
    }
    get program() {
        return this._programErrorStack.stack[this._programErrorStack.stack.length - 1]
    }
    get programErrorStack() {
        return this._programErrorStack.stack
    }
    toString() {
        return this.message
    }
}
class ProgramError extends Error {
    constructor(o, a, $) {
        super(), this.code = o, this.msg = a, this.logs = $, $ && (this._programErrorStack = ProgramErrorStack.parse($))
    }
    static parse(o, a) {
        const $ = o.toString();
        let j;
        if ($.includes("custom program error:")) {
            let tt = $.split("custom program error: ");
            if (tt.length !== 2) return null;
            j = tt[1]
        } else {
            const tt = $.match(/"Custom":([0-9]+)}/g);
            if (!tt || tt.length > 1) return null;
            j = tt[0].match(/([0-9]+)/g)[0]
        }
        let _e;
        try {
            _e = parseInt(j)
        } catch {
            return null
        }
        let et = a.get(_e);
        return et !== void 0 ? new ProgramError(_e, et, o.logs) : (et = LangErrorMessage.get(_e), et !== void 0 ? new ProgramError(_e, et, o.logs) : null)
    }
    get program() {
        var o;
        return (o = this._programErrorStack) === null || o === void 0 ? void 0 : o.stack[this._programErrorStack.stack.length - 1]
    }
    get programErrorStack() {
        var o;
        return (o = this._programErrorStack) === null || o === void 0 ? void 0 : o.stack
    }
    toString() {
        return this.msg
    }
}

function translateError(s, o) {
    isSet("debug-logs") && console.log("Translating error:", s);
    const a = AnchorError.parse(s.logs);
    if (a) return a;
    const $ = ProgramError.parse(s, o);
    if ($) return $;
    if (s.logs) {
        const j = {
            get: function(_e, et) {
                return et === "programErrorStack" ? _e.programErrorStack.stack : et === "program" ? _e.programErrorStack.stack[s.programErrorStack.stack.length - 1] : Reflect.get(...arguments)
            }
        };
        return s.programErrorStack = ProgramErrorStack.parse(s.logs), new Proxy(s, j)
    }
    return s
}
const LangErrorCode = {
        InstructionMissing: 100,
        InstructionFallbackNotFound: 101,
        InstructionDidNotDeserialize: 102,
        InstructionDidNotSerialize: 103,
        IdlInstructionStub: 1e3,
        IdlInstructionInvalidProgram: 1001,
        ConstraintMut: 2e3,
        ConstraintHasOne: 2001,
        ConstraintSigner: 2002,
        ConstraintRaw: 2003,
        ConstraintOwner: 2004,
        ConstraintRentExempt: 2005,
        ConstraintSeeds: 2006,
        ConstraintExecutable: 2007,
        ConstraintState: 2008,
        ConstraintAssociated: 2009,
        ConstraintAssociatedInit: 2010,
        ConstraintClose: 2011,
        ConstraintAddress: 2012,
        ConstraintZero: 2013,
        ConstraintTokenMint: 2014,
        ConstraintTokenOwner: 2015,
        ConstraintMintMintAuthority: 2016,
        ConstraintMintFreezeAuthority: 2017,
        ConstraintMintDecimals: 2018,
        ConstraintSpace: 2019,
        ConstraintAccountIsNone: 2020,
        RequireViolated: 2500,
        RequireEqViolated: 2501,
        RequireKeysEqViolated: 2502,
        RequireNeqViolated: 2503,
        RequireKeysNeqViolated: 2504,
        RequireGtViolated: 2505,
        RequireGteViolated: 2506,
        AccountDiscriminatorAlreadySet: 3e3,
        AccountDiscriminatorNotFound: 3001,
        AccountDiscriminatorMismatch: 3002,
        AccountDidNotDeserialize: 3003,
        AccountDidNotSerialize: 3004,
        AccountNotEnoughKeys: 3005,
        AccountNotMutable: 3006,
        AccountOwnedByWrongProgram: 3007,
        InvalidProgramId: 3008,
        InvalidProgramExecutable: 3009,
        AccountNotSigner: 3010,
        AccountNotSystemOwned: 3011,
        AccountNotInitialized: 3012,
        AccountNotProgramData: 3013,
        AccountNotAssociatedTokenAccount: 3014,
        AccountSysvarMismatch: 3015,
        AccountReallocExceedsLimit: 3016,
        AccountDuplicateReallocs: 3017,
        StateInvalidAddress: 4e3,
        DeclaredProgramIdMismatch: 4100,
        Deprecated: 5e3
    },
    LangErrorMessage = new Map([
        [LangErrorCode.InstructionMissing, "8 byte instruction identifier not provided"],
        [LangErrorCode.InstructionFallbackNotFound, "Fallback functions are not supported"],
        [LangErrorCode.InstructionDidNotDeserialize, "The program could not deserialize the given instruction"],
        [LangErrorCode.InstructionDidNotSerialize, "The program could not serialize the given instruction"],
        [LangErrorCode.IdlInstructionStub, "The program was compiled without idl instructions"],
        [LangErrorCode.IdlInstructionInvalidProgram, "The transaction was given an invalid program for the IDL instruction"],
        [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
        [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"],
        [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
        [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
        [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
        [LangErrorCode.ConstraintRentExempt, "A rent exemption constraint was violated"],
        [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
        [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
        [LangErrorCode.ConstraintState, "A state constraint was violated"],
        [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
        [LangErrorCode.ConstraintAssociatedInit, "An associated init constraint was violated"],
        [LangErrorCode.ConstraintClose, "A close constraint was violated"],
        [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
        [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
        [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
        [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
        [LangErrorCode.ConstraintMintMintAuthority, "A mint mint authority constraint was violated"],
        [LangErrorCode.ConstraintMintFreezeAuthority, "A mint freeze authority constraint was violated"],
        [LangErrorCode.ConstraintMintDecimals, "A mint decimals constraint was violated"],
        [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
        [LangErrorCode.ConstraintAccountIsNone, "A required account for the constraint is None"],
        [LangErrorCode.RequireViolated, "A require expression was violated"],
        [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
        [LangErrorCode.RequireKeysEqViolated, "A require_keys_eq expression was violated"],
        [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
        [LangErrorCode.RequireKeysNeqViolated, "A require_keys_neq expression was violated"],
        [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
        [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
        [LangErrorCode.AccountDiscriminatorAlreadySet, "The account discriminator was already set on this account"],
        [LangErrorCode.AccountDiscriminatorNotFound, "No 8 byte discriminator was found on the account"],
        [LangErrorCode.AccountDiscriminatorMismatch, "8 byte discriminator did not match what was expected"],
        [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
        [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
        [LangErrorCode.AccountNotEnoughKeys, "Not enough account keys given to the instruction"],
        [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
        [LangErrorCode.AccountOwnedByWrongProgram, "The given account is owned by a different program than expected"],
        [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
        [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
        [LangErrorCode.AccountNotSigner, "The given account did not sign"],
        [LangErrorCode.AccountNotSystemOwned, "The given account is not owned by the system program"],
        [LangErrorCode.AccountNotInitialized, "The program expected this account to be already initialized"],
        [LangErrorCode.AccountNotProgramData, "The given account is not a program data account"],
        [LangErrorCode.AccountNotAssociatedTokenAccount, "The given account is not the associated token account"],
        [LangErrorCode.AccountSysvarMismatch, "The given public key does not match the required sysvar"],
        [LangErrorCode.AccountReallocExceedsLimit, "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],
        [LangErrorCode.AccountDuplicateReallocs, "The account was duplicated for more than one reallocation"],
        [LangErrorCode.StateInvalidAddress, "The given state account does not have the correct address"],
        [LangErrorCode.DeclaredProgramIdMismatch, "The declared program id does not match the actual program id"],
        [LangErrorCode.Deprecated, "The API being used is deprecated and should no longer be used"]
    ]);
var __assign$1 = function() {
        return __assign$1 = Object.assign || function(o) {
            for (var a, $ = 1, j = arguments.length; $ < j; $++) {
                a = arguments[$];
                for (var _e in a) Object.prototype.hasOwnProperty.call(a, _e) && (o[_e] = a[_e])
            }
            return o
        }, __assign$1.apply(this, arguments)
    },
    __assign = function() {
        return __assign = Object.assign || function(o) {
            for (var a, $ = 1, j = arguments.length; $ < j; $++) {
                a = arguments[$];
                for (var _e in a) Object.prototype.hasOwnProperty.call(a, _e) && (o[_e] = a[_e])
            }
            return o
        }, __assign.apply(this, arguments)
    };

function lowerCase(s) {
    return s.toLowerCase()
}
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g],
    DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;

function noCase(s, o) {
    o === void 0 && (o = {});
    for (var a = o.splitRegexp, $ = a === void 0 ? DEFAULT_SPLIT_REGEXP : a, j = o.stripRegexp, _e = j === void 0 ? DEFAULT_STRIP_REGEXP : j, et = o.transform, tt = et === void 0 ? lowerCase : et, nt = o.delimiter, rt = nt === void 0 ? " " : nt, ot = replace(replace(s, $, "$1\0$2"), _e, "\0"), st = 0, lt = ot.length; ot.charAt(st) === "\0";) st++;
    for (; ot.charAt(lt - 1) === "\0";) lt--;
    return ot.slice(st, lt).split("\0").map(tt).join(rt)
}

function replace(s, o, a) {
    return o instanceof RegExp ? s.replace(o, a) : o.reduce(function($, j) {
        return $.replace(j, a)
    }, s)
}

function dotCase(s, o) {
    return o === void 0 && (o = {}), noCase(s, __assign({
        delimiter: "."
    }, o))
}

function snakeCase(s, o) {
    return o === void 0 && (o = {}), dotCase(s, __assign$1({
        delimiter: "_"
    }, o))
}
class IdlCoder {
    static fieldLayout(o, a) {
        const $ = o.name !== void 0 ? camelCase$1(o.name) : void 0;
        switch (o.type) {
            case "bool":
                return dist.bool($);
            case "u8":
                return dist.u8($);
            case "i8":
                return dist.i8($);
            case "u16":
                return dist.u16($);
            case "i16":
                return dist.i16($);
            case "u32":
                return dist.u32($);
            case "i32":
                return dist.i32($);
            case "f32":
                return dist.f32($);
            case "u64":
                return dist.u64($);
            case "i64":
                return dist.i64($);
            case "f64":
                return dist.f64($);
            case "u128":
                return dist.u128($);
            case "i128":
                return dist.i128($);
            case "u256":
                return dist.u256($);
            case "i256":
                return dist.i256($);
            case "bytes":
                return dist.vecU8($);
            case "string":
                return dist.str($);
            case "publicKey":
                return dist.publicKey($);
            default:
                {
                    if ("vec" in o.type) return dist.vec(IdlCoder.fieldLayout({
                        name: void 0,
                        type: o.type.vec
                    }, a), $);
                    if ("option" in o.type) return dist.option(IdlCoder.fieldLayout({
                        name: void 0,
                        type: o.type.option
                    }, a), $);
                    if ("defined" in o.type) {
                        const j = o.type.defined;
                        if (a === void 0) throw new IdlError("User defined types not provided");
                        const _e = a.filter(et => et.name === j);
                        if (_e.length !== 1) throw new IdlError(`Type not found: ${JSON.stringify(o)}`);
                        return IdlCoder.typeDefLayout(_e[0], a, $)
                    } else if ("array" in o.type) {
                        let j = o.type.array[0],
                            _e = o.type.array[1],
                            et = IdlCoder.fieldLayout({
                                name: void 0,
                                type: j
                            }, a);
                        return dist.array(et, _e, $)
                    } else throw new Error(`Not yet implemented: ${o}`)
                }
        }
    }
    static typeDefLayout(o, a = [], $) {
        if (o.type.kind === "struct") {
            const j = o.type.fields.map(_e => IdlCoder.fieldLayout(_e, a));
            return dist.struct(j, $)
        } else if (o.type.kind === "enum") {
            let j = o.type.variants.map(_e => {
                const et = camelCase$1(_e.name);
                if (_e.fields === void 0) return dist.struct([], et);
                const tt = _e.fields.map((nt, rt) => nt.hasOwnProperty("name") ? IdlCoder.fieldLayout(nt, a) : IdlCoder.fieldLayout({
                    type: nt,
                    name: rt.toString()
                }, a));
                return dist.struct(tt, et)
            });
            return $ !== void 0 ? dist.rustEnum(j).replicate($) : dist.rustEnum(j, $)
        } else throw new Error(`Unknown type kint: ${o}`)
    }
}
const SIGHASH_STATE_NAMESPACE = "state",
    SIGHASH_GLOBAL_NAMESPACE = "global";
class BorshInstructionCoder {
    constructor(o) {
        this.idl = o, this.ixLayout = BorshInstructionCoder.parseIxLayout(o);
        const a = new Map;
        o.instructions.forEach($ => {
            const j = sighash(SIGHASH_GLOBAL_NAMESPACE, $.name);
            a.set(bs58$1$1.encode(j), {
                layout: this.ixLayout.get($.name),
                name: $.name
            })
        }), o.state && o.state.methods.map($ => {
            const j = sighash(SIGHASH_STATE_NAMESPACE, $.name);
            a.set(bs58$1$1.encode(j), {
                layout: this.ixLayout.get($.name),
                name: $.name
            })
        }), this.sighashLayouts = a
    }
    encode(o, a) {
        return this._encode(SIGHASH_GLOBAL_NAMESPACE, o, a)
    }
    encodeState(o, a) {
        return this._encode(SIGHASH_STATE_NAMESPACE, o, a)
    }
    _encode(o, a, $) {
        const j = buffer.Buffer.alloc(1e3),
            _e = camelCase$1(a),
            et = this.ixLayout.get(_e);
        if (!et) throw new Error(`Unknown method: ${_e}`);
        const tt = et.encode($, j),
            nt = j.slice(0, tt);
        return buffer.Buffer.concat([sighash(o, a), nt])
    }
    static parseIxLayout(o) {
        const $ = (o.state ? o.state.methods : []).map(j => {
            let _e = j.args.map(tt => {
                var nt, rt;
                return IdlCoder.fieldLayout(tt, Array.from([...(nt = o.accounts) !== null && nt !== void 0 ? nt : [], ...(rt = o.types) !== null && rt !== void 0 ? rt : []]))
            });
            const et = camelCase$1(j.name);
            return [et, dist.struct(_e, et)]
        }).concat(o.instructions.map(j => {
            let _e = j.args.map(tt => {
                var nt, rt;
                return IdlCoder.fieldLayout(tt, Array.from([...(nt = o.accounts) !== null && nt !== void 0 ? nt : [], ...(rt = o.types) !== null && rt !== void 0 ? rt : []]))
            });
            const et = camelCase$1(j.name);
            return [et, dist.struct(_e, et)]
        }));
        return new Map($)
    }
    decode(o, a = "hex") {
        typeof o == "string" && (o = a === "hex" ? buffer.Buffer.from(o, "hex") : bs58$1$1.decode(o));
        let $ = bs58$1$1.encode(o.slice(0, 8)),
            j = o.slice(8);
        const _e = this.sighashLayouts.get($);
        return _e ? {
            data: _e.layout.decode(j),
            name: _e.name
        } : null
    }
    format(o, a) {
        return InstructionFormatter.format(o, a, this.idl)
    }
}
class InstructionFormatter {
    static format(o, a, $) {
        const j = $.instructions.filter(nt => o.name === nt.name)[0];
        if (j === void 0) return console.error("Invalid instruction given"), null;
        const _e = j.args.map(nt => ({
                name: nt.name,
                type: InstructionFormatter.formatIdlType(nt.type),
                data: InstructionFormatter.formatIdlData(nt, o.data[nt.name], $.types)
            })),
            et = InstructionFormatter.flattenIdlAccounts(j.accounts),
            tt = a.map((nt, rt) => rt < et.length ? {
                name: et[rt].name,
                ...nt
            } : {
                name: void 0,
                ...nt
            });
        return {
            args: _e,
            accounts: tt
        }
    }
    static formatIdlType(o) {
        if (typeof o == "string") return o;
        if ("vec" in o) return `Vec<${this.formatIdlType(o.vec)}>`;
        if ("option" in o) return `Option<${this.formatIdlType(o.option)}>`;
        if ("defined" in o) return o.defined;
        if ("array" in o) return `Array<${o.array[0]}; ${o.array[1]}>`;
        throw new Error(`Unknown IDL type: ${o}`)
    }
    static formatIdlData(o, a, $) {
        if (typeof o.type == "string") return a.toString();
        if (o.type.hasOwnProperty("vec")) return "[" + a.map(j => this.formatIdlData({
            name: "",
            type: o.type.vec
        }, j)).join(", ") + "]";
        if (o.type.hasOwnProperty("option")) return a === null ? "null" : this.formatIdlData({
            name: "",
            type: o.type.option
        }, a, $);
        if (o.type.hasOwnProperty("defined")) {
            if ($ === void 0) throw new Error("User defined types not provided");
            const j = $.filter(_e => _e.name === o.type.defined);
            if (j.length !== 1) throw new Error(`Type not found: ${o.type.defined}`);
            return InstructionFormatter.formatIdlDataDefined(j[0], a, $)
        }
        return "unknown"
    }
    static formatIdlDataDefined(o, a, $) {
        if (o.type.kind === "struct") {
            const j = o.type;
            return "{ " + Object.keys(a).map(et => {
                const tt = j.fields.filter(nt => nt.name === et)[0];
                if (tt === void 0) throw new Error("Unable to find type");
                return et + ": " + InstructionFormatter.formatIdlData(tt, a[et], $)
            }).join(", ") + " }"
        } else {
            if (o.type.variants.length === 0) return "{}";
            if (o.type.variants[0].name) {
                const j = o.type.variants,
                    _e = Object.keys(a)[0],
                    et = a[_e],
                    tt = Object.keys(et).map(rt => {
                        var ot;
                        const st = et[rt],
                            lt = (ot = j[_e]) === null || ot === void 0 ? void 0 : ot.filter(ft => ft.name === rt)[0];
                        if (lt === void 0) throw new Error("Unable to find variant");
                        return rt + ": " + InstructionFormatter.formatIdlData(lt, st, $)
                    }).join(", "),
                    nt = camelCase$1(_e, {
                        pascalCase: !0
                    });
                return tt.length === 0 ? nt : `${nt} { ${tt} }`
            } else return "Tuple formatting not yet implemented"
        }
    }
    static flattenIdlAccounts(o, a) {
        return o.map($ => {
            const j = sentenceCase($.name);
            if ($.hasOwnProperty("accounts")) {
                const _e = a ? `${a} > ${j}` : j;
                return InstructionFormatter.flattenIdlAccounts($.accounts, _e)
            } else return { ...$,
                name: a ? `${a} > ${j}` : j
            }
        }).flat()
    }
}

function sentenceCase(s) {
    const o = s.replace(/([A-Z])/g, " $1");
    return o.charAt(0).toUpperCase() + o.slice(1)
}

function sighash(s, o) {
    let a = snakeCase(o),
        $ = `${s}:${a}`;
    return buffer.Buffer.from(sha256Exports.sha256.digest($)).slice(0, 8)
}

function accountSize(s, o) {
    if (o.type.kind === "enum") {
        let a = o.type.variants.map($ => $.fields === void 0 ? 0 : $.fields.map(j => {
            if (!(typeof j == "object" && "name" in j)) throw new Error("Tuple enum variants not yet implemented.");
            return typeSize(s, j.type)
        }).reduce((j, _e) => j + _e));
        return Math.max(...a) + 1
    }
    return o.type.fields === void 0 ? 0 : o.type.fields.map(a => typeSize(s, a.type)).reduce((a, $) => a + $, 0)
}

function typeSize(s, o) {
    var a, $;
    switch (o) {
        case "bool":
            return 1;
        case "u8":
            return 1;
        case "i8":
            return 1;
        case "i16":
            return 2;
        case "u16":
            return 2;
        case "u32":
            return 4;
        case "i32":
            return 4;
        case "f32":
            return 4;
        case "u64":
            return 8;
        case "i64":
            return 8;
        case "f64":
            return 8;
        case "u128":
            return 16;
        case "i128":
            return 16;
        case "u256":
            return 32;
        case "i256":
            return 32;
        case "bytes":
            return 1;
        case "string":
            return 1;
        case "publicKey":
            return 32;
        default:
            if ("vec" in o) return 1;
            if ("option" in o) return 1 + typeSize(s, o.option);
            if ("coption" in o) return 4 + typeSize(s, o.coption);
            if ("defined" in o) {
                const j = ($ = (a = s.types) === null || a === void 0 ? void 0 : a.filter(et => et.name === o.defined)) !== null && $ !== void 0 ? $ : [];
                if (j.length !== 1) throw new IdlError(`Type not found: ${JSON.stringify(o)}`);
                let _e = j[0];
                return accountSize(s, _e)
            }
            if ("array" in o) {
                let j = o.array[0],
                    _e = o.array[1];
                return typeSize(s, j) * _e
            }
            throw new Error(`Invalid type ${JSON.stringify(o)}`)
    }
}
const ACCOUNT_DISCRIMINATOR_SIZE = 8;
class BorshAccountsCoder {
    constructor(o) {
        if (o.accounts === void 0) {
            this.accountLayouts = new Map;
            return
        }
        const a = o.accounts.map($ => [$.name, IdlCoder.typeDefLayout($, o.types)]);
        this.accountLayouts = new Map(a), this.idl = o
    }
    async encode(o, a) {
        const $ = buffer.Buffer.alloc(1e3),
            j = this.accountLayouts.get(o);
        if (!j) throw new Error(`Unknown account: ${o}`);
        const _e = j.encode(a, $);
        let et = $.slice(0, _e),
            tt = BorshAccountsCoder.accountDiscriminator(o);
        return buffer.Buffer.concat([tt, et])
    }
    decode(o, a) {
        if (BorshAccountsCoder.accountDiscriminator(o).compare(a.slice(0, 8))) throw new Error("Invalid account discriminator");
        return this.decodeUnchecked(o, a)
    }
    decodeAny(o) {
        const a = o.slice(0, 8),
            $ = Array.from(this.accountLayouts.keys()).find(j => BorshAccountsCoder.accountDiscriminator(j).equals(a));
        if (!$) throw new Error("Account descriminator not found");
        return this.decodeUnchecked($, o)
    }
    decodeUnchecked(o, a) {
        const $ = a.slice(ACCOUNT_DISCRIMINATOR_SIZE),
            j = this.accountLayouts.get(o);
        if (!j) throw new Error(`Unknown account: ${o}`);
        return j.decode($)
    }
    memcmp(o, a) {
        const $ = BorshAccountsCoder.accountDiscriminator(o);
        return {
            offset: 0,
            bytes: bs58$1$1.encode(a ? buffer.Buffer.concat([$, a]) : $)
        }
    }
    size(o) {
        var a;
        return ACCOUNT_DISCRIMINATOR_SIZE + ((a = accountSize(this.idl, o)) !== null && a !== void 0 ? a : 0)
    }
    static accountDiscriminator(o) {
        return buffer.Buffer.from(sha256Exports.sha256.digest(`account:${camelCase$1(o,{pascalCase:!0,preserveConsecutiveUppercase:!0})}`)).slice(0, ACCOUNT_DISCRIMINATOR_SIZE)
    }
}
class BorshEventCoder {
    constructor(o) {
        if (o.events === void 0) {
            this.layouts = new Map;
            return
        }
        const a = o.events.map($ => {
            let j = {
                name: $.name,
                type: {
                    kind: "struct",
                    fields: $.fields.map(_e => ({
                        name: _e.name,
                        type: _e.type
                    }))
                }
            };
            return [$.name, IdlCoder.typeDefLayout(j, o.types)]
        });
        this.layouts = new Map(a), this.discriminators = new Map(o.events === void 0 ? [] : o.events.map($ => [fromByteArray_1(eventDiscriminator($.name)), $.name]))
    }
    decode(o) {
        let a;
        try {
            a = buffer.Buffer.from(toByteArray_1(o))
        } catch {
            return null
        }
        const $ = fromByteArray_1(a.slice(0, 8)),
            j = this.discriminators.get($);
        if (j === void 0) return null;
        const _e = this.layouts.get(j);
        if (!_e) throw new Error(`Unknown event: ${j}`);
        return {
            data: _e.decode(a.slice(8)),
            name: j
        }
    }
}

function eventDiscriminator(s) {
    return buffer.Buffer.from(sha256Exports.sha256.digest(`event:${s}`)).slice(0, 8)
}
class BorshStateCoder {
    constructor(o) {
        if (o.state === void 0) throw new Error("Idl state not defined.");
        this.layout = IdlCoder.typeDefLayout(o.state.struct, o.types)
    }
    async encode(o, a) {
        const $ = buffer.Buffer.alloc(1e3),
            j = this.layout.encode(a, $),
            _e = await stateDiscriminator(o),
            et = $.slice(0, j);
        return buffer.Buffer.concat([_e, et])
    }
    decode(o) {
        const a = o.slice(8);
        return this.layout.decode(a)
    }
}
async function stateDiscriminator(s) {
    let o = isSet("anchor-deprecated-state") ? "account" : "state";
    return buffer.Buffer.from(sha256Exports.sha256.digest(`${o}:${s}`)).slice(0, 8)
}
class BorshTypesCoder {
    constructor(o) {
        if (o.types === void 0) {
            this.typeLayouts = new Map;
            return
        }
        const a = o.types.map($ => [$.name, IdlCoder.typeDefLayout($, o.types)]);
        this.typeLayouts = new Map(a), this.idl = o
    }
    encode(o, a) {
        const $ = buffer.Buffer.alloc(1e3),
            j = this.typeLayouts.get(o);
        if (!j) throw new Error(`Unknown type: ${o}`);
        const _e = j.encode(a, $);
        return $.slice(0, _e)
    }
    decode(o, a) {
        const $ = this.typeLayouts.get(o);
        if (!$) throw new Error(`Unknown type: ${o}`);
        return $.decode(a)
    }
}
class BorshCoder {
    constructor(o) {
        this.instruction = new BorshInstructionCoder(o), this.accounts = new BorshAccountsCoder(o), this.events = new BorshEventCoder(o), o.state && (this.state = new BorshStateCoder(o)), this.types = new BorshTypesCoder(o)
    }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function getDefaultExportFromCjs(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}
let Layout$1 = class {
    constructor(o, a) {
        if (!Number.isInteger(o)) throw new TypeError("span must be an integer");
        this.span = o, this.property = a
    }
    makeDestinationObject() {
        return {}
    }
    decode(o, a) {
        throw new Error("Layout is abstract")
    }
    encode(o, a, $) {
        throw new Error("Layout is abstract")
    }
    getSpan(o, a) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(o) {
        const a = Object.create(this.constructor.prototype);
        return Object.assign(a, this), a.property = o, a
    }
    fromArray(o) {}
};
var Layout_2 = Layout$1;

function nameWithProperty(s, o) {
    return o.property ? s + "[" + o.property + "]" : s
}
class ExternalLayout extends Layout$1 {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
class OffsetLayout extends ExternalLayout {
    constructor(o, a, $) {
        if (!(o instanceof Layout$1)) throw new TypeError("layout must be a Layout");
        if (a === void 0) a = 0;
        else if (!Number.isInteger(a)) throw new TypeError("offset must be integer or undefined");
        super(o.span, $ || o.property), this.layout = o, this.offset = a
    }
    isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE
    }
    decode(o, a) {
        return a === void 0 && (a = 0), this.layout.decode(o, a + this.offset)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), this.layout.encode(o, a, $ + this.offset)
    }
}
class UInt extends Layout$1 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readUIntLE(a, this.span)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeUIntLE(o, $, this.span), this.span
    }
}
class UIntBE extends Layout$1 {
    constructor(o, a) {
        if (super(o, a), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(o, a) {
        return a === void 0 && (a = 0), o.readUIntBE(a, this.span)
    }
    encode(o, a, $) {
        return $ === void 0 && ($ = 0), a.writeUIntBE(o, $, this.span), this.span
    }
}
const V2E32 = Math.pow(2, 32);

function divmodInt64(s) {
    const o = Math.floor(s / V2E32),
        a = s - o * V2E32;
    return {
        hi32: o,
        lo32: a
    }
}

function roundedInt64(s, o) {
    return s * V2E32 + o
}
class NearUInt64 extends Layout$1 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = o.readUInt32LE(a),
            j = o.readUInt32LE(a + 4);
        return roundedInt64(j, $)
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = divmodInt64(o);
        return a.writeUInt32LE(j.lo32, $), a.writeUInt32LE(j.hi32, $ + 4), 8
    }
}
class NearInt64 extends Layout$1 {
    constructor(o) {
        super(8, o)
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = o.readUInt32LE(a),
            j = o.readInt32LE(a + 4);
        return roundedInt64(j, $)
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = divmodInt64(o);
        return a.writeUInt32LE(j.lo32, $), a.writeInt32LE(j.hi32, $ + 4), 8
    }
}
class Structure extends Layout$1 {
    constructor(o, a, $) {
        if (!(Array.isArray(o) && o.reduce((_e, et) => _e && et instanceof Layout$1, !0))) throw new TypeError("fields must be array of Layout instances");
        typeof a == "boolean" && $ === void 0 && ($ = a, a = void 0);
        for (const _e of o)
            if (0 > _e.span && _e.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
        let j = -1;
        try {
            j = o.reduce((_e, et) => _e + et.getSpan(), 0)
        } catch {}
        super(j, a), this.fields = o, this.decodePrefixes = !!$
    }
    getSpan(o, a) {
        if (0 <= this.span) return this.span;
        a === void 0 && (a = 0);
        let $ = 0;
        try {
            $ = this.fields.reduce((j, _e) => {
                const et = _e.getSpan(o, a);
                return a += et, j + et
            }, 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return $
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        const $ = this.makeDestinationObject();
        for (const j of this.fields)
            if (j.property !== void 0 && ($[j.property] = j.decode(o, a)), a += j.getSpan(o, a), this.decodePrefixes && o.length === a) break;
        return $
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = $;
        let _e = 0,
            et = 0;
        for (const tt of this.fields) {
            let nt = tt.span;
            if (et = 0 < nt ? nt : 0, tt.property !== void 0) {
                const rt = o[tt.property];
                rt !== void 0 && (et = tt.encode(rt, a, $), 0 > nt && (nt = tt.getSpan(a, $)))
            }
            _e = $, $ += nt
        }
        return _e + et - j
    }
    fromArray(o) {
        const a = this.makeDestinationObject();
        for (const $ of this.fields) $.property !== void 0 && 0 < o.length && (a[$.property] = o.shift());
        return a
    }
    layoutFor(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        for (const a of this.fields)
            if (a.property === o) return a
    }
    offsetOf(o) {
        if (typeof o != "string") throw new TypeError("property must be string");
        let a = 0;
        for (const $ of this.fields) {
            if ($.property === o) return a;
            0 > $.span ? a = -1 : 0 <= a && (a += $.span)
        }
    }
}
class UnionDiscriminator {
    constructor(o) {
        this.property = o
    }
    decode() {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode() {
        throw new Error("UnionDiscriminator is abstract")
    }
}
class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(o, a) {
        if (!(o instanceof ExternalLayout && o.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(a || o.property || "variant"), this.layout = o
    }
    decode(o, a) {
        return this.layout.decode(o, a)
    }
    encode(o, a, $) {
        return this.layout.encode(o, a, $)
    }
}
class Union extends Layout$1 {
    constructor(o, a, $) {
        const j = o instanceof UInt || o instanceof UIntBE;
        if (j) o = new UnionLayoutDiscriminator(new OffsetLayout(o));
        else if (o instanceof ExternalLayout && o.isCount()) o = new UnionLayoutDiscriminator(o);
        else if (!(o instanceof UnionDiscriminator)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (a === void 0 && (a = null), !(a === null || a instanceof Layout$1)) throw new TypeError("defaultLayout must be null or a Layout");
        if (a !== null) {
            if (0 > a.span) throw new Error("defaultLayout must have constant span");
            a.property === void 0 && (a = a.replicate("content"))
        }
        let _e = -1;
        a && (_e = a.span, 0 <= _e && j && (_e += o.layout.span)), super(_e, $), this.discriminator = o, this.usesPrefixDiscriminator = j, this.defaultLayout = a, this.registry = {};
        let et = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(tt) {
            return et(tt)
        }, this.configGetSourceVariant = function(tt) {
            et = tt.bind(this)
        }
    }
    getSpan(o, a) {
        if (0 <= this.span) return this.span;
        a === void 0 && (a = 0);
        const $ = this.getVariant(o, a);
        if (!$) throw new Error("unable to determine span for unrecognized variant");
        return $.getSpan(o, a)
    }
    defaultGetSourceVariant(o) {
        if (o.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && o.hasOwnProperty(this.defaultLayout.property)) return;
            const a = this.registry[o[this.discriminator.property]];
            if (a && (!a.layout || o.hasOwnProperty(a.property))) return a
        } else
            for (const a in this.registry) {
                const $ = this.registry[a];
                if (o.hasOwnProperty($.property)) return $
            }
        throw new Error("unable to infer src variant")
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        let $;
        const j = this.discriminator,
            _e = j.decode(o, a);
        let et = this.registry[_e];
        if (et === void 0) {
            let tt = 0;
            et = this.defaultLayout, this.usesPrefixDiscriminator && (tt = j.layout.span), $ = this.makeDestinationObject(), $[j.property] = _e, $[et.property] = this.defaultLayout.decode(o, a + tt)
        } else $ = et.decode(o, a);
        return $
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        const j = this.getSourceVariant(o);
        if (j === void 0) {
            const _e = this.discriminator,
                et = this.defaultLayout;
            let tt = 0;
            return this.usesPrefixDiscriminator && (tt = _e.layout.span), _e.encode(o[_e.property], a, $), tt + et.encode(o[et.property], a, $ + tt)
        }
        return j.encode(o, a, $)
    }
    addVariant(o, a, $) {
        const j = new VariantLayout(this, o, a, $);
        return this.registry[o] = j, j
    }
    getVariant(o, a) {
        let $ = o;
        return Buffer.isBuffer(o) && (a === void 0 && (a = 0), $ = this.discriminator.decode(o, a)), this.registry[$]
    }
}
class VariantLayout extends Layout$1 {
    constructor(o, a, $, j) {
        if (!(o instanceof Union)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(a) || 0 > a) throw new TypeError("variant must be a (non-negative) integer");
        if (typeof $ == "string" && j === void 0 && (j = $, $ = null), $) {
            if (!($ instanceof Layout$1)) throw new TypeError("layout must be a Layout");
            if (o.defaultLayout !== null && 0 <= $.span && $.span > o.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
            if (typeof j != "string") throw new TypeError("variant must have a String property")
        }
        let _e = o.span;
        0 > o.span && (_e = $ ? $.span : 0, 0 <= _e && o.usesPrefixDiscriminator && (_e += o.discriminator.layout.span)), super(_e, j), this.union = o, this.variant = a, this.layout = $ || null
    }
    getSpan(o, a) {
        if (0 <= this.span) return this.span;
        a === void 0 && (a = 0);
        let $ = 0;
        return this.union.usesPrefixDiscriminator && ($ = this.union.discriminator.layout.span), $ + this.layout.getSpan(o, a + $)
    }
    decode(o, a) {
        const $ = this.makeDestinationObject();
        if (a === void 0 && (a = 0), this !== this.union.getVariant(o, a)) throw new Error("variant mismatch");
        let j = 0;
        return this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout ? $[this.property] = this.layout.decode(o, a + j) : this.property ? $[this.property] = !0 : this.union.usesPrefixDiscriminator && ($[this.union.discriminator.property] = this.variant), $
    }
    encode(o, a, $) {
        $ === void 0 && ($ = 0);
        let j = 0;
        if (this.union.usesPrefixDiscriminator && (j = this.union.discriminator.layout.span), this.layout && !o.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, a, $);
        let _e = j;
        if (this.layout && (this.layout.encode(o[this.property], a, $ + j), _e += this.layout.getSpan(a, $ + j), 0 <= this.union.span && _e > this.union.span)) throw new Error("encoded variant overruns containing union");
        return _e
    }
    fromArray(o) {
        if (this.layout) return this.layout.fromArray(o)
    }
}
class Blob$1 extends Layout$1 {
    constructor(o, a) {
        if (!(o instanceof ExternalLayout && o.isCount() || Number.isInteger(o) && 0 <= o)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let $ = -1;
        o instanceof ExternalLayout || ($ = o), super($, a), this.length = o
    }
    getSpan(o, a) {
        let $ = this.span;
        return 0 > $ && ($ = this.length.decode(o, a)), $
    }
    decode(o, a) {
        a === void 0 && (a = 0);
        let $ = this.span;
        return 0 > $ && ($ = this.length.decode(o, a)), o.slice(a, a + $)
    }
    encode(o, a, $) {
        let j = this.length;
        if (this.length instanceof ExternalLayout && (j = o.length), !(Buffer.isBuffer(o) && j === o.length)) throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + j + ") Buffer as src");
        if ($ + j > a.length) throw new RangeError("encoding overruns Buffer");
        return a.write(o.toString("hex"), $, j, "hex"), this.length instanceof ExternalLayout && this.length.encode(j, a, $), j
    }
}
var offset = (s, o, a) => new OffsetLayout(s, o, a),
    u8 = s => new UInt(1, s),
    u32 = s => new UInt(4, s),
    nu64 = s => new NearUInt64(s),
    ns64 = s => new NearInt64(s),
    struct = (s, o, a) => new Structure(s, o, a),
    union = (s, o, a) => new Union(s, o, a),
    blob = (s, o) => new Blob$1(s, o);
class RustStringLayout extends Layout_2 {
    constructor(o) {
        super(-1, o), this.property = o, this.layout = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], this.property)
    }
    encode(o, a, $ = 0) {
        if (o == null) return this.layout.span;
        const j = {
            chars: Buffer.from(o, "utf8")
        };
        return this.layout.encode(j, a, $)
    }
    decode(o, a = 0) {
        return this.layout.decode(o, a).chars.toString()
    }
    getSpan(o, a = 0) {
        return u32().span + u32().span + new BN(new Uint8Array(o).slice(a, a + 4), 10, "le").toNumber()
    }
}

function rustStringLayout(s) {
    return new RustStringLayout(s)
}

function publicKey$2(s) {
    return blob(32, s)
}
const LAYOUT = union(u32("instruction"));
LAYOUT.addVariant(0, struct([ns64("lamports"), ns64("space"), publicKey$2("owner")]), "createAccount");
LAYOUT.addVariant(1, struct([publicKey$2("owner")]), "assign");
LAYOUT.addVariant(2, struct([ns64("lamports")]), "transfer");
LAYOUT.addVariant(3, struct([publicKey$2("base"), rustStringLayout("seed"), ns64("lamports"), ns64("space"), publicKey$2("owner")]), "createAccountWithSeed");
LAYOUT.addVariant(4, struct([publicKey$2("authorized")]), "advanceNonceAccount");
LAYOUT.addVariant(5, struct([ns64("lamports")]), "withdrawNonceAccount");
LAYOUT.addVariant(6, struct([publicKey$2("authorized")]), "initializeNonceAccount");
LAYOUT.addVariant(7, struct([publicKey$2("authorized")]), "authorizeNonceAccount");
LAYOUT.addVariant(8, struct([ns64("space")]), "allocate");
LAYOUT.addVariant(9, struct([publicKey$2("base"), rustStringLayout("seed"), ns64("space"), publicKey$2("owner")]), "allocateWithSeed");
LAYOUT.addVariant(10, struct([publicKey$2("base"), rustStringLayout("seed"), publicKey$2("owner")]), "assignWithSeed");
LAYOUT.addVariant(11, struct([ns64("lamports"), rustStringLayout("seed"), publicKey$2("owner")]), "transferWithSeed");
Math.max(...Object.values(LAYOUT.registry).map(s => s.span));
class WrappedLayout$1 extends Layout_2 {
    constructor(o, a, $, j) {
        super(o.span, j), this.layout = o, this.decoder = a, this.encoder = $
    }
    decode(o, a) {
        return this.decoder(this.layout.decode(o, a))
    }
    encode(o, a, $) {
        return this.layout.encode(this.encoder(o), a, $)
    }
    getSpan(o, a) {
        return this.layout.getSpan(o, a)
    }
}

function publicKey$1(s) {
    return new WrappedLayout$1(blob(32), o => new PublicKey(o), o => o.toBuffer(), s)
}
struct([u32("version"), u32("state"), publicKey$1("authorizedPubkey"), publicKey$1("nonce"), struct([nu64("lamportsPerSignature")], "feeCalculator")]);

function hash(s) {
    return sha256Exports.sha256(s)
}
var sha256 = Object.freeze({
    __proto__: null,
    hash
});

function createWithSeedSync(s, o, a) {
    const $ = buffer.Buffer.concat([s.toBuffer(), buffer.Buffer.from(o), a.toBuffer()]),
        j = sha256Exports.sha256.digest($);
    return new PublicKey(buffer.Buffer.from(j))
}

function createProgramAddressSync(s, o) {
    let $ = buffer.Buffer.alloc(0);
    s.forEach(function(et) {
        if (et.length > 32) throw new TypeError("Max seed length exceeded");
        $ = buffer.Buffer.concat([$, toBuffer(et)])
    }), $ = buffer.Buffer.concat([$, o.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    let j = sha256Exports.sha256(new Uint8Array($)),
        _e = new BN(j, 16).toArray(void 0, 32);
    if (PublicKey.isOnCurve(new Uint8Array(_e))) throw new Error("Invalid seeds, address must fall off the curve");
    return new PublicKey(_e)
}

function findProgramAddressSync(s, o) {
    let a = 255,
        $;
    for (; a != 0;) {
        try {
            const j = s.concat(buffer.Buffer.from([a]));
            $ = createProgramAddressSync(j, o)
        } catch (j) {
            if (j instanceof TypeError) throw j;
            a--;
            continue
        }
        return [$, a]
    }
    throw new Error("Unable to find a viable program address nonce")
}
const toBuffer = s => s instanceof buffer.Buffer ? s : s instanceof Uint8Array ? buffer.Buffer.from(s.buffer, s.byteOffset, s.byteLength) : buffer.Buffer.from(s);
async function associated(s, ...o) {
    let a = [buffer.Buffer.from([97, 110, 99, 104, 111, 114])];
    o.forEach(j => {
        a.push(j instanceof buffer.Buffer ? j : translateAddress(j).toBuffer())
    });
    const [$] = await PublicKey.findProgramAddress(a, translateAddress(s));
    return $
}
var pubkey = Object.freeze({
    __proto__: null,
    createWithSeedSync,
    createProgramAddressSync,
    findProgramAddressSync,
    associated
});
const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    ASSOCIATED_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
async function associatedAddress({
    mint: s,
    owner: o
}) {
    return (await PublicKey.findProgramAddress([o.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), s.toBuffer()], ASSOCIATED_PROGRAM_ID))[0]
}
var token = Object.freeze({
        __proto__: null,
        TOKEN_PROGRAM_ID,
        ASSOCIATED_PROGRAM_ID,
        associatedAddress
    }),
    browserPonyfill = {
        exports: {}
    };
(function(s, o) {
    var a = typeof self < "u" ? self : commonjsGlobal,
        $ = function() {
            function _e() {
                this.fetch = !1, this.DOMException = a.DOMException
            }
            return _e.prototype = a, new _e
        }();
    (function(_e) {
        (function(et) {
            var tt = {
                searchParams: "URLSearchParams" in _e,
                iterable: "Symbol" in _e && "iterator" in Symbol,
                blob: "FileReader" in _e && "Blob" in _e && function() {
                    try {
                        return new Blob, !0
                    } catch {
                        return !1
                    }
                }(),
                formData: "FormData" in _e,
                arrayBuffer: "ArrayBuffer" in _e
            };

            function nt(it) {
                return it && DataView.prototype.isPrototypeOf(it)
            }
            if (tt.arrayBuffer) var rt = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                ot = ArrayBuffer.isView || function(it) {
                    return it && rt.indexOf(Object.prototype.toString.call(it)) > -1
                };

            function st(it) {
                if (typeof it != "string" && (it = String(it)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(it)) throw new TypeError("Invalid character in header field name");
                return it.toLowerCase()
            }

            function lt(it) {
                return typeof it != "string" && (it = String(it)), it
            }

            function ft(it) {
                var at = {
                    next: function() {
                        var mt = it.shift();
                        return {
                            done: mt === void 0,
                            value: mt
                        }
                    }
                };
                return tt.iterable && (at[Symbol.iterator] = function() {
                    return at
                }), at
            }

            function yt(it) {
                this.map = {}, it instanceof yt ? it.forEach(function(at, mt) {
                    this.append(mt, at)
                }, this) : Array.isArray(it) ? it.forEach(function(at) {
                    this.append(at[0], at[1])
                }, this) : it && Object.getOwnPropertyNames(it).forEach(function(at) {
                    this.append(at, it[at])
                }, this)
            }
            yt.prototype.append = function(it, at) {
                it = st(it), at = lt(at);
                var mt = this.map[it];
                this.map[it] = mt ? mt + ", " + at : at
            }, yt.prototype.delete = function(it) {
                delete this.map[st(it)]
            }, yt.prototype.get = function(it) {
                return it = st(it), this.has(it) ? this.map[it] : null
            }, yt.prototype.has = function(it) {
                return this.map.hasOwnProperty(st(it))
            }, yt.prototype.set = function(it, at) {
                this.map[st(it)] = lt(at)
            }, yt.prototype.forEach = function(it, at) {
                for (var mt in this.map) this.map.hasOwnProperty(mt) && it.call(at, this.map[mt], mt, this)
            }, yt.prototype.keys = function() {
                var it = [];
                return this.forEach(function(at, mt) {
                    it.push(mt)
                }), ft(it)
            }, yt.prototype.values = function() {
                var it = [];
                return this.forEach(function(at) {
                    it.push(at)
                }), ft(it)
            }, yt.prototype.entries = function() {
                var it = [];
                return this.forEach(function(at, mt) {
                    it.push([mt, at])
                }), ft(it)
            }, tt.iterable && (yt.prototype[Symbol.iterator] = yt.prototype.entries);

            function bt(it) {
                if (it.bodyUsed) return Promise.reject(new TypeError("Already read"));
                it.bodyUsed = !0
            }

            function ht(it) {
                return new Promise(function(at, mt) {
                    it.onload = function() {
                        at(it.result)
                    }, it.onerror = function() {
                        mt(it.error)
                    }
                })
            }

            function vt(it) {
                var at = new FileReader,
                    mt = ht(at);
                return at.readAsArrayBuffer(it), mt
            }

            function wt(it) {
                var at = new FileReader,
                    mt = ht(at);
                return at.readAsText(it), mt
            }

            function gt(it) {
                for (var at = new Uint8Array(it), mt = new Array(at.length), xt = 0; xt < at.length; xt++) mt[xt] = String.fromCharCode(at[xt]);
                return mt.join("")
            }

            function At(it) {
                if (it.slice) return it.slice(0);
                var at = new Uint8Array(it.byteLength);
                return at.set(new Uint8Array(it)), at.buffer
            }

            function Pt() {
                return this.bodyUsed = !1, this._initBody = function(it) {
                    this._bodyInit = it, it ? typeof it == "string" ? this._bodyText = it : tt.blob && Blob.prototype.isPrototypeOf(it) ? this._bodyBlob = it : tt.formData && FormData.prototype.isPrototypeOf(it) ? this._bodyFormData = it : tt.searchParams && URLSearchParams.prototype.isPrototypeOf(it) ? this._bodyText = it.toString() : tt.arrayBuffer && tt.blob && nt(it) ? (this._bodyArrayBuffer = At(it.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : tt.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(it) || ot(it)) ? this._bodyArrayBuffer = At(it) : this._bodyText = it = Object.prototype.toString.call(it) : this._bodyText = "", this.headers.get("content-type") || (typeof it == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : tt.searchParams && URLSearchParams.prototype.isPrototypeOf(it) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }, tt.blob && (this.blob = function() {
                    var it = bt(this);
                    if (it) return it;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }, this.arrayBuffer = function() {
                    return this._bodyArrayBuffer ? bt(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(vt)
                }), this.text = function() {
                    var it = bt(this);
                    if (it) return it;
                    if (this._bodyBlob) return wt(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(gt(this._bodyArrayBuffer));
                    if (this._bodyFormData) throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }, tt.formData && (this.formData = function() {
                    return this.text().then(Ut)
                }), this.json = function() {
                    return this.text().then(JSON.parse)
                }, this
            }
            var Bt = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

            function Lt(it) {
                var at = it.toUpperCase();
                return Bt.indexOf(at) > -1 ? at : it
            }

            function Nt(it, at) {
                at = at || {};
                var mt = at.body;
                if (it instanceof Nt) {
                    if (it.bodyUsed) throw new TypeError("Already read");
                    this.url = it.url, this.credentials = it.credentials, at.headers || (this.headers = new yt(it.headers)), this.method = it.method, this.mode = it.mode, this.signal = it.signal, !mt && it._bodyInit != null && (mt = it._bodyInit, it.bodyUsed = !0)
                } else this.url = String(it);
                if (this.credentials = at.credentials || this.credentials || "same-origin", (at.headers || !this.headers) && (this.headers = new yt(at.headers)), this.method = Lt(at.method || this.method || "GET"), this.mode = at.mode || this.mode || null, this.signal = at.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && mt) throw new TypeError("Body not allowed for GET or HEAD requests");
                this._initBody(mt)
            }
            Nt.prototype.clone = function() {
                return new Nt(this, {
                    body: this._bodyInit
                })
            };

            function Ut(it) {
                var at = new FormData;
                return it.trim().split("&").forEach(function(mt) {
                    if (mt) {
                        var xt = mt.split("="),
                            $t = xt.shift().replace(/\+/g, " "),
                            Rt = xt.join("=").replace(/\+/g, " ");
                        at.append(decodeURIComponent($t), decodeURIComponent(Rt))
                    }
                }), at
            }

            function Vt(it) {
                var at = new yt,
                    mt = it.replace(/\r?\n[\t ]+/g, " ");
                return mt.split(/\r?\n/).forEach(function(xt) {
                    var $t = xt.split(":"),
                        Rt = $t.shift().trim();
                    if (Rt) {
                        var It = $t.join(":").trim();
                        at.append(Rt, It)
                    }
                }), at
            }
            Pt.call(Nt.prototype);

            function Ft(it, at) {
                at || (at = {}), this.type = "default", this.status = at.status === void 0 ? 200 : at.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in at ? at.statusText : "OK", this.headers = new yt(at.headers), this.url = at.url || "", this._initBody(it)
            }
            Pt.call(Ft.prototype), Ft.prototype.clone = function() {
                return new Ft(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new yt(this.headers),
                    url: this.url
                })
            }, Ft.error = function() {
                var it = new Ft(null, {
                    status: 0,
                    statusText: ""
                });
                return it.type = "error", it
            };
            var Wt = [301, 302, 303, 307, 308];
            Ft.redirect = function(it, at) {
                if (Wt.indexOf(at) === -1) throw new RangeError("Invalid status code");
                return new Ft(null, {
                    status: at,
                    headers: {
                        location: it
                    }
                })
            }, et.DOMException = _e.DOMException;
            try {
                new et.DOMException
            } catch {
                et.DOMException = function(at, mt) {
                    this.message = at, this.name = mt;
                    var xt = Error(at);
                    this.stack = xt.stack
                }, et.DOMException.prototype = Object.create(Error.prototype), et.DOMException.prototype.constructor = et.DOMException
            }

            function Ct(it, at) {
                return new Promise(function(mt, xt) {
                    var $t = new Nt(it, at);
                    if ($t.signal && $t.signal.aborted) return xt(new et.DOMException("Aborted", "AbortError"));
                    var Rt = new XMLHttpRequest;

                    function It() {
                        Rt.abort()
                    }
                    Rt.onload = function() {
                        var Tt = {
                            status: Rt.status,
                            statusText: Rt.statusText,
                            headers: Vt(Rt.getAllResponseHeaders() || "")
                        };
                        Tt.url = "responseURL" in Rt ? Rt.responseURL : Tt.headers.get("X-Request-URL");
                        var dt = "response" in Rt ? Rt.response : Rt.responseText;
                        mt(new Ft(dt, Tt))
                    }, Rt.onerror = function() {
                        xt(new TypeError("Network request failed"))
                    }, Rt.ontimeout = function() {
                        xt(new TypeError("Network request failed"))
                    }, Rt.onabort = function() {
                        xt(new et.DOMException("Aborted", "AbortError"))
                    }, Rt.open($t.method, $t.url, !0), $t.credentials === "include" ? Rt.withCredentials = !0 : $t.credentials === "omit" && (Rt.withCredentials = !1), "responseType" in Rt && tt.blob && (Rt.responseType = "blob"), $t.headers.forEach(function(Tt, dt) {
                        Rt.setRequestHeader(dt, Tt)
                    }), $t.signal && ($t.signal.addEventListener("abort", It), Rt.onreadystatechange = function() {
                        Rt.readyState === 4 && $t.signal.removeEventListener("abort", It)
                    }), Rt.send(typeof $t._bodyInit > "u" ? null : $t._bodyInit)
                })
            }
            return Ct.polyfill = !0, _e.fetch || (_e.fetch = Ct, _e.Headers = yt, _e.Request = Nt, _e.Response = Ft), et.Headers = yt, et.Request = Nt, et.Response = Ft, et.fetch = Ct, Object.defineProperty(et, "__esModule", {
                value: !0
            }), et
        })({})
    })($), $.fetch.ponyfill = !0, delete $.fetch.polyfill;
    var j = $;
    o = j.fetch, o.default = j.fetch, o.fetch = j.fetch, o.Headers = j.Headers, o.Request = j.Request, o.Response = j.Response, s.exports = o
})(browserPonyfill, browserPonyfill.exports);
var fetch$1 = getDefaultExportFromCjs(browserPonyfill.exports);
async function verifiedBuild(s, o, a = 5) {
    const $ = `https://api.apr.dev/api/v0/program/${o.toString()}/latest?limit=${a}`,
        [j, _e] = await Promise.all([fetchData(s, o), fetch$1($)]),
        et = (await _e.json()).filter(nt => !nt.aborted && nt.state === "Built" && nt.verified === "Verified");
    if (et.length === 0) return null;
    const tt = et[0];
    return j.slot.toNumber() !== tt.verified_slot ? null : tt
}
async function fetchData(s, o) {
    const a = await s.getAccountInfo(o);
    if (a === null) throw new Error("program account not found");
    const {
        program: $
    } = decodeUpgradeableLoaderState(a.data), j = await s.getAccountInfo($.programdataAddress);
    if (j === null) throw new Error("program data account not found");
    const {
        programData: _e
    } = decodeUpgradeableLoaderState(j.data);
    return _e
}
const UPGRADEABLE_LOADER_STATE_LAYOUT = dist.rustEnum([dist.struct([], "uninitialized"), dist.struct([dist.option(dist.publicKey(), "authorityAddress")], "buffer"), dist.struct([dist.publicKey("programdataAddress")], "program"), dist.struct([dist.u64("slot"), dist.option(dist.publicKey(), "upgradeAuthorityAddress")], "programData")], void 0, dist.u32());

function decodeUpgradeableLoaderState(s) {
    return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(s)
}
var registry = Object.freeze({
        __proto__: null,
        verifiedBuild,
        fetchData,
        decodeUpgradeableLoaderState
    }),
    index = Object.freeze({
        __proto__: null,
        sha256,
        rpc,
        publicKey: pubkey,
        bytes: index$1,
        token,
        features,
        registry
    });

function isIdlAccounts(s) {
    return "accounts" in s
}
async function idlAddress(s) {
    const o = (await PublicKey.findProgramAddress([], s))[0];
    return await PublicKey.createWithSeed(o, seed(), s)
}

function seed() {
    return "anchor:idl"
}
const IDL_ACCOUNT_LAYOUT = dist.struct([dist.publicKey("authority"), dist.vecU8("data")]);

function decodeIdlAccount(s) {
    return IDL_ACCOUNT_LAYOUT.decode(s)
}

function splitArgsAndCtx(s, o) {
    var a, $;
    let j = {};
    const _e = s.args ? s.args.length : 0;
    if (o.length > _e) {
        if (o.length !== _e + 1) throw new Error(`provided too many arguments ${o} to instruction ${s==null?void 0:s.name} expecting: ${($=(a=s.args)===null||a===void 0?void 0:a.map(et=>et.name))!==null&&$!==void 0?$:[]}`);
        j = o.pop()
    }
    return [o, j]
}
class InstructionNamespaceFactory {
    static build(o, a, $) {
        if (o.name === "_inner") throw new IdlError("the _inner name is reserved");
        const j = (..._e) => {
            const [et, tt] = splitArgsAndCtx(o, [..._e]);
            validateAccounts(o.accounts, tt.accounts), validateInstruction(o, ..._e);
            const nt = j.accounts(tt.accounts);
            return tt.remainingAccounts !== void 0 && nt.push(...tt.remainingAccounts), isSet("debug-logs") && console.log("Outgoing account metas:", nt), new TransactionInstruction({
                keys: nt,
                programId: $,
                data: a(o.name, toInstruction(o, ...et))
            })
        };
        return j.accounts = _e => InstructionNamespaceFactory.accountsArray(_e, o.accounts, $, o.name), j
    }
    static accountsArray(o, a, $, j) {
        return o ? a.map(_e => {
            if (("accounts" in _e ? _e.accounts : void 0) !== void 0) {
                const tt = o[_e.name];
                return InstructionNamespaceFactory.accountsArray(tt, _e.accounts, $, j).flat()
            } else {
                const tt = _e;
                let nt;
                try {
                    nt = translateAddress(o[_e.name])
                } catch {
                    throw new Error(`Wrong input type for account "${_e.name}" in the instruction accounts object${j!==void 0?' for instruction "'+j+'"':""}. Expected PublicKey or string.`)
                }
                const rt = tt.isOptional && nt.equals($),
                    ot = tt.isMut && !rt,
                    st = tt.isSigner && !rt;
                return {
                    pubkey: nt,
                    isWritable: ot,
                    isSigner: st
                }
            }
        }).flat() : []
    }
}

function validateInstruction(s, ...o) {}
class RpcFactory {
    static build(o, a, $, j) {
        return async (...et) => {
            var tt;
            const nt = a(...et),
                [, rt] = splitArgsAndCtx(o, [...et]);
            if (j.sendAndConfirm === void 0) throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
            try {
                return await j.sendAndConfirm(nt, (tt = rt.signers) !== null && tt !== void 0 ? tt : [], rt.options)
            } catch (ot) {
                throw translateError(ot, $)
            }
        }
    }
}
class TransactionFactory {
    static build(o, a) {
        return (...j) => {
            var _e, et, tt;
            const [, nt] = splitArgsAndCtx(o, [...j]), rt = new Transaction;
            if (nt.preInstructions && nt.instructions) throw new Error("instructions is deprecated, use preInstructions");
            return (_e = nt.preInstructions) === null || _e === void 0 || _e.forEach(ot => rt.add(ot)), (et = nt.instructions) === null || et === void 0 || et.forEach(ot => rt.add(ot)), rt.add(a(...j)), (tt = nt.postInstructions) === null || tt === void 0 || tt.forEach(ot => rt.add(ot)), rt
        }
    }
}
class StateFactory {
    static build(o, a, $, j) {
        if (o.state !== void 0) return new StateClient(o, $, j, a)
    }
}
class StateClient {
    get programId() {
        return this._programId
    }
    constructor(o, a, $ = getProvider(), j = new BorshCoder(o)) {
        this.provider = $, this.coder = j, this._idl = o, this._programId = a, this._address = programStateAddress(a), this._sub = null;
        const [_e, et, tt] = (() => {
            var nt;
            let rt = {},
                ot = {},
                st = {};
            return (nt = o.state) === null || nt === void 0 || nt.methods.forEach(lt => {
                const ft = InstructionNamespaceFactory.build(lt, (vt, wt) => j.instruction.encodeState(vt, wt), a);
                ft.accounts = vt => stateInstructionKeys(a, $, lt, vt).concat(InstructionNamespaceFactory.accountsArray(vt, lt.accounts, a, lt.name));
                const yt = TransactionFactory.build(lt, ft),
                    bt = RpcFactory.build(lt, yt, parseIdlErrors(o), $),
                    ht = camelCase$1(lt.name);
                rt[ht] = ft, ot[ht] = yt, st[ht] = bt
            }), [rt, ot, st]
        })();
        this.instruction = _e, this.transaction = et, this.rpc = tt
    }
    async fetch() {
        const o = this.address(),
            a = await this.provider.connection.getAccountInfo(o);
        if (a === null) throw new Error(`Account does not exist ${o.toString()}`);
        const $ = this._idl.state;
        if (!$) throw new Error("State is not specified in IDL.");
        if ((await stateDiscriminator($.struct.name)).compare(a.data.slice(0, 8))) throw new Error("Invalid account discriminator");
        return this.coder.state.decode(a.data)
    }
    address() {
        return this._address
    }
    subscribe(o) {
        if (this._sub !== null) return this._sub.ee;
        const a = new EventEmitter,
            $ = this.provider.connection.onAccountChange(this.address(), j => {
                const _e = this.coder.state.decode(j.data);
                a.emit("change", _e)
            }, o);
        return this._sub = {
            ee: a,
            listener: $
        }, a
    }
    unsubscribe() {
        this._sub !== null && this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {
            this._sub = null
        }).catch(console.error)
    }
}

function programStateAddress(s) {
    let [o] = findProgramAddressSync([], s);
    return createWithSeedSync(o, "unversioned", s)
}

function stateInstructionKeys(s, o, a, $) {
    if (a.name === "new") {
        const [j] = findProgramAddressSync([], s);
        if (o.wallet === void 0) throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
        return [{
            pubkey: o.wallet.publicKey,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: programStateAddress(s),
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: j,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: s,
            isWritable: !1,
            isSigner: !1
        }]
    } else return validateAccounts(a.accounts, $), [{
        pubkey: programStateAddress(s),
        isWritable: !0,
        isSigner: !1
    }]
}
class AccountFactory {
    static build(o, a, $, j) {
        var _e;
        const et = {};
        return (_e = o.accounts) === null || _e === void 0 || _e.forEach(tt => {
            const nt = camelCase$1(tt.name);
            et[nt] = new AccountClient(o, tt, $, j, a)
        }), et
    }
}
class AccountClient {
    get size() {
        return this._size
    }
    get programId() {
        return this._programId
    }
    get provider() {
        return this._provider
    }
    get coder() {
        return this._coder
    }
    constructor(o, a, $, j, _e) {
        this._idlAccount = a, this._programId = $, this._provider = j ? ? getProvider(), this._coder = _e ? ? new BorshCoder(o), this._size = this._coder.accounts.size(a)
    }
    async fetchNullable(o, a) {
        const {
            data: $
        } = await this.fetchNullableAndContext(o, a);
        return $
    }
    async fetchNullableAndContext(o, a) {
        const $ = await this.getAccountInfoAndContext(o, a),
            {
                value: j,
                context: _e
            } = $;
        return {
            data: j && j.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, j.data) : null,
            context: _e
        }
    }
    async fetch(o, a) {
        const {
            data: $
        } = await this.fetchNullableAndContext(o, a);
        if ($ === null) throw new Error(`Account does not exist or has no data ${o.toString()}`);
        return $
    }
    async fetchAndContext(o, a) {
        const {
            data: $,
            context: j
        } = await this.fetchNullableAndContext(o, a);
        if ($ === null) throw new Error(`Account does not exist ${o.toString()}`);
        return {
            data: $,
            context: j
        }
    }
    async fetchMultiple(o, a) {
        return (await this.fetchMultipleAndContext(o, a)).map(j => j ? j.data : null)
    }
    async fetchMultipleAndContext(o, a) {
        return (await getMultipleAccountsAndContext(this._provider.connection, o.map(j => translateAddress(j)), a)).map(j => {
            if (j == null) return null;
            const {
                account: _e,
                context: et
            } = j;
            return {
                data: this._coder.accounts.decode(this._idlAccount.name, _e.data),
                context: et
            }
        })
    }
    async all(o) {
        const a = this.coder.accounts.memcmp(this._idlAccount.name, o instanceof Buffer ? o : void 0),
            $ = [];
        return (a == null ? void 0 : a.offset) != null && (a == null ? void 0 : a.bytes) != null && $.push({
            memcmp: {
                offset: a.offset,
                bytes: a.bytes
            }
        }), (a == null ? void 0 : a.dataSize) != null && $.push({
            dataSize: a.dataSize
        }), (await this._provider.connection.getProgramAccounts(this._programId, {
            commitment: this._provider.connection.commitment,
            filters: [...$, ...Array.isArray(o) ? o : []]
        })).map(({
            pubkey: _e,
            account: et
        }) => ({
            publicKey: _e,
            account: this._coder.accounts.decode(this._idlAccount.name, et.data)
        }))
    }
    subscribe(o, a) {
        const $ = subscriptions.get(o.toString());
        if ($) return $.ee;
        const j = new EventEmitter;
        o = translateAddress(o);
        const _e = this._provider.connection.onAccountChange(o, et => {
            const tt = this._coder.accounts.decode(this._idlAccount.name, et.data);
            j.emit("change", tt)
        }, a);
        return subscriptions.set(o.toString(), {
            ee: j,
            listener: _e
        }), j
    }
    async unsubscribe(o) {
        let a = subscriptions.get(o.toString());
        if (!a) {
            console.warn("Address is not subscribed");
            return
        }
        subscriptions && await this._provider.connection.removeAccountChangeListener(a.listener).then(() => {
            subscriptions.delete(o.toString())
        }).catch(console.error)
    }
    async createInstruction(o, a) {
        const $ = this.size;
        if (this._provider.publicKey === void 0) throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
        return SystemProgram.createAccount({
            fromPubkey: this._provider.publicKey,
            newAccountPubkey: o.publicKey,
            space: a ? ? $,
            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(a ? ? $),
            programId: this._programId
        })
    }
    async associated(...o) {
        const a = await this.associatedAddress(...o);
        return await this.fetch(a)
    }
    async associatedAddress(...o) {
        return await associated(this._programId, ...o)
    }
    async getAccountInfo(o, a) {
        return await this._provider.connection.getAccountInfo(translateAddress(o), a)
    }
    async getAccountInfoAndContext(o, a) {
        return await this._provider.connection.getAccountInfoAndContext(translateAddress(o), a)
    }
}
const subscriptions = new Map,
    PROGRAM_LOG = "Program log: ",
    PROGRAM_DATA = "Program data: ",
    PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length,
    PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
class EventManager {
    constructor(o, a, $) {
        this._programId = o, this._provider = a, this._eventParser = new EventParser(o, $), this._eventCallbacks = new Map, this._eventListeners = new Map, this._listenerIdCount = 0
    }
    addEventListener(o, a) {
        var $;
        let j = this._listenerIdCount;
        return this._listenerIdCount += 1, this._eventListeners.has(o) || this._eventListeners.set(o, []), this._eventListeners.set(o, (($ = this._eventListeners.get(o)) !== null && $ !== void 0 ? $ : []).concat(j)), this._eventCallbacks.set(j, [o, a]), this._onLogsSubscriptionId !== void 0 || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (_e, et) => {
            if (!_e.err)
                for (const tt of this._eventParser.parseLogs(_e.logs)) {
                    const nt = this._eventListeners.get(tt.name);
                    nt && nt.forEach(rt => {
                        const ot = this._eventCallbacks.get(rt);
                        if (ot) {
                            const [, st] = ot;
                            st(tt.data, et.slot, _e.signature)
                        }
                    })
                }
        })), j
    }
    async removeEventListener(o) {
        const a = this._eventCallbacks.get(o);
        if (!a) throw new Error(`Event listener ${o} doesn't exist!`);
        const [$] = a;
        let j = this._eventListeners.get($);
        if (!j) throw new Error(`Event listeners don't exist for ${$}!`);
        this._eventCallbacks.delete(o), j = j.filter(_e => _e !== o), this._eventListeners.set($, j), j.length === 0 && this._eventListeners.delete($), this._eventCallbacks.size == 0 && (assertExports.ok(this._eventListeners.size === 0), this._onLogsSubscriptionId !== void 0 && (await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId), this._onLogsSubscriptionId = void 0))
    }
}
class EventParser {
    constructor(o, a) {
        this.coder = a, this.programId = o
    }* parseLogs(o, a = !1) {
        const $ = new LogScanner(o),
            j = new ExecutionContext;
        let _e = $.next();
        for (; _e !== null;) {
            let [et, tt, nt] = this.handleLog(j, _e, a);
            et && (yield et), tt && j.push(tt), nt && j.pop(), _e = $.next()
        }
    }
    handleLog(o, a, $) {
        return o.stack.length > 0 && o.program() === this.programId.toString() ? this.handleProgramLog(a, $) : [null, ...this.handleSystemLog(a)]
    }
    handleProgramLog(o, a) {
        if (o.startsWith(PROGRAM_LOG) || o.startsWith(PROGRAM_DATA)) {
            const $ = o.startsWith(PROGRAM_LOG) ? o.slice(PROGRAM_LOG_START_INDEX) : o.slice(PROGRAM_DATA_START_INDEX),
                j = this.coder.events.decode($);
            if (a && j === null) throw new Error(`Unable to decode event ${$}`);
            return [j, null, !1]
        } else return [null, ...this.handleSystemLog(o)]
    }
    handleSystemLog(o) {
        const a = o.split(":")[0];
        return a.match(/^Program (.*) success/g) !== null ? [null, !0] : a.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), !1] : a.includes("invoke") ? ["cpi", !1] : [null, !1]
    }
}
class ExecutionContext {
    constructor() {
        this.stack = []
    }
    program() {
        return assertExports.ok(this.stack.length > 0), this.stack[this.stack.length - 1]
    }
    push(o) {
        this.stack.push(o)
    }
    pop() {
        assertExports.ok(this.stack.length > 0), this.stack.pop()
    }
}
class LogScanner {
    constructor(o) {
        this.logs = o
    }
    next() {
        if (this.logs.length === 0) return null;
        let o = this.logs[0];
        return this.logs = this.logs.slice(1), o
    }
}
class SimulateFactory {
    static build(o, a, $, j, _e, et, tt) {
        return async (...rt) => {
            var ot;
            const st = a(...rt),
                [, lt] = splitArgsAndCtx(o, [...rt]);
            let ft;
            if (j.simulate === void 0) throw new Error("This function requires 'Provider.simulate' to be implemented.");
            try {
                ft = await j.simulate(st, lt.signers, (ot = lt.options) === null || ot === void 0 ? void 0 : ot.commitment)
            } catch (ht) {
                throw translateError(ht, $)
            }
            if (ft === void 0) throw new Error("Unable to simulate transaction");
            const yt = ft.logs;
            if (!yt) throw new Error("Simulated logs not found");
            const bt = [];
            if (tt.events) {
                let ht = new EventParser(et, _e);
                for (const vt of ht.parseLogs(yt)) bt.push(vt)
            }
            return {
                events: bt,
                raw: yt
            }
        }
    }
}

function uint64(s) {
    return new WrappedLayout(blob(8), o => u64.fromBuffer(o), o => o.toBuffer(), s)
}

function publicKey(s) {
    return new WrappedLayout(blob(32), o => new PublicKey(o), o => o.toBuffer(), s)
}

function coption(s, o) {
    return new COptionLayout(s, o)
}
class WrappedLayout extends Layout_2 {
    constructor(o, a, $, j) {
        super(o.span, j), this.layout = o, this.decoder = a, this.encoder = $
    }
    decode(o, a) {
        return this.decoder(this.layout.decode(o, a))
    }
    encode(o, a, $) {
        return this.layout.encode(this.encoder(o), a, $)
    }
    getSpan(o, a) {
        return this.layout.getSpan(o, a)
    }
}
class COptionLayout extends Layout_2 {
    constructor(o, a) {
        super(-1, a), this.layout = o, this.discriminator = u32()
    }
    encode(o, a, $ = 0) {
        return o == null ? this.layout.span + this.discriminator.encode(0, a, $) : (this.discriminator.encode(1, a, $), this.layout.encode(o, a, $ + 4) + 4)
    }
    decode(o, a = 0) {
        const $ = this.discriminator.decode(o, a);
        if ($ === 0) return null;
        if ($ === 1) return this.layout.decode(o, a + 4);
        throw new Error("Invalid coption " + this.layout.property)
    }
    getSpan(o, a = 0) {
        return this.layout.getSpan(o, a + 4) + 4
    }
}
class u64 extends BN {
    toBuffer() {
        const o = super.toArray().reverse(),
            a = Buffer.from(o);
        if (a.length === 8) return a;
        if (a.length >= 8) throw new Error("u64 too large");
        const $ = Buffer.alloc(8);
        return a.copy($), $
    }
    static fromBuffer(o) {
        if (o.length !== 8) throw new Error(`Invalid buffer length: ${o.length}`);
        return new u64([...o].reverse().map(a => `00${a.toString(16)}`.slice(-2)).join(""), 16)
    }
}
const TOKEN_ACCOUNT_LAYOUT = struct([publicKey("mint"), publicKey("owner"), uint64("amount"), coption(publicKey(), "delegate"), (s => {
    const o = union(u8("discriminator"), null, s);
    return o.addVariant(0, struct([]), "uninitialized"), o.addVariant(1, struct([]), "initialized"), o.addVariant(2, struct([]), "frozen"), o
})("state"), coption(uint64(), "isNative"), uint64("delegatedAmount"), coption(publicKey(), "closeAuthority")]);

function decodeTokenAccount(s) {
    return TOKEN_ACCOUNT_LAYOUT.decode(s)
}
class AccountsResolver {
    constructor(o, a, $, j, _e, et, tt, nt) {
        this._accounts = a, this._provider = $, this._programId = j, this._idlIx = _e, this._idlTypes = tt, this._customResolver = nt, this._args = o, this._accountStore = new AccountStore($, et, this._programId)
    }
    args(o) {
        this._args = o
    }
    async resolve() {
        for (await this.resolveConst(this._idlIx.accounts); await this.resolvePdas(this._idlIx.accounts) + await this.resolveRelations(this._idlIx.accounts) + await this.resolveCustom() > 0;);
    }
    async resolveCustom() {
        if (this._customResolver) {
            const {
                accounts: o,
                resolved: a
            } = await this._customResolver({
                args: this._args,
                accounts: this._accounts,
                provider: this._provider,
                programId: this._programId,
                idlIx: this._idlIx
            });
            return this._accounts = o, a
        }
        return 0
    }
    resolveOptionalsHelper(o, a) {
        const $ = {};
        for (const j of a) {
            const _e = j.name,
                et = o[_e];
            et !== void 0 && (isPartialAccounts(et) ? isIdlAccounts(j) ? $[_e] = this.resolveOptionalsHelper(et, j.accounts) : $[_e] = flattenPartialAccounts(et) : et !== null ? $[_e] = translateAddress(et) : j.isOptional && ($[_e] = this._programId))
        }
        return $
    }
    resolveOptionals(o) {
        Object.assign(this._accounts, this.resolveOptionalsHelper(o, this._idlIx.accounts))
    }
    get(o) {
        const a = o.reduce(($, j) => $ && $[j], this._accounts);
        if (a && a.toBase58) return a
    }
    set(o, a) {
        let $ = this._accounts;
        o.forEach((j, _e) => {
            _e == o.length - 1 && ($[j] = a), $[j] = $[j] || {}, $ = $[j]
        })
    }
    async resolveConst(o, a = []) {
        for (let $ = 0; $ < o.length; $ += 1) {
            const j = o[$],
                _e = j.accounts;
            _e && await this.resolveConst(_e, [...a, camelCase$1(j.name)]);
            const et = j,
                tt = camelCase$1(j.name);
            if (et.isSigner && !this.get([...a, tt])) {
                if (this._provider.wallet === void 0) throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
                this.set([...a, tt], this._provider.wallet.publicKey)
            }
            Reflect.has(AccountsResolver.CONST_ACCOUNTS, tt) && !this.get([...a, tt]) && this.set([...a, tt], AccountsResolver.CONST_ACCOUNTS[tt])
        }
    }
    async resolvePdas(o, a = []) {
        let $ = 0;
        for (let j = 0; j < o.length; j += 1) {
            const _e = o[j],
                et = _e.accounts;
            et && ($ += await this.resolvePdas(et, [...a, camelCase$1(_e.name)]));
            const tt = _e,
                nt = camelCase$1(_e.name);
            tt.pda && tt.pda.seeds.length > 0 && !this.get([...a, nt]) && await this.autoPopulatePda(tt, a) && ($ += 1)
        }
        return $
    }
    async resolveRelations(o, a = []) {
        let $ = 0;
        for (let j = 0; j < o.length; j += 1) {
            const _e = o[j],
                et = _e.accounts;
            et && ($ += await this.resolveRelations(et, [...a, camelCase$1(_e.name)]));
            const tt = _e.relations || [],
                nt = camelCase$1(_e.name),
                rt = [...a, nt],
                ot = this.get(rt);
            if (ot) {
                const st = tt.filter(lt => !this.get([...a, camelCase$1(lt)]));
                if ($ += st.length, st.length > 0) {
                    const lt = await this._accountStore.fetchAccount({
                        publicKey: ot
                    });
                    await Promise.all(st.map(async ft => {
                        const yt = camelCase$1(ft);
                        return this.set([...a, yt], lt[yt]), lt[yt]
                    }))
                }
            }
        }
        return $
    }
    async autoPopulatePda(o, a = []) {
        if (!o.pda || !o.pda.seeds) throw new Error("Must have seeds");
        const $ = await Promise.all(o.pda.seeds.map(et => this.toBuffer(et, a)));
        if ($.some(et => typeof et > "u")) return;
        const j = await this.parseProgramId(o, a);
        if (!j) return;
        const [_e] = await PublicKey.findProgramAddress($, j);
        this.set([...a, camelCase$1(o.name)], _e)
    }
    async parseProgramId(o, a = []) {
        var $;
        if (!(!(($ = o.pda) === null || $ === void 0) && $.programId)) return this._programId;
        switch (o.pda.programId.kind) {
            case "const":
                return new PublicKey(this.toBufferConst(o.pda.programId.value));
            case "arg":
                return this.argValue(o.pda.programId);
            case "account":
                return await this.accountValue(o.pda.programId, a);
            default:
                throw new Error(`Unexpected program seed kind: ${o.pda.programId.kind}`)
        }
    }
    async toBuffer(o, a = []) {
        switch (o.kind) {
            case "const":
                return this.toBufferConst(o);
            case "arg":
                return await this.toBufferArg(o);
            case "account":
                return await this.toBufferAccount(o, a);
            default:
                throw new Error(`Unexpected seed kind: ${o.kind}`)
        }
    }
    getType(o, a = []) {
        if (a.length > 0 && o.defined) {
            const $ = this._idlTypes.find(et => et.name === o.defined);
            if (!$) throw new Error(`Cannot find type ${o.defined}`);
            const _e = $.type.fields.find(et => et.name === a[0]);
            return this.getType(_e.type, a.slice(1))
        }
        return o
    }
    toBufferConst(o) {
        return this.toBufferValue(this.getType(o.type, (o.path || "").split(".").slice(1)), o.value)
    }
    async toBufferArg(o) {
        const a = this.argValue(o);
        if (!(typeof a > "u")) return this.toBufferValue(this.getType(o.type, (o.path || "").split(".").slice(1)), a)
    }
    argValue(o) {
        const a = o.path.split("."),
            $ = camelCase$1(a[0]),
            j = this._idlIx.args.findIndex(_e => _e.name === $);
        if (j === -1) throw new Error(`Unable to find argument for seed: ${$}`);
        return a.slice(1).reduce((_e, et) => (_e || {})[et], this._args[j])
    }
    async toBufferAccount(o, a = []) {
        const $ = await this.accountValue(o, a);
        if ($) return this.toBufferValue(o.type, $)
    }
    async accountValue(o, a = []) {
        const $ = o.path.split("."),
            j = $[0],
            _e = this.get([...a, camelCase$1(j)]);
        if (_e === null) throw new Error("fieldPubkey is null");
        if ($.length === 1) return _e;
        const et = await this._accountStore.fetchAccount({
            publicKey: _e,
            name: o.account
        });
        return this.parseAccountValue(et, $.slice(1))
    }
    parseAccountValue(o, a) {
        let $;
        for (; a.length > 0;) $ = o[camelCase$1(a[0])], a = a.slice(1);
        return $
    }
    toBufferValue(o, a) {
        switch (o) {
            case "u8":
                return Buffer.from([a]);
            case "u16":
                let $ = Buffer.alloc(2);
                return $.writeUInt16LE(a), $;
            case "u32":
                let j = Buffer.alloc(4);
                return j.writeUInt32LE(a), j;
            case "u64":
                let _e = Buffer.alloc(8);
                return _e.writeBigUInt64LE(BigInt(a)), _e;
            case "string":
                return Buffer.from(encode$2(a));
            case "publicKey":
                return a.toBuffer();
            default:
                if (o.array) return Buffer.from(a);
                throw new Error(`Unexpected seed type: ${o}`)
        }
    }
}
AccountsResolver.CONST_ACCOUNTS = {
    associatedTokenProgram: ASSOCIATED_PROGRAM_ID,
    rent: SYSVAR_RENT_PUBKEY,
    systemProgram: SystemProgram.programId,
    tokenProgram: TOKEN_PROGRAM_ID,
    clock: SYSVAR_CLOCK_PUBKEY
};
class AccountStore {
    constructor(o, a, $) {
        this._provider = o, this._programId = $, this._cache = new Map, this._idls = {}, this._idls[$.toBase58()] = a
    }
    async ensureIdl(o) {
        if (!this._idls[o.toBase58()]) {
            const a = await Program.fetchIdl(o, this._provider);
            if (a) {
                const $ = new Program(a, o, this._provider);
                this._idls[o.toBase58()] = $.account
            }
        }
        return this._idls[o.toBase58()]
    }
    async fetchAccount({
        publicKey: o,
        name: a,
        programId: $ = this._programId
    }) {
        const j = o.toString();
        if (!this._cache.has(j))
            if (a === "TokenAccount") {
                const _e = await this._provider.connection.getAccountInfo(o);
                if (_e === null) throw new Error(`invalid account info for ${j}`);
                const et = decodeTokenAccount(_e.data);
                this._cache.set(j, et)
            } else if (a) {
            const _e = await this.ensureIdl($);
            if (_e) {
                const et = _e[camelCase$1(a)];
                if (et) {
                    const tt = await et.fetch(o);
                    this._cache.set(j, tt)
                }
            }
        } else {
            const _e = await this._provider.connection.getAccountInfo(o);
            if (_e === null) throw new Error(`invalid account info for ${j}`);
            const et = _e.data,
                tt = await this.ensureIdl(_e.owner);
            if (tt) {
                const nt = Object.values(tt)[0];
                if (!nt) throw new Error("No accounts for this program");
                const rt = nt.coder.accounts.decodeAny(et);
                this._cache.set(j, rt)
            }
        }
        return this._cache.get(j)
    }
}
class MethodsBuilderFactory {
    static build(o, a, $, j, _e, et, tt, nt, rt, ot, st) {
        return (...lt) => new MethodsBuilder(lt, j, _e, et, tt, nt, o, a, $, rt, ot, st)
    }
}

function isPartialAccounts(s) {
    return typeof s == "object" && s !== null && !("_bn" in s)
}

function flattenPartialAccounts(s, o) {
    const a = {};
    for (const $ in s) {
        const j = s[$];
        if (j === null) throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
        a[$] = isPartialAccounts(j) ? flattenPartialAccounts(j) : translateAddress(j)
    }
    return a
}
class MethodsBuilder {
    constructor(o, a, $, j, _e, et, tt, nt, rt, ot, st, lt) {
        this._ixFn = a, this._txFn = $, this._rpcFn = j, this._simulateFn = _e, this._viewFn = et, this._programId = nt, this._accounts = {}, this._remainingAccounts = [], this._signers = [], this._preInstructions = [], this._postInstructions = [], this._autoResolveAccounts = !0, this._args = o, this._accountsResolver = new AccountsResolver(o, this._accounts, tt, nt, rt, ot, st, lt)
    }
    args(o) {
        this._args = o, this._accountsResolver.args(o)
    }
    async pubkeys() {
        return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._accounts
    }
    accounts(o) {
        return this._autoResolveAccounts = !0, this._accountsResolver.resolveOptionals(o), this
    }
    accountsStrict(o) {
        return this._autoResolveAccounts = !1, this._accountsResolver.resolveOptionals(o), this
    }
    signers(o) {
        return this._signers = this._signers.concat(o), this
    }
    remainingAccounts(o) {
        return this._remainingAccounts = this._remainingAccounts.concat(o), this
    }
    preInstructions(o) {
        return this._preInstructions = this._preInstructions.concat(o), this
    }
    postInstructions(o) {
        return this._postInstructions = this._postInstructions.concat(o), this
    }
    async rpc(o) {
        return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._rpcFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions,
            options: o
        })
    }
    async rpcAndKeys(o) {
        return {
            pubkeys: await this.pubkeys(),
            signature: await this.rpc(o)
        }
    }
    async view(o) {
        if (this._autoResolveAccounts && await this._accountsResolver.resolve(), !this._viewFn) throw new Error("Method does not support views");
        return this._viewFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions,
            options: o
        })
    }
    async simulate(o) {
        return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._simulateFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions,
            options: o
        })
    }
    async instruction() {
        return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._ixFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions
        })
    }
    async prepare() {
        return {
            instruction: await this.instruction(),
            pubkeys: await this.pubkeys(),
            signers: await this._signers
        }
    }
    async transaction() {
        return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._txFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions
        })
    }
}
class ViewFactory {
    static build(o, a, $, j) {
        const _e = a.accounts.find(nt => nt.isMut),
            et = !!a.returns;
        return _e || !et ? void 0 : async (...nt) => {
            var rt, ot;
            let st = await $(...nt);
            const lt = `Program return: ${o} `;
            let ft = st.raw.find(vt => vt.startsWith(lt));
            if (!ft) throw new Error("View expected return log");
            let yt = decode(ft.slice(lt.length)),
                bt = a.returns;
            if (!bt) throw new Error("View expected return type");
            return IdlCoder.fieldLayout({
                type: bt
            }, Array.from([...(rt = j.accounts) !== null && rt !== void 0 ? rt : [], ...(ot = j.types) !== null && ot !== void 0 ? ot : []])).decode(yt)
        }
    }
}
class NamespaceFactory {
    static build(o, a, $, j, _e) {
        const et = {},
            tt = {},
            nt = {},
            rt = {},
            ot = {},
            st = {},
            lt = parseIdlErrors(o),
            ft = o.accounts ? AccountFactory.build(o, a, $, j) : {},
            yt = StateFactory.build(o, a, $, j);
        return o.instructions.forEach(bt => {
            const ht = InstructionNamespaceFactory.build(bt, (Lt, Nt) => a.instruction.encode(Lt, Nt), $),
                vt = TransactionFactory.build(bt, ht),
                wt = RpcFactory.build(bt, vt, lt, j),
                gt = SimulateFactory.build(bt, vt, lt, j, a, $, o),
                At = ViewFactory.build($, bt, gt, o),
                Pt = MethodsBuilderFactory.build(j, $, bt, ht, vt, wt, gt, At, ft, o.types || [], _e && _e(bt)),
                Bt = camelCase$1(bt.name);
            tt[Bt] = ht, nt[Bt] = vt, et[Bt] = wt, rt[Bt] = gt, ot[Bt] = Pt, At && (st[Bt] = At)
        }), [et, tt, nt, ft, rt, ot, yt, st]
    }
}
class Program {
    get programId() {
        return this._programId
    }
    get idl() {
        return this._idl
    }
    get coder() {
        return this._coder
    }
    get provider() {
        return this._provider
    }
    constructor(o, a, $, j, _e) {
        a = translateAddress(a), $ || ($ = getProvider()), this._idl = o, this._provider = $, this._programId = a, this._coder = j ? ? new BorshCoder(o), this._events = new EventManager(this._programId, $, this._coder);
        const [et, tt, nt, rt, ot, st, lt, ft] = NamespaceFactory.build(o, this._coder, a, $, _e ? ? (() => {}));
        this.rpc = et, this.instruction = tt, this.transaction = nt, this.account = rt, this.simulate = ot, this.methods = st, this.state = lt, this.views = ft
    }
    static async at(o, a) {
        const $ = translateAddress(o),
            j = await Program.fetchIdl($, a);
        if (!j) throw new Error(`IDL not found for program: ${o.toString()}`);
        return new Program(j, $, a)
    }
    static async fetchIdl(o, a) {
        a = a ? ? getProvider();
        const $ = translateAddress(o),
            j = await idlAddress($),
            _e = await a.connection.getAccountInfo(j);
        if (!_e) return null;
        let et = decodeIdlAccount(_e.data.slice(8));
        const tt = inflate_1(et.data);
        return JSON.parse(decode$2(tt))
    }
    addEventListener(o, a) {
        return this._events.addEventListener(o, a)
    }
    async removeEventListener(o) {
        return await this._events.removeEventListener(o)
    }
}
new PublicKey("11111111111111111111111111111111");

function Header() {
    reactExports.useState(!1);
    const [s, o] = reactExports.useState(0), a = new Connection(clusterApiUrl("devnet"), "confirmed"), $ = useWallet(), j = index.bytes.utf8.encode("state");
    index.bytes.utf8.encode("round");
    const _e = new PublicKey(idl.metadata.address),
        et = reactExports.useMemo(() => new AnchorProvider(a, {
            publicKey: null,
            signAllTransactions: async () => [],
            signTransaction: async () => null
        }, AnchorProvider.defaultOptions()), [a]),
        tt = reactExports.useMemo(() => $ && $.connected ? new AnchorProvider(a, $, AnchorProvider.defaultOptions()) : et, [$, a, et]),
        nt = reactExports.useMemo(() => tt ? new Program(idl, _e, tt) : null, [tt]),
        rt = async () => {
            var ot, st;
            try {
                const lt = new PublicKey("doGqrWF94feTv6agyW14kPsbetbWrhnUBea5r2eCDFd"),
                    [ft] = PublicKey.findProgramAddressSync([j, lt.toBuffer()], _e),
                    yt = await ((st = (ot = nt == null ? void 0 : nt.account) == null ? void 0 : ot.state) == null ? void 0 : st.fetch(ft));
                console.log("stateData", yt), yt && o(yt.totalParticipantsAllTime.toNumber())
            } catch (lt) {
                console.error("Error fetching round data:", lt)
            }
        };
    return reactExports.useEffect(() => {
        rt()
    }, [nt]), reactExports.useEffect(() => {
        const ot = () => {
            const st = document.getElementById("header-main");
            window.scrollY === 0 ? st == null || st.classList.remove("sticky-header") : st == null || st.classList.add("sticky-header")
        };
        return window.addEventListener("scroll", ot), () => window.removeEventListener("scroll", ot)
    }, []), jsxRuntimeExports.jsx(Index.Box, {
        className: "header-main",
        id: "header-main",
        children: jsxRuntimeExports.jsx(Index.Box, {
            className: "container",
            children: jsxRuntimeExports.jsxs(Index.Box, {
                className: "header-row",
                children: [jsxRuntimeExports.jsx(Index.Box, {
                    className: "header-cust-col",
                    children: jsxRuntimeExports.jsxs(Index.Box, {
                        className: "icon-wrapper",
                        children: [jsxRuntimeExports.jsxs(Index.Box, {
                            className: "icon-flex",
                            children: [jsxRuntimeExports.jsx("img", {
                                src: PagesIndex.Svg.userIcon,
                                alt: "User",
                                className: "icons"
                            }), jsxRuntimeExports.jsxs(Index.Typography, {
                                className: "icon-text",
                                children: [s, " Total Wish"]
                            })]
                        }), jsxRuntimeExports.jsxs(Index.Box, {
                            className: "icon-flex",
                            children: [jsxRuntimeExports.jsx("img", {
                                src: PagesIndex.Svg.whiteCoinIcon,
                                alt: "Total Sol Distributed",
                                className: "icons"
                            }), jsxRuntimeExports.jsxs(Index.Typography, {
                                className: "icon-text",
                                children: [(s * .05).toFixed(4), " Total Sol Distributed"]
                            })]
                        })]
                    })
                }), jsxRuntimeExports.jsx(Index.Box, {
                    className: "header-cust-col",
                    children: jsxRuntimeExports.jsx(Index.Box, {
                        className: "border-btn-main header-btn-main",
                        children: jsxRuntimeExports.jsx(Index.Button, {
                            className: "border-btn",
                            children: jsxRuntimeExports.jsx(WalletMultiButton, {})
                        })
                    })
                })]
            })
        })
    })
}

function Footer() {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsx(Index.Box, {
            className: "footer-main",
            children: jsxRuntimeExports.jsx(Index.Box, {
                className: "container",
                children: jsxRuntimeExports.jsx(Index.Box, {
                    className: "footer-row",
                    children: jsxRuntimeExports.jsxs(Index.List, {
                        className: "footer-nav",
                        children: [jsxRuntimeExports.jsx(Index.ListItem, {
                            className: "footer-nav-item",
                            children: jsxRuntimeExports.jsx(Index.Link, {
                                to: "/",
                                className: "footer-nav-link",
                                children: "Faq"
                            })
                        }), jsxRuntimeExports.jsx(Index.ListItem, {
                            className: "footer-nav-item",
                            children: jsxRuntimeExports.jsx(Index.Link, {
                                to: "/",
                                className: "footer-nav-link",
                                children: "HOW TO PLAY"
                            })
                        }), jsxRuntimeExports.jsx(Index.ListItem, {
                            className: "footer-nav-item",
                            children: jsxRuntimeExports.jsx(Index.Link, {
                                to: "/",
                                className: "footer-nav-link",
                                children: "T&C"
                            })
                        }), jsxRuntimeExports.jsx(Index.ListItem, {
                            className: "footer-nav-item",
                            children: jsxRuntimeExports.jsx(Index.Link, {
                                to: "/",
                                className: "footer-nav-link",
                                children: "AML"
                            })
                        }), jsxRuntimeExports.jsx(Index.ListItem, {
                            className: "footer-nav-item",
                            children: jsxRuntimeExports.jsx(Index.Link, {
                                to: "/",
                                className: "footer-nav-link",
                                children: "KYC"
                            })
                        })]
                    })
                })
            })
        })
    })
}
const style = {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)"
    },
    IOSSwitch = Index.styled(s => jsxRuntimeExports.jsx(Index.Switch, {
        focusVisibleClassName: ".Mui-focusVisible",
        disableRipple: !0,
        ...s
    }))(({
        theme: s
    }) => ({
        width: 34,
        height: 20,
        padding: 0,
        "& .MuiSwitch-switchBase": {
            padding: 0,
            margin: 3,
            transitionDuration: "300ms",
            "&.Mui-checked": {
                transform: "translateX(16px)",
                color: "#fff",
                "& + .MuiSwitch-track": {
                    backgroundColor: s.palette.mode === "dark" ? "#2ECA45" : "#114A65",
                    opacity: 1,
                    border: 0
                },
                "&.Mui-disabled + .MuiSwitch-track": {
                    opacity: .5
                }
            },
            "&.Mui-focusVisible .MuiSwitch-thumb": {
                color: "#33cf4d",
                border: "6px solid #fff"
            },
            "&.Mui-disabled .MuiSwitch-thumb": {
                color: s.palette.mode === "light" ? s.palette.grey[100] : s.palette.grey[600]
            },
            "&.Mui-disabled + .MuiSwitch-track": {
                opacity: s.palette.mode === "light" ? .7 : .3
            }
        },
        "& .MuiSwitch-thumb": {
            boxSizing: "border-box",
            width: 14,
            height: 14,
            boxShadow: "none"
        },
        "& .MuiSwitch-track": {
            borderRadius: 26 / 2,
            backgroundColor: s.palette.mode === "light" ? "#E9E9EA" : "#39393D",
            opacity: 1,
            transition: s.transitions.create(["background-color"], {
                duration: 500
            })
        }
    })),
    StyledMenu = styled(s => jsxRuntimeExports.jsx(Index.Menu, {
        elevation: 0,
        anchorOrigin: {
            vertical: "bottom",
            horizontal: "right"
        },
        transformOrigin: {
            vertical: "top",
            horizontal: "right"
        },
        ...s
    }))(({
        theme: s
    }) => ({
        "& .MuiPaper-root": {
            borderRadius: 6,
            marginTop: s.spacing(1),
            minWidth: 180,
            color: s.palette.mode === "light" ? "rgb(55, 65, 81)" : s.palette.grey[300],
            boxShadow: "rgb(255, 255, 255) 0px 0px 0px 0px, rgba(0, 0, 0, 0.05) 0px 0px 0px 1px, rgba(0, 0, 0, 0.1) 0px 10px 15px -3px, rgba(0, 0, 0, 0.05) 0px 4px 6px -2px",
            "& .MuiMenu-list": {
                padding: "4px 0"
            },
            "& .MuiMenuItem-root": {
                "& .MuiSvgIcon-root": {
                    fontSize: 18,
                    color: s.palette.text.secondary,
                    marginRight: s.spacing(1.5)
                },
                "&:active": {
                    backgroundColor: alpha$2(s.palette.primary.main, s.palette.action.selectedOpacity)
                }
            }
        }
    })),
    BpIcon = styled("span")(({
        theme: s
    }) => ({
        borderRadius: 3,
        border: "1px solid #635BFF",
        width: 16,
        height: 16,
        boxShadow: s.palette.mode === "dark" ? "0 0 0 1px rgb(16 22 26 / 40%)" : "inset 0 0 0 1px rgba(16,22,26,.2), inset 0 -1px 0 rgba(16,22,26,.1)",
        backgroundColor: s.palette.mode === "dark" ? "#394b59" : "#f5f8fa",
        backgroundImage: s.palette.mode === "dark" ? "linear-gradient(180deg,hsla(0,0%,100%,.05),hsla(0,0%,100%,0))" : "linear-gradient(180deg,hsla(0,0%,100%,.8),hsla(0,0%,100%,0))",
        ".Mui-focusVisible &": {
            outline: "2px auto rgba(19,124,189,.6)",
            outlineOffset: 2
        },
        "input:hover ~ &": {
            backgroundColor: s.palette.mode === "dark" ? "#635BFF" : "#ebf1f5"
        },
        "input:disabled ~ &": {
            boxShadow: "none",
            background: s.palette.mode === "dark" ? "rgba(57,75,89,.5)" : "rgba(206,217,224,.5)"
        }
    })),
    BpCheckedIcon = styled(BpIcon)({
        backgroundColor: "#233D63",
        backgroundImage: "linear-gradient(180deg,hsla(0,0%,100%,.1),hsla(0,0%,100%,0))",
        "&::before": {
            display: "block",
            width: 14,
            height: 14,
            backgroundImage: `url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M12 5c-.28 0-.53.11-.71.29L7 9.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l5-5A1.003 1.003 0 0012 5z' fill='%23fff'/%3E%3C/svg%3E")`,
            content: '""'
        },
        "input:hover ~ &": {
            backgroundColor: "#233D63"
        }
    });

function BpCheckbox(s) {
    return jsxRuntimeExports.jsx(Index.Checkbox, {
        sx: {
            "&:hover": {
                bgcolor: "transparent"
            }
        },
        disableRipple: !0,
        color: "default",
        checkedIcon: jsxRuntimeExports.jsx(BpCheckedIcon, {}),
        icon: jsxRuntimeExports.jsx(BpIcon, {}),
        inputProps: {
            "aria-label": "Checkbox demo"
        },
        ...s
    })
}
const CustomTabPanel = ({
    children: s,
    value: o,
    index: a,
    className: $,
    ...j
}) => jsxRuntimeExports.jsx("div", {
    role: "tabpanel",
    hidden: o !== a,
    id: `tabpanel-${a}`,
    "aria-labelledby": `tab-${a}`,
    className: $,
    ...j,
    children: o === a && jsxRuntimeExports.jsx(Index.Box, {
        children: jsxRuntimeExports.jsx(Index.Typography, {
            children: s
        })
    })
});

function Pagination(s) {
    const {
        page: o,
        rowsPerPage: a,
        setPage: $,
        setRowsPerPage: j,
        count: _e
    } = s, et = (nt, rt) => {
        $(rt)
    }, tt = nt => {
        j(parseInt(nt.target.value, 10)), $(0)
    };
    return jsxRuntimeExports.jsx(Index.Box, {
        className: "pagination-main",
        children: jsxRuntimeExports.jsx(Index.TablePagination, {
            component: "div",
            rowsPerPageOptions: [10, 50, 100],
            count: _e,
            page: o,
            onPageChange: et,
            rowsPerPage: a,
            onRowsPerPageChange: tt
        })
    })
}

function HeroSection({
    fetchRoundDataHome: s
}) {
    const [o, a] = reactExports.useState(0), $ = new Connection(clusterApiUrl("devnet"), "confirmed"), j = useWallet(), _e = index.bytes.utf8.encode("state"), et = index.bytes.utf8.encode("round"), tt = new PublicKey(idl.metadata.address), nt = reactExports.useMemo(() => new AnchorProvider($, {
        publicKey: null,
        signAllTransactions: async () => [],
        signTransaction: async () => null
    }, AnchorProvider.defaultOptions()), [$]), rt = reactExports.useMemo(() => j && j.connected ? new AnchorProvider($, j, AnchorProvider.defaultOptions()) : nt, [j, $, nt]), ot = reactExports.useMemo(() => {
        if (rt) return new Program(idl, tt, rt)
    }, [rt]), st = async () => {
        var ft, yt;
        try {
            const bt = new PublicKey("doGqrWF94feTv6agyW14kPsbetbWrhnUBea5r2eCDFd"),
                [ht] = PublicKey.findProgramAddressSync([_e, bt.toBuffer()], tt),
                vt = await ((yt = (ft = ot == null ? void 0 : ot.account) == null ? void 0 : ft.state) == null ? void 0 : yt.fetch(ht)),
                wt = vt == null ? void 0 : vt.currentRound,
                [gt] = PublicKey.findProgramAddressSync([et, new BN(wt).toArrayLike(Buffer, "le", 8), bt.toBuffer()], tt),
                At = await (ot == null ? void 0 : ot.account.round.fetch(gt));
            a(At == null ? void 0 : At.totalParticipants.toNumber())
        } catch (bt) {
            console.error("Error fetching round data:", bt)
        }
    };
    reactExports.useEffect(() => {
        st()
    });
    const lt = async () => {
        if (!j || !j.publicKey) {
            console.error("Wallet not connected");
            try {
                await j.connect()
            } catch (ft) {
                console.error("Error connecting wallet:", ft), alert("Error connecting to wallet. Please try again.");
                return
            }
        }
        try {
            const ft = new PublicKey("doGqrWF94feTv6agyW14kPsbetbWrhnUBea5r2eCDFd"),
                [yt] = PublicKey.findProgramAddressSync([_e, ft.toBuffer()], tt),
                bt = await (ot == null ? void 0 : ot.account.state.fetch(yt)),
                ht = bt == null ? void 0 : bt.currentRound,
                [vt] = PublicKey.findProgramAddressSync([et, new BN(ht).toArrayLike(Buffer, "le", 8), ft.toBuffer()], tt);
            if (!await $.getAccountInfo(vt)) {
                console.error("Round account does not exist at: ", vt.toBase58()), alert("Round account does not exist. Please start the round first.");
                return
            }
            if (!(await (ot == null ? void 0 : ot.account.round.fetch(vt))).isActive) {
                alert("The round is not currently active. Please try again later.");
                return
            }
            const At = .05,
                Pt = new BN(At * LAMPORTS_PER_SOL);
            let Bt = await (ot == null ? void 0 : ot.methods.participate(Pt).accounts({
                admin: ft,
                participant: j.publicKey,
                state: yt,
                round: vt,
                systemProgram: SystemProgram.programId
            }).instruction());
            const Lt = new Transaction().add(Bt),
                Nt = await rt.sendAndConfirm(Lt);
            alert("Participation successful!"), await st(), await s(), console.log("Signature", Nt)
        } catch (ft) {
            console.error("Error during participation: ", ft), alert("An error occurred during participation. Please try again.")
        }
    };
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(Index.Box, {
            className: "hero-section",
            children: jsxRuntimeExports.jsx(Index.Box, {
                className: "container",
                children: jsxRuntimeExports.jsxs(Index.Box, {
                    className: "hero-content-main",
                    children: [jsxRuntimeExports.jsx(PagesIndex.RollingCounter, {}), jsxRuntimeExports.jsx(Index.Typography, {
                        className: "hero-heading",
                        children: "Wishing Wallet"
                    }), jsxRuntimeExports.jsx(Index.Typography, {
                        className: "hero-para",
                        children: "Lorem Ipsum is simply dummy text of the printing and typesetting industry"
                    }), jsxRuntimeExports.jsx("img", {
                        src: PagesIndex.Svg.hero,
                        alt: "",
                        className: "hero-img"
                    }), jsxRuntimeExports.jsx(Index.Box, {
                        className: "hero-btn-main primary-btn-main",
                        children: jsxRuntimeExports.jsx(Index.Button, {
                            className: "hero-btn primary-btn",
                            onClick: lt,
                            children: "Throw A Coin"
                        })
                    }), jsxRuntimeExports.jsx(Index.Box, {
                        className: "hero-icon-main",
                        children: jsxRuntimeExports.jsxs(Index.Box, {
                            className: "icon-wrapper",
                            children: [jsxRuntimeExports.jsxs(Index.Box, {
                                className: "icon-flex",
                                children: [jsxRuntimeExports.jsx("img", {
                                    src: PagesIndex.Svg.userIcon,
                                    alt: "User",
                                    className: "icons"
                                }), jsxRuntimeExports.jsx(Index.Typography, {
                                    className: "icon-text",
                                    children: "Total Wish"
                                })]
                            }), jsxRuntimeExports.jsxs(Index.Box, {
                                className: "icon-flex",
                                children: [jsxRuntimeExports.jsx("img", {
                                    src: PagesIndex.Svg.whiteCoinIcon,
                                    alt: "User",
                                    className: "icons"
                                }), jsxRuntimeExports.jsx(Index.Typography, {
                                    className: "icon-text",
                                    children: "Total Sol Distributed"
                                })]
                            })]
                        })
                    })]
                })
            })
        }), jsxRuntimeExports.jsx(Index.Box, {
            className: "hero-card-section",
            children: jsxRuntimeExports.jsx(Index.Box, {
                className: "container",
                children: jsxRuntimeExports.jsxs(Index.Box, {
                    className: "hero-cards-main",
                    children: [jsxRuntimeExports.jsxs(Index.Box, {
                        className: "hero-cards",
                        children: [jsxRuntimeExports.jsx(Index.Typography, {
                            className: "hero-card-digit",
                            children: o
                        }), jsxRuntimeExports.jsx(Index.Typography, {
                            className: "hero-card-digit-title",
                            children: "Total Participants"
                        })]
                    }), jsxRuntimeExports.jsxs(Index.Box, {
                        className: "hero-cards",
                        children: [jsxRuntimeExports.jsx(Index.Typography, {
                            className: "hero-card-digit",
                            children: Number(o * .05).toFixed(2)
                        }), jsxRuntimeExports.jsx(Index.Typography, {
                            className: "hero-card-digit-title",
                            children: "Total SoL"
                        })]
                    })]
                })
            })
        })]
    })
}

function LastWinners({
    winners: s,
    solReceived: o
}) {
    return jsxRuntimeExports.jsx(Index.Box, {
        className: "last-winner-section",
        children: jsxRuntimeExports.jsxs(Index.Box, {
            className: "container",
            children: [jsxRuntimeExports.jsx(Index.Box, {
                className: "section-heading-main last-winner-heading-main",
                children: jsxRuntimeExports.jsx(Index.Typography, {
                    className: "section-heading",
                    children: "Last Winners"
                })
            }), jsxRuntimeExports.jsx(Index.Box, {
                className: "last-winner-row",
                children: s.length > 0 ? s.map((a, $) => jsxRuntimeExports.jsxs(Index.Box, {
                    className: "last-winner-col",
                    children: [jsxRuntimeExports.jsxs(Index.Typography, {
                        className: "last-winner-percentages",
                        children: [
                            [50, 30, 20][$] || 0, "% "
                        ]
                    }), jsxRuntimeExports.jsx("img", {
                        src: PagesIndex.Svg[`lastWinner${$%3+1}`],
                        className: "last-winner-img",
                        alt: "Winner"
                    }), jsxRuntimeExports.jsxs(Index.Typography, {
                        className: "last-winner-name",
                        children: [a == null ? void 0 : a.slice(0, 4), "...", a == null ? void 0 : a.slice(-4)]
                    }), jsxRuntimeExports.jsxs(Index.Typography, {
                        className: "last-winner-text",
                        children: ["Sol Received: ", o[$] ? o[$].toFixed(4) : 0, " SOL"]
                    })]
                }, a)) : jsxRuntimeExports.jsx(Index.Typography, {
                    children: "No winners found."
                })
            })]
        })
    })
}

function RecentPlays({
    participants: s,
    participationTimes: o
}) {
    const a = $ => {
        const _e = Math.floor(new Date().getTime() / 1e3) - $;
        return _e < 60 ? `${Math.floor(_e)} seconds ago` : _e < 3600 ? `${Math.floor(_e/60)} minutes ago` : _e < 86400 ? `${Math.floor(_e/3600)} hours ago` : `${Math.floor(_e/86400)} days ago`
    };
    return jsxRuntimeExports.jsx(Index.Box, {
        className: "recent-plays-section",
        children: jsxRuntimeExports.jsxs(Index.Box, {
            className: "container",
            children: [jsxRuntimeExports.jsx(Index.Box, {
                className: "section-heading-main recent-heading-main",
                children: jsxRuntimeExports.jsx(Index.Typography, {
                    className: "section-heading",
                    children: "Recent Plays"
                })
            }), jsxRuntimeExports.jsx(Index.Box, {
                className: "recent-plays-main",
                children: s.length > 0 ? s.map(($, j) => jsxRuntimeExports.jsx(Index.Box, {
                    className: "recent-plays-row",
                    children: jsxRuntimeExports.jsxs(Index.Box, {
                        className: "recent-flex-main",
                        children: [jsxRuntimeExports.jsxs(Index.Box, {
                            className: "recent-left-content-main",
                            children: [jsxRuntimeExports.jsx("img", {
                                src: PagesIndex.Svg[`recent${j%6+1}`],
                                alt: "Recent Plays",
                                className: "recent-img"
                            }), jsxRuntimeExports.jsxs(Index.Typography, {
                                className: "recent-text",
                                children: [jsxRuntimeExports.jsx("span", {
                                    children: "Wallet:"
                                }), " ", $, " made a wish"]
                            })]
                        }), jsxRuntimeExports.jsx(Index.Box, {
                            className: "recent-right-content-main",
                            children: jsxRuntimeExports.jsx(Index.Typography, {
                                className: "recent-time-text",
                                children: a(o[j])
                            })
                        })]
                    })
                }, $)) : jsxRuntimeExports.jsx(Index.Typography, {
                    children: "No recent plays found."
                })
            })]
        })
    })
}

function RollingCounter() {
    const [s, o] = reactExports.useState(0), [a, $] = reactExports.useState(0), [j, _e] = reactExports.useState(0), [et, tt] = reactExports.useState(0), [nt, rt] = reactExports.useState(-1), [ot, st] = reactExports.useState(j - 1), [lt, ft] = reactExports.useState(!1), yt = new Connection(clusterApiUrl("devnet"), "confirmed"), bt = useWallet(), ht = index.bytes.utf8.encode("state"), vt = index.bytes.utf8.encode("round"), wt = new PublicKey(idl.metadata.address), gt = reactExports.useMemo(() => new AnchorProvider(yt, {
        publicKey: null,
        signAllTransactions: async () => [],
        signTransaction: async () => null
    }, AnchorProvider.defaultOptions()), [yt]), At = reactExports.useMemo(() => bt && bt.connected ? new AnchorProvider(yt, bt, AnchorProvider.defaultOptions()) : gt, [bt, yt, gt]), Pt = reactExports.useMemo(() => {
        if (At) return new Program(idl, wt, At)
    }, [At]), Bt = async () => {
        var Lt, Nt;
        try {
            const Ut = new PublicKey("doGqrWF94feTv6agyW14kPsbetbWrhnUBea5r2eCDFd"),
                [Vt] = PublicKey.findProgramAddressSync([ht, Ut.toBuffer()], wt),
                Ft = await ((Nt = (Lt = Pt == null ? void 0 : Pt.account) == null ? void 0 : Lt.state) == null ? void 0 : Nt.fetch(Vt)),
                Wt = Ft == null ? void 0 : Ft.currentRound,
                [Ct] = PublicKey.findProgramAddressSync([vt, new BN(Wt).toArrayLike(Buffer, "le", 8), Ut.toBuffer()], wt),
                it = await (Pt == null ? void 0 : Pt.account.round.fetch(Ct));
            console.log("roundAccount", it.endTime.toNumber());
            const at = it == null ? void 0 : it.endTime.toNumber();
            console.log(at, "z"), tt(at), localStorage.setItem("countdown", at)
        } catch (Ut) {
            console.error("Error fetching round data:", Ut)
        }
    };
    return reactExports.useEffect(() => {
        Bt()
    }, []), reactExports.useEffect(() => {
        const Lt = setInterval(() => {
            const Nt = Math.floor(Date.now() / 1e3),
                Ut = et - Nt;
            let Vt = Ut % 60;
            const Ft = Math.floor(Ut % 3600 / 60),
                Wt = Math.floor(Ut / 3600);
            console.log(Vt, Ft, Wt), rt(Ut), Ut <= 0 && Bt(), Vt < 0 && (Vt = 59), Ut > 0 && ($(Ft < 0 ? 0 : Ft), _e(Vt), o(Wt < 0 ? 0 : Wt), st(Vt - 1), setTimeout(() => _e(Vt - 1 < 0 ? 59 : Vt - 1), 400)), ft(!0), setTimeout(() => ft(!1), 500)
        }, 1e3);
        return () => clearInterval(Lt)
    }, [et]), et <= 0 || nt < 0 ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) : jsxRuntimeExports.jsx(Index.Box, {
        className: "timer-main",
        children: jsxRuntimeExports.jsxs(Index.Box, {
            className: "timer-flex",
            children: [jsxRuntimeExports.jsxs(Index.Box, {
                className: "time-box",
                children: [jsxRuntimeExports.jsx(Index.Typography, {
                    id: "hours",
                    className: "time-text",
                    children: String(s).padStart(2, "0")
                }), jsxRuntimeExports.jsx(Index.Typography, {
                    className: "time-label",
                    children: "HOURS"
                })]
            }), jsxRuntimeExports.jsx(Index.Box, {
                className: "colon-img-box",
                children: jsxRuntimeExports.jsx("img", {
                    src: PagesIndex.Svg.colunIcon,
                    alt: "Colon",
                    className: "colon-img"
                })
            }), jsxRuntimeExports.jsxs(Index.Box, {
                className: "time-box",
                children: [jsxRuntimeExports.jsx(Index.Typography, {
                    id: "minutes",
                    className: "time-text",
                    children: String(a).padStart(2, "0")
                }), jsxRuntimeExports.jsx(Index.Typography, {
                    className: "time-label",
                    children: "MINUTES"
                })]
            }), jsxRuntimeExports.jsx(Index.Box, {
                className: "colon-img-box",
                children: jsxRuntimeExports.jsx("img", {
                    src: PagesIndex.Svg.colunIcon,
                    alt: "Colon",
                    className: "colon-img"
                })
            }), jsxRuntimeExports.jsxs(Index.Box, {
                className: "time-box",
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "digits-container",
                    children: [jsxRuntimeExports.jsx(Index.Typography, {
                        className: "time-text",
                        children: String(j).padStart(2, "0")[0]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "last-digit-wrapper",
                        children: [jsxRuntimeExports.jsx("div", {
                            className: `current-digit ${lt?"slide-up":""}`,
                            children: jsxRuntimeExports.jsx(Index.Typography, {
                                className: "time-text",
                                children: String(j).padStart(2, "0")[1]
                            })
                        }), jsxRuntimeExports.jsx("div", {
                            className: `next-digit ${lt?"slide-up":""}`,
                            children: jsxRuntimeExports.jsx(Index.Typography, {
                                className: "time-text",
                                children: String(ot).padStart(2, "0")[1]
                            })
                        })]
                    })]
                }), jsxRuntimeExports.jsx(Index.Typography, {
                    className: "time-label",
                    children: "SECONDS"
                })]
            })]
        })
    })
}
const PagesIndex = {
        Svg,
        Png,
        Header,
        Footer,
        BpCheckbox,
        CustomTabPanel,
        IOSSwitch,
        StyledMenu,
        style,
        useLocation,
        Pagination,
        HeroSection,
        LastWinners,
        RecentPlays,
        RollingCounter
    },
    Layout = () => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(PagesIndex.Header, {}), jsxRuntimeExports.jsx(Outlet, {}), jsxRuntimeExports.jsx(PagesIndex.Footer, {})]
    });

function Home() {
    const [s, o] = reactExports.useState([]), [a, $] = reactExports.useState([]), [j, _e] = reactExports.useState([]), [et, tt] = reactExports.useState([]), nt = useWallet(), rt = reactExports.useMemo(() => new Connection(clusterApiUrl("devnet"), "confirmed"), []), ot = reactExports.useMemo(() => new PublicKey(idl.metadata.address), []), st = reactExports.useMemo(() => index.bytes.utf8.encode("state"), []), lt = reactExports.useMemo(() => index.bytes.utf8.encode("round"), []), ft = reactExports.useMemo(() => new AnchorProvider(rt, {
        publicKey: null,
        signAllTransactions: async () => [],
        signTransaction: async () => null
    }, AnchorProvider.defaultOptions()), [rt]), yt = reactExports.useMemo(() => nt && nt.connected && nt.publicKey ? new AnchorProvider(rt, nt, AnchorProvider.defaultOptions()) : ft, [nt, rt, ft]), bt = reactExports.useMemo(() => yt ? new Program(idl, ot, yt) : null, [yt, ot]), ht = reactExports.useCallback(async () => {
        if (bt) try {
            const vt = new PublicKey("doGqrWF94feTv6agyW14kPsbetbWrhnUBea5r2eCDFd"),
                [wt] = PublicKey.findProgramAddressSync([st, vt.toBuffer()], ot),
                At = (await bt.account.state.fetch(wt)).currentRound,
                [Pt] = PublicKey.findProgramAddressSync([lt, new BN(At).toArrayLike(Buffer, "le", 8), vt.toBuffer()], ot),
                Bt = await bt.account.round.fetch(Pt),
                Lt = Bt.participants.map(Wt => Wt.toBase58());
            if (_e(Wt => JSON.stringify(Wt) !== JSON.stringify(Lt) ? Lt : Wt), tt(Bt.participationTimes.map(Wt => Wt.toNumber())), !Bt.winners || Bt.winners.length === 0) {
                o([]), $([]);
                return
            }
            const Nt = Bt.winners.map(Wt => Wt.toBase58()),
                Vt = new BN(Bt.totalDistributed).toNumber(),
                Ft = Nt.map((Wt, Ct) => [50, 30, 20][Ct] / 100 * Vt / LAMPORTS_PER_SOL);
            o(Wt => JSON.stringify(Wt) !== JSON.stringify(Nt) ? Nt : Wt), $(Wt => JSON.stringify(Wt) !== JSON.stringify(Ft) ? Ft : Wt)
        } catch (vt) {
            console.error("Error fetching round data:", vt)
        }
    }, [bt, ot, st, lt]);
    return reactExports.useEffect(() => {
        bt && ht()
    }, [bt, ht]), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsxs(Index.Box, {
            className: "home-main",
            children: [jsxRuntimeExports.jsx(PagesIndex.HeroSection, {
                fetchRoundDataHome: ht
            }), jsxRuntimeExports.jsx(PagesIndex.LastWinners, {
                winners: s,
                solReceived: a
            }), jsxRuntimeExports.jsx(PagesIndex.RecentPlays, {
                participants: j,
                participationTimes: et
            })]
        })
    })
}

function Routes() {
    return jsxRuntimeExports.jsx(BrowserRouter, {
        children: jsxRuntimeExports.jsx(Routes$1, {
            children: jsxRuntimeExports.jsx(Route, {
                path: "/",
                element: jsxRuntimeExports.jsx(Layout, {}),
                children: jsxRuntimeExports.jsx(Route, {
                    index: !0,
                    element: jsxRuntimeExports.jsx(Home, {})
                })
            })
        })
    })
}
const PhantomWalletName = "Phantom";
class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter {
    constructor(o = {}) {
        super(), this.name = PhantomWalletName, this.url = "https://phantom.app", this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==", this.supportedTransactionVersions = new Set(["legacy", 0]), this._readyState = typeof window > "u" || typeof document > "u" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected, this._disconnected = () => {
            const a = this._wallet;
            a && (a.off("disconnect", this._disconnected), a.off("accountChanged", this._accountChanged), this._wallet = null, this._publicKey = null, this.emit("error", new WalletDisconnectedError), this.emit("disconnect"))
        }, this._accountChanged = a => {
            const $ = this._publicKey;
            if ($) {
                try {
                    a = new PublicKey$1(a.toBytes())
                } catch (j) {
                    this.emit("error", new WalletPublicKeyError(j == null ? void 0 : j.message, j));
                    return
                }
                $.equals(a) || (this._publicKey = a, this.emit("connect", a))
            }
        }, this._connecting = !1, this._wallet = null, this._publicKey = null, this._readyState !== WalletReadyState.Unsupported && (isIosAndRedirectable() ? (this._readyState = WalletReadyState.Loadable, this.emit("readyStateChange", this._readyState)) : scopePollingDetectionStrategy(() => {
            var a, $, j;
            return ($ = (a = window.phantom) == null ? void 0 : a.solana) != null && $.isPhantom || (j = window.solana) != null && j.isPhantom ? (this._readyState = WalletReadyState.Installed, this.emit("readyStateChange", this._readyState), !0) : !1
        }))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === WalletReadyState.Installed && await this.connect()
    }
    async connect() {
        var o;
        try {
            if (this.connected || this.connecting) return;
            if (this.readyState === WalletReadyState.Loadable) {
                const j = encodeURIComponent(window.location.href),
                    _e = encodeURIComponent(window.location.origin);
                window.location.href = `https://phantom.app/ul/browse/${j}?ref=${_e}`;
                return
            }
            if (this.readyState !== WalletReadyState.Installed) throw new WalletNotReadyError;
            this._connecting = !0;
            const a = ((o = window.phantom) == null ? void 0 : o.solana) || window.solana;
            if (!a.isConnected) try {
                await a.connect()
            } catch (j) {
                throw new WalletConnectionError(j == null ? void 0 : j.message, j)
            }
            if (!a.publicKey) throw new WalletAccountError;
            let $;
            try {
                $ = new PublicKey$1(a.publicKey.toBytes())
            } catch (j) {
                throw new WalletPublicKeyError(j == null ? void 0 : j.message, j)
            }
            a.on("disconnect", this._disconnected), a.on("accountChanged", this._accountChanged), this._wallet = a, this._publicKey = $, this.emit("connect", $)
        } catch (a) {
            throw this.emit("error", a), a
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const o = this._wallet;
        if (o) {
            o.off("disconnect", this._disconnected), o.off("accountChanged", this._accountChanged), this._wallet = null, this._publicKey = null;
            try {
                await o.disconnect()
            } catch (a) {
                this.emit("error", new WalletDisconnectionError(a == null ? void 0 : a.message, a))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(o, a, $ = {}) {
        try {
            const j = this._wallet;
            if (!j) throw new WalletNotConnectedError;
            try {
                const {
                    signers: _e,
                    ...et
                } = $;
                isVersionedTransaction$1(o) ? _e != null && _e.length && o.sign(_e) : (o = await this.prepareTransaction(o, a, et), _e != null && _e.length && o.partialSign(..._e)), et.preflightCommitment = et.preflightCommitment || a.commitment;
                const {
                    signature: tt
                } = await j.signAndSendTransaction(o, et);
                return tt
            } catch (_e) {
                throw _e instanceof WalletError ? _e : new WalletSendTransactionError(_e == null ? void 0 : _e.message, _e)
            }
        } catch (j) {
            throw this.emit("error", j), j
        }
    }
    async signTransaction(o) {
        try {
            const a = this._wallet;
            if (!a) throw new WalletNotConnectedError;
            try {
                return await a.signTransaction(o) || o
            } catch ($) {
                throw new WalletSignTransactionError($ == null ? void 0 : $.message, $)
            }
        } catch (a) {
            throw this.emit("error", a), a
        }
    }
    async signAllTransactions(o) {
        try {
            const a = this._wallet;
            if (!a) throw new WalletNotConnectedError;
            try {
                return await a.signAllTransactions(o) || o
            } catch ($) {
                throw new WalletSignTransactionError($ == null ? void 0 : $.message, $)
            }
        } catch (a) {
            throw this.emit("error", a), a
        }
    }
    async signMessage(o) {
        try {
            const a = this._wallet;
            if (!a) throw new WalletNotConnectedError;
            try {
                const {
                    signature: $
                } = await a.signMessage(o);
                return $
            } catch ($) {
                throw new WalletSignMessageError($ == null ? void 0 : $.message, $)
            }
        } catch (a) {
            throw this.emit("error", a), a
        }
    }
}
var browser = {
        exports: {}
    },
    process$1 = browser.exports = {},
    cachedSetTimeout, cachedClearTimeout;

function defaultSetTimout() {
    throw new Error("setTimeout has not been defined")
}

function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined")
}(function() {
    try {
        typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout
    } catch {
        cachedSetTimeout = defaultSetTimout
    }
    try {
        typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout
    } catch {
        cachedClearTimeout = defaultClearTimeout
    }
})();

function runTimeout(s) {
    if (cachedSetTimeout === setTimeout) return setTimeout(s, 0);
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(s, 0);
    try {
        return cachedSetTimeout(s, 0)
    } catch {
        try {
            return cachedSetTimeout.call(null, s, 0)
        } catch {
            return cachedSetTimeout.call(this, s, 0)
        }
    }
}

function runClearTimeout(s) {
    if (cachedClearTimeout === clearTimeout) return clearTimeout(s);
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(s);
    try {
        return cachedClearTimeout(s)
    } catch {
        try {
            return cachedClearTimeout.call(null, s)
        } catch {
            return cachedClearTimeout.call(this, s)
        }
    }
}
var queue = [],
    draining = !1,
    currentQueue, queueIndex = -1;

function cleanUpNextTick() {
    !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue())
}

function drainQueue() {
    if (!draining) {
        var s = runTimeout(cleanUpNextTick);
        draining = !0;
        for (var o = queue.length; o;) {
            for (currentQueue = queue, queue = []; ++queueIndex < o;) currentQueue && currentQueue[queueIndex].run();
            queueIndex = -1, o = queue.length
        }
        currentQueue = null, draining = !1, runClearTimeout(s)
    }
}
process$1.nextTick = function(s) {
    var o = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var a = 1; a < arguments.length; a++) o[a - 1] = arguments[a];
    queue.push(new Item(s, o)), queue.length === 1 && !draining && runTimeout(drainQueue)
};

function Item(s, o) {
    this.fun = s, this.array = o
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array)
};
process$1.title = "browser";
process$1.browser = !0;
process$1.env = {};
process$1.argv = [];
process$1.version = "";
process$1.versions = {};

function noop() {}
process$1.on = noop;
process$1.addListener = noop;
process$1.once = noop;
process$1.off = noop;
process$1.removeListener = noop;
process$1.removeAllListeners = noop;
process$1.emit = noop;
process$1.prependListener = noop;
process$1.prependOnceListener = noop;
process$1.listeners = function(s) {
    return []
};
process$1.binding = function(s) {
    throw new Error("process.binding is not supported")
};
process$1.cwd = function() {
    return "/"
};
process$1.chdir = function(s) {
    throw new Error("process.chdir is not supported")
};
process$1.umask = function() {
    return 0
};
var browserExports = browser.exports;
const process$2 = getDefaultExportFromCjs$3(browserExports);
window.process = process$2;

function App() {
    const s = createTheme({
            typography: {
                allVariants: {
                    fontFamily: "Inter, sans-serif",
                    fontWeight: "400",
                    lineHeight: "normal"
                }
            }
        }),
        o = [new PhantomWalletAdapter];
    return jsxRuntimeExports.jsx(ThemeProvider, {
        theme: s,
        children: jsxRuntimeExports.jsx(ConnectionProvider, {
            endpoint: clusterApiUrl("devnet"),
            children: jsxRuntimeExports.jsx(WalletProvider, {
                wallets: o,
                autoConnect: !0,
                children: jsxRuntimeExports.jsx(WalletModalProvider, {
                    children: jsxRuntimeExports.jsx("div", {
                        className: "App",
                        children: jsxRuntimeExports.jsx(Routes, {})
                    })
                })
            })
        })
    })
}
window.Buffer = buffer.Buffer;
client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(App, {}));